<BOF>from distutils.core import setup <EOL>from distutils.extension import Extension <EOL>from Cython.Distutils import build_ext <EOL>setup(name='py2d',<EOL>version='0.1',<EOL>description='<STR_LIT>',<EOL>url='<STR_LIT>',<EOL>author='Stefan Seemayer',<EOL>author_email='<STR_LIT>',<EOL>packages=['py2d','py2d.Math'],<EOL>cmdclass={'build_ext':build_ext },<EOL>ext_modules=[<EOL>Extension("py2d.Bezier",["py2d/Bezier.py"]),<EOL>Extension("py2d.FOV",["py2d/FOV.py"]),<EOL>Extension('<STR_LIT>',['<STR_LIT>']),<EOL>Extension("py2d.Navigation",['<STR_LIT>']),<EOL>Extension("py2d.SVG",["py2d/SVG.py"]),<EOL>Extension("py2d.Math",['<STR_LIT>']),<EOL>Extension('<STR_LIT>',['<STR_LIT>']),<EOL>Extension('<STR_LIT>',['<STR_LIT>']),<EOL>Extension('<STR_LIT>',['<STR_LIT>']),<EOL>Extension('<STR_LIT>',['<STR_LIT>']),<EOL>])<EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import video <EOL>from common import nothing,getsize <EOL>def build_lappyr(img,leveln=,dtype=np.int16):<EOL><INDENT>img=dtype(img)<EOL>levels=[]<EOL>for i in xrange(leveln -):<EOL><INDENT>next_img=cv2.pyrDown(img)<EOL>img1=cv2.pyrUp(next_img,dstsize=getsize(img))<EOL>levels.append(img -img1)<EOL>img=next_img <EOL><DEDENT>levels.append(img)<EOL>return levels <EOL><DEDENT>def merge_lappyr(levels):<EOL><INDENT>img=levels [-]<EOL>for lev_img in levels [-::-]:<EOL><INDENT>img=cv2.pyrUp(img,dstsize=getsize(lev_img))<EOL>img +=lev_img <EOL><DEDENT>return np.uint8(np.clip(img,,))<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>import sys <EOL>print __doc__ <EOL>try :fn=sys.argv []<EOL>except :fn=<EOL>cap=video.create_capture(fn)<EOL>leveln=<EOL>cv2.namedWindow('level control')<EOL>for i in xrange(leveln):<EOL><INDENT>cv2.createTrackbar('%d'%i,'level control',,,nothing)<EOL><DEDENT>while True :<EOL><INDENT>ret,frame=cap.read()<EOL>pyr=build_lappyr(frame,leveln)<EOL>for i in xrange(leveln):<EOL><INDENT>v=cv2.getTrackbarPos('%d'%i,'level control')/<EOL>pyr [i ]*=v <EOL><DEDENT>res=merge_lappyr(pyr)<EOL>cv2.imshow('<STR_LIT>',res)<EOL>if cv2.waitKey()==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>from makeCorp import makeCorpus <EOL>from similarity_measures import cosine_similarity,jaccard_dependency <EOL>from graphs import buildGraph <EOL>class BuildTree(object):<EOL><INDENT>def __init__(self,similarity_func,dependency_func,build_graph_func,folder_name):<EOL><INDENT>self.similarity_func=similarity_func <EOL>self.dependency_func=dependency_func <EOL>self.build_graph_func=build_graph_func <EOL>self.folder_name=folder_name <EOL>self.run()<EOL><DEDENT>def run(self):<EOL><INDENT>corpus=makeCorpus(self.folder_name)<EOL>vectors=corpus.keys()<EOL>N=len(corpus)<EOL>simList=[]<EOL>for idx,vec in enumerate(vectors):<EOL><INDENT>if idx==N -:<EOL><INDENT>break <EOL><DEDENT>for next_ in range(idx +,N):<EOL><INDENT>n1=vectors [idx ]<EOL>n2=vectors [next_ ]<EOL>similarity=self.similarity_func(corpus [n1 ],corpus [n2 ])<EOL>dep=self.dependency_func(corpus [n1 ],corpus [n2 ])<EOL>simList.append((similarity,dep,n1,n2))<EOL><DEDENT> <DEDENT>self._graph=self.build_graph_func(simList)<EOL><DEDENT>@property <EOL>def graph(self):<EOL><INDENT>return self._graph <EOL><DEDENT> <DEDENT>def main(folder_name):<EOL><INDENT>b=BuildTree(cosine_similarity,jaccard_dependency,<EOL>buildGraph,folder_name)<EOL>return b <EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>main()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>__all__=[<EOL>'insert','select','update','delete',<EOL>'join','left_join','right_join','cross_join',<EOL>'replace'<EOL>]<EOL>from.util import Query <EOL>from.stmt import insert,replace,select,update,delete,join <EOL>insert=Query(insert,('table','set'))<EOL>select=Query(select,('table','where'))<EOL>update=Query(update,('table','where','set'))<EOL>delete=Query(delete,('table','where'))<EOL>join=Query(join,('table','on'))<EOL>left_join=join.breed({'type':'left'})<EOL>right_join=join.breed({'type':'right'})<EOL>cross_join=join.breed({'type':'cross'})<EOL>replace=Query(replace,('table','set'))<EOF><BOF>import sys <EOL>import threading <EOL>class Thread(threading.Thread):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,runner,name=None):<EOL><INDENT>threading.Thread.__init__(self,target=runner,name=name)<EOL>self._stopped=False <EOL><DEDENT>def start(self):<EOL><INDENT>self.__run_backup=self.run <EOL>self.run=self.__run <EOL>threading.Thread.start(self)<EOL><DEDENT>def stop(self):<EOL><INDENT>self._stopped=True <EOL><DEDENT>def __run(self):<EOL><INDENT> '<STR_LIT>'<EOL>sys.settrace(self._globaltrace)<EOL>self.__run_backup()<EOL>self.run=self.__run_backup <EOL><DEDENT>def _globaltrace(self,frame,why,arg):<EOL><INDENT>if why=='call':<EOL><INDENT>return self._localtrace <EOL><DEDENT>else :<EOL><INDENT>return None <EOL><DEDENT> <DEDENT>def _localtrace(self,frame,why,arg):<EOL><INDENT>if self._stopped :<EOL><INDENT>if why=='line':<EOL><INDENT>raise SystemExit()<EOL><DEDENT> <DEDENT>return self._localtrace <EOL><DEDENT> <DEDENT><EOF><BOF>from __future__ import unicode_literals <EOL>from django.db import migrations,models <EOL>class Migration(migrations.Migration):<EOL><INDENT>dependencies=[('buildservice','<STR_LIT>'),<EOL>]<EOL>operations=[<EOL>migrations.AddField(<EOL>model_name='oauthtoken',<EOL>name='value',<EOL>field=models.TextField(default=None),<EOL>preserve_default=False,),<EOL>]<EOL><DEDENT><EOF><BOF>import inspect <EOL>import os.path <EOL>from robot import utils <EOL>from robot.errors import DataError <EOL>from.loggerhelper import AbstractLoggerProxy <EOL>from.logger import LOGGER <EOL>if utils.is_jython :<EOL><INDENT>from java.lang import Object <EOL>from java.util import HashMap <EOL><DEDENT>class _RecursionAvoidingMetaclass(type):<EOL><INDENT> '<STR_LIT>'<EOL>def __new__(cls,name,bases,dct):<EOL><INDENT>for attr,value in dct.items():<EOL><INDENT>if not attr.startswith('_')and inspect.isroutine(value):<EOL><INDENT>dct [attr ]=cls._wrap_listener_method(value)<EOL><DEDENT> <DEDENT>dct ['_calling_method']=False <EOL>return type.__new__(cls,name,bases,dct)<EOL><DEDENT>@staticmethod <EOL>def _wrap_listener_method(method):<EOL><INDENT>def wrapped(self,*args):<EOL><INDENT>if not self._calling_method :<EOL><INDENT>self._calling_method=True <EOL>method(self,*args)<EOL>self._calling_method=False <EOL><DEDENT> <DEDENT>return wrapped <EOL><DEDENT> <DEDENT>class Listeners(object):<EOL><INDENT>__metaclass__=_RecursionAvoidingMetaclass <EOL>_start_attrs=['doc','starttime','longname']<EOL>_end_attrs=_start_attrs +['endtime','elapsedtime','status','message']<EOL>def __init__(self,listeners):<EOL><INDENT>self._listeners=self._import_listeners(listeners)<EOL>self._running_test=False <EOL>self._setup_or_teardown_type=None <EOL><DEDENT>def __nonzero__(self):<EOL><INDENT>return bool(self._listeners)<EOL><DEDENT>def _import_listeners(self,listener_data):<EOL><INDENT>listeners=[]<EOL>for name,args in listener_data :<EOL><INDENT>try :<EOL><INDENT>listeners.append(_ListenerProxy(name,args))<EOL><DEDENT>except DataError,err :<EOL><INDENT>if args :<EOL><INDENT>name +=':'+':'.join(args)<EOL><DEDENT>LOGGER.error('<STR_LIT>'<EOL>%(name,unicode(err)))<EOL><DEDENT> <DEDENT>return listeners <EOL><DEDENT>def start_suite(self,suite):<EOL><INDENT>for li in self._listeners :<EOL><INDENT>if li.version==:<EOL><INDENT>li.call_method(li.start_suite,suite.name,suite.doc)<EOL><DEDENT>else :<EOL><INDENT>attrs=self._get_start_attrs(suite,'metadata')<EOL>attrs.update({'tests':[t.name for t in suite.tests ],<EOL>'suites':[s.name for s in suite.suites ],<EOL>'totaltests':suite.get_test_count(),<EOL>'source':suite.source or ''})<EOL>li.call_method(li.start_suite,suite.name,attrs)<EOL><DEDENT> <DEDENT> <DEDENT>def end_suite(self,suite):<EOL><INDENT>for li in self._listeners :<EOL><INDENT>if li.version==:<EOL><INDENT>li.call_method(li.end_suite,suite.status,<EOL>suite.get_full_message())<EOL><DEDENT>else :<EOL><INDENT>attrs=self._get_end_attrs(suite,'metadata')<EOL>attrs.update({'statistics':suite.get_stat_message(),<EOL>'source':suite.source or ''})<EOL>li.call_method(li.end_suite,suite.name,attrs)<EOL><DEDENT> <DEDENT> <DEDENT>def start_test(self,test):<EOL><INDENT>self._running_test=True <EOL>for li in self._listeners :<EOL><INDENT>if li.version==:<EOL><INDENT>li.call_method(li.start_test,test.name,test.doc,test.tags)<EOL><DEDENT>else :<EOL><INDENT>attrs=self._get_start_attrs(test,'tags')<EOL>attrs ['critical']='yes'if test.critical else 'no'<EOL>attrs ['template']=test.template or ''<EOL>li.call_method(li.start_test,test.name,attrs)<EOL><DEDENT> <DEDENT> <DEDENT>def end_test(self,test):<EOL><INDENT>self._running_test=False <EOL>for li in self._listeners :<EOL><INDENT>if li.version==:<EOL><INDENT>li.call_method(li.end_test,test.status,test.message)<EOL><DEDENT>else :<EOL><INDENT>attrs=self._get_end_attrs(test,'tags')<EOL>attrs ['critical']='yes'if test.critical else 'no'<EOL>attrs ['template']=test.template or ''<EOL>li.call_method(li.end_test,test.name,attrs)<EOL><DEDENT> <DEDENT> <DEDENT>def start_keyword(self,kw):<EOL><INDENT>for li in self._listeners :<EOL><INDENT>if li.version==:<EOL><INDENT>li.call_method(li.start_keyword,kw.name,kw.args)<EOL><DEDENT>else :<EOL><INDENT>attrs=self._get_start_attrs(kw,'args','-longname')<EOL>attrs ['type']=self._get_keyword_type(kw,start=True)<EOL>li.call_method(li.start_keyword,kw.name,attrs)<EOL><DEDENT> <DEDENT> <DEDENT>def end_keyword(self,kw):<EOL><INDENT>for li in self._listeners :<EOL><INDENT>if li.version==:<EOL><INDENT>li.call_method(li.end_keyword,kw.status)<EOL><DEDENT>else :<EOL><INDENT>attrs=self._get_end_attrs(kw,'args','-longname','-message')<EOL>attrs ['type']=self._get_keyword_type(kw,start=False)<EOL>li.call_method(li.end_keyword,kw.name,attrs)<EOL><DEDENT> <DEDENT> <DEDENT>def _get_keyword_type(self,kw,start=True):<EOL><INDENT>if kw.type=='kw':<EOL><INDENT>return self._setup_or_teardown_type or 'Keyword'<EOL><DEDENT>kw_type=self._get_setup_or_teardown_type(kw)<EOL>self._setup_or_teardown_type=kw_type if start else None <EOL>return kw_type <EOL><DEDENT>def _get_setup_or_teardown_type(self,kw):<EOL><INDENT>return '%s %s'%(('Test'if self._running_test else 'Suite'),<EOL>kw.type.title())<EOL><DEDENT>def log_message(self,msg):<EOL><INDENT>for li in self._listeners :<EOL><INDENT>if li.version==:<EOL><INDENT>li.call_method(li.log_message,self._create_msg_dict(msg))<EOL><DEDENT> <DEDENT> <DEDENT>def message(self,msg):<EOL><INDENT>for li in self._listeners :<EOL><INDENT>if li.version==:<EOL><INDENT>li.call_method(li.message,self._create_msg_dict(msg))<EOL><DEDENT> <DEDENT> <DEDENT>def _create_msg_dict(self,msg):<EOL><INDENT>return {'timestamp':msg.timestamp,'message':msg.message,<EOL>'level':msg.level,'html':'yes'if msg.html else 'no'}<EOL><DEDENT>def output_file(self,name,path):<EOL><INDENT>for li in self._listeners :<EOL><INDENT>li.call_method(getattr(li,'%s_file'%name.lower()),path)<EOL><DEDENT> <DEDENT>def close(self):<EOL><INDENT>for li in self._listeners :<EOL><INDENT>li.call_method(li.close)<EOL><DEDENT> <DEDENT>def _get_start_attrs(self,item,*names):<EOL><INDENT>return self._get_attrs(item,self._start_attrs,names)<EOL><DEDENT>def _get_end_attrs(self,item,*names):<EOL><INDENT>return self._get_attrs(item,self._end_attrs,names)<EOL><DEDENT>def _get_attrs(self,item,defaults,extras):<EOL><INDENT>names=self._get_attr_names(defaults,extras)<EOL>return dict((n,self._get_attr_value(item,n))for n in names)<EOL><DEDENT>def _get_attr_names(self,defaults,extras):<EOL><INDENT>names=list(defaults)<EOL>for name in extras :<EOL><INDENT>if name.startswith('-'):<EOL><INDENT>names.remove(name [:])<EOL><DEDENT>else :<EOL><INDENT>names.append(name)<EOL><DEDENT> <DEDENT>return names <EOL><DEDENT>def _get_attr_value(self,item,name):<EOL><INDENT>value=getattr(item,name)<EOL>return self._take_copy_of_mutable_value(value)<EOL><DEDENT>def _take_copy_of_mutable_value(self,value):<EOL><INDENT>if isinstance(value,(dict,utils.NormalizedDict)):<EOL><INDENT>return dict(value)<EOL><DEDENT>if isinstance(value,list):<EOL><INDENT>return list(value)<EOL><DEDENT>return value <EOL><DEDENT> <DEDENT>class _ListenerProxy(AbstractLoggerProxy):<EOL><INDENT>_methods=['start_suite','end_suite','start_test','end_test',<EOL>'start_keyword','end_keyword','log_message','message',<EOL>'output_file','report_file','log_file','debug_file',<EOL>'xunit_file','close']<EOL>def __init__(self,name,args):<EOL><INDENT>listener=self._import_listener(name,args)<EOL>AbstractLoggerProxy.__init__(self,listener)<EOL>self.name=name <EOL>self.version=self._get_version(listener)<EOL>self.is_java=utils.is_jython and isinstance(listener,Object)<EOL><DEDENT>def _import_listener(self,name,args):<EOL><INDENT>importer=utils.Importer('listener')<EOL>return importer.import_class_or_module(os.path.normpath(name),<EOL>instantiate_with_args=args)<EOL><DEDENT>def _get_version(self,listener):<EOL><INDENT>try :<EOL><INDENT>return int(getattr(listener,'<STR_LIT>',))<EOL><DEDENT>except ValueError :<EOL><INDENT>return <EOL><DEDENT> <DEDENT>def call_method(self,method,*args):<EOL><INDENT>if self.is_java :<EOL><INDENT>args=[self._to_map(a)if isinstance(a,dict)else a for a in args ]<EOL><DEDENT>try :<EOL><INDENT>method(*args)<EOL><DEDENT>except :<EOL><INDENT>message,details=utils.get_error_details()<EOL>LOGGER.error('<STR_LIT>'<EOL>%(method.__name__,self.name,message))<EOL>LOGGER.info("Details:\n%s"%details)<EOL><DEDENT> <DEDENT>def _to_map(self,dictionary):<EOL><INDENT>map=HashMap()<EOL>for key,value in dictionary.iteritems():<EOL><INDENT>map.put(key,value)<EOL><DEDENT>return map <EOL><DEDENT> <DEDENT><EOF><BOF>__version__='0.1'<EOL>from getpass import getpass <EOL>from smtplib import SMTP <EOL>class Postbox(object):<EOL><INDENT>host=None <EOL>port=None <EOL>user=None <EOL>password=None <EOL>tls=True <EOL>prompt_user='username? '<EOL>prompt_password='password? '<EOL>debuglevel=None <EOL>dry_run=False <EOL>def _update(self,attrs):<EOL><INDENT>for key,value in attrs.items():<EOL><INDENT>setattr(self,key,value)<EOL><DEDENT> <DEDENT>def __init__(self,**attrs):<EOL><INDENT>self.server=None <EOL>self.connect(**attrs)<EOL><DEDENT>def connect(self,**attrs):<EOL><INDENT>if attrs :<EOL><INDENT>self._update(attrs)<EOL><DEDENT>self.server=SMTP(self.host,self.port)<EOL>if self.debuglevel :<EOL><INDENT>self.server.set_debuglevel(self.debuglevel)<EOL><DEDENT>if self.tls :<EOL><INDENT>self.server.starttls()<EOL><DEDENT>if not self.user and self.prompt_user :<EOL><INDENT>self.user=raw_input(self.prompt_user)<EOL><DEDENT>if self.user and not self.password and self.prompt_password :<EOL><INDENT>self.password=getpass(self.prompt_password)<EOL><DEDENT>if self.user and self.password :<EOL><INDENT>self.server.login(self.user,self.password)<EOL><DEDENT> <DEDENT>def send(self,body,**headers_dict):<EOL><INDENT>sendmail_args={'from':self.user,'to':''}<EOL>headers=[]<EOL>for key,value in headers_dict.items():<EOL><INDENT>key=key.rstrip('_').lower().replace('_','-')<EOL>if key in sendmail_args :<EOL><INDENT>sendmail_args [key ]=value <EOL><DEDENT>if hasattr(value,'__iter__')and not isinstance(value,str):<EOL><INDENT>value=', '.join(value)<EOL><DEDENT>headers.append('%s: %s'%(key,value))<EOL><DEDENT>headers='\r\n'.join(headers)<EOL>if not self.dry_run :<EOL><INDENT>self.server.sendmail(<EOL>sendmail_args ['from'],<EOL>sendmail_args ['to'],<EOL>'%s\r\n\r\n%s'%(headers,body))<EOL><DEDENT> <DEDENT>def close(self):<EOL><INDENT>self.server.quit()<EOL><DEDENT>def __enter__(self):<EOL><INDENT>return self <EOL><DEDENT>def __exit__(self,exc_type,exc_value,exc_tb):<EOL><INDENT>self.close()<EOL><DEDENT> <DEDENT>class Gmail(Postbox):<EOL><INDENT>host='smtp.gmail.com'<EOL>port='587'<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import cv2 <EOL>import video <EOL>import sys <EOL>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>try :fn=sys.argv []<EOL>except :fn=<EOL>def nothing(*arg):<EOL><INDENT>pass <EOL><DEDENT>cv2.namedWindow('edge')<EOL>cv2.createTrackbar('thrs1','edge',,,nothing)<EOL>cv2.createTrackbar('thrs2','edge',,,nothing)<EOL>cap=video.create_capture(fn)<EOL>while True :<EOL><INDENT>flag,img=cap.read()<EOL>gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)<EOL>thrs1=cv2.getTrackbarPos('thrs1','edge')<EOL>thrs2=cv2.getTrackbarPos('thrs2','edge')<EOL>edge=cv2.Canny(gray,thrs1,thrs2,apertureSize=)<EOL>vis=img.copy()<EOL>vis /=<EOL>vis [edge !=]=(,,)<EOL>cv2.imshow('edge',vis)<EOL>ch=cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>import csv <EOL>from numpy import array <EOL>from StringIO import StringIO <EOL>from operator import add <EOL>from pyspark import SparkConf,SparkContext <EOL>def contribution(authors,rank):<EOL><INDENT> '<STR_LIT>'<EOL>count=len(authors)<EOL>for author in authors :<EOL><INDENT>yield(author,rank /count)<EOL><DEDENT> <DEDENT>def split(line):<EOL><INDENT> '<STR_LIT>'<EOL>reader=csv.reader(StringIO(line))<EOL>return tuple(reader.next())<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>sc=SparkContext("local[*]","PageRank")<EOL>lines=sc.textFile('<STR_LIT>')<EOL>links=lines.map(lambda line :split(line)).distinct().groupByKey().cache()<EOL>ranks=links.map(lambda(author,neighbors):(author,))<EOL>for iteration in xrange():<EOL><INDENT>contribs=links.join(ranks).flatMap(lambda(author,(authors,rank)):<EOL>contribution(authors,rank))<EOL>ranks=contribs.reduceByKey(add).mapValues(lambda rank :rank *+)<EOL><DEDENT>for(link,rank)in ranks.collect():<EOL><INDENT>print '<STR_LIT>'%(link,rank)<EOL><DEDENT> <DEDENT><EOF><BOF>import os <EOL>import sys <EOL>try :<EOL><INDENT>from ctypes import windll,Structure,c_short,c_ushort,byref <EOL><DEDENT>except ImportError :<EOL><INDENT>windll=None <EOL><DEDENT>def Highlighter(stream):<EOL><INDENT>if os.sep=='/':<EOL><INDENT>return AnsiHighlighter(stream)<EOL><DEDENT>return DosHighlighter(stream)if windll else NoHighlighting(stream)<EOL><DEDENT>class AnsiHighlighter(object):<EOL><INDENT>_ANSI_GREEN='\033[32m'<EOL>_ANSI_RED='\033[31m'<EOL>_ANSI_YELLOW='\033[33m'<EOL>_ANSI_RESET='\033[0m'<EOL>def __init__(self,stream):<EOL><INDENT>self._stream=stream <EOL><DEDENT>def green(self):<EOL><INDENT>self._set_color(self._ANSI_GREEN)<EOL><DEDENT>def red(self):<EOL><INDENT>self._set_color(self._ANSI_RED)<EOL><DEDENT>def yellow(self):<EOL><INDENT>self._set_color(self._ANSI_YELLOW)<EOL><DEDENT>def reset(self):<EOL><INDENT>self._set_color(self._ANSI_RESET)<EOL><DEDENT>def _set_color(self,color):<EOL><INDENT>self._stream.write(color)<EOL><DEDENT> <DEDENT>class NoHighlighting(AnsiHighlighter):<EOL><INDENT>def _set_color(self,color):<EOL><INDENT>pass <EOL><DEDENT> <DEDENT>class DosHighlighter(object):<EOL><INDENT>_FOREGROUND_GREEN=<EOL>_FOREGROUND_RED=<EOL>_FOREGROUND_YELLOW=<EOL>_FOREGROUND_GREY=<EOL>_FOREGROUND_INTENSITY=<EOL>_BACKGROUND_MASK=<EOL>_STDOUT_HANDLE=-<EOL>_STDERR_HANDLE=-<EOL>def __init__(self,stream):<EOL><INDENT>self._handle=self._get_std_handle(stream)<EOL>self._orig_colors=self._get_colors()<EOL>self._background=self._orig_colors &self._BACKGROUND_MASK <EOL><DEDENT>def green(self):<EOL><INDENT>self._set_foreground_colors(self._FOREGROUND_GREEN)<EOL><DEDENT>def red(self):<EOL><INDENT>self._set_foreground_colors(self._FOREGROUND_RED)<EOL><DEDENT>def yellow(self):<EOL><INDENT>self._set_foreground_colors(self._FOREGROUND_YELLOW)<EOL><DEDENT>def reset(self):<EOL><INDENT>self._set_colors(self._orig_colors)<EOL><DEDENT>def _get_std_handle(self,stream):<EOL><INDENT>handle=self._STDOUT_HANDLE if stream is sys.__stdout__ else self._STDERR_HANDLE <EOL>return windll.kernel32.GetStdHandle(handle)<EOL><DEDENT>def _get_colors(self):<EOL><INDENT>csbi=_CONSOLE_SCREEN_BUFFER_INFO()<EOL>ok=windll.kernel32.GetConsoleScreenBufferInfo(self._handle,byref(csbi))<EOL>if not ok :<EOL><INDENT>return self._FOREGROUND_GREY <EOL><DEDENT>return csbi.wAttributes <EOL><DEDENT>def _set_foreground_colors(self,colors):<EOL><INDENT>self._set_colors(colors |self._FOREGROUND_INTENSITY |self._background)<EOL><DEDENT>def _set_colors(self,colors):<EOL><INDENT>windll.kernel32.SetConsoleTextAttribute(self._handle,colors)<EOL><DEDENT> <DEDENT>if windll :<EOL><INDENT>class _COORD(Structure):<EOL><INDENT>_fields_=[("X",c_short),("Y",c_short)]<EOL><DEDENT>class _SMALL_RECT(Structure):<EOL><INDENT>_fields_=[("Left",c_short),("Top",c_short),("Right",c_short),("Bottom",c_short)]<EOL><DEDENT>class _CONSOLE_SCREEN_BUFFER_INFO(Structure):<EOL><INDENT>_fields_=[("dwSize",_COORD),('<STR_LIT>',_COORD),("wAttributes",c_ushort),("srWindow",_SMALL_RECT),('<STR_LIT>',_COORD)]<EOL><DEDENT> <DEDENT><EOF><BOF>from __future__ import print_function <EOL>import sys <EOL>def draw(story,squash=,verbose=False):<EOL><INDENT> '<STR_LIT>'<EOL>if verbose :<EOL><INDENT>print('Story : {}'.format(story),file=sys.stderr)<EOL>print('Squash: {}'.format(squash),file=sys.stderr)<EOL>print(file=sys.stderr)<EOL><DEDENT>ground_len=+(story -)*squash *<EOL>for i in range(,ground_len +,squash *):<EOL><INDENT>print(('*'*i).center(ground_len))<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>import clime.now <EOL><DEDENT><EOF><BOF>import unittest <EOL>from yapper import db <EOL>from yapper.blueprints.user.models import User,Role,Permission,AnonymousUser <EOL>from config import Config <EOL>class UserModelTestCase(unittest.TestCase):<EOL><INDENT>def setUp(self):<EOL><INDENT>db.create_all()<EOL>Role.insert_roles()<EOL><DEDENT>def tearDown(self):<EOL><INDENT>db.session.remove()<EOL>db.drop_all()<EOL><DEDENT>def test_password_setter(self):<EOL><INDENT>u=User(password='cat')<EOL>self.assertTrue(u.password_hash is not None)<EOL><DEDENT>def test_no_password_getter(self):<EOL><INDENT>u=User(password='cat')<EOL>with self.assertRaises(AttributeError):<EOL><INDENT>u.password <EOL><DEDENT> <DEDENT>def test_password_verification(self):<EOL><INDENT>u=User(password='cat')<EOL>self.assertTrue(u.verify_password('cat'))<EOL>self.assertFalse(u.verify_password('dog'))<EOL><DEDENT>def test_password_salts_are_random(self):<EOL><INDENT>u=User(password='cat')<EOL>u2=User(password='cat')<EOL>self.assertTrue(u.password_hash !=u2.password_hash)<EOL><DEDENT>def test_roles_and_permissions(self):<EOL><INDENT>u=User(email='user@gmail.com',password='adt')<EOL>self.assertTrue(u.can(Permission.WRITE_POSTS))<EOL><DEDENT>def test_admin(self):<EOL><INDENT>Role.insert_roles()<EOL>u=User(email=Config.FLASKY_ADMIN,password='adt')<EOL>self.assertTrue(u.is_admin())<EOL><DEDENT>def test_anon_user(self):<EOL><INDENT>u=AnonymousUser()<EOL>self.assertTrue(u.id==-)<EOL>self.assertFalse(u.can(Permission.WRITE_POSTS))<EOL><DEDENT> <DEDENT><EOF><BOF>import numpy as np <EOL>import cv2 <EOL>import video <EOL>help_message='<STR_LIT>'<EOL>def draw_flow(img,flow,step=):<EOL><INDENT>h,w=img.shape [:]<EOL>y,x=np.mgrid [step /:h :step,step /:w :step ].reshape(,-)<EOL>fx,fy=flow [y,x ].T <EOL>lines=np.vstack([x,y,x +fx,y +fy ]).T.reshape(-,,)<EOL>lines=np.int32(lines +)<EOL>vis=cv2.cvtColor(img,cv2.COLOR_GRAY2BGR)<EOL>cv2.polylines(vis,lines,,(,,))<EOL>for(x1,y1),(x2,y2)in lines :<EOL><INDENT>cv2.circle(vis,(x1,y1),,(,,),-)<EOL><DEDENT>return vis <EOL><DEDENT>def draw_hsv(flow):<EOL><INDENT>h,w=flow.shape [:]<EOL>fx,fy=flow [:,:,],flow [:,:,]<EOL>ang=np.arctan2(fy,fx)+np.pi <EOL>v=np.sqrt(fx *fx +fy *fy)<EOL>hsv=np.zeros((h,w,),np.uint8)<EOL>hsv [...,]=ang *(/np.pi /)<EOL>hsv [...,]=<EOL>hsv [...,]=np.minimum(v *,)<EOL>bgr=cv2.cvtColor(hsv,cv2.COLOR_HSV2BGR)<EOL>return bgr <EOL><DEDENT>def warp_flow(img,flow):<EOL><INDENT>h,w=flow.shape [:]<EOL>flow=-flow <EOL>flow [:,:,]+=np.arange(w)<EOL>flow [:,:,]+=np.arange(h)[:,np.newaxis ]<EOL>res=cv2.remap(img,flow,None,cv2.INTER_LINEAR)<EOL>return res <EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>import sys <EOL>print help_message <EOL>try :<EOL><INDENT>fn=sys.argv []<EOL><DEDENT>except :<EOL><INDENT>fn=<EOL><DEDENT>cam=video.create_capture(fn)<EOL>ret,prev=cam.read()<EOL>prevgray=cv2.cvtColor(prev,cv2.COLOR_BGR2GRAY)<EOL>show_hsv=False <EOL>show_glitch=False <EOL>cur_glitch=prev.copy()<EOL>while True :<EOL><INDENT>ret,img=cam.read()<EOL>gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)<EOL>flow=cv2.calcOpticalFlowFarneback(prevgray,gray,None,,,,,,,)<EOL>prevgray=gray <EOL>cv2.imshow('flow',draw_flow(gray,flow))<EOL>if show_hsv :<EOL><INDENT>cv2.imshow('flow HSV',draw_hsv(flow))<EOL><DEDENT>if show_glitch :<EOL><INDENT>cur_glitch=warp_flow(cur_glitch,flow)<EOL>cv2.imshow('glitch',cur_glitch)<EOL><DEDENT>ch=&cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT>if ch==ord('1'):<EOL><INDENT>show_hsv=not show_hsv <EOL>print '<STR_LIT>',['off','on'][show_hsv ]<EOL><DEDENT>if ch==ord('2'):<EOL><INDENT>show_glitch=not show_glitch <EOL>if show_glitch :<EOL><INDENT>cur_glitch=img.copy()<EOL><DEDENT>print 'glitch is',['off','on'][show_glitch ]<EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>class NotJsonError(ValueError):<EOL><INDENT> '<STR_LIT>'<EOL>pass <EOL><DEDENT>class InvalidKeyError(TypeError):<EOL><INDENT> '<STR_LIT>'<EOL>pass <EOL><DEDENT>class DifferentRepoError(ValueError):<EOL><INDENT> '<STR_LIT>'<EOL>pass <EOL><DEDENT>class NoGlobalSettingError(RuntimeError):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,name):<EOL><INDENT>super(NoGlobalSettingError,self).__init__(<EOL>'<STR_LIT>'%name)<EOL><DEDENT> <DEDENT>class StagedDataError(RuntimeError):<EOL><INDENT> '<STR_LIT>'<EOL>pass <EOL><DEDENT><EOF><BOF>try :<EOL><INDENT>from setuptools import setup <EOL><DEDENT>except ImportError :<EOL><INDENT>from distutils.core import setup <EOL><DEDENT>config={<EOL>'description':'<STR_LIT>',<EOL>'author':'Aaron Stannard',<EOL>'url':'<STR_LIT>',<EOL>'download_url':'<STR_LIT>',<EOL>'author_email':'<STR_LIT>',<EOL>'version':'0.1.5',<EOL>'<STR_LIT>':['nose'],<EOL>'packages':['scaffold'],<EOL>'scripts':[],<EOL>'name':'Scaffold',<EOL>'entry_points':{<EOL>'console_scripts':[<EOL>'<STR_LIT>',<EOL>],<EOL>'<STR_LIT>':[<EOL>'<STR_LIT>',<EOL>],<EOL>}<EOL>}<EOL>setup(**config)<EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>from numpy import linalg as LA <EOL>import cv2 <EOL>from cam import OpenCV_Cam <EOL>def contour_proc(frame,debug=False):<EOL><INDENT>gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)<EOL>if debug :cv2.imshow('gray',gray)<EOL>edge=cv2.Canny(gray,,)<EOL>edge=cv2.blur(edge,(,))<EOL>if debug :cv2.imshow('blured edge',edge)<EOL>thresh1,thresh=cv2.threshold(edge,,,cv2.THRESH_BINARY)<EOL>if debug :cv2.imshow('thresh',thresh)<EOL>contours,hry=cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)<EOL>cpframe=frame.copy()<EOL>cv2.drawContours(cpframe,contours,-,(,,),)<EOL>if debug :cv2.imshow('cpframe',cpframe)<EOL>parallelograms=find_parallelograms(contours)<EOL>cv2.drawContours(frame,parallelograms,-,(,,),)<EOL>return frame <EOL><DEDENT>def find_parallelograms(contours):<EOL><INDENT>parallelograms=[]<EOL>for ctr in contours :<EOL><INDENT>area=cv2.contourArea(ctr)<EOL>if area <:continue <EOL>simp_ctr=cv2.approxPolyDP(ctr,,True)<EOL>simp_area=cv2.contourArea(simp_ctr)<EOL>if simp_area <:continue <EOL>if len(simp_ctr)!=:continue <EOL>edges=[LA.norm(a -b)for a,b in zip(simp_ctr,np.roll(simp_ctr,))]<EOL>if(-edges []/edges [])**>:continue <EOL>if(-edges []/edges [])**>:continue <EOL>parallelograms.append(simp_ctr)<EOL><DEDENT>return parallelograms <EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>cam=OpenCV_Cam()<EOL>cam.cam_loop(contour_proc)<DEDENT><EOF><BOF>from __future__ import unicode_literals <EOL>from django.db import migrations <EOL>class Migration(migrations.Migration):<EOL><INDENT>dependencies=[('buildservice','<STR_LIT>'),<EOL>]<EOL>operations=[<EOL>migrations.AlterUniqueTogether(<EOL>name='build',<EOL>unique_together=set([('repository','number')]),),<EOL>]<EOL><DEDENT><EOF><BOF>import unittest <EOL>def get_keyword_at_pos(line,col):<EOL><INDENT>length=len(line)<EOL>if length==:<EOL><INDENT>return None <EOL><DEDENT>if((col >=length or line [col ]==' 'or line [col ]=="\t")<EOL>and(col==or line [col -]==' 'or line [col -]=="\t")):<EOL><INDENT>return None <EOL><DEDENT>i=col -<EOL>while i >=:<EOL><INDENT>if line [i ]=="\t"or((line [i -]==' 'or line [i -]=='|')and line [i ]==' '):<EOL><INDENT>break <EOL><DEDENT>i -=<EOL><DEDENT>begin=i +<EOL>i=col <EOL>while i <length :<EOL><INDENT>if line [i ]=="\t"or(line [i ]==" "and len(line)>i and(line [i +]==" "or line [i +]=='|')):<EOL><INDENT>break <EOL><DEDENT>i +=<EOL><DEDENT>end=i <EOL>keyword=line [begin :end ]<EOL>return line [begin :end ]<EOL><DEDENT>class TestGetKeywordAtPos(unittest.TestCase):<EOL><INDENT>def test_edges(self):<EOL><INDENT>self.assertEqual(get_keyword_at_pos('',),None)<EOL>self.assertEqual(get_keyword_at_pos('A',),'A')<EOL>self.assertEqual(get_keyword_at_pos('A',),'A')<EOL>for i in range(,):<EOL><INDENT>self.assertEqual(get_keyword_at_pos('AB',i),'AB')<EOL><DEDENT>for i in range(,):<EOL><INDENT>self.assertEqual(get_keyword_at_pos('A B',i),'A B')<EOL><DEDENT>self.assertEqual(get_keyword_at_pos('   A',),'A')<EOL>self.assertEqual(get_keyword_at_pos('A   ',),'A')<EOL><DEDENT>def test_splitting(self):<EOL><INDENT>self.assertEqual(get_keyword_at_pos('ABC  DEF',),'ABC')<EOL>self.assertEqual(get_keyword_at_pos('ABC  DEF',),'DEF')<EOL>self.assertEqual(get_keyword_at_pos('ABC  DEF',),'DEF')<EOL>self.assertEqual(get_keyword_at_pos('  ABC  DEF  ',),'ABC')<EOL>self.assertEqual(get_keyword_at_pos('  ABC  DEF  ',),'DEF')<EOL><DEDENT>def test_inbetween_spaces(self):<EOL><INDENT>self.assertEqual(get_keyword_at_pos('ABC  DEF',),None)<EOL>self.assertEqual(get_keyword_at_pos('  ',),None)<EOL>self.assertEqual(get_keyword_at_pos('  ',),None)<EOL>self.assertEqual(get_keyword_at_pos('  ',),None)<EOL>self.assertEqual(get_keyword_at_pos('   A',),None)<EOL><DEDENT>def test_samples(self):<EOL><INDENT>self.assertEqual(get_keyword_at_pos('<STR_LIT>',),'<STR_LIT>')<EOL>self.assertEqual(get_keyword_at_pos('<STR_LIT>',),'<STR_LIT>')<EOL>self.assertEqual(get_keyword_at_pos('<STR_LIT>',),'Some Keyword')<EOL><DEDENT>def test_tab_char(self):<EOL><INDENT>self.assertEqual(get_keyword_at_pos('<STR_LIT>',),'Some Keyword')<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>unittest.main()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from django import template <EOL>register=template.Library()<EOL>@register.simple_tag <EOL>def build_icon(build):<EOL><INDENT> '<STR_LIT>'<EOL>if build.is_success :<EOL><INDENT>return 'done'<EOL><DEDENT>elif build.is_pending :<EOL><INDENT>return 'alarm'<EOL><DEDENT>return 'clear'<EOL><DEDENT>@register.simple_tag <EOL>def build_icon_color(build):<EOL><INDENT> '<STR_LIT>'<EOL>if build.is_success :<EOL><INDENT>return 'success'<EOL><DEDENT>elif build.is_pending :<EOL><INDENT>return 'warning'<EOL><DEDENT>return 'danger'<EOL><DEDENT><EOF><BOF>import csv <EOL>from datetime import datetime <EOL>from StringIO import StringIO <EOL>from collections import namedtuple <EOL>DATE_FMT='<STR_LIT>'<EOL>Customer=namedtuple('Customer',('id','name','email','gender','registered','city','state','zip'))<EOL>def parse(row):<EOL><INDENT> '<STR_LIT>'<EOL>row []=int(row [])<EOL>row []=datetime.strptime(row [],DATE_FMT)<EOL>return Customer(*row)<EOL><DEDENT>def split(line):<EOL><INDENT> '<STR_LIT>'<EOL>reader=csv.reader(StringIO(line))<EOL>return reader.next()<EOL><DEDENT><EOF><BOF>from robot import model,utils <EOL>from keyword import Keyword <EOL>class TestCase(model.TestCase):<EOL><INDENT>__slots__=['status','message','starttime','endtime']<EOL>keyword_class=Keyword <EOL>def __init__(self,name='',doc='',tags=None,timeout='',status='FAIL',<EOL>message='',starttime=None,endtime=None):<EOL><INDENT> '<STR_LIT>'<EOL>model.TestCase.__init__(self,name,doc,tags,timeout)<EOL>self.status=status <EOL>self.message=message <EOL>self.starttime=starttime <EOL>self.endtime=endtime <EOL><DEDENT>@property <EOL>def elapsedtime(self):<EOL><INDENT>return utils.get_elapsed_time(self.starttime,self.endtime)<EOL><DEDENT>@property <EOL>def passed(self):<EOL><INDENT>return self.status=='PASS'<EOL><DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from django.db import models <EOL>from django.conf import settings <EOL>from django.core.urlresolvers import reverse <EOL>from buildservice.errors import InvalidStatus <EOL>from buildservice.utils import github <EOL>class Build(models.Model):<EOL><INDENT> '<STR_LIT>'<EOL>STATUSES=(('success','Success'),('failure','Failure'),('errored','Errored'),('pending','Pending'),)<EOL>repository=models.ForeignKey('Repository',on_delete=models.CASCADE)<EOL>number=models.IntegerField(default=)<EOL>branch=models.CharField(max_length=)<EOL>sha=models.CharField(max_length=)<EOL>pusher_name=models.CharField(max_length=)<EOL>status=models.CharField(max_length=,choices=STATUSES,default='pending')<EOL>created_at=models.DateTimeField(auto_now_add=True)<EOL>updated_at=models.DateTimeField(auto_now=True)<EOL>class Meta(object):<EOL><INDENT> '<STR_LIT>'<EOL>unique_together=(('repository','number'),)<EOL><DEDENT>@property <EOL>def pusher_profile_url(self):<EOL><INDENT> '<STR_LIT>'<EOL>return settings.GITHUB_USER_PROFILE_URL %self.pusher_name <EOL><DEDENT>@property <EOL>def url(self):<EOL><INDENT> '<STR_LIT>'<EOL>return "%s%s"%(<EOL>settings.BUILDSERVICE_BASE_URL,<EOL>reverse('build_detail',args=[self.repository.name,self.number ]))<EOL><DEDENT>@property <EOL>def is_success(self):<EOL><INDENT> '<STR_LIT>'<EOL>return self.status=='success'<EOL><DEDENT>@property <EOL>def is_pending(self):<EOL><INDENT> '<STR_LIT>'<EOL>return self.status=='pending'<EOL><DEDENT>@property <EOL>def short_sha(self):<EOL><INDENT> '<STR_LIT>'<EOL>return self.sha [:]<EOL><DEDENT>def update_status(self,status):<EOL><INDENT> '<STR_LIT>'<EOL>token=self.repository.get_token()<EOL>if status not in('success','pending','errored','failure'):<EOL><INDENT>raise InvalidStatus('Invalid status.')<EOL><DEDENT>self.status=status <EOL>self.save()<EOL>github.create_status(<EOL>token.value,self.repository.name,self.sha,<EOL>state=status,target_url=self.url )<EOL><DEDENT> <DEDENT><EOF><BOF>import os <EOL>import sys <EOL>from.encoding import decode_from_system,encode_to_system <EOL>from.unic import unic <EOL>def get_env_var(name,default=None):<EOL><INDENT>value=_get_env_var_from_java(name)<EOL>if value is not None :<EOL><INDENT>return value <EOL><DEDENT>try :<EOL><INDENT>value=os.environ [_encode(name)]<EOL><DEDENT>except KeyError :<EOL><INDENT>return default <EOL><DEDENT>else :<EOL><INDENT>return _decode(value)<EOL><DEDENT> <DEDENT>def set_env_var(name,value):<EOL><INDENT>os.environ [_encode(name)]=_encode(value)<EOL><DEDENT>def del_env_var(name):<EOL><INDENT>value=get_env_var(name)<EOL>if value is not None :<EOL><INDENT>del os.environ [_encode(name)]<EOL><DEDENT>return value <EOL><DEDENT>def get_env_vars():<EOL><INDENT>return dict((name if os.sep=='/'else name.upper(),get_env_var(name))<EOL>for name in(_decode(name)for name in os.environ))<EOL><DEDENT>def _encode(var):<EOL><INDENT>if isinstance(var,str):<EOL><INDENT>return var <EOL><DEDENT>if isinstance(var,unicode):<EOL><INDENT>return encode_to_system(var)<EOL><DEDENT>return str(var)<EOL><DEDENT>def _decode(var):<EOL><INDENT>return decode_from_system(var,can_be_from_java=False)<EOL><DEDENT>if not sys.platform.startswith('java'):<EOL><INDENT>def _get_env_var_from_java(name):<EOL><INDENT>return None <EOL><DEDENT> <DEDENT>else :<EOL><INDENT>from java.lang import String,System <EOL>def _get_env_var_from_java(name):<EOL><INDENT>name=name if isinstance(name,basestring)else unic(name)<EOL>value_set_before_execution=System.getenv(name)<EOL>if value_set_before_execution is None :<EOL><INDENT>return None <EOL><DEDENT>current_value=String(os.environ [name ]).toString()<EOL>if value_set_before_execution !=current_value :<EOL><INDENT>return None <EOL><DEDENT>return value_set_before_execution <EOL><DEDENT> <DEDENT><EOF><BOF>import os <EOL>import copy <EOL>from robot.errors import DataError <EOL>from robot.variables import is_var <EOL>from robot.output import LOGGER <EOL>from robot import utils <EOL>from robot.writer import DataFileWriter <EOL>from settings import(Documentation,Fixture,Timeout,Tags,Metadata,<EOL>Library,Resource,Variables,Arguments,Return,Template,Comment,<EOL>MetadataList,ImportList)<EOL>from populators import FromFilePopulator,FromDirectoryPopulator <EOL>def TestData(parent=None,source=None,include_suites=[],<EOL>warn_on_skipped=False):<EOL><INDENT> '<STR_LIT>'<EOL>if os.path.isdir(source):<EOL><INDENT>return TestDataDirectory(parent,source).populate(include_suites,<EOL>warn_on_skipped)<EOL><DEDENT>return TestCaseFile(parent,source).populate()<EOL><DEDENT>class _TestData(object):<EOL><INDENT>_setting_table_names='Setting','Settings','Metadata'<EOL>_variable_table_names='Variable','Variables'<EOL>_testcase_table_names='Test Case','Test Cases'<EOL>_keyword_table_names='Keyword','Keywords','User Keyword','User Keywords'<EOL>def __init__(self,parent=None,source=None):<EOL><INDENT>self.parent=parent <EOL>self.source=utils.abspath(source)if source else None <EOL>self.children=[]<EOL>self._tables=utils.NormalizedDict(self._get_tables())<EOL><DEDENT>def _get_tables(self):<EOL><INDENT>for names,table in [(self._setting_table_names,self.setting_table),(self._variable_table_names,self.variable_table),(self._testcase_table_names,self.testcase_table),(self._keyword_table_names,self.keyword_table)]:<EOL><INDENT>for name in names :<EOL><INDENT>yield name,table <EOL><DEDENT> <DEDENT> <DEDENT>def start_table(self,header_row):<EOL><INDENT>try :<EOL><INDENT>table=self._tables [header_row []]<EOL><DEDENT>except(KeyError,IndexError):<EOL><INDENT>return None <EOL><DEDENT>if not self._table_is_allowed(table):<EOL><INDENT>return None <EOL><DEDENT>table.set_header(header_row)<EOL>return table <EOL><DEDENT>@property <EOL>def name(self):<EOL><INDENT>return self._format_name(self._get_basename())if self.source else None <EOL><DEDENT>def _get_basename(self):<EOL><INDENT>return os.path.splitext(os.path.basename(self.source))[]<EOL><DEDENT>def _format_name(self,name):<EOL><INDENT>name=self._strip_possible_prefix_from_name(name)<EOL>name=name.replace('_',' ').strip()<EOL>return name.title()if name.islower()else name <EOL><DEDENT>def _strip_possible_prefix_from_name(self,name):<EOL><INDENT>return name.split('__',)[-]<EOL><DEDENT>@property <EOL>def keywords(self):<EOL><INDENT>return self.keyword_table.keywords <EOL><DEDENT>@property <EOL>def imports(self):<EOL><INDENT>return self.setting_table.imports <EOL><DEDENT>def report_invalid_syntax(self,table,message,level='ERROR'):<EOL><INDENT>initfile=getattr(self,'initfile',None)<EOL>path=os.path.join(self.source,initfile)if initfile else self.source <EOL>LOGGER.write('<STR_LIT>'<EOL>%(path,table,message),level)<EOL><DEDENT>def save(self,**options):<EOL><INDENT> '<STR_LIT>'<EOL>return DataFileWriter(**options).write(self)<EOL><DEDENT> <DEDENT>class TestCaseFile(_TestData):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,parent=None,source=None):<EOL><INDENT>self.directory=os.path.dirname(source)if source else None <EOL>self.setting_table=TestCaseFileSettingTable(self)<EOL>self.variable_table=VariableTable(self)<EOL>self.testcase_table=TestCaseTable(self)<EOL>self.keyword_table=KeywordTable(self)<EOL>_TestData.__init__(self,parent,source)<EOL><DEDENT>def populate(self):<EOL><INDENT>FromFilePopulator(self).populate(self.source)<EOL>self._validate()<EOL>return self <EOL><DEDENT>def _validate(self):<EOL><INDENT>if not self.testcase_table.is_started():<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT> <DEDENT>def _table_is_allowed(self,table):<EOL><INDENT>return True <EOL><DEDENT>def has_tests(self):<EOL><INDENT>return True <EOL><DEDENT>def __iter__(self):<EOL><INDENT>for table in [self.setting_table,self.variable_table,<EOL>self.testcase_table,self.keyword_table ]:<EOL><INDENT>yield table <EOL><DEDENT> <DEDENT> <DEDENT>class ResourceFile(_TestData):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,source=None):<EOL><INDENT>self.directory=os.path.dirname(source)if source else None <EOL>self.setting_table=ResourceFileSettingTable(self)<EOL>self.variable_table=VariableTable(self)<EOL>self.testcase_table=TestCaseTable(self)<EOL>self.keyword_table=KeywordTable(self)<EOL>_TestData.__init__(self,source=source)<EOL><DEDENT>def populate(self):<EOL><INDENT>FromFilePopulator(self).populate(self.source)<EOL>self._report_status()<EOL>return self <EOL><DEDENT>def _report_status(self):<EOL><INDENT>if self.setting_table or self.variable_table or self.keyword_table :<EOL><INDENT>LOGGER.info('<STR_LIT>'<EOL>%(self.source,len(self.keyword_table.keywords)))<EOL><DEDENT>else :<EOL><INDENT>LOGGER.warn('<STR_LIT>'%self.source)<EOL><DEDENT> <DEDENT>def _table_is_allowed(self,table):<EOL><INDENT>if table is self.testcase_table :<EOL><INDENT>raise DataError('<STR_LIT>'<EOL>'<STR_LIT>'%self.source)<EOL><DEDENT>return True <EOL><DEDENT>def __iter__(self):<EOL><INDENT>for table in [self.setting_table,self.variable_table,self.keyword_table ]:<EOL><INDENT>yield table <EOL><DEDENT> <DEDENT> <DEDENT>class TestDataDirectory(_TestData):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,parent=None,source=None):<EOL><INDENT>self.directory=source <EOL>self.initfile=None <EOL>self.setting_table=InitFileSettingTable(self)<EOL>self.variable_table=VariableTable(self)<EOL>self.testcase_table=TestCaseTable(self)<EOL>self.keyword_table=KeywordTable(self)<EOL>_TestData.__init__(self,parent,source)<EOL><DEDENT>def populate(self,include_suites=[],warn_on_skipped=False,recurse=True):<EOL><INDENT>FromDirectoryPopulator().populate(self.source,self,include_suites,<EOL>warn_on_skipped,recurse)<EOL>self.children=[ch for ch in self.children if ch.has_tests()]<EOL>return self <EOL><DEDENT>def _get_basename(self):<EOL><INDENT>return os.path.basename(self.source)<EOL><DEDENT>def _table_is_allowed(self,table):<EOL><INDENT>if table is self.testcase_table :<EOL><INDENT>LOGGER.error('<STR_LIT>'<EOL>'<STR_LIT>'%self.source)<EOL>return False <EOL><DEDENT>return True <EOL><DEDENT>def add_child(self,path,include_suites):<EOL><INDENT>self.children.append(TestData(parent=self,source=path,<EOL>include_suites=include_suites))<EOL><DEDENT>def has_tests(self):<EOL><INDENT>return any(ch.has_tests()for ch in self.children)<EOL><DEDENT>def __iter__(self):<EOL><INDENT>for table in [self.setting_table,self.variable_table,self.keyword_table ]:<EOL><INDENT>yield table <EOL><DEDENT> <DEDENT> <DEDENT>class _Table(object):<EOL><INDENT>def __init__(self,parent):<EOL><INDENT>self.parent=parent <EOL>self._header=None <EOL><DEDENT>def set_header(self,header):<EOL><INDENT>self._header=self._prune_old_style_headers(header)<EOL><DEDENT>def _prune_old_style_headers(self,header):<EOL><INDENT>if len(header)<:<EOL><INDENT>return header <EOL><DEDENT>if self._old_header_matcher.match(header):<EOL><INDENT>return [header []]<EOL><DEDENT>return header <EOL><DEDENT>@property <EOL>def header(self):<EOL><INDENT>return self._header or [self.type.title()+'s']<EOL><DEDENT>@property <EOL>def name(self):<EOL><INDENT>return self.header []<EOL><DEDENT>@property <EOL>def source(self):<EOL><INDENT>return self.parent.source <EOL><DEDENT>@property <EOL>def directory(self):<EOL><INDENT>return self.parent.directory <EOL><DEDENT>def report_invalid_syntax(self,message,level='ERROR'):<EOL><INDENT>self.parent.report_invalid_syntax(self.name,message,level)<EOL><DEDENT>def __nonzero__(self):<EOL><INDENT>return bool(self._header or len(self))<EOL><DEDENT>def __len__(self):<EOL><INDENT>return sum(for item in self)<EOL><DEDENT> <DEDENT>class _WithSettings(object):<EOL><INDENT>def get_setter(self,setting_name):<EOL><INDENT>normalized=self.normalize(setting_name)<EOL>if normalized in self._setters :<EOL><INDENT>return self._setters [normalized ](self)<EOL><DEDENT>self.report_invalid_syntax('<STR_LIT>'%setting_name)<EOL><DEDENT>def is_setting(self,setting_name):<EOL><INDENT>return self.normalize(setting_name)in self._setters <EOL><DEDENT>def normalize(self,setting):<EOL><INDENT>result=utils.normalize(setting)<EOL>return result [:-]if result and result [-]==':'else result <EOL><DEDENT> <DEDENT>class _SettingTable(_Table,_WithSettings):<EOL><INDENT>type='setting'<EOL>def __init__(self,parent):<EOL><INDENT>_Table.__init__(self,parent)<EOL>self.doc=Documentation('Documentation',self)<EOL>self.suite_setup=Fixture('Suite Setup',self)<EOL>self.suite_teardown=Fixture('Suite Teardown',self)<EOL>self.test_setup=Fixture('Test Setup',self)<EOL>self.test_teardown=Fixture('Test Teardown',self)<EOL>self.force_tags=Tags('Force Tags',self)<EOL>self.default_tags=Tags('Default Tags',self)<EOL>self.test_template=Template('Test Template',self)<EOL>self.test_timeout=Timeout('Test Timeout',self)<EOL>self.metadata=MetadataList(self)<EOL>self.imports=ImportList(self)<EOL><DEDENT>@property <EOL>def _old_header_matcher(self):<EOL><INDENT>return OldStyleSettingAndVariableTableHeaderMatcher()<EOL><DEDENT>def add_metadata(self,name,value='',comment=None):<EOL><INDENT>self.metadata.add(Metadata(self,name,value,comment,linenumber=self.linenumber))<EOL>return self.metadata [-]<EOL><DEDENT>def add_library(self,name,args=None,comment=None):<EOL><INDENT>self.imports.add(Library(self,name,args,comment=comment))<EOL>return self.imports [-]<EOL><DEDENT>def add_resource(self,name,invalid_args=None,comment=None):<EOL><INDENT>self.imports.add(Resource(self,name,invalid_args,comment=comment))<EOL>return self.imports [-]<EOL><DEDENT>def add_variables(self,name,args=None,comment=None):<EOL><INDENT>self.imports.add(Variables(self,name,args,comment=comment))<EOL>return self.imports [-]<EOL><DEDENT>def __len__(self):<EOL><INDENT>return sum(for setting in self if setting.is_set())<EOL><DEDENT> <DEDENT>class TestCaseFileSettingTable(_SettingTable):<EOL><INDENT>_setters={'documentation':lambda s :s.doc.populate,<EOL>'document':lambda s :s.doc.populate,<EOL>'suitesetup':lambda s :s.suite_setup.populate,<EOL>'<STR_LIT>':lambda s :s.suite_setup.populate,<EOL>'suiteteardown':lambda s :s.suite_teardown.populate,<EOL>'<STR_LIT>':lambda s :s.suite_teardown.populate,<EOL>'testsetup':lambda s :s.test_setup.populate,<EOL>'<STR_LIT>':lambda s :s.test_setup.populate,<EOL>'testteardown':lambda s :s.test_teardown.populate,<EOL>'<STR_LIT>':lambda s :s.test_teardown.populate,<EOL>'forcetags':lambda s :s.force_tags.populate,<EOL>'defaulttags':lambda s :s.default_tags.populate,<EOL>'testtemplate':lambda s :s.test_template.populate,<EOL>'testtimeout':lambda s :s.test_timeout.populate,<EOL>'library':lambda s :s.imports.populate_library,<EOL>'resource':lambda s :s.imports.populate_resource,<EOL>'variables':lambda s :s.imports.populate_variables,<EOL>'metadata':lambda s :s.metadata.populate }<EOL>def __iter__(self):<EOL><INDENT>for setting in [self.doc,self.suite_setup,self.suite_teardown,<EOL>self.test_setup,self.test_teardown,self.force_tags,<EOL>self.default_tags,self.test_template,self.test_timeout ]+self.metadata.data +self.imports.data :<EOL><INDENT>yield setting <EOL><DEDENT> <DEDENT> <DEDENT>class ResourceFileSettingTable(_SettingTable):<EOL><INDENT>_setters={'documentation':lambda s :s.doc.populate,<EOL>'document':lambda s :s.doc.populate,<EOL>'library':lambda s :s.imports.populate_library,<EOL>'resource':lambda s :s.imports.populate_resource,<EOL>'variables':lambda s :s.imports.populate_variables }<EOL>def __iter__(self):<EOL><INDENT>for setting in [self.doc ]+self.imports.data :<EOL><INDENT>yield setting <EOL><DEDENT> <DEDENT> <DEDENT>class InitFileSettingTable(_SettingTable):<EOL><INDENT>_setters={'documentation':lambda s :s.doc.populate,<EOL>'document':lambda s :s.doc.populate,<EOL>'suitesetup':lambda s :s.suite_setup.populate,<EOL>'<STR_LIT>':lambda s :s.suite_setup.populate,<EOL>'suiteteardown':lambda s :s.suite_teardown.populate,<EOL>'<STR_LIT>':lambda s :s.suite_teardown.populate,<EOL>'testsetup':lambda s :s.test_setup.populate,<EOL>'<STR_LIT>':lambda s :s.test_setup.populate,<EOL>'testteardown':lambda s :s.test_teardown.populate,<EOL>'<STR_LIT>':lambda s :s.test_teardown.populate,<EOL>'testtimeout':lambda s :s.test_timeout.populate,<EOL>'forcetags':lambda s :s.force_tags.populate,<EOL>'library':lambda s :s.imports.populate_library,<EOL>'resource':lambda s :s.imports.populate_resource,<EOL>'variables':lambda s :s.imports.populate_variables,<EOL>'metadata':lambda s :s.metadata.populate }<EOL>def __iter__(self):<EOL><INDENT>for setting in [self.doc,self.suite_setup,self.suite_teardown,<EOL>self.test_setup,self.test_teardown,self.force_tags,<EOL>self.test_timeout ]+self.metadata.data +self.imports.data :<EOL><INDENT>yield setting <EOL><DEDENT> <DEDENT> <DEDENT>class VariableTable(_Table):<EOL><INDENT>type='variable'<EOL>def __init__(self,parent):<EOL><INDENT>_Table.__init__(self,parent)<EOL>self.variables=[]<EOL><DEDENT>@property <EOL>def _old_header_matcher(self):<EOL><INDENT>return OldStyleSettingAndVariableTableHeaderMatcher()<EOL><DEDENT>def add(self,name,value,comment=None,linenumber=None):<EOL><INDENT>self.variables.append(Variable(name,value,comment))<EOL><DEDENT>def __iter__(self):<EOL><INDENT>return iter(self.variables)<EOL><DEDENT> <DEDENT>class TestCaseTable(_Table):<EOL><INDENT>type='test case'<EOL>def __init__(self,parent):<EOL><INDENT>_Table.__init__(self,parent)<EOL>self.tests=[]<EOL><DEDENT>@property <EOL>def _old_header_matcher(self):<EOL><INDENT>return OldStyleTestAndKeywordTableHeaderMatcher()<EOL><DEDENT>def add(self,name):<EOL><INDENT>self.tests.append(TestCase(self,name))<EOL>return self.tests [-]<EOL><DEDENT>def __iter__(self):<EOL><INDENT>return iter(self.tests)<EOL><DEDENT>def is_started(self):<EOL><INDENT>return bool(self._header)<EOL><DEDENT>def __nonzero__(self):<EOL><INDENT>return True <EOL><DEDENT> <DEDENT>class KeywordTable(_Table):<EOL><INDENT>type='keyword'<EOL>def __init__(self,parent):<EOL><INDENT>_Table.__init__(self,parent)<EOL>self.keywords=[]<EOL><DEDENT>@property <EOL>def _old_header_matcher(self):<EOL><INDENT>return OldStyleTestAndKeywordTableHeaderMatcher()<EOL><DEDENT>def add(self,name):<EOL><INDENT>self.keywords.append(UserKeyword(self,name))<EOL>return self.keywords [-]<EOL><DEDENT>def __iter__(self):<EOL><INDENT>return iter(self.keywords)<EOL><DEDENT> <DEDENT>class Variable(object):<EOL><INDENT>def __init__(self,name,value,comment=None,linenumber=None):<EOL><INDENT>self.name=name.rstrip('= ')<EOL>if name.startswith('$')and value==[]:<EOL><INDENT>value=''<EOL><DEDENT>if isinstance(value,basestring):<EOL><INDENT>value=[value ]<EOL><DEDENT>self.value=value <EOL>self.comment=Comment(comment)<EOL>self.linenumber=linenumber <EOL><DEDENT>def as_list(self):<EOL><INDENT>if self.has_data():<EOL><INDENT>return [self.name ]+self.value +self.comment.as_list()<EOL><DEDENT>return self.comment.as_list()<EOL><DEDENT>def is_set(self):<EOL><INDENT>return True <EOL><DEDENT>def is_for_loop(self):<EOL><INDENT>return False <EOL><DEDENT>def has_data(self):<EOL><INDENT>return bool(self.name or ''.join(self.value))<EOL><DEDENT> <DEDENT>class _WithSteps(object):<EOL><INDENT>def add_step(self,content,comment=None,linenumber=None):<EOL><INDENT>self.steps.append(Step(content,comment,linenumber))<EOL>return self.steps [-]<EOL><DEDENT>def copy(self,name):<EOL><INDENT>new=copy.deepcopy(self)<EOL>new.name=name <EOL>self._add_to_parent(new)<EOL>return new <EOL><DEDENT> <DEDENT>class TestCase(_WithSteps,_WithSettings):<EOL><INDENT>def __init__(self,parent,name):<EOL><INDENT>self.parent=parent <EOL>self.name=name <EOL>self.doc=Documentation('[Documentation]',self)<EOL>self.template=Template('[Template]',self)<EOL>self.tags=Tags('[Tags]',self)<EOL>self.setup=Fixture('[Setup]',self)<EOL>self.teardown=Fixture('[Teardown]',self)<EOL>self.timeout=Timeout('[Timeout]',self)<EOL>self.linenumber=None <EOL>self.steps=[]<EOL><DEDENT>_setters={'documentation':lambda s :s.doc.populate,<EOL>'document':lambda s :s.doc.populate,<EOL>'template':lambda s :s.template.populate,<EOL>'setup':lambda s :s.setup.populate,<EOL>'precondition':lambda s :s.setup.populate,<EOL>'teardown':lambda s :s.teardown.populate,<EOL>'postcondition':lambda s :s.teardown.populate,<EOL>'tags':lambda s :s.tags.populate,<EOL>'timeout':lambda s :s.timeout.populate }<EOL>@property <EOL>def source(self):<EOL><INDENT>return self.parent.source <EOL><DEDENT>@property <EOL>def directory(self):<EOL><INDENT>return self.parent.directory <EOL><DEDENT>def add_for_loop(self,data):<EOL><INDENT>self.steps.append(ForLoop(data))<EOL>return self.steps [-]<EOL><DEDENT>def report_invalid_syntax(self,message,level='ERROR'):<EOL><INDENT>type_='test case'if type(self)is TestCase else 'keyword'<EOL>message='<STR_LIT>'%(type_,self.name,message)<EOL>self.parent.report_invalid_syntax(message,level)<EOL><DEDENT>def _add_to_parent(self,test):<EOL><INDENT>self.parent.tests.append(test)<EOL><DEDENT>@property <EOL>def settings(self):<EOL><INDENT>return [self.doc,self.tags,self.setup,self.template,self.timeout,<EOL>self.teardown ]<EOL><DEDENT>def __iter__(self):<EOL><INDENT>for element in [self.doc,self.tags,self.setup,<EOL>self.template,self.timeout ]+self.steps +[self.teardown ]:<EOL><INDENT>yield element <EOL><DEDENT> <DEDENT> <DEDENT>class UserKeyword(TestCase):<EOL><INDENT>def __init__(self,parent,name):<EOL><INDENT>self.parent=parent <EOL>self.name=name <EOL>self.doc=Documentation('[Documentation]',self)<EOL>self.args=Arguments('[Arguments]',self)<EOL>self.return_=Return('[Return]',self)<EOL>self.timeout=Timeout('[Timeout]',self)<EOL>self.teardown=Fixture('[Teardown]',self)<EOL>self.linenumber=None <EOL>self.steps=[]<EOL><DEDENT>_setters={'documentation':lambda s :s.doc.populate,<EOL>'document':lambda s :s.doc.populate,<EOL>'arguments':lambda s :s.args.populate,<EOL>'return':lambda s :s.return_.populate,<EOL>'timeout':lambda s :s.timeout.populate,<EOL>'teardown':lambda s :s.teardown.populate }<EOL>def _add_to_parent(self,test):<EOL><INDENT>self.parent.keywords.append(test)<EOL><DEDENT>@property <EOL>def settings(self):<EOL><INDENT>return [self.args,self.doc,self.timeout,self.teardown,self.return_ ]<EOL><DEDENT>def __iter__(self):<EOL><INDENT>for element in [self.args,self.doc,self.timeout ]+self.steps +[self.teardown,self.return_ ]:<EOL><INDENT>yield element <EOL><DEDENT> <DEDENT> <DEDENT>class ForLoop(_WithSteps):<EOL><INDENT>def __init__(self,content):<EOL><INDENT>self.range,index=self._get_range_and_index(content)<EOL>self.vars=content [:index ]<EOL>self.items=content [index +:]<EOL>self.steps=[]<EOL>self.linenumber=None <EOL><DEDENT>def _get_range_and_index(self,content):<EOL><INDENT>for index,item in enumerate(content):<EOL><INDENT>item=item.upper().replace(' ','')<EOL>if item in ['IN','INRANGE']:<EOL><INDENT>return item=='INRANGE',index <EOL><DEDENT> <DEDENT>return False,len(content)<EOL><DEDENT>def is_comment(self):<EOL><INDENT>return False <EOL><DEDENT>def is_for_loop(self):<EOL><INDENT>return True <EOL><DEDENT>def apply_template(self,template):<EOL><INDENT>return self <EOL><DEDENT>def as_list(self,indent=False,include_comment=False):<EOL><INDENT>return [': FOR']+self.vars +['IN RANGE'if self.range else 'IN']+self.items <EOL><DEDENT>def __iter__(self):<EOL><INDENT>return iter(self.steps)<EOL><DEDENT>def is_set(self):<EOL><INDENT>return True <EOL><DEDENT> <DEDENT>class Step(object):<EOL><INDENT>def __init__(self,content,comment=None,linenumber=None):<EOL><INDENT>self.assign=list(self._get_assigned_vars(content))<EOL>try :<EOL><INDENT>self.keyword=content [len(self.assign)]<EOL><DEDENT>except IndexError :<EOL><INDENT>self.keyword=None <EOL><DEDENT>self.args=content [len(self.assign)+:]<EOL>self.comment=Comment(comment)<EOL>self.linenumber=linenumber <EOL><DEDENT>def _get_assigned_vars(self,content):<EOL><INDENT>for item in content :<EOL><INDENT>if not is_var(item.rstrip('= ')):<EOL><INDENT>return <EOL><DEDENT>yield item <EOL><DEDENT> <DEDENT>def is_comment(self):<EOL><INDENT>return not(self.assign or self.keyword or self.args)<EOL><DEDENT>def is_for_loop(self):<EOL><INDENT>return False <EOL><DEDENT>def apply_template(self,template):<EOL><INDENT>if self.is_comment():<EOL><INDENT>return self <EOL><DEDENT>return Step([template ]+self.as_list(include_comment=False))<EOL><DEDENT>def is_set(self):<EOL><INDENT>return True <EOL><DEDENT>def as_list(self,indent=False,include_comment=True):<EOL><INDENT>kw=[self.keyword ]if self.keyword is not None else []<EOL>ret=self.assign +kw +self.args <EOL>if indent :<EOL><INDENT>ret.insert(,'')<EOL><DEDENT>if include_comment and self.comment :<EOL><INDENT>ret +=self.comment.as_list()<EOL><DEDENT>return ret <EOL><DEDENT> <DEDENT>class OldStyleSettingAndVariableTableHeaderMatcher(object):<EOL><INDENT>def match(self,header):<EOL><INDENT>return all((True if e.lower()=='value'else False)<EOL>for e in header [:])<EOL><DEDENT> <DEDENT>class OldStyleTestAndKeywordTableHeaderMatcher(object):<EOL><INDENT>def match(self,header):<EOL><INDENT>if header [].lower()!='action':<EOL><INDENT>return False <EOL><DEDENT>for h in header [:]:<EOL><INDENT>if not h.lower().startswith('arg'):<EOL><INDENT>return False <EOL><DEDENT> <DEDENT>return True <EOL><DEDENT> <DEDENT><EOF><BOF>import os <EOL>import re <EOL>import time <EOL>from robot.output import LOGGER,Message <EOL>from robot.errors import DataError,ExecutionFailed,ExecutionFailures <EOL>from robot import utils <EOL>from robot.utils import asserts <EOL>from robot.variables import is_var,is_list_var <EOL>from robot.running import Keyword,RUN_KW_REGISTER <EOL>from robot.running.context import EXECUTION_CONTEXTS <EOL>from robot.common import UserErrorHandler <EOL>from robot.version import get_version <EOL>from robot.model import TagPatterns <EOL>if utils.is_jython :<EOL><INDENT>from java.lang import String,Number <EOL><DEDENT>try :<EOL><INDENT>bin <EOL><DEDENT>except NameError :<EOL><INDENT>def bin(integer):<EOL><INDENT>if not isinstance(integer,(int,long)):<EOL><INDENT>raise TypeError <EOL><DEDENT>if integer >=:<EOL><INDENT>prefix='0b'<EOL><DEDENT>else :<EOL><INDENT>prefix='-0b'<EOL>integer=abs(integer)<EOL><DEDENT>bins=[]<EOL>while integer >:<EOL><INDENT>integer,remainder=divmod(integer,)<EOL>bins.append(str(remainder))<EOL><DEDENT>bins.append(str(integer))<EOL>return prefix +''.join(reversed(bins))<EOL><DEDENT> <DEDENT>class _Converter :<EOL><INDENT>def convert_to_integer(self,item,base=None):<EOL><INDENT> '<STR_LIT>'<EOL>self._log_types(item)<EOL>return self._convert_to_integer(item,base)<EOL><DEDENT>def _convert_to_integer(self,orig,base=None):<EOL><INDENT>try :<EOL><INDENT>item=self._handle_java_numbers(orig)<EOL>item,base=self._get_base(item,base)<EOL>if base :<EOL><INDENT>return int(item,self._convert_to_integer(base))<EOL><DEDENT>return int(item)<EOL><DEDENT>except :<EOL><INDENT>raise RuntimeError('<STR_LIT>'<EOL>%(orig,utils.get_error_message()))<EOL><DEDENT> <DEDENT>def _handle_java_numbers(self,item):<EOL><INDENT>if not utils.is_jython :<EOL><INDENT>return item <EOL><DEDENT>if isinstance(item,String):<EOL><INDENT>return utils.unic(item)<EOL><DEDENT>if isinstance(item,Number):<EOL><INDENT>return item.doubleValue()<EOL><DEDENT>return item <EOL><DEDENT>def _get_base(self,item,base):<EOL><INDENT>if not isinstance(item,basestring):<EOL><INDENT>return item,base <EOL><DEDENT>item=utils.normalize(item)<EOL>if item.startswith(('-','+')):<EOL><INDENT>sign=item []<EOL>item=item [:]<EOL><DEDENT>else :<EOL><INDENT>sign=''<EOL><DEDENT>bases={'0b':,'0o':,'0x':}<EOL>if base or not item.startswith(tuple(bases)):<EOL><INDENT>return sign +item,base <EOL><DEDENT>return sign +item [:],bases [item [:]]<EOL><DEDENT>def convert_to_binary(self,item,base=None,prefix=None,length=None):<EOL><INDENT> '<STR_LIT>'<EOL>return self._convert_to_bin_oct_hex(bin,item,base,prefix,length)<EOL><DEDENT>def convert_to_octal(self,item,base=None,prefix=None,length=None):<EOL><INDENT> '<STR_LIT>'<EOL>return self._convert_to_bin_oct_hex(oct,item,base,prefix,length)<EOL><DEDENT>def convert_to_hex(self,item,base=None,prefix=None,length=None,<EOL>lowercase=False):<EOL><INDENT> '<STR_LIT>'<EOL>return self._convert_to_bin_oct_hex(hex,item,base,prefix,length,<EOL>lowercase)<EOL><DEDENT>def _convert_to_bin_oct_hex(self,method,item,base,prefix,length,<EOL>lowercase=False):<EOL><INDENT>self._log_types(item)<EOL>ret=method(self._convert_to_integer(item,base)).upper()<EOL>prefix=prefix or ''<EOL>if ret []=='-':<EOL><INDENT>prefix='-'+prefix <EOL>ret=ret [:]<EOL><DEDENT>if len(ret)>:<EOL><INDENT>prefix_length={bin :,oct :,hex :}[method ]<EOL>ret=ret [prefix_length :]<EOL><DEDENT>if length :<EOL><INDENT>ret=ret.rjust(self._convert_to_integer(length),'0')<EOL><DEDENT>if lowercase :<EOL><INDENT>ret=ret.lower()<EOL><DEDENT>return prefix +ret <EOL><DEDENT>def convert_to_number(self,item,precision=None):<EOL><INDENT> '<STR_LIT>'<EOL>self._log_types(item)<EOL>return self._convert_to_number(item,precision)<EOL><DEDENT>def _convert_to_number(self,item,precision=None):<EOL><INDENT>number=self._convert_to_number_without_precision(item)<EOL>if precision :<EOL><INDENT>number=round(number,self._convert_to_integer(precision))<EOL><DEDENT>return number <EOL><DEDENT>def _convert_to_number_without_precision(self,item):<EOL><INDENT>try :<EOL><INDENT>if utils.is_jython :<EOL><INDENT>item=self._handle_java_numbers(item)<EOL><DEDENT>return float(item)<EOL><DEDENT>except :<EOL><INDENT>error=utils.get_error_message()<EOL>try :<EOL><INDENT>return float(self._convert_to_integer(item))<EOL><DEDENT>except RuntimeError :<EOL><INDENT>raise RuntimeError('<STR_LIT>'<EOL>'<STR_LIT>'%(item,error))<EOL><DEDENT> <DEDENT> <DEDENT>def convert_to_string(self,item):<EOL><INDENT> '<STR_LIT>'<EOL>self._log_types(item)<EOL>return self._convert_to_string(item)<EOL><DEDENT>def _convert_to_string(self,item):<EOL><INDENT>return utils.unic(item)<EOL><DEDENT>def convert_to_boolean(self,item):<EOL><INDENT> '<STR_LIT>'<EOL>self._log_types(item)<EOL>if isinstance(item,basestring):<EOL><INDENT>if utils.eq(item,'True'):<EOL><INDENT>return True <EOL><DEDENT>if utils.eq(item,'False'):<EOL><INDENT>return False <EOL><DEDENT> <DEDENT>return bool(item)<EOL><DEDENT>def create_list(self,*items):<EOL><INDENT> '<STR_LIT>'<EOL>return list(items)<EOL><DEDENT> <DEDENT>class _Verify :<EOL><INDENT>def fail(self,msg=None,*tags):<EOL><INDENT> '<STR_LIT>'<EOL>set_tags=[tag for tag in tags if not tag.startswith('-')]<EOL>remove_tags=[tag [:]for tag in tags if tag.startswith('-')]<EOL>if remove_tags :<EOL><INDENT>self.remove_tags(*remove_tags)<EOL><DEDENT>if set_tags :<EOL><INDENT>self.set_tags(*set_tags)<EOL><DEDENT>raise AssertionError(msg)if msg else AssertionError()<EOL><DEDENT>def fatal_error(self,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>error=AssertionError(msg)if msg else AssertionError()<EOL>error.ROBOT_EXIT_ON_FAILURE=True <EOL>raise error <EOL><DEDENT>def exit_for_loop(self):<EOL><INDENT> '<STR_LIT>'<EOL>error=AssertionError('<STR_LIT>')<EOL>error.ROBOT_EXIT_FOR_LOOP=True <EOL>raise error <EOL><DEDENT>def should_not_be_true(self,condition,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>if not msg :<EOL><INDENT>msg='<STR_LIT>'%condition <EOL><DEDENT>asserts.fail_if(self._is_true(condition),msg)<EOL><DEDENT>def should_be_true(self,condition,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>if not msg :<EOL><INDENT>msg='<STR_LIT>'%condition <EOL><DEDENT>asserts.fail_unless(self._is_true(condition),msg)<EOL><DEDENT>def should_be_equal(self,first,second,msg=None,values=True):<EOL><INDENT> '<STR_LIT>'<EOL>self._log_types(first,second)<EOL>self._should_be_equal(first,second,msg,values)<EOL><DEDENT>def _should_be_equal(self,first,second,msg,values):<EOL><INDENT>asserts.fail_unless_equal(first,second,msg,<EOL>self._include_values(values))<EOL><DEDENT>def _log_types(self,*args):<EOL><INDENT>msg=['<STR_LIT>']+[self._get_type(a)for a in args ]<EOL>self.log('\n'.join(msg))<EOL><DEDENT>def _get_type(self,arg):<EOL><INDENT>if isinstance(arg,unicode):<EOL><INDENT>return '<STR_LIT>'<EOL><DEDENT>return str(type(arg))<EOL><DEDENT>def _include_values(self,values):<EOL><INDENT>if isinstance(values,basestring):<EOL><INDENT>return values.lower()not in ['no values','false']<EOL><DEDENT>return bool(values)<EOL><DEDENT>def should_not_be_equal(self,first,second,msg=None,values=True):<EOL><INDENT> '<STR_LIT>'<EOL>self._log_types(first,second)<EOL>self._should_not_be_equal(first,second,msg,values)<EOL><DEDENT>def _should_not_be_equal(self,first,second,msg,values):<EOL><INDENT>asserts.fail_if_equal(first,second,msg,self._include_values(values))<EOL><DEDENT>def should_not_be_equal_as_integers(self,first,second,msg=None,<EOL>values=True,base=None):<EOL><INDENT> '<STR_LIT>'<EOL>self._log_types(first,second)<EOL>self._should_not_be_equal(self._convert_to_integer(first,base),<EOL>self._convert_to_integer(second,base),<EOL>msg,values)<EOL><DEDENT>def should_be_equal_as_integers(self,first,second,msg=None,values=True,<EOL>base=None):<EOL><INDENT> '<STR_LIT>'<EOL>self._log_types(first,second)<EOL>self._should_be_equal(self._convert_to_integer(first,base),<EOL>self._convert_to_integer(second,base),<EOL>msg,values)<EOL><DEDENT>def should_not_be_equal_as_numbers(self,first,second,msg=None,<EOL>values=True,precision=):<EOL><INDENT> '<STR_LIT>'<EOL>self._log_types(first,second)<EOL>first=self._convert_to_number(first,precision)<EOL>second=self._convert_to_number(second,precision)<EOL>self._should_not_be_equal(first,second,msg,values)<EOL><DEDENT>def should_be_equal_as_numbers(self,first,second,msg=None,values=True,<EOL>precision=):<EOL><INDENT> '<STR_LIT>'<EOL>self._log_types(first,second)<EOL>first=self._convert_to_number(first,precision)<EOL>second=self._convert_to_number(second,precision)<EOL>self._should_be_equal(first,second,msg,values)<EOL><DEDENT>def should_not_be_equal_as_strings(self,first,second,msg=None,values=True):<EOL><INDENT> '<STR_LIT>'<EOL>self._log_types(first,second)<EOL>first,second=[self._convert_to_string(i)for i in first,second ]<EOL>self._should_not_be_equal(first,second,msg,values)<EOL><DEDENT>def should_be_equal_as_strings(self,first,second,msg=None,values=True):<EOL><INDENT> '<STR_LIT>'<EOL>self._log_types(first,second)<EOL>first,second=[self._convert_to_string(i)for i in first,second ]<EOL>self._should_be_equal(first,second,msg,values)<EOL><DEDENT>def should_not_start_with(self,str1,str2,msg=None,values=True):<EOL><INDENT> '<STR_LIT>'<EOL>msg=self._get_string_msg(str1,str2,msg,values,'starts with')<EOL>asserts.fail_if(str1.startswith(str2),msg)<EOL><DEDENT>def should_start_with(self,str1,str2,msg=None,values=True):<EOL><INDENT> '<STR_LIT>'<EOL>msg=self._get_string_msg(str1,str2,msg,values,'<STR_LIT>')<EOL>asserts.fail_unless(str1.startswith(str2),msg)<EOL><DEDENT>def should_not_end_with(self,str1,str2,msg=None,values=True):<EOL><INDENT> '<STR_LIT>'<EOL>msg=self._get_string_msg(str1,str2,msg,values,'ends with')<EOL>asserts.fail_if(str1.endswith(str2),msg)<EOL><DEDENT>def should_end_with(self,str1,str2,msg=None,values=True):<EOL><INDENT> '<STR_LIT>'<EOL>msg=self._get_string_msg(str1,str2,msg,values,'<STR_LIT>')<EOL>asserts.fail_unless(str1.endswith(str2),msg)<EOL><DEDENT>def should_not_contain(self,item1,item2,msg=None,values=True):<EOL><INDENT> '<STR_LIT>'<EOL>msg=self._get_string_msg(item1,item2,msg,values,'contains')<EOL>asserts.fail_if(item2 in item1,msg)<EOL><DEDENT>def should_contain(self,item1,item2,msg=None,values=True):<EOL><INDENT> '<STR_LIT>'<EOL>msg=self._get_string_msg(item1,item2,msg,values,'<STR_LIT>')<EOL>asserts.fail_unless(item2 in item1,msg)<EOL><DEDENT>def should_contain_x_times(self,item1,item2,count,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>if not msg :<EOL><INDENT>msg='<STR_LIT>'%(utils.unic(item1),utils.unic(item2),count)<EOL><DEDENT>self.should_be_equal_as_integers(self.get_count(item1,item2),<EOL>count,msg,values=False)<EOL><DEDENT>def get_count(self,item1,item2):<EOL><INDENT> '<STR_LIT>'<EOL>if not hasattr(item1,'count'):<EOL><INDENT>try :<EOL><INDENT>item1=list(item1)<EOL><DEDENT>except :<EOL><INDENT>raise RuntimeError('<STR_LIT>'<EOL>%(item1,utils.get_error_message()))<EOL><DEDENT> <DEDENT>count=item1.count(item2)<EOL>self.log('<STR_LIT>'<EOL>%(count,utils.plural_or_not(count)))<EOL>return count <EOL><DEDENT>def should_not_match(self,string,pattern,msg=None,values=True):<EOL><INDENT> '<STR_LIT>'<EOL>msg=self._get_string_msg(string,pattern,msg,values,'matches')<EOL>asserts.fail_if(self._matches(string,pattern),msg)<EOL><DEDENT>def should_match(self,string,pattern,msg=None,values=True):<EOL><INDENT> '<STR_LIT>'<EOL>msg=self._get_string_msg(string,pattern,msg,values,<EOL>'does not match')<EOL>asserts.fail_unless(self._matches(string,pattern),msg)<EOL><DEDENT>def should_match_regexp(self,string,pattern,msg=None,values=True):<EOL><INDENT> '<STR_LIT>'<EOL>msg=self._get_string_msg(string,pattern,msg,values,'does not match')<EOL>res=re.search(pattern,string)<EOL>asserts.fail_if_none(res,msg,False)<EOL>match=res.group()<EOL>groups=res.groups()<EOL>if groups :<EOL><INDENT>return [match ]+list(groups)<EOL><DEDENT>return match <EOL><DEDENT>def should_not_match_regexp(self,string,pattern,msg=None,values=True):<EOL><INDENT> '<STR_LIT>'<EOL>msg=self._get_string_msg(string,pattern,msg,values,'matches')<EOL>asserts.fail_unless_none(re.search(pattern,string),msg,False)<EOL><DEDENT>def get_length(self,item):<EOL><INDENT> '<STR_LIT>'<EOL>length=self._get_length(item)<EOL>self.log('Length is %d'%length)<EOL>return length <EOL><DEDENT>def _get_length(self,item):<EOL><INDENT>try :return len(item)<EOL>except utils.RERAISED_EXCEPTIONS :raise <EOL>except :<EOL><INDENT>try :return item.length()<EOL>except utils.RERAISED_EXCEPTIONS :raise <EOL>except :<EOL><INDENT>try :return item.size()<EOL>except utils.RERAISED_EXCEPTIONS :raise <EOL>except :<EOL><INDENT>try :return item.length <EOL>except utils.RERAISED_EXCEPTIONS :raise <EOL>except :<EOL><INDENT>raise RuntimeError('<STR_LIT>'%item)<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>def length_should_be(self,item,length,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>length=self._convert_to_integer(length)<EOL>actual=self.get_length(item)<EOL>if actual !=length :<EOL><INDENT>raise AssertionError(msg or '<STR_LIT>'<EOL>%(item,length,actual))<EOL><DEDENT> <DEDENT>def should_be_empty(self,item,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>if self.get_length(item)>:<EOL><INDENT>raise AssertionError(msg or '<STR_LIT>'%item)<EOL><DEDENT> <DEDENT>def should_not_be_empty(self,item,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>if self.get_length(item)==:<EOL><INDENT>raise AssertionError(msg or '<STR_LIT>'%item)<EOL><DEDENT> <DEDENT>def _get_string_msg(self,str1,str2,msg,values,delim):<EOL><INDENT>default="'%s' %s '%s'"%(utils.unic(str1),delim,utils.unic(str2))<EOL>if not msg :<EOL><INDENT>msg=default <EOL><DEDENT>elif values is True :<EOL><INDENT>msg='%s: %s'%(msg,default)<EOL><DEDENT>return msg <EOL><DEDENT> <DEDENT>class _Variables :<EOL><INDENT>def get_variables(self):<EOL><INDENT> '<STR_LIT>'<EOL>return utils.NormalizedDict(self._variables.current,ignore='_')<EOL><DEDENT>def get_variable_value(self,name,default=None):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>return self._variables [self._get_var_name(name)]<EOL><DEDENT>except DataError :<EOL><INDENT>return self._variables.replace_scalar(default)<EOL><DEDENT> <DEDENT>def log_variables(self,level='INFO'):<EOL><INDENT> '<STR_LIT>'<EOL>variables=self.get_variables()<EOL>for name in sorted(variables.keys(),key=lambda s :s.lower()):<EOL><INDENT>msg=utils.format_assign_message(name,variables [name ],<EOL>cut_long=False)<EOL>self.log(msg,level)<EOL><DEDENT> <DEDENT>def variable_should_exist(self,name,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>name=self._get_var_name(name)<EOL>msg=self._variables.replace_string(msg)if msg else '<STR_LIT>'%name <EOL>asserts.fail_unless(name in self._variables,msg)<EOL><DEDENT>def variable_should_not_exist(self,name,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>name=self._get_var_name(name)<EOL>msg=self._variables.replace_string(msg)if msg else '<STR_LIT>'%name <EOL>asserts.fail_if(name in self._variables,msg)<EOL><DEDENT>def replace_variables(self,text):<EOL><INDENT> '<STR_LIT>'<EOL>return self._variables.replace_scalar(text)<EOL><DEDENT>def set_variable(self,*values):<EOL><INDENT> '<STR_LIT>'<EOL>if len(values)==:<EOL><INDENT>return ''<EOL><DEDENT>elif len(values)==:<EOL><INDENT>return values []<EOL><DEDENT>else :<EOL><INDENT>return list(values)<EOL><DEDENT> <DEDENT>def set_test_variable(self,name,*values):<EOL><INDENT> '<STR_LIT>'<EOL>name=self._get_var_name(name)<EOL>value=self._get_var_value(name,values)<EOL>self._variables.set_test(name,value)<EOL>self._log_set_variable(name,value)<EOL><DEDENT>def set_suite_variable(self,name,*values):<EOL><INDENT> '<STR_LIT>'<EOL>name=self._get_var_name(name)<EOL>value=self._get_var_value(name,values)<EOL>self._variables.set_suite(name,value)<EOL>self._log_set_variable(name,value)<EOL><DEDENT>def set_global_variable(self,name,*values):<EOL><INDENT> '<STR_LIT>'<EOL>name=self._get_var_name(name)<EOL>value=self._get_var_value(name,values)<EOL>self._variables.set_global(name,value)<EOL>self._log_set_variable(name,value)<EOL><DEDENT>def _get_var_name(self,orig):<EOL><INDENT>name=self._resolve_possible_variable(orig)<EOL>try :<EOL><INDENT>return self._unescape_variable_if_needed(name)<EOL><DEDENT>except ValueError :<EOL><INDENT>raise RuntimeError('<STR_LIT>'%orig)<EOL><DEDENT> <DEDENT>def _resolve_possible_variable(self,name):<EOL><INDENT>try :<EOL><INDENT>resolved=self._variables [name ]<EOL>return self._unescape_variable_if_needed(resolved)<EOL><DEDENT>except(KeyError,ValueError,DataError):<EOL><INDENT>return name <EOL><DEDENT> <DEDENT>def _unescape_variable_if_needed(self,name):<EOL><INDENT>if not(isinstance(name,basestring)and len(name)>):<EOL><INDENT>raise ValueError <EOL><DEDENT>if name.startswith('\\'):<EOL><INDENT>name=name [:]<EOL><DEDENT>elif name []in ['$','@']and name []!='{':<EOL><INDENT>name='%s{%s}'%(name [],name [:])<EOL><DEDENT>if is_var(name):<EOL><INDENT>return name <EOL><DEDENT>name='%s{%s}'%(name [],self.replace_variables(name [:-]))<EOL>if is_var(name):<EOL><INDENT>return name <EOL><DEDENT>raise ValueError <EOL><DEDENT>def _get_var_value(self,name,values):<EOL><INDENT>if not values :<EOL><INDENT>return self._variables [name ]<EOL><DEDENT>values=self._variables.replace_list(values)<EOL>if len(values)==and name []=='$':<EOL><INDENT>return values []<EOL><DEDENT>return list(values)<EOL><DEDENT>def _log_set_variable(self,name,value):<EOL><INDENT>self.log(utils.format_assign_message(name,value))<EOL><DEDENT> <DEDENT>class _RunKeyword :<EOL><INDENT>def run_keyword(self,name,*args):<EOL><INDENT> '<STR_LIT>'<EOL>if not isinstance(name,basestring):<EOL><INDENT>raise RuntimeError('<STR_LIT>')<EOL><DEDENT>kw=Keyword(name,list(args))<EOL>return kw.run(self._execution_context)<EOL><DEDENT>def run_keywords(self,*names):<EOL><INDENT> '<STR_LIT>'<EOL>errors=[]<EOL>for kw in self._variables.replace_list(names):<EOL><INDENT>try :<EOL><INDENT>self.run_keyword(kw)<EOL><DEDENT>except ExecutionFailed,err :<EOL><INDENT>errors.extend(err.get_errors())<EOL>if not err.can_continue(self._execution_context.teardown):<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT>if errors :<EOL><INDENT>raise ExecutionFailures(errors)<EOL><DEDENT> <DEDENT>def run_keyword_if(self,condition,name,*args):<EOL><INDENT> '<STR_LIT>'<EOL>args,branch=self._split_elif_or_else_branch(args)<EOL>if self._is_true(condition):<EOL><INDENT>return self.run_keyword(name,*args)<EOL><DEDENT>return branch()<EOL><DEDENT>def _split_elif_or_else_branch(self,args):<EOL><INDENT>if 'ELSE IF'in args :<EOL><INDENT>args,branch=self._split_branch(args,'ELSE IF',,<EOL>'<STR_LIT>')<EOL>return args,lambda :self.run_keyword_if(*branch)<EOL><DEDENT>if 'ELSE'in args :<EOL><INDENT>args,branch=self._split_branch(args,'ELSE',,'keyword')<EOL>return args,lambda :self.run_keyword(*branch)<EOL><DEDENT>return args,lambda :None <EOL><DEDENT>def _split_branch(self,args,control_word,required,required_error):<EOL><INDENT>args=list(args)<EOL>index=args.index(control_word)<EOL>branch=self._variables.replace_from_beginning(args [index +:],required,<EOL>extra_escapes=('ELSE','ELSE IF'))<EOL>if len(branch)<required :<EOL><INDENT>raise DataError('%s requires %s.'%(control_word,required_error))<EOL><DEDENT>return args [:index ],branch <EOL><DEDENT>def run_keyword_unless(self,condition,name,*args):<EOL><INDENT> '<STR_LIT>'<EOL>if not self._is_true(condition):<EOL><INDENT>return self.run_keyword(name,*args)<EOL><DEDENT> <DEDENT>def run_keyword_and_ignore_error(self,name,*args):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>return 'PASS',self.run_keyword(name,*args)<EOL><DEDENT>except ExecutionFailed,err :<EOL><INDENT>if err.dont_cont :<EOL><INDENT>raise <EOL><DEDENT>return 'FAIL',unicode(err)<EOL><DEDENT> <DEDENT>def run_keyword_and_continue_on_failure(self,name,*args):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>return self.run_keyword(name,*args)<EOL><DEDENT>except ExecutionFailed,err :<EOL><INDENT>if not err.dont_cont :<EOL><INDENT>err.cont=True <EOL><DEDENT>raise err <EOL><DEDENT> <DEDENT>def run_keyword_and_expect_error(self,expected_error,name,*args):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>self.run_keyword(name,*args)<EOL><DEDENT>except ExecutionFailed,err :<EOL><INDENT>if err.dont_cont :<EOL><INDENT>raise <EOL><DEDENT> <DEDENT>else :<EOL><INDENT>raise AssertionError('<STR_LIT>'<EOL>%expected_error)<EOL><DEDENT>if not self._matches(unicode(err),expected_error):<EOL><INDENT>raise AssertionError('<STR_LIT>'<EOL>%(expected_error,err))<EOL><DEDENT>return unicode(err)<EOL><DEDENT>def repeat_keyword(self,times,name,*args):<EOL><INDENT> '<STR_LIT>'<EOL>times=utils.normalize(str(times))<EOL>if times.endswith('times'):<EOL><INDENT>times=times [:-]<EOL><DEDENT>elif times.endswith('x'):<EOL><INDENT>times=times [:-]<EOL><DEDENT>times=self._convert_to_integer(times)<EOL>if times <=:<EOL><INDENT>self.log('<STR_LIT>'%name)<EOL><DEDENT>for i in xrange(times):<EOL><INDENT>self.log('<STR_LIT>'%(i +,times))<EOL>self.run_keyword(name,*args)<EOL><DEDENT> <DEDENT>def wait_until_keyword_succeeds(self,timeout,retry_interval,name,*args):<EOL><INDENT> '<STR_LIT>'<EOL>timeout=utils.timestr_to_secs(timeout)<EOL>retry_interval=utils.timestr_to_secs(retry_interval)<EOL>maxtime=time.time()+timeout <EOL>error=None <EOL>while not error :<EOL><INDENT>try :<EOL><INDENT>return self.run_keyword(name,*args)<EOL><DEDENT>except ExecutionFailed,err :<EOL><INDENT>if err.dont_cont :<EOL><INDENT>raise <EOL><DEDENT>if time.time()>maxtime :<EOL><INDENT>error=unicode(err)<EOL><DEDENT>else :<EOL><INDENT>time.sleep(retry_interval)<EOL><DEDENT> <DEDENT> <DEDENT>raise AssertionError('<STR_LIT>'<EOL>%(utils.secs_to_timestr(timeout),error))<EOL><DEDENT>def set_variable_if(self,condition,*values):<EOL><INDENT> '<STR_LIT>'<EOL>values=self._verify_values_for_set_variable_if(list(values))<EOL>if self._is_true(condition):<EOL><INDENT>return self._variables.replace_scalar(values [])<EOL><DEDENT>values=self._verify_values_for_set_variable_if(values [:],True)<EOL>if len(values)==:<EOL><INDENT>return self._variables.replace_scalar(values [])<EOL><DEDENT>return self.run_keyword('<STR_LIT>',*values [:])<EOL><DEDENT>def _verify_values_for_set_variable_if(self,values,default=False):<EOL><INDENT>if not values :<EOL><INDENT>if default :<EOL><INDENT>return [None ]<EOL><DEDENT>raise RuntimeError('<STR_LIT>')<EOL><DEDENT>if is_list_var(values []):<EOL><INDENT>values [:]=[utils.escape(item)for item in <EOL>self._variables [values []]]<EOL>return self._verify_values_for_set_variable_if(values)<EOL><DEDENT>return values <EOL><DEDENT>def run_keyword_if_test_failed(self,name,*args):<EOL><INDENT> '<STR_LIT>'<EOL>test=self._get_test_in_teardown('<STR_LIT>')<EOL>if not test.passed :<EOL><INDENT>return self.run_keyword(name,*args)<EOL><DEDENT> <DEDENT>def run_keyword_if_test_passed(self,name,*args):<EOL><INDENT> '<STR_LIT>'<EOL>test=self._get_test_in_teardown('<STR_LIT>')<EOL>if test.passed :<EOL><INDENT>return self.run_keyword(name,*args)<EOL><DEDENT> <DEDENT>def run_keyword_if_timeout_occurred(self,name,*args):<EOL><INDENT> '<STR_LIT>'<EOL>test=self._get_test_in_teardown('<STR_LIT>')<EOL>if test.timeout.any_timeout_occurred():<EOL><INDENT>return self.run_keyword(name,*args)<EOL><DEDENT> <DEDENT>def _get_test_in_teardown(self,kwname):<EOL><INDENT>test=self._namespace.test <EOL>if test and test.status !='RUNNING':<EOL><INDENT>return test <EOL><DEDENT>raise RuntimeError('<STR_LIT>'<EOL>%kwname)<EOL><DEDENT>def run_keyword_if_all_critical_tests_passed(self,name,*args):<EOL><INDENT> '<STR_LIT>'<EOL>suite=self._get_suite_in_teardown('Run Keyword If '<EOL>'<STR_LIT>')<EOL>if suite.critical_stats.failed==:<EOL><INDENT>return self.run_keyword(name,*args)<EOL><DEDENT> <DEDENT>def run_keyword_if_any_critical_tests_failed(self,name,*args):<EOL><INDENT> '<STR_LIT>'<EOL>suite=self._get_suite_in_teardown('Run Keyword If '<EOL>'<STR_LIT>')<EOL>if suite.critical_stats.failed >:<EOL><INDENT>return self.run_keyword(name,*args)<EOL><DEDENT> <DEDENT>def run_keyword_if_all_tests_passed(self,name,*args):<EOL><INDENT> '<STR_LIT>'<EOL>suite=self._get_suite_in_teardown('<STR_LIT>')<EOL>if suite.all_stats.failed==:<EOL><INDENT>return self.run_keyword(name,*args)<EOL><DEDENT> <DEDENT>def run_keyword_if_any_tests_failed(self,name,*args):<EOL><INDENT> '<STR_LIT>'<EOL>suite=self._get_suite_in_teardown('<STR_LIT>')<EOL>if suite.all_stats.failed >:<EOL><INDENT>return self.run_keyword(name,*args)<EOL><DEDENT> <DEDENT>def _get_suite_in_teardown(self,kwname):<EOL><INDENT>if self._namespace.suite.status=='RUNNING':<EOL><INDENT>raise RuntimeError('<STR_LIT>'<EOL>%kwname)<EOL><DEDENT>return self._namespace.suite <EOL><DEDENT> <DEDENT>class _Misc :<EOL><INDENT>def no_operation(self):<EOL><INDENT> '<STR_LIT>'<EOL><DEDENT>def sleep(self,time_,reason=None):<EOL><INDENT> '<STR_LIT>'<EOL>seconds=utils.timestr_to_secs(time_)<EOL>if seconds <:<EOL><INDENT>seconds=<EOL><DEDENT>self._sleep_in_parts(seconds)<EOL>self.log('Slept %s'%utils.secs_to_timestr(seconds))<EOL>if reason :<EOL><INDENT>self.log(reason)<EOL><DEDENT> <DEDENT>def _sleep_in_parts(self,seconds):<EOL><INDENT>endtime=time.time()+float(seconds)<EOL>while True :<EOL><INDENT>remaining=endtime -time.time()<EOL>if remaining <=:<EOL><INDENT>break <EOL><DEDENT>time.sleep(min(remaining,))<EOL><DEDENT> <DEDENT>def catenate(self,*items):<EOL><INDENT> '<STR_LIT>'<EOL>if not items :<EOL><INDENT>return ''<EOL><DEDENT>items=[utils.unic(item)for item in items ]<EOL>if items [].startswith('SEPARATOR='):<EOL><INDENT>sep=items [][len('SEPARATOR='):]<EOL>items=items [:]<EOL><DEDENT>else :<EOL><INDENT>sep=' '<EOL><DEDENT>return sep.join(items)<EOL><DEDENT>def log(self,message,level="INFO"):<EOL><INDENT> '<STR_LIT>'<EOL>LOGGER.log_message(Message(message,level))<EOL><DEDENT>def log_many(self,*messages):<EOL><INDENT> '<STR_LIT>'<EOL>for msg in messages :<EOL><INDENT>self.log(msg)<EOL><DEDENT> <DEDENT>def comment(self,*messages):<EOL><INDENT> '<STR_LIT>'<EOL>pass <EOL><DEDENT>def set_log_level(self,level):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>old=self._execution_context.output.set_log_level(level)<EOL><DEDENT>except DataError,err :<EOL><INDENT>raise RuntimeError(unicode(err))<EOL><DEDENT>self.log('<STR_LIT>'%(old,level.upper()))<EOL>return old <EOL><DEDENT>def import_library(self,name,*args):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>self._namespace.import_library(name.replace('/',os.sep),list(args))<EOL><DEDENT>except DataError,err :<EOL><INDENT>raise RuntimeError(unicode(err))<EOL><DEDENT> <DEDENT>def import_variables(self,path,*args):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>self._namespace.import_variables(path.replace('/',os.sep),<EOL>list(args),overwrite=True)<EOL><DEDENT>except DataError,err :<EOL><INDENT>raise RuntimeError(unicode(err))<EOL><DEDENT> <DEDENT>def import_resource(self,path):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>self._namespace.import_resource(path.replace('/',os.sep))<EOL><DEDENT>except DataError,err :<EOL><INDENT>raise RuntimeError(unicode(err))<EOL><DEDENT> <DEDENT>def set_library_search_order(self,*libraries):<EOL><INDENT> '<STR_LIT>'<EOL>old_order=self._namespace.library_search_order <EOL>self._namespace.library_search_order=libraries <EOL>return old_order <EOL><DEDENT>def keyword_should_exist(self,name,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>handler=self._namespace._get_handler(name)<EOL>if not handler :<EOL><INDENT>raise DataError('<STR_LIT>'%name)<EOL><DEDENT>if isinstance(handler,UserErrorHandler):<EOL><INDENT>handler.run()<EOL><DEDENT> <DEDENT>except DataError,err :<EOL><INDENT>raise AssertionError(msg or unicode(err))<EOL><DEDENT> <DEDENT>def get_time(self,format='timestamp',time_='NOW'):<EOL><INDENT> '<STR_LIT>'<EOL>return utils.get_time(format,utils.parse_time(time_))<EOL><DEDENT>def evaluate(self,expression,modules=None):<EOL><INDENT> '<STR_LIT>'<EOL>modules=modules.replace(' ','').split(',')if modules else []<EOL>namespace=dict((m,__import__(m))for m in modules if m !='')<EOL>try :<EOL><INDENT>return eval(expression,namespace)<EOL><DEDENT>except :<EOL><INDENT>raise RuntimeError('<STR_LIT>'<EOL>%(expression,utils.get_error_message()))<EOL><DEDENT> <DEDENT>def call_method(self,object,method_name,*args):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>method=getattr(object,method_name)<EOL><DEDENT>except AttributeError :<EOL><INDENT>raise RuntimeError('<STR_LIT>'<EOL>%(object,method_name))<EOL><DEDENT>return method(*args)<EOL><DEDENT>def regexp_escape(self,*patterns):<EOL><INDENT> '<STR_LIT>'<EOL>if len(patterns)==:<EOL><INDENT>return ''<EOL><DEDENT>if len(patterns)==:<EOL><INDENT>return re.escape(patterns [])<EOL><DEDENT>return [re.escape(p)for p in patterns ]<EOL><DEDENT>def set_test_message(self,message):<EOL><INDENT> '<STR_LIT>'<EOL>if not isinstance(message,unicode):<EOL><INDENT>message=utils.unic(message)<EOL><DEDENT>test=self._namespace.test <EOL>if not test :<EOL><INDENT>raise RuntimeError('<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT>test.message=message <EOL>self.log('<STR_LIT>'%message)<EOL><DEDENT>def set_test_documentation(self,doc):<EOL><INDENT> '<STR_LIT>'<EOL>if not isinstance(doc,unicode):<EOL><INDENT>doc=utils.unic(doc)<EOL><DEDENT>test=self._namespace.test <EOL>if not test :<EOL><INDENT>raise RuntimeError('<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT>test.doc=doc <EOL>self._variables.set_test('<STR_LIT>',test.doc)<EOL>self.log('<STR_LIT>'%doc)<EOL><DEDENT>def set_suite_documentation(self,doc):<EOL><INDENT> '<STR_LIT>'<EOL>if not isinstance(doc,unicode):<EOL><INDENT>doc=utils.unic(doc)<EOL><DEDENT>suite=self._namespace.suite <EOL>suite.doc=doc <EOL>self._variables.set_suite('<STR_LIT>',suite.doc)<EOL>self.log('<STR_LIT>'%doc)<EOL><DEDENT>def set_suite_metadata(self,name,value):<EOL><INDENT> '<STR_LIT>'<EOL>metadata=self._namespace.suite.metadata <EOL>metadata [name ]=value <EOL>self._variables.set_suite('<STR_LIT>',metadata.copy())<EOL>self.log('<STR_LIT>'%(name,value))<EOL><DEDENT>def set_tags(self,*tags):<EOL><INDENT> '<STR_LIT>'<EOL>tags=utils.normalize_tags(tags)<EOL>handler=lambda test :utils.normalize_tags(test.tags +tags)<EOL>self._set_or_remove_tags(handler)<EOL>self.log('Set tag%s %s.'%(utils.plural_or_not(tags),<EOL>utils.seq2str(tags)))<EOL><DEDENT>def remove_tags(self,*tags):<EOL><INDENT> '<STR_LIT>'<EOL>tags=TagPatterns(tags)<EOL>handler=lambda test :[t for t in test.tags if not tags.match(t)]<EOL>self._set_or_remove_tags(handler)<EOL>self.log('<STR_LIT>'%(utils.plural_or_not(tags),<EOL>utils.seq2str(tags)))<EOL><DEDENT>def _set_or_remove_tags(self,handler,suite=None,test=None):<EOL><INDENT>if not(suite or test):<EOL><INDENT>ns=self._namespace <EOL>if ns.test is None :<EOL><INDENT>if ns.suite.status !='RUNNING':<EOL><INDENT>raise RuntimeError('<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT>self._set_or_remove_tags(handler,suite=ns.suite)<EOL><DEDENT>else :<EOL><INDENT>self._set_or_remove_tags(handler,test=ns.test)<EOL>ns.variables.set_test('@{TEST_TAGS}',ns.test.tags [:])<EOL><DEDENT>ns.suite._set_critical_tags(ns.suite.critical)<EOL><DEDENT>elif suite :<EOL><INDENT>for sub in suite.suites :<EOL><INDENT>self._set_or_remove_tags(handler,suite=sub)<EOL><DEDENT>for test in suite.tests :<EOL><INDENT>self._set_or_remove_tags(handler,test=test)<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>test.tags=handler(test)<EOL><DEDENT> <DEDENT>def get_library_instance(self,name):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>return self._namespace.get_library_instance(name)<EOL><DEDENT>except DataError,err :<EOL><INDENT>raise RuntimeError(unicode(err))<EOL><DEDENT> <DEDENT> <DEDENT>class BuiltIn(_Verify,_Converter,_Variables,_RunKeyword,_Misc):<EOL><INDENT> '<STR_LIT>'<EOL>ROBOT_LIBRARY_SCOPE='GLOBAL'<EOL>ROBOT_LIBRARY_VERSION=get_version()<EOL>@property <EOL>def _execution_context(self):<EOL><INDENT>return EXECUTION_CONTEXTS.current <EOL><DEDENT>@property <EOL>def _namespace(self):<EOL><INDENT>return self._execution_context.namespace <EOL><DEDENT>@property <EOL>def _variables(self):<EOL><INDENT>return self._namespace.variables <EOL><DEDENT>def _matches(self,string,pattern):<EOL><INDENT>return utils.matches(string,pattern,caseless=False,spaceless=False)<EOL><DEDENT>def _is_true(self,condition):<EOL><INDENT>if isinstance(condition,basestring):<EOL><INDENT>try :<EOL><INDENT>condition=eval(condition)<EOL><DEDENT>except :<EOL><INDENT>raise RuntimeError('<STR_LIT>'<EOL>%(condition,utils.get_error_message()))<EOL><DEDENT> <DEDENT>return bool(condition)<EOL><DEDENT> <DEDENT>def register_run_keyword(library,keyword,args_to_process=None):<EOL><INDENT> '<STR_LIT>'<EOL>RUN_KW_REGISTER.register_run_keyword(library,keyword,args_to_process)<EOL><DEDENT>for name in [attr for attr in dir(_RunKeyword)if not attr.startswith('_')]:<EOL><INDENT>register_run_keyword('BuiltIn',getattr(_RunKeyword,name))<EOL><DEDENT>for name in ['<STR_LIT>','<STR_LIT>','<STR_LIT>',<EOL>'<STR_LIT>','<STR_LIT>','comment',<EOL>'<STR_LIT>']:<EOL><INDENT>register_run_keyword('BuiltIn',name,)<EOL><DEDENT>del name,attr <EOF><BOF>'<STR_LIT>'<EOF><BOF>'<STR_LIT>'<EOL>from operator import attrgetter <EOL>from django.conf import settings <EOL>from.views import get_user_active_repositories <EOL>def base(request):<EOL><INDENT> '<STR_LIT>'<EOL>return {<EOL>"app_name":settings.BUILDSERVICE_APP_NAME,<EOL>'<STR_LIT>':sorted(<EOL>get_user_active_repositories(request.user),<EOL>key=attrgetter('name'))<EOL>}<EOL><DEDENT><EOF><BOF>import psycopg2 <EOL>from mosql.util import star <EOL>from mosql.query import insert <EOL>from mosql.db import Database,one_to_dict <EOL>person_insert=insert.breed({'table':'person'})<EOL>dave={<EOL>'person_id':'dave',<EOL>'name':'Dave',<EOL>}<EOL>db=Database(psycopg2,host='127.0.0.1')<EOL>with db as cur :<EOL><INDENT>cur.execute(person_insert(set=dave,returning=star))<EOL>print one_to_dict(cur)<EOL>print <EOL>assert,'Rollback!'<EOL><DEDENT><EOF><BOF>from sqlalchemy.exc import IntegrityError <EOL>from yapper.lib.response import json_success,json_error <EOL>from yapper.lib.decorators import validate_form_data <EOL>from yapper import db <EOL>from..blog.models import Tag <EOL>from..blog.forms import TagForm <EOL>from.blog import PostAPI <EOL>class TagAPI(PostAPI):<EOL><INDENT>MODEL=Tag <EOL>FORM=TagForm <EOL>@validate_form_data(FORM)<EOL>def post(self,form=None,*args,**kwargs):<EOL><INDENT>try :<EOL><INDENT>item=self.MODEL(name=form.name.data.lower())<EOL>item.save()<EOL><DEDENT>except IntegrityError :<EOL><INDENT>db.session.rollback()<EOL>return json_error(data='<STR_LIT>',code=)<EOL><DEDENT>return json_success(data=item.to_json())<EOL><DEDENT> <DEDENT><EOF><BOF>import ntpath <EOL>class Context :<EOL><INDENT>window=None <EOL>settingsPath=""<EOL>basedir=""<EOL>scriptModules=None <EOL>textModules=None <EOL>modulesByImportString={}<EOL>modulesByFullPath={}<EOL>scriptPackages=[]<EOL>def __init__(self,window,settingsPath):<EOL><INDENT>self.window=window <EOL>self.settingsPath=settingsPath <EOL><DEDENT>def window(self):<EOL><INDENT>return self.window <EOL><DEDENT>def settingsPath(self):<EOL><INDENT>return self.settingsPath <EOL><DEDENT>def getBaseDir(self):<EOL><INDENT>return ntpath.dirname(self.settingsPath).replace("\\","/")+"/"<EOL><DEDENT>def setSettings(self,settings):<EOL><INDENT>self.settings=settings <EOL><DEDENT>def settings(self):<EOL><INDENT>return self.settings <EOL><DEDENT>def isSublimeRJS(self):<EOL><INDENT>return self.settingsPath is not ""<EOL><DEDENT>def resetModules(self):<EOL><INDENT>self.scriptModules=[]<EOL>self.textModules=[]<EOL>self.scriptPackages=[]<EOL>self.scriptPackages.append("")<EOL>self.textPackages=[]<EOL>self.textPackages.append("")<EOL>self.modulesByFullPath={}<EOL><DEDENT>def addScriptModule(self,module):<EOL><INDENT>self.scriptModules.append(module)<EOL>self.modulesByImportString [module.getImportString()]=module <EOL>self.modulesByFullPath [module.getFullPath()]=module <EOL>filtred=self.filterModule(module)<EOL>if module.package not in self.scriptPackages and filtred is not None :<EOL><INDENT>self.scriptPackages.append(module.package)<EOL><DEDENT> <DEDENT>def getModuleByImportString(self,importString):<EOL><INDENT>if importString in self.modulesByImportString :<EOL><INDENT>return self.modulesByImportString [importString ]<EOL><DEDENT>else :<EOL><INDENT>return None <EOL><DEDENT> <DEDENT>def getModuleByFullPath(self,fullPath):<EOL><INDENT>if fullPath in self.modulesByFullPath :<EOL><INDENT>return self.modulesByFullPath [fullPath ]<EOL><DEDENT>else :<EOL><INDENT>return None <EOL><DEDENT> <DEDENT>def getScriptModules(self):<EOL><INDENT>return self.scriptModules <EOL><DEDENT>def addTextModule(self,module):<EOL><INDENT>self.textModules.append(module)<EOL>self.modulesByImportString [module.getImportString()]=module <EOL>self.modulesByFullPath [module.getFullPath()]=module <EOL>filtred=self.filterModule(module)<EOL>if module.package not in self.textPackages and filtred is not None :<EOL><INDENT>self.textPackages.append(module.package)<EOL><DEDENT> <DEDENT>def getTextModules(self):<EOL><INDENT>return self.textModules <EOL><DEDENT>def setModuleAliasMap(self,moduleAliasMap):<EOL><INDENT>self.moduleAliasMap=moduleAliasMap <EOL><DEDENT>def getModuleAliasMap(self):<EOL><INDENT>return self.moduleAliasMap <EOL><DEDENT>def getTextPackages(self):<EOL><INDENT>collection=[]<EOL>return self.textPackages <EOL><DEDENT>def getScriptPackages(self):<EOL><INDENT>return self.scriptPackages <EOL><DEDENT>def filterModule(self,module):<EOL><INDENT>if len(self.settings ["excludes"])>:<EOL><INDENT>for exclude in self.settings ["excludes"]:<EOL><INDENT>if self.getBaseDir()+exclude in module.path +"/"+module.name :<EOL><INDENT>return None <EOL><DEDENT> <DEDENT> <DEDENT>return module <EOL><DEDENT> <DEDENT>def reverseSlashes(input):<EOL><INDENT>return input.replace("")<EOL><DEDENT>class Module :<EOL><INDENT>name=""<EOL>path=""<EOL>type=""<EOL>package=""<EOL>importAlias=""<EOL>refrenceAlias=""<EOL>def __init__(self,name,path,ext,type,package,context):<EOL><INDENT>self.name=name <EOL>self.path=path.replace("\\","/")<EOL>self.ext=ext <EOL>self.type=type <EOL>self.package=package.replace("\\","/")<EOL>self.context=context <EOL><DEDENT>def name(self):<EOL><INDENT>return self.name <EOL><DEDENT>def package(self):<EOL><INDENT>return self.package <EOL><DEDENT>def getImportString(self):<EOL><INDENT>if self.importAlias is not "":<EOL><INDENT>return self.importAlias <EOL><DEDENT>if self.type=="script":<EOL><INDENT>return self.package +self.name.split(self.ext)[]<EOL><DEDENT>elif self.type=="text":<EOL><INDENT>return "text!"+self.context.settings ["texts_name"]+"/"+self.package +self.name <EOL><DEDENT> <DEDENT>def getRefrenceString(self):<EOL><INDENT>if self.importAlias is not "":<EOL><INDENT>if self.refrenceAlias is not "":<EOL><INDENT>return self.refrenceAlias <EOL><DEDENT>return self.importAlias <EOL><DEDENT>if self.refrenceAlias is not "":<EOL><INDENT>return self.refrenceAlias <EOL><DEDENT>return self.name.split(self.ext)[]<EOL><DEDENT>def setImportAlias(self,alias):<EOL><INDENT>self.importAlias=alias <EOL><DEDENT>def setRefrenceAlias(self,alias):<EOL><INDENT>self.refrenceAlias=alias <EOL><DEDENT>def getFullPath(self):<EOL><INDENT>return self.path +"/"+self.name <EOL><DEDENT>def getRelativePath(self):<EOL><INDENT>return self.path.split(self.context.getBaseDir())[]+"/"+self.name <EOL><DEDENT> <DEDENT><EOF><BOF>from __future__ import with_statement <EOL>from robot import utils <EOL>from robot.errors import DataError <EOL>from robot.variables import is_list_var <EOL>from outputcapture import OutputCapturer <EOL>from runkwregister import RUN_KW_REGISTER <EOL>from keywords import Keywords,Keyword <EOL>from arguments import(PythonKeywordArguments,JavaKeywordArguments,<EOL>DynamicKeywordArguments,RunKeywordArguments,<EOL>PythonInitArguments,JavaInitArguments)<EOL>from signalhandler import STOP_SIGNAL_MONITOR <EOL>if utils.is_jython :<EOL><INDENT>from org.python.core import PyReflectedFunction,PyReflectedConstructor <EOL>def _is_java_init(init):<EOL><INDENT>return isinstance(init,PyReflectedConstructor)<EOL><DEDENT>def _is_java_method(method):<EOL><INDENT>return hasattr(method,'im_func')and isinstance(method.im_func,PyReflectedFunction)<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>_is_java_init=_is_java_method=lambda item :False <EOL><DEDENT>def Handler(library,name,method):<EOL><INDENT>if RUN_KW_REGISTER.is_run_keyword(library.orig_name,name):<EOL><INDENT>return _RunKeywordHandler(library,name,method)<EOL><DEDENT>if _is_java_method(method):<EOL><INDENT>return _JavaHandler(library,name,method)<EOL><DEDENT>else :<EOL><INDENT>return _PythonHandler(library,name,method)<EOL><DEDENT> <DEDENT>def DynamicHandler(library,name,method,doc,argspec):<EOL><INDENT>if RUN_KW_REGISTER.is_run_keyword(library.orig_name,name):<EOL><INDENT>return _DynamicRunKeywordHandler(library,name,method,doc,argspec)<EOL><DEDENT>return _DynamicHandler(library,name,method,doc,argspec)<EOL><DEDENT>def InitHandler(library,method,docgetter=None):<EOL><INDENT>Init=_PythonInitHandler if not _is_java_init(method)else _JavaInitHandler <EOL>return Init(library,'__init__',method,docgetter)<EOL><DEDENT>class _BaseHandler(object):<EOL><INDENT>type='library'<EOL>_doc=''<EOL>def __init__(self,library,handler_name,handler_method):<EOL><INDENT>self.library=library <EOL>self.name=utils.printable_name(handler_name,code_style=True)<EOL>self.arguments=self._parse_arguments(handler_method)<EOL><DEDENT>def _parse_arguments(self,handler_method):<EOL><INDENT>raise NotImplementedError(self.__class__.__name__)<EOL><DEDENT>@property <EOL>def doc(self):<EOL><INDENT>return self._doc <EOL><DEDENT>@property <EOL>def longname(self):<EOL><INDENT>return '%s.%s'%(self.library.name,self.name)<EOL><DEDENT>@property <EOL>def shortdoc(self):<EOL><INDENT>return self.doc.splitlines()[]if self.doc else ''<EOL><DEDENT>@property <EOL>def libname(self):<EOL><INDENT>return self.library.name <EOL><DEDENT> <DEDENT>class _RunnableHandler(_BaseHandler):<EOL><INDENT>def __init__(self,library,handler_name,handler_method):<EOL><INDENT>_BaseHandler.__init__(self,library,handler_name,handler_method)<EOL>self._handler_name=handler_name <EOL>self._method=self._get_initial_handler(library,handler_name,<EOL>handler_method)<EOL><DEDENT>def _get_initial_handler(self,library,name,method):<EOL><INDENT>if library.scope=='GLOBAL':<EOL><INDENT>return self._get_global_handler(method,name)<EOL><DEDENT>return None <EOL><DEDENT>def init_keyword(self,varz):<EOL><INDENT>pass <EOL><DEDENT>def run(self,context,args):<EOL><INDENT>if context.dry_run :<EOL><INDENT>return self._dry_run(context,args)<EOL><DEDENT>return self._run(context,args)<EOL><DEDENT>def _dry_run(self,context,args):<EOL><INDENT>if self.longname=='<STR_LIT>':<EOL><INDENT>return self._run(context,args)<EOL><DEDENT>self.arguments.check_arg_limits_for_dry_run(args)<EOL>return None <EOL><DEDENT>def _run(self,context,args):<EOL><INDENT>output=context.output <EOL>positional,named=self.arguments.resolve(args,context.get_current_vars(),output)<EOL>runner=self._runner_for(self._current_handler(),output,positional,<EOL>named,self._get_timeout(context.namespace))<EOL>return self._run_with_output_captured_and_signal_monitor(runner,context)<EOL><DEDENT>def _runner_for(self,handler,output,positional,named,timeout):<EOL><INDENT>if timeout and timeout.active :<EOL><INDENT>output.debug(timeout.get_message)<EOL>return lambda :timeout.run(handler,args=positional,kwargs=named)<EOL><DEDENT>return lambda :handler(*positional,**named)<EOL><DEDENT>def _run_with_output_captured_and_signal_monitor(self,runner,context):<EOL><INDENT>with OutputCapturer():<EOL><INDENT>return self._run_with_signal_monitoring(runner,context)<EOL><DEDENT> <DEDENT>def _run_with_signal_monitoring(self,runner,context):<EOL><INDENT>try :<EOL><INDENT>STOP_SIGNAL_MONITOR.start_running_keyword(context.teardown)<EOL>return runner()<EOL><DEDENT>finally :<EOL><INDENT>STOP_SIGNAL_MONITOR.stop_running_keyword()<EOL><DEDENT> <DEDENT>def _current_handler(self):<EOL><INDENT>if self._method :<EOL><INDENT>return self._method <EOL><DEDENT>return self._get_handler(self.library.get_instance(),<EOL>self._handler_name)<EOL><DEDENT>def _get_global_handler(self,method,name):<EOL><INDENT>return method <EOL><DEDENT>def _get_handler(self,lib_instance,handler_name):<EOL><INDENT>return getattr(lib_instance,handler_name)<EOL><DEDENT>def _get_timeout(self,namespace):<EOL><INDENT>timeoutable=self._get_timeoutable_items(namespace)<EOL>if timeoutable :<EOL><INDENT>return min(item.timeout for item in timeoutable)<EOL><DEDENT>return None <EOL><DEDENT>def _get_timeoutable_items(self,namespace):<EOL><INDENT>items=namespace.uk_handlers [:]<EOL>if self._test_running_and_not_in_teardown(namespace.test):<EOL><INDENT>items.append(namespace.test)<EOL><DEDENT>return items <EOL><DEDENT>def _test_running_and_not_in_teardown(self,test):<EOL><INDENT>return test and test.status=='RUNNING'<EOL><DEDENT> <DEDENT>class _PythonHandler(_RunnableHandler):<EOL><INDENT>def __init__(self,library,handler_name,handler_method):<EOL><INDENT>_RunnableHandler.__init__(self,library,handler_name,handler_method)<EOL>self._doc=utils.getdoc(handler_method)<EOL><DEDENT>def _parse_arguments(self,handler_method):<EOL><INDENT>return PythonKeywordArguments(handler_method,self.longname)<EOL><DEDENT> <DEDENT>class _JavaHandler(_RunnableHandler):<EOL><INDENT>def _parse_arguments(self,handler_method):<EOL><INDENT>return JavaKeywordArguments(handler_method,self.longname)<EOL><DEDENT> <DEDENT>class _DynamicHandler(_RunnableHandler):<EOL><INDENT>def __init__(self,library,handler_name,handler_method,doc='',<EOL>argspec=None):<EOL><INDENT>self._argspec=argspec <EOL>_RunnableHandler.__init__(self,library,handler_name,handler_method)<EOL>self._run_keyword_method_name=handler_method.__name__ <EOL>self._doc=doc is not None and utils.unic(doc)or ''<EOL><DEDENT>def _parse_arguments(self,handler_method):<EOL><INDENT>return DynamicKeywordArguments(self._argspec,self.longname)<EOL><DEDENT>def _get_handler(self,lib_instance,handler_name):<EOL><INDENT>runner=getattr(lib_instance,self._run_keyword_method_name)<EOL>return self._get_dynamic_handler(runner,handler_name)<EOL><DEDENT>def _get_global_handler(self,method,name):<EOL><INDENT>return self._get_dynamic_handler(method,name)<EOL><DEDENT>def _get_dynamic_handler(self,runner,name):<EOL><INDENT>def handler(*args):<EOL><INDENT>return runner(name,list(args))<EOL><DEDENT>return handler <EOL><DEDENT> <DEDENT>class _RunKeywordHandler(_PythonHandler):<EOL><INDENT>def __init__(self,library,handler_name,handler_method):<EOL><INDENT>_PythonHandler.__init__(self,library,handler_name,handler_method)<EOL>self._handler_method=handler_method <EOL><DEDENT>def _run_with_signal_monitoring(self,runner,context):<EOL><INDENT>return runner()<EOL><DEDENT>def _parse_arguments(self,handler_method):<EOL><INDENT>arg_index=RUN_KW_REGISTER.get_args_to_process(self.library.orig_name,<EOL>self.name)<EOL>return RunKeywordArguments(handler_method,self.longname,arg_index)<EOL><DEDENT>def _get_timeout(self,namespace):<EOL><INDENT>return None <EOL><DEDENT>def _dry_run(self,context,args):<EOL><INDENT>_RunnableHandler._dry_run(self,context,args)<EOL>keywords=self._get_runnable_keywords(context,args)<EOL>keywords.run(context)<EOL><DEDENT>def _get_runnable_keywords(self,context,args):<EOL><INDENT>keywords=Keywords([])<EOL>for keyword in self._get_keywords(args):<EOL><INDENT>if self._variable_syntax_in(keyword.name,context):<EOL><INDENT>continue <EOL><DEDENT>keywords.add_keyword(keyword)<EOL><DEDENT>return keywords <EOL><DEDENT>def _variable_syntax_in(self,kw_name,context):<EOL><INDENT>try :<EOL><INDENT>resolved=context.namespace.variables.replace_string(kw_name)<EOL>return resolved !=kw_name <EOL><DEDENT>except DataError :<EOL><INDENT>return True <EOL><DEDENT> <DEDENT>def _get_keywords(self,args):<EOL><INDENT>if self._handler_name=='run_keyword_if':<EOL><INDENT>return list(self._get_run_kw_if_keywords(args))<EOL><DEDENT>if self._handler_name=='run_keywords':<EOL><INDENT>return self._get_run_kws_keywords(args)<EOL><DEDENT>if 'name'in self.arguments.names :<EOL><INDENT>return self._get_default_run_kw_keywords(args)<EOL><DEDENT>return []<EOL><DEDENT>def _get_run_kw_if_keywords(self,given_args):<EOL><INDENT>for kw_call in self._get_run_kw_if_calls(given_args):<EOL><INDENT>if kw_call :<EOL><INDENT>yield Keyword(kw_call [],kw_call [:])<EOL><DEDENT> <DEDENT> <DEDENT>def _get_run_kw_if_calls(self,given_args):<EOL><INDENT>while 'ELSE IF'in given_args :<EOL><INDENT>kw_call,given_args=self._split_run_kw_if_args(given_args,'ELSE IF',)<EOL>yield kw_call <EOL><DEDENT>if 'ELSE'in given_args :<EOL><INDENT>kw_call,else_call=self._split_run_kw_if_args(given_args,'ELSE',)<EOL>yield kw_call <EOL>yield else_call <EOL><DEDENT>elif self._validate_kw_call(given_args):<EOL><INDENT>expr,kw_call=given_args [],given_args [:]<EOL>if not is_list_var(expr):<EOL><INDENT>yield kw_call <EOL><DEDENT> <DEDENT> <DEDENT>def _split_run_kw_if_args(self,given_args,control_word,required_after):<EOL><INDENT>index=given_args.index(control_word)<EOL>expr_and_call=given_args [:index ]<EOL>remaining=given_args [index +:]<EOL>if not(self._validate_kw_call(expr_and_call)and <EOL>self._validate_kw_call(remaining,required_after)):<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>if is_list_var(expr_and_call []):<EOL><INDENT>return [],remaining <EOL><DEDENT>return expr_and_call [:],remaining <EOL><DEDENT>def _validate_kw_call(self,kw_call,min_length=):<EOL><INDENT>if len(kw_call)>=min_length :<EOL><INDENT>return True <EOL><DEDENT>return any(is_list_var(item)for item in kw_call)<EOL><DEDENT>def _get_run_kws_keywords(self,given_args):<EOL><INDENT>return [Keyword(name,[])for name in given_args ]<EOL><DEDENT>def _get_default_run_kw_keywords(self,given_args):<EOL><INDENT>index=self.arguments.names.index('name')<EOL>return [Keyword(given_args [index ],given_args [index +:])]<EOL><DEDENT> <DEDENT>class _XTimesHandler(_RunKeywordHandler):<EOL><INDENT>def __init__(self,handler,name):<EOL><INDENT>_RunKeywordHandler.__init__(self,handler.library,handler.name,<EOL>handler._handler_method)<EOL>self.name=name <EOL>self._doc='<STR_LIT>'<EOL><DEDENT>def run(self,context,args):<EOL><INDENT>resolved_times=context.namespace.variables.replace_string(self.name)<EOL>_RunnableHandler.run(self,context,[resolved_times ]+args)<EOL><DEDENT>@property <EOL>def longname(self):<EOL><INDENT>return self.name <EOL><DEDENT> <DEDENT>class _DynamicRunKeywordHandler(_DynamicHandler,_RunKeywordHandler):<EOL><INDENT>_parse_arguments=_RunKeywordHandler._parse_arguments <EOL>_get_timeout=_RunKeywordHandler._get_timeout <EOL><DEDENT>class _PythonInitHandler(_PythonHandler):<EOL><INDENT>def __init__(self,library,handler_name,handler_method,docgetter):<EOL><INDENT>_PythonHandler.__init__(self,library,handler_name,handler_method)<EOL>self._docgetter=docgetter <EOL><DEDENT>@property <EOL>def doc(self):<EOL><INDENT>if self._docgetter :<EOL><INDENT>self._doc=self._docgetter()or self._doc <EOL>self._docgetter=None <EOL><DEDENT>return self._doc <EOL><DEDENT>def _parse_arguments(self,handler_method):<EOL><INDENT>return PythonInitArguments(handler_method,self.library.name)<EOL><DEDENT> <DEDENT>class _JavaInitHandler(_BaseHandler):<EOL><INDENT>def __init__(self,library,handler_name,handler_method,docgetter):<EOL><INDENT>_BaseHandler.__init__(self,library,handler_name,handler_method)<EOL>self._docgetter=docgetter <EOL><DEDENT>@property <EOL>def doc(self):<EOL><INDENT>if self._docgetter :<EOL><INDENT>self._doc=self._docgetter()or self._doc <EOL>self._docgetter=None <EOL><DEDENT>return self._doc <EOL><DEDENT>def _parse_arguments(self,handler_method):<EOL><INDENT>return JavaInitArguments(handler_method,self.library.name)<EOL><DEDENT> <DEDENT><EOF><BOF>import numpy as np <EOL>import cv2 <EOL>import os <EOL>from common import splitfn <EOL>USAGE='<STR_LIT>'<EOL>if __name__=='__main__':<EOL><INDENT>import sys,getopt <EOL>from glob import glob <EOL>args,img_mask=getopt.getopt(sys.argv [:],'',['save=','debug=','square_size='])<EOL>args=dict(args)<EOL>try :img_mask=img_mask []<EOL>except :img_mask='<STR_LIT>'<EOL>img_names=glob(img_mask)<EOL>debug_dir=args.get('--debug')<EOL>square_size=float(args.get('--square_size',))<EOL>pattern_size=(,)<EOL>pattern_points=np.zeros((np.prod(pattern_size),),np.float32)<EOL>pattern_points [:,:]=np.indices(pattern_size).T.reshape(-,)<EOL>pattern_points *=square_size <EOL>obj_points=[]<EOL>img_points=[]<EOL>h,w=,<EOL>for fn in img_names :<EOL><INDENT>print '<STR_LIT>'%fn,<EOL>img=cv2.imread(fn,)<EOL>h,w=img.shape [:]<EOL>found,corners=cv2.findChessboardCorners(img,pattern_size)<EOL>if found :<EOL><INDENT>term=(cv2.TERM_CRITERIA_EPS +cv2.TERM_CRITERIA_COUNT,,)<EOL>cv2.cornerSubPix(img,corners,(,),(-,-),term)<EOL><DEDENT>if debug_dir :<EOL><INDENT>vis=cv2.cvtColor(img,cv2.COLOR_GRAY2BGR)<EOL>cv2.drawChessboardCorners(vis,pattern_size,corners,found)<EOL>path,name,ext=splitfn(fn)<EOL>cv2.imwrite('%s/%s_chess.bmp'%(debug_dir,name),vis)<EOL><DEDENT>if not found :<EOL><INDENT>print '<STR_LIT>'<EOL>continue <EOL><DEDENT>img_points.append(corners.reshape(-,))<EOL>obj_points.append(pattern_points)<EOL>print 'ok'<EOL><DEDENT>rms,camera_matrix,dist_coefs,rvecs,tvecs=cv2.calibrateCamera(obj_points,img_points,(w,h))<EOL>print "RMS:",rms <EOL>print '<STR_LIT>',camera_matrix <EOL>print '<STR_LIT>',dist_coefs.ravel()<EOL>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>import re <EOL>from robot.model.tags import TagPatterns <EOL>from robot.utils import Matcher,MultiMatcher,NormalizedDict <EOL>class Statistics :<EOL><INDENT>def __init__(self,suite,suite_stat_level=-,tag_stat_include=None,<EOL>tag_stat_exclude=None,tag_stat_combine=None,tag_doc=None,<EOL>tag_stat_link=None):<EOL><INDENT>self.tags=TagStatistics(tag_stat_include,tag_stat_exclude,<EOL>tag_stat_combine,tag_doc,tag_stat_link)<EOL>self.suite=SuiteStatistics(suite,self.tags,suite_stat_level)<EOL>self.total=TotalStatistics(self.suite)<EOL>self.tags.sort()<EOL><DEDENT>def serialize(self,serializer):<EOL><INDENT>serializer.start_statistics(self)<EOL>self.total.serialize(serializer)<EOL>self.tags.serialize(serializer)<EOL>self.suite.serialize(serializer)<EOL>serializer.end_statistics(self)<EOL><DEDENT> <DEDENT>class Stat :<EOL><INDENT>def __init__(self,name=''):<EOL><INDENT>self.name=name <EOL>self.passed=<EOL>self.failed=<EOL><DEDENT>@property <EOL>def total(self):<EOL><INDENT>return self.passed +self.failed <EOL><DEDENT>def add_stat(self,other):<EOL><INDENT>self.passed +=other.passed <EOL>self.failed +=other.failed <EOL><DEDENT>def add_test(self,test):<EOL><INDENT>if test.passed :<EOL><INDENT>self.passed +=<EOL><DEDENT>else :<EOL><INDENT>self.failed +=<EOL><DEDENT> <DEDENT>def fail_all(self):<EOL><INDENT>self.failed +=self.passed <EOL>self.passed=<EOL><DEDENT>def add_suite(self,suite):<EOL><INDENT>for test in suite.tests :<EOL><INDENT>if self._is_included(test):<EOL><INDENT>self.add_test(test)<EOL><DEDENT> <DEDENT>for suite in suite.suites :<EOL><INDENT>self.add_stat(self._subsuite_stats(suite))<EOL><DEDENT> <DEDENT>def _is_included(self,test):<EOL><INDENT>return True <EOL><DEDENT>def _subsuite_stats(self,suite):<EOL><INDENT>return suite.all_stats <EOL><DEDENT>def __cmp__(self,other):<EOL><INDENT>return cmp(self.name,other.name)<EOL><DEDENT>def __nonzero__(self):<EOL><INDENT>return self.failed==<EOL><DEDENT> <DEDENT>class CriticalStats(Stat):<EOL><INDENT>def __init__(self,suite):<EOL><INDENT>Stat.__init__(self)<EOL>self.add_suite(suite)<EOL><DEDENT>def _is_included(self,test):<EOL><INDENT>return test.critical <EOL><DEDENT>def _subsuite_stats(self,suite):<EOL><INDENT>return suite.critical_stats <EOL><DEDENT> <DEDENT>class AllStats(Stat):<EOL><INDENT>def __init__(self,suite):<EOL><INDENT>Stat.__init__(self)<EOL>self.add_suite(suite)<EOL><DEDENT> <DEDENT>class SuiteStat(Stat):<EOL><INDENT>type='suite'<EOL>def __init__(self,suite):<EOL><INDENT>Stat.__init__(self,suite.name)<EOL>self.longname=suite.longname <EOL>self.id=suite.id <EOL><DEDENT>def serialize(self,serializer):<EOL><INDENT>serializer.suite_stat(self)<EOL><DEDENT> <DEDENT>class TagStat(Stat):<EOL><INDENT>type='tag'<EOL>def __init__(self,name,doc='',links=[],critical=False,<EOL>non_critical=False,combined=''):<EOL><INDENT>Stat.__init__(self,name)<EOL>self.doc=doc <EOL>self.links=links <EOL>self.critical=critical <EOL>self.non_critical=non_critical <EOL>self.combined=combined <EOL>self.tests=[]<EOL><DEDENT>def add_test(self,test):<EOL><INDENT>Stat.add_test(self,test)<EOL>self.tests.append(test)<EOL><DEDENT>def __cmp__(self,other):<EOL><INDENT>if self.critical !=other.critical :<EOL><INDENT>return cmp(other.critical,self.critical)<EOL><DEDENT>if self.non_critical !=other.non_critical :<EOL><INDENT>return cmp(other.non_critical,self.non_critical)<EOL><DEDENT>if bool(self.combined)!=bool(other.combined):<EOL><INDENT>return cmp(bool(other.combined),bool(self.combined))<EOL><DEDENT>return cmp(self.name,other.name)<EOL><DEDENT>def serialize(self,serializer):<EOL><INDENT>serializer.tag_stat(self)<EOL><DEDENT> <DEDENT>class TotalStat(Stat):<EOL><INDENT>type='total'<EOL>def __init__(self,name,suite_stat):<EOL><INDENT>Stat.__init__(self,name)<EOL>self.passed=suite_stat.passed <EOL>self.failed=suite_stat.failed <EOL><DEDENT>def serialize(self,serializer):<EOL><INDENT>serializer.total_stat(self)<EOL><DEDENT> <DEDENT>class SuiteStatistics :<EOL><INDENT>def __init__(self,suite,tag_stats,suite_stat_level=-):<EOL><INDENT>self.all=SuiteStat(suite)<EOL>self.critical=SuiteStat(suite)<EOL>self.suites=[]<EOL>self._process_suites(suite,tag_stats)<EOL>self._process_tests(suite,tag_stats)<EOL>self._suite_stat_level=suite_stat_level <EOL><DEDENT>def _process_suites(self,suite,tag_stats):<EOL><INDENT>for subsuite in suite.suites :<EOL><INDENT>substat=SuiteStatistics(subsuite,tag_stats)<EOL>self.suites.append(substat)<EOL>self.all.add_stat(substat.all)<EOL>self.critical.add_stat(substat.critical)<EOL><DEDENT> <DEDENT>def _process_tests(self,suite,tag_stats):<EOL><INDENT>for test in suite.tests :<EOL><INDENT>self.all.add_test(test)<EOL>if test.critical :<EOL><INDENT>self.critical.add_test(test)<EOL><DEDENT>tag_stats.add_test(test,suite.critical)<EOL><DEDENT> <DEDENT>def serialize(self,serializer):<EOL><INDENT>serializer.start_suite_stats(self)<EOL>self._serialize(serializer,self._suite_stat_level)<EOL>serializer.end_suite_stats(self)<EOL><DEDENT>def _serialize(self,serializer,max_suite_level,suite_level=):<EOL><INDENT>self.all.serialize(serializer)<EOL>if max_suite_level <or max_suite_level >suite_level :<EOL><INDENT>for suite in self.suites :<EOL><INDENT>suite._serialize(serializer,max_suite_level,suite_level +)<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>class TagStatistics :<EOL><INDENT>def __init__(self,include=None,exclude=None,combine=None,docs=None,<EOL>links=None):<EOL><INDENT>self.stats=NormalizedDict(ignore=['_'])<EOL>self._include=MultiMatcher(include,ignore=['_'])<EOL>self._exclude=MultiMatcher(exclude,ignore=['_'])<EOL>self._combine=combine or []<EOL>info=TagStatInfo(docs or [],links or [])<EOL>self._get_doc=info.get_doc <EOL>self._get_links=info.get_links <EOL><DEDENT>def add_test(self,test,critical):<EOL><INDENT>self._add_tags_statistics(test,critical)<EOL>self._add_combined_statistics(test)<EOL><DEDENT>def _add_tags_statistics(self,test,critical):<EOL><INDENT>for tag in test.tags :<EOL><INDENT>if not self._is_included(tag):<EOL><INDENT>continue <EOL><DEDENT>if tag not in self.stats :<EOL><INDENT>self.stats [tag ]=TagStat(tag,self._get_doc(tag),<EOL>self._get_links(tag),<EOL>critical.is_critical(tag),<EOL>critical.is_non_critical(tag))<EOL><DEDENT>self.stats [tag ].add_test(test)<EOL><DEDENT> <DEDENT>def _is_included(self,tag):<EOL><INDENT>if self._include and not self._include.match(tag):<EOL><INDENT>return False <EOL><DEDENT>return not self._exclude.match(tag)<EOL><DEDENT>def _add_combined_statistics(self,test):<EOL><INDENT>for pattern,name in self._combine :<EOL><INDENT>name=name or pattern <EOL>if name not in self.stats :<EOL><INDENT>self.stats [name ]=TagStat(name,self._get_doc(name),<EOL>self._get_links(name),<EOL>combined=pattern)<EOL><DEDENT>if TagPatterns(pattern).match(test.tags):<EOL><INDENT>self.stats [name ].add_test(test)<EOL><DEDENT> <DEDENT> <DEDENT>def serialize(self,serializer):<EOL><INDENT>serializer.start_tag_stats(self)<EOL>for stat in sorted(self.stats.values()):<EOL><INDENT>stat.serialize(serializer)<EOL><DEDENT>serializer.end_tag_stats(self)<EOL><DEDENT>def sort(self):<EOL><INDENT>for stat in self.stats.values():<EOL><INDENT>stat.tests.sort()<EOL><DEDENT> <DEDENT> <DEDENT>class TotalStatistics :<EOL><INDENT>def __init__(self,suite):<EOL><INDENT>self.critical=TotalStat('Critical Tests',suite.critical)<EOL>self.all=TotalStat('All Tests',suite.all)<EOL><DEDENT>def serialize(self,serializer):<EOL><INDENT>serializer.start_total_stats(self)<EOL>self.critical.serialize(serializer)<EOL>self.all.serialize(serializer)<EOL>serializer.end_total_stats(self)<EOL><DEDENT> <DEDENT>class TagStatInfo :<EOL><INDENT>def __init__(self,docs,links):<EOL><INDENT>self._docs=[TagStatDoc(*doc)for doc in docs ]<EOL>self._links=[TagStatLink(*link)for link in links ]<EOL><DEDENT>def get_doc(self,tag):<EOL><INDENT>return ' & '.join(doc.text for doc in self._docs if doc.matches(tag))<EOL><DEDENT>def get_links(self,tag):<EOL><INDENT>return [link.get_link(tag)for link in self._links if link.matches(tag)]<EOL><DEDENT> <DEDENT>class TagStatDoc :<EOL><INDENT>def __init__(self,pattern,doc):<EOL><INDENT>self.text=doc <EOL>self._matcher=Matcher(pattern,ignore=['_'])<EOL><DEDENT>def matches(self,tag):<EOL><INDENT>return self._matcher.match(tag)<EOL><DEDENT> <DEDENT>class TagStatLink :<EOL><INDENT>_match_pattern_tokenizer=re.compile('(\*|\?)')<EOL>def __init__(self,pattern,link,title):<EOL><INDENT>self._regexp=self._get_match_regexp(pattern)<EOL>self._link=link <EOL>self._title=title.replace('_',' ')<EOL><DEDENT>def matches(self,tag):<EOL><INDENT>return self._regexp.match(tag)is not None <EOL><DEDENT>def get_link(self,tag):<EOL><INDENT>match=self._regexp.match(tag)<EOL>if not match :<EOL><INDENT>return None <EOL><DEDENT>link,title=self._replace_groups(self._link,self._title,match)<EOL>return link,title <EOL><DEDENT>def _replace_groups(self,link,title,match):<EOL><INDENT>for index,group in enumerate(match.groups()):<EOL><INDENT>placefolder='%'+str(index +)<EOL>link=link.replace(placefolder,group)<EOL>title=title.replace(placefolder,group)<EOL><DEDENT>return link,title <EOL><DEDENT>def _get_match_regexp(self,pattern):<EOL><INDENT>regexp=[]<EOL>open_parenthesis=False <EOL>for token in self._match_pattern_tokenizer.split(pattern):<EOL><INDENT>if token=='':<EOL><INDENT>continue <EOL><DEDENT>if token=='?':<EOL><INDENT>if not open_parenthesis :<EOL><INDENT>regexp.append('(')<EOL>open_parenthesis=True <EOL><DEDENT>regexp.append('.')<EOL>continue <EOL><DEDENT>if open_parenthesis :<EOL><INDENT>regexp.append(')')<EOL>open_parenthesis=False <EOL><DEDENT>if token=='*':<EOL><INDENT>regexp.append('(.*)')<EOL>continue <EOL><DEDENT>regexp.append(re.escape(token))<EOL><DEDENT>if open_parenthesis :<EOL><INDENT>regexp.append(')')<EOL><DEDENT>return re.compile('^%s$'%''.join(regexp),re.IGNORECASE)<EOL><DEDENT> <DEDENT><EOF><BOF>import re <EOL>from.aligners import FirstColumnAligner,ColumnAligner,NullAligner <EOL>from.dataextractor import DataExtractor <EOL>from.rowsplitter import RowSplitter <EOL>class _DataFileFormatter(object):<EOL><INDENT>_whitespace=re.compile('\s{2,}')<EOL>def __init__(self,column_count):<EOL><INDENT>self._splitter=RowSplitter(column_count)<EOL>self._column_count=column_count <EOL>self._extractor=DataExtractor(self._want_names_on_first_content_row)<EOL><DEDENT>def _want_names_on_first_content_row(self,table,name):<EOL><INDENT>return True <EOL><DEDENT>def empty_row_after(self,table):<EOL><INDENT>return self._format_row([],table)<EOL><DEDENT>def format_header(self,table):<EOL><INDENT>header=self._format_row(table.header)<EOL>return self._format_header(header,table)<EOL><DEDENT>def format_table(self,table):<EOL><INDENT>rows=self._extractor.rows_from_table(table)<EOL>if self._should_split_rows(table):<EOL><INDENT>return self._split_rows(rows,table)<EOL><DEDENT>return(self._format_row(r,table)for r in rows)<EOL><DEDENT>def _should_split_rows(self,table):<EOL><INDENT>return not self._should_align_columns(table)<EOL><DEDENT>def _split_rows(self,rows,table):<EOL><INDENT>indented=self._is_indented_table(table)<EOL>for row in rows :<EOL><INDENT>for r in self._splitter.split(row,indented):<EOL><INDENT>yield self._format_row(r,table)<EOL><DEDENT> <DEDENT> <DEDENT>def _should_align_columns(self,table):<EOL><INDENT>return self._is_indented_table(table)and bool(table.header [:])<EOL><DEDENT>def _is_indented_table(self,table):<EOL><INDENT>return table is not None and table.type in ['test case','keyword']<EOL><DEDENT>def _escape_consecutive_whitespace(self,row):<EOL><INDENT>return [self._whitespace.sub(self._whitespace_escaper,<EOL>cell.replace('\n',' '))for cell in row ]<EOL><DEDENT>def _whitespace_escaper(self,match):<EOL><INDENT>return '\\'.join(match.group())<EOL><DEDENT>def _format_row(self,row,table=None):<EOL><INDENT>raise NotImplementedError <EOL><DEDENT>def _format_header(self,header,table):<EOL><INDENT>raise NotImplementedError <EOL><DEDENT> <DEDENT>class TsvFormatter(_DataFileFormatter):<EOL><INDENT>def _format_header(self,header,table):<EOL><INDENT>return [self._format_header_cell(cell)for cell in header ]<EOL><DEDENT>def _format_header_cell(self,cell):<EOL><INDENT>return '*%s*'%cell if cell else ''<EOL><DEDENT>def _format_row(self,row,table=None):<EOL><INDENT>return self._pad(self._escape(row))<EOL><DEDENT>def _escape(self,row):<EOL><INDENT>return self._escape_consecutive_whitespace(self._escape_tabs(row))<EOL><DEDENT>def _escape_tabs(self,row):<EOL><INDENT>return [c.replace('\t','\\t')for c in row ]<EOL><DEDENT>def _pad(self,row):<EOL><INDENT>row=[cell.replace('\n',' ')for cell in row ]<EOL>return row +['']*(self._column_count -len(row))<EOL><DEDENT> <DEDENT>class TxtFormatter(_DataFileFormatter):<EOL><INDENT>_test_or_keyword_name_width=<EOL>_setting_and_variable_name_width=<EOL>def _format_row(self,row,table=None):<EOL><INDENT>row=self._escape(row)<EOL>aligner=self._aligner_for(table)<EOL>return aligner.align_row(row)<EOL><DEDENT>def _aligner_for(self,table):<EOL><INDENT>if table and table.type in ['setting','variable']:<EOL><INDENT>return FirstColumnAligner(self._setting_and_variable_name_width)<EOL><DEDENT>if self._should_align_columns(table):<EOL><INDENT>return ColumnAligner(self._test_or_keyword_name_width,table)<EOL><DEDENT>return NullAligner()<EOL><DEDENT>def _format_header(self,header,table):<EOL><INDENT>header=['*** %s ***'%header []]+header [:]<EOL>aligner=self._aligner_for(table)<EOL>return aligner.align_row(header)<EOL><DEDENT>def _want_names_on_first_content_row(self,table,name):<EOL><INDENT>return self._should_align_columns(table)and len(name)<=self._test_or_keyword_name_width <EOL><DEDENT>def _escape(self,row):<EOL><INDENT>if not row :<EOL><INDENT>return row <EOL><DEDENT>return self._escape_cells(self._escape_consecutive_whitespace(row))<EOL><DEDENT>def _escape_cells(self,row):<EOL><INDENT>return [row []]+[self._escape_empty(cell)for cell in row [:]]<EOL><DEDENT>def _escape_empty(self,cell):<EOL><INDENT>return cell or '\\'<EOL><DEDENT> <DEDENT>class PipeFormatter(TxtFormatter):<EOL><INDENT>def _escape_cells(self,row):<EOL><INDENT>return [self._escape_empty(self._escape_pipes(cell))for cell in row ]<EOL><DEDENT>def _escape_empty(self,cell):<EOL><INDENT>return cell or '  '<EOL><DEDENT>def _escape_pipes(self,cell):<EOL><INDENT>if ' | 'in cell :<EOL><INDENT>cell=cell.replace(' | ',' \\| ')<EOL><DEDENT>if cell.startswith('| '):<EOL><INDENT>cell='\\'+cell <EOL><DEDENT>if cell.endswith(' |'):<EOL><INDENT>cell=cell [:-]+'\\|'<EOL><DEDENT>return cell <EOL><DEDENT> <DEDENT><EOF><BOF>import sys <EOL>sys.path.append("core")<EOL>import model <EOL>import sublime <EOL>import sublime_plugin <EOL>import move_module <EOL>import file_search <EOL>import module_parser <EOL>import editor <EOL>import context_helper <EOL>import factory <EOL>import json <EOL>import shutil <EOL>import pprint <EOL>global context <EOL>context=None <EOL>global contextWindow <EOL>contextWindow=None <EOL>global shadowList <EOL>shadowList=None <EOL>global moduleAddInLine <EOL>moduleAddInLine=None <EOL>global moduelOpenInLine <EOL>moduleOpenInLine=None <EOL>global currentModuleEdit <EOL>def getContext(window):<EOL><INDENT>global context <EOL>global contextWindow <EOL>context=None <EOL>contextWindow=window <EOL>if window is not None :<EOL><INDENT>for folder in window.folders():<EOL><INDENT>file_search.findFile(folder,'<STR_LIT>',onSearchedForSettings)<EOL><DEDENT> <DEDENT> <DEDENT>def onSearchedForSettings(file):<EOL><INDENT>if file is not None :<EOL><INDENT>setContext(model.Context(contextWindow,file))<EOL><DEDENT>else :<EOL><INDENT>pass <EOL><DEDENT> <DEDENT>def setContext(newContext):<EOL><INDENT>global context <EOL>context=newContext <EOL>sublime.set_timeout(initContext,)<EOL><DEDENT>def initContext():<EOL><INDENT>global context <EOL>context_helper.initializeContext(context)<EOL>module_parser.parseModules(context,onModulePareDone)<EOL><DEDENT>def onModulePareDone():<EOL><INDENT>sublime.set_timeout(checkModulesAddInLine,)<EOL><DEDENT>def checkModulesAddInLine():<EOL><INDENT>global moduleAddInLine <EOL>global moduleOpenInLine <EOL>module=context.getModuleByImportString(moduleAddInLine)<EOL>if module is not None :<EOL><INDENT>addModule(module)<EOL>moduleAddInLine=None <EOL><DEDENT>if moduleOpenInLine is not None :<EOL><INDENT>openModuleFile(context.getModuleByImportString(moduleOpenInLine))<EOL>moduleOpenInLine=None <EOL><DEDENT>pass <EOL><DEDENT>def openModuleFile(module):<EOL><INDENT>if module.type=="script":<EOL><INDENT>focus=int(context.settings ["script_group"])<EOL>sublime.active_window().focus_group(focus)<EOL><DEDENT>elif module.type=="text":<EOL><INDENT>focus=int(context.settings ["text_group"])<EOL>sublime.active_window().focus_group(focus)<EOL><DEDENT>sublime.active_window().open_file(module.getFullPath())<EOL><DEDENT>class AppListener(sublime_plugin.EventListener):<EOL><INDENT>def on_post_save(self,view):<EOL><INDENT>global context <EOL>if context is not None :<EOL><INDENT>if sublime.active_window().active_view().file_name()==context.settingsPath :<EOL><INDENT>getContext(sublime.active_window())<EOL><DEDENT> <DEDENT>pass <EOL><DEDENT>def on_activated(self,view):<EOL><INDENT>if context is not None :<EOL><INDENT>if sublime.active_window()is not None :<EOL><INDENT>if sublime.active_window().id()!=context.window.id():<EOL><INDENT>getContext(sublime.active_window())<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>getContext(sublime.active_window())<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>getContext(sublime.active_window())<EOL><DEDENT> <DEDENT> <DEDENT>def updateContext():<EOL><INDENT>getContext(sublime.active_window())<EOL>pass <EOL><DEDENT>def moveModule():<EOL><INDENT>global context <EOL>move_module.moveModuleInView(context,updateContext)<EOL><DEDENT>def selectModule(onSelectCallback,group):<EOL><INDENT>global shadowList <EOL>global context <EOL>shadowList=[]<EOL>list=[]<EOL>for module in group :<EOL><INDENT>module=filterModule(module)<EOL>if module is not None :<EOL><INDENT>list.append([module.name,module.package ])<EOL>shadowList.append(module)<EOL><DEDENT> <DEDENT>context.window.show_quick_panel(list,onSelectCallback,)<EOL><DEDENT>def filterModule(module):<EOL><INDENT>if len(context.settings ["excludes"])>:<EOL><INDENT>for exclude in context.settings ["excludes"]:<EOL><INDENT>if context.getBaseDir()+exclude in module.path +"/"+module.name :<EOL><INDENT>return None <EOL><DEDENT> <DEDENT> <DEDENT>return module <EOL><DEDENT>def addModule(module):<EOL><INDENT>if module is None :<EOL><INDENT>return <EOL><DEDENT>global context <EOL>addEdit=editor.ModuleEdit(context.window.active_view().substr(sublime.Region(,context.window.active_view().size())),context)<EOL>defineRegion=addEdit.getDefineRegion()<EOL>addEdit.addModule(module,"")<EOL>edit=context.window.active_view().begin_edit()<EOL>context.window.active_view().replace(edit,defineRegion,addEdit.render())<EOL>context.window.active_view().end_edit(edit)<EOL><DEDENT>def onScriptSelectAdd(selectionIndex):<EOL><INDENT>if selectionIndex==-:<EOL><INDENT>return <EOL><DEDENT>global shadowList <EOL>addModule(shadowList [selectionIndex ])<EOL><DEDENT>def onTextSelectAdd(selectionIndex):<EOL><INDENT>if selectionIndex==-:<EOL><INDENT>return <EOL><DEDENT>global shadowList <EOL>addModule(shadowList [selectionIndex ])<EOL><DEDENT>def removeModule():<EOL><INDENT>global context <EOL>global currentModuleEdit <EOL>currentModuleEdit=editor.ModuleEdit(context.window.active_view().substr(sublime.Region(,context.window.active_view().size())),context)<EOL>modules=currentModuleEdit.getModules()<EOL>selectModule(onModuleSelectRemove,modules)<EOL><DEDENT>def onModuleSelectRemove(selectionIndex):<EOL><INDENT>if selectionIndex==-:<EOL><INDENT>return <EOL><DEDENT>global shadowList <EOL>global currentModuleEdit <EOL>global context <EOL>currentModuleEdit.removeModule(shadowList [selectionIndex ])<EOL>edit=context.window.active_view().begin_edit()<EOL>context.window.active_view().replace(edit,currentModuleEdit.getDefineRegion(),currentModuleEdit.render())<EOL>context.window.active_view().end_edit(edit)<EOL><DEDENT>def createModule(importOnCreated,type):<EOL><INDENT>global context <EOL>region=context.window.active_view().sel()[]<EOL>moduleName=""<EOL>if region.begin()!=region.end():<EOL><INDENT>moduleName=context.window.active_view().substr(region)<EOL><DEDENT>createConfig={<EOL>"type":type,<EOL>"callback":onModuleCreated,<EOL>"name":moduleName,<EOL>"importOnCreated":importOnCreated <EOL>}<EOL>factory.createModule(context,createConfig)<EOL><DEDENT>def onModuleCreated(importString,createConfig):<EOL><INDENT>global moduleAddInLine <EOL>global moduleOpenInLine <EOL>if createConfig ["importOnCreated"]==True :<EOL><INDENT>moduleAddInLine=importString <EOL><DEDENT>moduleOpenInLine=importString <EOL>module_parser.parseModules(context,onModulePareDone)<EOL><DEDENT>def onMainActionSelected(selectionIndex):<EOL><INDENT>global context <EOL>if selectionIndex==-:<EOL><INDENT>return <EOL><DEDENT>if len(context.settings ["text_folder"])>:<EOL><INDENT>if(selectionIndex==):<EOL><INDENT>selectModule(onScriptSelectAdd,context.getScriptModules())<EOL><DEDENT>elif(selectionIndex==):<EOL><INDENT>selectModule(onTextSelectAdd,context.getTextModules())<EOL><DEDENT>elif selectionIndex==:<EOL><INDENT>removeModule()<EOL><DEDENT>elif selectionIndex==:<EOL><INDENT>createModule(False,"script")<EOL><DEDENT>elif selectionIndex==:<EOL><INDENT>createModule(False,"text")<EOL><DEDENT>elif selectionIndex==:<EOL><INDENT>createModule(True,"script")<EOL><DEDENT>elif selectionIndex==:<EOL><INDENT>createModule(True,"text")<EOL><DEDENT>elif selectionIndex==:<EOL><INDENT>moveModule()<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>if(selectionIndex==):<EOL><INDENT>selectModule(onScriptSelectAdd,context.getScriptModules())<EOL><DEDENT>elif selectionIndex==:<EOL><INDENT>removeModule()<EOL><DEDENT>elif selectionIndex==:<EOL><INDENT>createModule(False,"script")<EOL><DEDENT>elif selectionIndex==:<EOL><INDENT>createModule(True,"script")<EOL><DEDENT>elif selectionIndex==:<EOL><INDENT>moveModule()<EOL><DEDENT> <DEDENT> <DEDENT>def onScriptSelectOpen(selectionIndex):<EOL><INDENT>if selectionIndex==-:<EOL><INDENT>return <EOL><DEDENT>global shadowList <EOL>sublime.active_window().open_file(shadowList [selectionIndex ].getFullPath())<EOL>pass <EOL><DEDENT>def onTextSelectOpen(selectionIndex):<EOL><INDENT>if selectionIndex==-:<EOL><INDENT>return <EOL><DEDENT>global shadowList <EOL>sublime.active_window().open_file(shadowList [selectionIndex ].getFullPath())<EOL>pass <EOL><DEDENT>def openModule(index):<EOL><INDENT>global context <EOL>if context.settings ["script_group"]==str(index):<EOL><INDENT>selectModule(onScriptSelectOpen,context.getScriptModules())<EOL><DEDENT>elif context.settings ["text_group"]==str(index):<EOL><INDENT>selectModule(onTextSelectOpen,context.getTextModules())<EOL><DEDENT> <DEDENT>class SublimeRjsOpen1Command(sublime_plugin.WindowCommand):<EOL><INDENT>def run(slef):<EOL><INDENT>sublime.active_window().focus_group()<EOL>openModule()<EOL><DEDENT> <DEDENT>class SublimeRjsOpen2Command(sublime_plugin.WindowCommand):<EOL><INDENT>def run(slef):<EOL><INDENT>sublime.active_window().focus_group()<EOL>openModule()<EOL><DEDENT> <DEDENT>class SublimeRjsOpen3Command(sublime_plugin.WindowCommand):<EOL><INDENT>def run(slef):<EOL><INDENT>sublime.active_window().focus_group()<EOL>openModule()<EOL><DEDENT> <DEDENT>class SublimeRjsCommand(sublime_plugin.WindowCommand):<EOL><INDENT>def run(self):<EOL><INDENT>global context <EOL>createAndImportScript='<STR_LIT>'<EOL>createAndImportText='<STR_LIT>'<EOL>region=context.window.active_view().sel()[]<EOL>if region.begin()!=region.end():<EOL><INDENT>createAndImportScript +=" '"+context.window.active_view().substr(region)+"'"<EOL>createAndImportText +=" '"+context.window.active_view().substr(region)+"'"<EOL><DEDENT>if len(context.settings ["text_folder"])>:<EOL><INDENT>options=['<STR_LIT>','<STR_LIT>',"Remove module",'<STR_LIT>','<STR_LIT>',createAndImportScript,createAndImportText,'<STR_LIT>']<EOL><DEDENT>else :<EOL><INDENT>options=['<STR_LIT>',"Remove module",'<STR_LIT>',createAndImportScript,'<STR_LIT>']<EOL><DEDENT>self.window.show_quick_panel(options,onMainActionSelected,)<EOL><DEDENT> <DEDENT>class AddSublimeRjsCommand(sublime_plugin.ApplicationCommand):<EOL><INDENT>def run(self,dirs):<EOL><INDENT>srcFile=sublime.packages_path()+'<STR_LIT>'<EOL>destFile=dirs []+'<STR_LIT>'<EOL>shutil.copyfile(srcFile,destFile)<EOL>sublime.active_window().open_file(destFile)<EOL>getContext(sublime.active_window())<EOL><DEDENT> <DEDENT>getContext(sublime.active_window())<EOF><BOF>USAGE='<STR_LIT>'<EOL>import sys <EOL>import os <EOL>if 'robot'not in sys.modules and __name__=='__main__':<EOL><INDENT>import pythonpathsetter <EOL><DEDENT>from robot.utils import Application,seq2str <EOL>from robot.errors import DataError <EOL>from robot.libdocpkg import LibraryDocumentation,ConsoleViewer <EOL>class LibDoc(Application):<EOL><INDENT>def __init__(self):<EOL><INDENT>Application.__init__(self,USAGE,arg_limits=(,),auto_version=False)<EOL><DEDENT>def validate(self,options,arguments):<EOL><INDENT>if ConsoleViewer.handles(arguments []):<EOL><INDENT>ConsoleViewer.validate_command(arguments [],arguments [:])<EOL><DEDENT>elif len(arguments)>:<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>return options,arguments <EOL><DEDENT>def main(self,args,name='',version='',format=None,docformat=None):<EOL><INDENT>lib_or_res,output=args [:]<EOL>libdoc=LibraryDocumentation(lib_or_res,name,version,<EOL>self._get_doc_format(docformat))<EOL>if ConsoleViewer.handles(output):<EOL><INDENT>ConsoleViewer(libdoc).view(output,*args [:])<EOL><DEDENT>else :<EOL><INDENT>libdoc.save(output,self._get_output_format(format,output))<EOL>self.console(os.path.abspath(output))<EOL><DEDENT> <DEDENT>def _get_doc_format(self,format):<EOL><INDENT>if not format :<EOL><INDENT>return None <EOL><DEDENT>return self._verify_format('Doc format',format,<EOL>['ROBOT','TEXT','HTML','REST'])<EOL><DEDENT>def _get_output_format(self,format,output):<EOL><INDENT>default=os.path.splitext(output)[][:]<EOL>return self._verify_format('Format',format or default,['HTML','XML'])<EOL><DEDENT>def _verify_format(self,type,format,valid):<EOL><INDENT>format=format.upper()<EOL>if format not in valid :<EOL><INDENT>raise DataError('<STR_LIT>'<EOL>%(type,seq2str(valid,lastsep=' or '),format))<EOL><DEDENT>return format <EOL><DEDENT> <DEDENT>def libdoc_cli(args):<EOL><INDENT> '<STR_LIT>'<EOL>LibDoc().execute_cli(args)<EOL><DEDENT>def libdoc(library_or_resource,outfile,name='',version='',format=None):<EOL><INDENT> '<STR_LIT>'<EOL>LibDoc().execute(library_or_resource,outfile,name=name,version=version,<EOL>format=format)<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>libdoc_cli(sys.argv [:])<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from.util import value,identifier,identifier_as,identifier_dir,paren <EOL>from.util import concat_by_comma,concat_by_space,build_values_list,build_where,build_set,build_on <EOL>single_value=(value,)<EOL>single_identifier=(identifier,)<EOL>single_identifier_as=(identifier_as,)<EOL>identifier_list=(identifier,concat_by_comma)<EOL>identifier_as_list=(identifier_as,concat_by_comma)<EOL>identifier_dir_list=(identifier_dir,concat_by_comma)<EOL>column_list=(identifier,concat_by_comma,paren)<EOL>values_list=(build_values_list,)<EOL>where_list=(build_where,)<EOL>set_list=(build_set,)<EOL>on_list=(build_on,)<EOL>statement_list=(concat_by_space,)<EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import video <EOL>from common import draw_str <EOL>lk_params=dict(winSize=(,),<EOL>maxLevel=,<EOL>criteria=(cv2.TERM_CRITERIA_EPS |cv2.TERM_CRITERIA_COUNT,,))<EOL>feature_params=dict(maxCorners=,<EOL>qualityLevel=,<EOL>minDistance=,<EOL>blockSize=)<EOL>def checkedTrace(img0,img1,p0,back_threshold=):<EOL><INDENT>p1,st,err=cv2.calcOpticalFlowPyrLK(img0,img1,p0,None,**lk_params)<EOL>p0r,st,err=cv2.calcOpticalFlowPyrLK(img1,img0,p1,None,**lk_params)<EOL>d=abs(p0 -p0r).reshape(-,).max(-)<EOL>status=d <back_threshold <EOL>return p1,status <EOL><DEDENT>green=(,,)<EOL>red=(,,)<EOL>class App :<EOL><INDENT>def __init__(self,video_src):<EOL><INDENT>self.cam=video.create_capture(video_src)<EOL>self.p0=None <EOL>self.use_ransac=True <EOL><DEDENT>def run(self):<EOL><INDENT>while True :<EOL><INDENT>ret,frame=self.cam.read()<EOL>frame_gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)<EOL>vis=frame.copy()<EOL>if self.p0 is not None :<EOL><INDENT>p2,trace_status=checkedTrace(self.gray1,frame_gray,self.p1)<EOL>self.p1=p2 [trace_status ].copy()<EOL>self.p0=self.p0 [trace_status ].copy()<EOL>self.gray1=frame_gray <EOL>if len(self.p0)<:<EOL><INDENT>self.p0=None <EOL>continue <EOL><DEDENT>H,status=cv2.findHomography(self.p0,self.p1,(,cv2.RANSAC)[self.use_ransac ],)<EOL>h,w=frame.shape [:]<EOL>overlay=cv2.warpPerspective(self.frame0,H,(w,h))<EOL>vis=cv2.addWeighted(vis,,overlay,,)<EOL>for(x0,y0),(x1,y1),good in zip(self.p0 [:,],self.p1 [:,],status [:,]):<EOL><INDENT>if good :<EOL><INDENT>cv2.line(vis,(x0,y0),(x1,y1),(,,))<EOL><DEDENT>cv2.circle(vis,(x1,y1),,(red,green)[good ],-)<EOL><DEDENT>draw_str(vis,(,),'track count: %d'%len(self.p1))<EOL>if self.use_ransac :<EOL><INDENT>draw_str(vis,(,),'RANSAC')<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>p=cv2.goodFeaturesToTrack(frame_gray,**feature_params)<EOL>if p is not None :<EOL><INDENT>for x,y in p [:,]:<EOL><INDENT>cv2.circle(vis,(x,y),,green,-)<EOL><DEDENT>draw_str(vis,(,),'<STR_LIT>'%len(p))<EOL><DEDENT> <DEDENT>cv2.imshow('lk_homography',vis)<EOL>ch=&cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT>if ch==ord(' '):<EOL><INDENT>self.frame0=frame.copy()<EOL>self.p0=cv2.goodFeaturesToTrack(frame_gray,**feature_params)<EOL>if self.p0 is not None :<EOL><INDENT>self.p1=self.p0 <EOL>self.gray0=frame_gray <EOL>self.gray1=frame_gray <EOL><DEDENT> <DEDENT>if ch==ord('r'):<EOL><INDENT>self.use_ransac=not self.use_ransac <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>def main():<EOL><INDENT>import sys <EOL>try :video_src=sys.argv []<EOL>except :video_src=<EOL>print __doc__ <EOL>App(video_src).run()<EOL>cv2.destroyAllWindows()<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>main()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import cv2 <EOL>from time import clock <EOL>class OpenCV_Cam(object):<EOL><INDENT>def __init__(self,src=None):<EOL><INDENT>self.start_cam(src)<EOL>self.__fcount,self.__frate,self.__start=,,clock()<EOL><DEDENT>@staticmethod <EOL>def cam_count():<EOL><INDENT>cam_idx=<EOL>cap=cv2.VideoCapture(cam_idx)<EOL>while cap.read()[]:<EOL><INDENT>cam_idx +=<EOL>cap=cv2.VideoCapture(cam_idx)<EOL><DEDENT>return cam_idx <EOL><DEDENT>def start_cam(self,src=None):<EOL><INDENT>if src is not None :<EOL><INDENT>self.cam=VideoCapture(src)<EOL>if not self.cam.isOpened():<EOL><INDENT>raise ValueError('Cannot open '+src +'as VideoCapture')<EOL><DEDENT>return <EOL><DEDENT>idx=<EOL>cam1,cam2=cv2.VideoCapture(),cv2.VideoCapture()<EOL>while(cam2.read()[]):<EOL><INDENT>cam1.release()<EOL>cam1=cam2 <EOL>idx +=<EOL>cam2=cv2.VideoCapture(idx)<EOL><DEDENT>self.cam=cam1 <EOL>if not self.cam.isOpened():<EOL><INDENT>raise Error('<STR_LIT>')<EOL><DEDENT> <DEDENT>@property <EOL>def size(self):<EOL><INDENT>w=self.cam.get(cv2.cv.CV_CAP_PROP_FRAME_WIDTH)<EOL>h=self.cam.get(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT)<EOL>return(int(w),int(h))<EOL><DEDENT>@size.setter <EOL>def size(self,shape):<EOL><INDENT>self.cam.set(cv2.cv.CV_CAP_PROP_FRAME_WIDTH,shape [])<EOL>self.cam.set(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT,shape [])<EOL><DEDENT>def read(self):<EOL><INDENT>self.__fcount +=<EOL>self.__frame=self.cam.read()[]<EOL>if self.__fcount==:<EOL><INDENT>end=clock()<EOL>self.__frate=/(end -self.__start)<EOL>self.__start=clock()<EOL>self.__fcount=<EOL><DEDENT>return self.__frame <EOL><DEDENT>@property <EOL>def frame_rate(self):<EOL><INDENT>return self.__frate <EOL><DEDENT>@property <EOL>def info(self):<EOL><INDENT>vars=[x [:]for x in dir(cv2.cv)if 'CV_CAP_PROP'in x ]<EOL>ret={}<EOL>for p in vars :<EOL><INDENT>cmd='ret[\''+p +'<STR_LIT>'+p +')'<EOL>exec cmd <EOL><DEDENT>return ret <EOL><DEDENT>def set(self,property,value):<EOL><INDENT>cmd='<STR_LIT>'+property +', '+str(value)+')'<EOL>print cmd <EOL>exec cmd <EOL><DEDENT>def cam_loop(self,func=lambda x :x,params=()):<EOL><INDENT>while True :<EOL><INDENT>input=self.read()<EOL>output=func(input,*params)<EOL>window_name=func.__name__ <EOL>if window_name=='<lambda>':window_name='camera image'<EOL>cv2.imshow(window_name,output)<EOL>k=cv2.waitKey()<EOL>if k==:<EOL><INDENT>break <EOL><DEDENT>elif k==ord('p'):<EOL><INDENT>info=self.info <EOL>for i in info :<EOL><INDENT>print i,'=',info [i ]<EOL><DEDENT> <DEDENT>elif k==ord('s'):<EOL><INDENT>p=raw_input('type property:')<EOL>if('<STR_LIT>'+p)not in dir(cv2.cv):<EOL><INDENT>print p,'<STR_LIT>'<EOL>print '<STR_LIT>',[x [:]for x in dir(cv2.cv)if 'CV_CAP_PROP'in x ]<EOL><DEDENT>else :<EOL><INDENT>v=raw_input('type value:')<EOL>self.set(p,v)<EOL><DEDENT> <DEDENT>elif k==ord('f'):<EOL><INDENT>print self.frame_rate <EOL><DEDENT> <DEDENT> <DEDENT>def __enter__(self):<EOL><INDENT>return self <EOL><DEDENT>def __exit__(self,exc_type,exc_value,traceback):<EOL><INDENT>self.cam.release()<EOL><DEDENT>def release(self):<EOL><INDENT>self.cam.release()<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>cam=OpenCV_Cam()<EOL>cam.size=(,)<EOL>cam.cam_loop()<EOL><DEDENT><EOF><BOF>from.totalstatistics import TotalStatisticsBuilder <EOL>from.suitestatistics import SuiteStatisticsBuilder <EOL>from.tagstatistics import TagStatisticsBuilder <EOL>from.visitor import SuiteVisitor <EOL>class Statistics(object):<EOL><INDENT>def __init__(self,suite,suite_stat_level=-,tag_stat_include=None,<EOL>tag_stat_exclude=None,tag_stat_combine=None,tag_doc=None,<EOL>tag_stat_link=None):<EOL><INDENT>total_builder=TotalStatisticsBuilder()<EOL>suite_builder=SuiteStatisticsBuilder(suite_stat_level)<EOL>tag_builder=TagStatisticsBuilder(suite.criticality,tag_stat_include,<EOL>tag_stat_exclude,tag_stat_combine,<EOL>tag_doc,tag_stat_link)<EOL>suite.visit(StatisticsBuilder(total_builder,suite_builder,tag_builder))<EOL>self.total=total_builder.stats <EOL>self.suite=suite_builder.stats <EOL>self.tags=tag_builder.stats <EOL><DEDENT>def visit(self,visitor):<EOL><INDENT>visitor.visit_statistics(self)<EOL><DEDENT> <DEDENT>class StatisticsBuilder(SuiteVisitor):<EOL><INDENT>def __init__(self,total_builder,suite_builder,tag_builder):<EOL><INDENT>self._total_builder=total_builder <EOL>self._suite_builder=suite_builder <EOL>self._tag_builder=tag_builder <EOL><DEDENT>def start_suite(self,suite):<EOL><INDENT>self._suite_builder.start_suite(suite)<EOL><DEDENT>def end_suite(self,suite):<EOL><INDENT>self._suite_builder.end_suite()<EOL><DEDENT>def visit_test(self,test):<EOL><INDENT>self._total_builder.add_test(test)<EOL>self._suite_builder.add_test(test)<EOL>self._tag_builder.add_test(test)<EOL><DEDENT>def visit_keyword(self,kw):<EOL><INDENT>pass <EOL><DEDENT> <DEDENT><EOF><BOF>import numpy as np <EOL>import cv2 <EOL>import os <EOL>from common import splitfn <EOL>USAGE='<STR_LIT>'<EOL>if __name__=='__main__':<EOL><INDENT>import sys,getopt <EOL>from glob import glob <EOL>args,img_mask=getopt.getopt(sys.argv [:],'',['save=','debug=','square_size='])<EOL>args=dict(args)<EOL>try :img_mask=img_mask []<EOL>except :img_mask='./origin/*.jpg'<EOL>img_names=glob(img_mask)<EOL>debug_dir=args.get('--debug')<EOL>square_size=float(args.get('--square_size',))<EOL>pattern_size=(,)<EOL>pattern_points=np.zeros((np.prod(pattern_size),),np.float32)<EOL>pattern_points [:,:]=np.indices(pattern_size).T.reshape(-,)<EOL>pattern_points *=square_size <EOL>obj_points=[]<EOL>img_points=[]<EOL>h,w=,<EOL>for fn in img_names :<EOL><INDENT>print '<STR_LIT>'%fn,<EOL>img=cv2.imread(fn,)<EOL>h,w=img.shape [:]<EOL>found,corners=cv2.findChessboardCorners(img,pattern_size)<EOL>if found :<EOL><INDENT>term=(cv2.TERM_CRITERIA_EPS +cv2.TERM_CRITERIA_COUNT,,)<EOL>cv2.cornerSubPix(img,corners,(,),(-,-),term)<EOL><DEDENT>if debug_dir :<EOL><INDENT>vis=cv2.cvtColor(img,cv2.COLOR_GRAY2BGR)<EOL>cv2.drawChessboardCorners(vis,pattern_size,corners,found)<EOL>path,name,ext=splitfn(fn)<EOL>cv2.imwrite('%s/%s_chess.bmp'%(debug_dir,name),vis)<EOL><DEDENT>if not found :<EOL><INDENT>print '<STR_LIT>'<EOL>continue <EOL><DEDENT>img_points.append(corners.reshape(-,))<EOL>obj_points.append(pattern_points)<EOL>print 'ok'<EOL><DEDENT>rms,camera_matrix,dist_coefs,rvecs,tvecs=cv2.calibrateCamera(obj_points,img_points,(w,h))<EOL>print "RMS:",rms <EOL>print '<STR_LIT>',camera_matrix <EOL>print '<STR_LIT>',dist_coefs.ravel()<EOL>np.savez('<STR_LIT>',mtx=camera_matrix,dist=dist_coefs,rvecs=rvecs,tvecs=tvecs)<EOL>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>import sys <EOL>import codecs <EOL>from contextlib import contextmanager <EOL>from.encodingsniffer import get_output_encoding,get_system_encoding <EOL>from.unic import unic <EOL>OUTPUT_ENCODING=get_output_encoding()<EOL>SYSTEM_ENCODING=get_system_encoding()<EOL>def decode_output(string):<EOL><INDENT> '<STR_LIT>'<EOL>return unic(string,OUTPUT_ENCODING)<EOL><DEDENT>def encode_output(string,errors='replace'):<EOL><INDENT> '<STR_LIT>'<EOL>if sys.platform=='cli':<EOL><INDENT>return string <EOL><DEDENT>return string.encode(OUTPUT_ENCODING,errors)<EOL><DEDENT>def decode_from_system(string,can_be_from_java=True):<EOL><INDENT> '<STR_LIT>'<EOL>if sys.platform=='cli':<EOL><INDENT>return string <EOL><DEDENT>if sys.platform.startswith('java')and can_be_from_java :<EOL><INDENT>from java.lang import String <EOL>string=String(string)<EOL><DEDENT>return unic(string,SYSTEM_ENCODING)<EOL><DEDENT>def encode_to_system(string,errors='replace'):<EOL><INDENT> '<STR_LIT>'<EOL>return string.encode(SYSTEM_ENCODING,errors)<EOL><DEDENT>@contextmanager <EOL>def utf8open(filename,mode='r'):<EOL><INDENT>file=codecs.open(filename,mode=mode,encoding='utf8')<EOL>try :<EOL><INDENT>yield file <EOL><DEDENT>finally :<EOL><INDENT>file.close()<EOL><DEDENT> <DEDENT><EOF><BOF>from __future__ import with_statement <EOL>from robot.model import Statistics <EOL>from robot.reporting.outputwriter import OutputWriter <EOL>from.executionerrors import ExecutionErrors <EOL>from.configurer import SuiteConfigurer <EOL>from.testsuite import TestSuite <EOL>class Result(object):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,source=None,root_suite=None,errors=None):<EOL><INDENT>self.source=source <EOL>self.suite=root_suite or TestSuite()<EOL>self.errors=errors or ExecutionErrors()<EOL>self.generator=None <EOL>self._status_rc=True <EOL>self._stat_config={}<EOL><DEDENT>@property <EOL>def statistics(self):<EOL><INDENT> '<STR_LIT>'<EOL>return Statistics(self.suite,**self._stat_config)<EOL><DEDENT>@property <EOL>def return_code(self):<EOL><INDENT> '<STR_LIT>'<EOL>if self._status_rc :<EOL><INDENT>return min(self.suite.statistics.critical.failed,)<EOL><DEDENT>return <EOL><DEDENT>def configure(self,status_rc=True,suite_config={},stat_config={}):<EOL><INDENT>SuiteConfigurer(**suite_config).configure(self.suite)<EOL>self._status_rc=status_rc <EOL>self._stat_config=stat_config <EOL><DEDENT>def visit(self,visitor):<EOL><INDENT>visitor.visit_result(self)<EOL><DEDENT>def save(self,path=None):<EOL><INDENT>self.visit(OutputWriter(path or self.source))<EOL><DEDENT> <DEDENT>class CombinedResult(Result):<EOL><INDENT>def __init__(self,others):<EOL><INDENT>Result.__init__(self)<EOL>for other in others :<EOL><INDENT>self.add_result(other)<EOL><DEDENT> <DEDENT>def add_result(self,other):<EOL><INDENT>self.suite.suites.append(other.suite)<EOL>self.errors.add(other.errors)<EOL><DEDENT> <DEDENT><EOF><BOF>import sys <EOL>from cv import *<EOL>def inside(r,q):<EOL><INDENT>(rx,ry),(rw,rh)=r (qx,qy),(qw,qh)=q <EOL>return rx >qx and ry >qy and rx +rw <qx +qw and ry +rh <qy +qh <EOL><DEDENT>try :<EOL><INDENT>img=LoadImage(sys.argv [])<EOL><DEDENT>except :<EOL><INDENT>try :<EOL><INDENT>f=open(sys.argv [],"rt")<EOL><DEDENT>except :<EOL><INDENT>print "cannot read "+sys.argv []<EOL>sys.exit(-)<EOL><DEDENT>imglist=list(f.readlines())<EOL><DEDENT>else :<EOL><INDENT>imglist=[sys.argv []]<EOL><DEDENT>NamedWindow('<STR_LIT>',)<EOL>storage=CreateMemStorage()<EOL>for name in imglist :<EOL><INDENT>n=name.strip()<EOL>print n <EOL>try :<EOL><INDENT>img=LoadImage(n)<EOL><DEDENT>except :<EOL><INDENT>continue <EOL><DEDENT>found=list(HOGDetectMultiScale(img,storage,win_stride=(,),<EOL>padding=(,),scale=,group_threshold=))<EOL>found_filtered=[]<EOL>for r in found :<EOL><INDENT>insidef=False <EOL>for q in found :<EOL><INDENT>if inside(r,q):<EOL><INDENT>insidef=True <EOL>break <EOL><DEDENT> <DEDENT>if not insidef :<EOL><INDENT>found_filtered.append(r)<EOL><DEDENT> <DEDENT>for r in found_filtered :<EOL><INDENT>(rx,ry),(rw,rh)=r <EOL>tl=(rx +int(rw *),ry +int(rh *))<EOL>br=(rx +int(rw *),ry +int(rh *))<EOL>Rectangle(img,tl,br,(,,),)<EOL><DEDENT>ShowImage('<STR_LIT>',img)<EOL>c=WaitKey()<EOL>if c==ord('q'):<EOL><INDENT>break <EOL><DEDENT> <DEDENT>cv.DestroyAllWindows()<EOF><BOF>class setter(object):<EOL><INDENT>def __init__(self,method):<EOL><INDENT>self.method=method <EOL>self.attr_name='_setter__'+method.__name__ <EOL><DEDENT>def __get__(self,instance,owner):<EOL><INDENT>if instance is None :<EOL><INDENT>return self <EOL><DEDENT>try :<EOL><INDENT>return getattr(instance,self.attr_name)<EOL><DEDENT>except AttributeError :<EOL><INDENT>raise AttributeError(self.method.__name__)<EOL><DEDENT> <DEDENT>def __set__(self,instance,value):<EOL><INDENT>if instance is None :<EOL><INDENT>return <EOL><DEDENT>setattr(instance,self.attr_name,self.method(instance,value))<EOL><DEDENT> <DEDENT>class SetterAwareType(type):<EOL><INDENT>def __new__(cls,name,bases,dct):<EOL><INDENT>slots=dct.get('__slots__')<EOL>if slots is not None :<EOL><INDENT>for item in dct.values():<EOL><INDENT>if isinstance(item,setter):<EOL><INDENT>slots.append(item.attr_name)<EOL><DEDENT> <DEDENT> <DEDENT>return type.__new__(cls,name,bases,dct)<EOL><DEDENT> <DEDENT><EOF><BOF>import re <EOL>from robot import utils <EOL>from.formatters import _DataFileFormatter <EOL>class HtmlFormatter(_DataFileFormatter):<EOL><INDENT>def _format_row(self,row,table=None):<EOL><INDENT>row=self._pad(self._escape_consecutive_whitespace(row),table)<EOL>if self._is_documentation_row(row):<EOL><INDENT>return self._create_documentation_row(row)<EOL><DEDENT>first_cell=self._create_first_cell(row [],table)<EOL>if self._is_indented_documentation_row(row [:],table):<EOL><INDENT>return self._create_indented_documentation_row(first_cell,row [:])<EOL><DEDENT>return [first_cell ]+[HtmlCell(c)for c in row [:]]<EOL><DEDENT>def _is_documentation_row(self,row):<EOL><INDENT>return row []=='Documentation'<EOL><DEDENT>def _create_documentation_row(self,row):<EOL><INDENT>return [NameCell(row []),DocumentationCell(row [],span=self._column_count -)]<EOL><DEDENT>def _is_indented_documentation_row(self,cells,table):<EOL><INDENT>return self._is_indented_table(table)and cells and cells []=='[Documentation]'<EOL><DEDENT>def _create_indented_documentation_row(self,first_cell,cells):<EOL><INDENT>start=[first_cell,HtmlCell(cells [])]<EOL>if any(c.startswith('#')for c in cells):<EOL><INDENT>return start +[HtmlCell(c)for c in cells [:]]<EOL><DEDENT>return start +[DocumentationCell(cells [],self._column_count -)]<EOL><DEDENT>def _create_first_cell(self,cell,table):<EOL><INDENT>if self._is_indented_table(table)and cell :<EOL><INDENT>return AnchorNameCell(cell,'keyword'if table.type=='keyword'<EOL>else 'test')<EOL><DEDENT>return NameCell(cell)<EOL><DEDENT>def format_header(self,table):<EOL><INDENT>if not self._should_align_columns(table)or len(table.header)==:<EOL><INDENT>return [HeaderCell(table.header [],self._column_count)]<EOL><DEDENT>headers=self._pad_header(table)<EOL>return [HeaderCell(hdr)for hdr in headers ]<EOL><DEDENT>def _pad_header(self,table):<EOL><INDENT>header=table.header <EOL>return header +['']*(self._get_column_count(table)-len(header))<EOL><DEDENT>def _pad(self,row,table):<EOL><INDENT>return row +['']*(self._get_column_count(table)-len(row))<EOL><DEDENT>def _get_column_count(self,table):<EOL><INDENT>if table is None or len(table.header)==or not self._is_indented_table(table):<EOL><INDENT>return self._column_count <EOL><DEDENT>return max(self._max_column_count(table),len(table.header))<EOL><DEDENT>def _max_column_count(self,table):<EOL><INDENT>count=<EOL>for item in table :<EOL><INDENT>for child in item :<EOL><INDENT>count=max(count,len(child.as_list())+)<EOL><DEDENT> <DEDENT>return count <EOL><DEDENT> <DEDENT>class HtmlCell(object):<EOL><INDENT>_backslash_matcher=re.compile(r'(\\+)n ')<EOL>def __init__(self,content='',attributes=None,tag='td',escape=True):<EOL><INDENT>if escape :<EOL><INDENT>content=utils.html_escape(content)<EOL><DEDENT>self.content=self._replace_newlines(content)<EOL>self.attributes=attributes or {}<EOL>self.tag=tag <EOL><DEDENT>def _replace_newlines(self,content):<EOL><INDENT>def replacer(match):<EOL><INDENT>backslash_count=len(match.group())<EOL>if backslash_count %==:<EOL><INDENT>return '%sn<br>\n'%match.group()<EOL><DEDENT>return match.group()<EOL><DEDENT>return self._backslash_matcher.sub(replacer,content)<EOL><DEDENT> <DEDENT>class NameCell(HtmlCell):<EOL><INDENT>def __init__(self,name='',attributes=None):<EOL><INDENT>HtmlCell.__init__(self,name,{'class':'name'})<EOL><DEDENT> <DEDENT>class AnchorNameCell(HtmlCell):<EOL><INDENT>def __init__(self,name,type_):<EOL><INDENT>HtmlCell.__init__(self,self._link_from_name(name,type_),<EOL>{'class':'name'},escape=False)<EOL><DEDENT>def _link_from_name(self,name,type_):<EOL><INDENT>return '<STR_LIT>'%(type_,utils.html_attr_escape(name),<EOL>utils.html_escape(name))<EOL><DEDENT> <DEDENT>class DocumentationCell(HtmlCell):<EOL><INDENT>def __init__(self,content,span):<EOL><INDENT>HtmlCell.__init__(self,content,{'class':'colspan%d'%span,<EOL>'colspan':'%d'%span })<EOL><DEDENT> <DEDENT>class HeaderCell(HtmlCell):<EOL><INDENT>def __init__(self,name,span=):<EOL><INDENT>HtmlCell.__init__(self,name,{'class':'name','colspan':'%d'%span },<EOL>tag='th')<EOL><DEDENT> <DEDENT><EOF><BOF>from __future__ import with_statement <EOL>import os <EOL>import sys <EOL>import inspect <EOL>if sys.platform.startswith('java'):<EOL><INDENT>from java.lang.System import getProperty <EOL><DEDENT>from robot.errors import DataError <EOL>from.encoding import decode_from_system <EOL>from.error import get_error_details <EOL>from.robotpath import abspath,normpath <EOL>class Importer(object):<EOL><INDENT>def __init__(self,type=None,logger=None):<EOL><INDENT>if not logger :<EOL><INDENT>from robot.output import LOGGER as logger <EOL><DEDENT>self._type=type or ''<EOL>self._logger=logger <EOL>self._importers=(ByPathImporter(logger),<EOL>NonDottedImporter(logger),<EOL>DottedImporter(logger))<EOL>self._by_path_importer=self._importers []<EOL><DEDENT>def import_class_or_module(self,name,instantiate_with_args=None):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>imported,source=self._import_class_or_module(name)<EOL>self._log_import_succeeded(imported,name,source)<EOL>return self._instantiate_if_needed(imported,instantiate_with_args)<EOL><DEDENT>except DataError,err :<EOL><INDENT>self._raise_import_failed(name,err)<EOL><DEDENT> <DEDENT>def _import_class_or_module(self,name):<EOL><INDENT>for importer in self._importers :<EOL><INDENT>if importer.handles(name):<EOL><INDENT>return importer.import_(name)<EOL><DEDENT> <DEDENT> <DEDENT>def import_class_or_module_by_path(self,path,instantiate_with_args=None):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>imported,source=self._by_path_importer.import_(path)<EOL>self._log_import_succeeded(imported,imported.__name__,source)<EOL>return self._instantiate_if_needed(imported,instantiate_with_args)<EOL><DEDENT>except DataError,err :<EOL><INDENT>self._raise_import_failed(path,err)<EOL><DEDENT> <DEDENT>def _raise_import_failed(self,name,error):<EOL><INDENT>import_type='%s '%self._type if self._type else ''<EOL>msg='<STR_LIT>'%(import_type,name,error.message)<EOL>if not error.details :<EOL><INDENT>raise DataError(msg)<EOL><DEDENT>msg=[msg,error.details ]<EOL>msg.extend(self._get_items_in('PYTHONPATH',sys.path))<EOL>if sys.platform.startswith('java'):<EOL><INDENT>classpath=getProperty('java.class.path').split(os.path.pathsep)<EOL>msg.extend(self._get_items_in('CLASSPATH',classpath))<EOL><DEDENT>raise DataError('\n'.join(msg))<EOL><DEDENT>def _get_items_in(self,type,items):<EOL><INDENT>yield '%s:'%type <EOL>for item in items :<EOL><INDENT>if item :<EOL><INDENT>yield '  %s'%(item if isinstance(item,unicode)<EOL>else decode_from_system(item))<EOL><DEDENT> <DEDENT> <DEDENT>def _instantiate_if_needed(self,imported,args):<EOL><INDENT>if args is None :<EOL><INDENT>return imported <EOL><DEDENT>if inspect.isclass(imported):<EOL><INDENT>return self._instantiate_class(imported,args)<EOL><DEDENT>if args :<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>return imported <EOL><DEDENT>def _instantiate_class(self,imported,args):<EOL><INDENT>try :<EOL><INDENT>return imported(*args)<EOL><DEDENT>except :<EOL><INDENT>raise DataError('<STR_LIT>'%get_error_details())<EOL><DEDENT> <DEDENT>def _log_import_succeeded(self,item,name,source):<EOL><INDENT>import_type='%s '%self._type if self._type else ''<EOL>item_type='module'if inspect.ismodule(item)else 'class'<EOL>location=("'%s'"%source)if source else '<STR_LIT>'<EOL>self._logger.info('<STR_LIT>'<EOL>%(import_type,item_type,name,location))<EOL><DEDENT> <DEDENT>class _Importer(object):<EOL><INDENT>def __init__(self,logger):<EOL><INDENT>self._logger=logger <EOL><DEDENT>def _import(self,name,fromlist=None,retry=True):<EOL><INDENT>try :<EOL><INDENT>try :<EOL><INDENT>return __import__(name,fromlist=fromlist)<EOL><DEDENT>except ImportError :<EOL><INDENT>if sys.platform.startswith('java')and fromlist and retry :<EOL><INDENT>__import__('%s.%s'%(name,fromlist []))<EOL>return self._import(name,fromlist,retry=False)<EOL><DEDENT>raise sys.exc_type,sys.exc_value,sys.exc_traceback <EOL><DEDENT> <DEDENT>except :<EOL><INDENT>raise DataError(*get_error_details())<EOL><DEDENT> <DEDENT>def _verify_type(self,imported):<EOL><INDENT>if inspect.isclass(imported)or inspect.ismodule(imported):<EOL><INDENT>return imported <EOL><DEDENT>raise DataError('<STR_LIT>'%type(imported).__name__)<EOL><DEDENT>def _get_class_from_module(self,module):<EOL><INDENT>klass=getattr(module,module.__name__,None)<EOL>return klass if inspect.isclass(klass)else None <EOL><DEDENT>def _get_source(self,module):<EOL><INDENT>source=getattr(module,'__file__',None)<EOL>return abspath(source)if source else None <EOL><DEDENT> <DEDENT>class ByPathImporter(_Importer):<EOL><INDENT>_valid_import_extensions=('.py','.java','.class','')<EOL>def handles(self,path):<EOL><INDENT>return os.path.isabs(path)<EOL><DEDENT>def import_(self,path):<EOL><INDENT>self._verify_import_path(path)<EOL>self._remove_wrong_module_from_sys_modules(path)<EOL>module=self._import_by_path(path)<EOL>imported=self._get_class_from_module(module)or module <EOL>return self._verify_type(imported),path <EOL><DEDENT>def _verify_import_path(self,path):<EOL><INDENT>if not os.path.exists(path):<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>if not os.path.isabs(path):<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>if not os.path.splitext(path)[]in self._valid_import_extensions :<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT> <DEDENT>def _remove_wrong_module_from_sys_modules(self,path):<EOL><INDENT>importing_from,name=self._split_path_to_module(path)<EOL>importing_package=os.path.splitext(path)[]==''<EOL>if self._wrong_module_imported(name,importing_from,importing_package):<EOL><INDENT>del sys.modules [name ]<EOL>self._logger.info('<STR_LIT>'<EOL>"fresh module."%name)<EOL><DEDENT> <DEDENT>def _split_path_to_module(self,path):<EOL><INDENT>module_dir,module_file=os.path.split(abspath(path))<EOL>module_name=os.path.splitext(module_file)[]<EOL>if module_name.endswith('$py'):<EOL><INDENT>module_name=module_name [:-]<EOL><DEDENT>return module_dir,module_name <EOL><DEDENT>def _wrong_module_imported(self,name,importing_from,importing_package):<EOL><INDENT>module=sys.modules.get(name)<EOL>if not module :<EOL><INDENT>return False <EOL><DEDENT>source=getattr(module,'__file__',None)<EOL>if not source :<EOL><INDENT>return True <EOL><DEDENT>imported_from,imported_package=self._get_import_information(source)<EOL>return((normpath(importing_from),importing_package)!=(normpath(imported_from),imported_package))<EOL><DEDENT>def _get_import_information(self,source):<EOL><INDENT>imported_from,imported_file=self._split_path_to_module(source)<EOL>imported_package=imported_file=='__init__'<EOL>if imported_package :<EOL><INDENT>imported_from=os.path.dirname(imported_from)<EOL><DEDENT>return imported_from,imported_package <EOL><DEDENT>def _import_by_path(self,path):<EOL><INDENT>module_dir,module_name=self._split_path_to_module(path)<EOL>sys.path.insert(,module_dir)<EOL>try :<EOL><INDENT>return self._import(module_name)<EOL><DEDENT>finally :<EOL><INDENT>sys.path.pop()<EOL><DEDENT> <DEDENT> <DEDENT>class NonDottedImporter(_Importer):<EOL><INDENT>def handles(self,name):<EOL><INDENT>return '.'not in name <EOL><DEDENT>def import_(self,name):<EOL><INDENT>module=self._import(name)<EOL>imported=self._get_class_from_module(module)or module <EOL>return self._verify_type(imported),self._get_source(module)<EOL><DEDENT> <DEDENT>class DottedImporter(_Importer):<EOL><INDENT>def handles(self,name):<EOL><INDENT>return '.'in name <EOL><DEDENT>def import_(self,name):<EOL><INDENT>parent_name,lib_name=name.rsplit('.',)<EOL>parent=self._import(parent_name,fromlist=[str(lib_name)])<EOL>try :<EOL><INDENT>imported=getattr(parent,lib_name)<EOL><DEDENT>except AttributeError :<EOL><INDENT>raise DataError('<STR_LIT>'<EOL>%(parent_name,lib_name))<EOL><DEDENT>return self._verify_type(imported),self._get_source(parent)<EOL><DEDENT> <DEDENT><EOF><BOF>from robot.model import SuiteVisitor <EOL>class ResultVisitor(SuiteVisitor):<EOL><INDENT>def visit_result(self,result):<EOL><INDENT>if self.start_result(result)is not False :<EOL><INDENT>result.suite.visit(self)<EOL>result.statistics.visit(self)<EOL>result.errors.visit(self)<EOL>self.end_result(result)<EOL><DEDENT> <DEDENT>def start_result(self,result):<EOL><INDENT>pass <EOL><DEDENT>def end_result(self,result):<EOL><INDENT>pass <EOL><DEDENT>def visit_statistics(self,stats):<EOL><INDENT>if self.start_statistics(stats)is not False :<EOL><INDENT>stats.total.visit(self)<EOL>stats.tags.visit(self)<EOL>stats.suite.visit(self)<EOL>self.end_statistics(stats)<EOL><DEDENT> <DEDENT>def start_statistics(self,stats):<EOL><INDENT>pass <EOL><DEDENT>def end_statistics(self,stats):<EOL><INDENT>pass <EOL><DEDENT>def visit_total_statistics(self,stats):<EOL><INDENT>if self.start_total_statistics(stats)is not False :<EOL><INDENT>for stat in stats :<EOL><INDENT>stat.visit(self)<EOL><DEDENT>self.end_total_statistics(stats)<EOL><DEDENT> <DEDENT>def start_total_statistics(self,stats):<EOL><INDENT>pass <EOL><DEDENT>def end_total_statistics(self,stats):<EOL><INDENT>pass <EOL><DEDENT>def visit_tag_statistics(self,stats):<EOL><INDENT>if self.start_tag_statistics(stats)is not False :<EOL><INDENT>for stat in stats :<EOL><INDENT>stat.visit(self)<EOL><DEDENT>self.end_tag_statistics(stats)<EOL><DEDENT> <DEDENT>def start_tag_statistics(self,stats):<EOL><INDENT>pass <EOL><DEDENT>def end_tag_statistics(self,stats):<EOL><INDENT>pass <EOL><DEDENT>def visit_suite_statistics(self,stats):<EOL><INDENT>if self.start_suite_statistics(stats)is not False :<EOL><INDENT>for stat in stats :<EOL><INDENT>stat.visit(self)<EOL><DEDENT>self.end_suite_statistics(stats)<EOL><DEDENT> <DEDENT>def start_suite_statistics(self,stats):<EOL><INDENT>pass <EOL><DEDENT>def end_suite_statistics(self,suite_stats):<EOL><INDENT>pass <EOL><DEDENT>def visit_stat(self,stat):<EOL><INDENT>if self.start_stat(stat)is not False :<EOL><INDENT>self.end_stat(stat)<EOL><DEDENT> <DEDENT>def start_stat(self,stat):<EOL><INDENT>pass <EOL><DEDENT>def end_stat(self,stat):<EOL><INDENT>pass <EOL><DEDENT>def visit_errors(self,errors):<EOL><INDENT>self.start_errors(errors)<EOL>for msg in errors :<EOL><INDENT>msg.visit(self)<EOL><DEDENT>self.end_errors(errors)<EOL><DEDENT>def start_errors(self,errors):<EOL><INDENT>pass <EOL><DEDENT>def end_errors(self,errors):<EOL><INDENT>pass <EOL><DEDENT> <DEDENT><EOF><BOF>__author__='fatcloud'<EOL>import cv2 <EOL>import numpy as np <EOL>from cam import OpenCV_Cam <EOL>class MotionDetector(object):<EOL><INDENT>def __init__(self,N=,shape=(,,)):<EOL><INDENT>self._N=N <EOL>self._frame=[None ]*(*N +)<EOL>self._index=<EOL>for i in range(*N +):<EOL><INDENT>self._frame [i ]=np.full(shape,,np.uint8)<EOL><DEDENT> <DEDENT>def three_frames(self):<EOL><INDENT>n=self._N <EOL>f0=self._frame [self._index ]<EOL>f1=self._frame [(self._index +n)%(*n)]<EOL>f2=self._frame [(self._index +*n)%(*n)]<EOL>return [f0,f1,f2 ]<EOL><DEDENT>def diff_img(self):<EOL><INDENT>f0,f1,f2=self.three_frames()<EOL>d1=cv2.absdiff(f1,f0)<EOL>d2=cv2.absdiff(f2,f1)<EOL>self.diff=cv2.bitwise_and(d1,d2)<EOL><DEDENT>def feed_image(self,image):<EOL><INDENT>self._index=(self._index +)%(*self._N)<EOL>self._frame [self._index ]=image <EOL>self.diff_img()<EOL><DEDENT> <DEDENT>winName="cam test"<EOL>cv2.namedWindow(winName,cv2.CV_WINDOW_AUTOSIZE)<EOL>cam=OpenCV_Cam()<EOL>md=MotionDetector(N=,shape=cam.read().shape)<EOL>while True :<EOL><INDENT>md.feed_image(cam.read())<EOL>cv2.imshow(winName,md.diff)<EOL>key=cv2.waitKey()<EOL>if key==or key==:<EOL><INDENT>md.cam.release()<EOL>cv2.destroyWindow(winName)<EOL>break <EOL><DEDENT> <DEDENT>print "Goodbye"<EOF><BOF>import os <EOL>from robot.htmldata import JsonWriter <EOL>class JsResultWriter(object):<EOL><INDENT>_output_attr='window.output'<EOL>_settings_attr='window.settings'<EOL>_suite_key='suite'<EOL>_strings_key='strings'<EOL>def __init__(self,output,<EOL>start_block='<STR_LIT>'+os.linesep,<EOL>end_block='</script>'+os.linesep,<EOL>split_threshold=):<EOL><INDENT>writer=JsonWriter(output,separator=end_block +start_block)<EOL>self._write=writer.write <EOL>self._write_json=writer.write_json <EOL>self._start_block=start_block <EOL>self._end_block=end_block <EOL>self._split_threshold=split_threshold <EOL><DEDENT>def write(self,result,settings):<EOL><INDENT>self._start_output_block()<EOL>self._write_suite(result.suite)<EOL>self._write_strings(result.strings)<EOL>self._write_data(result.data)<EOL>self._write_settings_and_end_output_block(settings)<EOL><DEDENT>def _start_output_block(self):<EOL><INDENT>self._write(self._start_block,postfix='',separator=False)<EOL>self._write('%s= {}'%self._output_attr)<EOL><DEDENT>def _write_suite(self,suite):<EOL><INDENT>writer=SuiteWriter(self._write_json,self._split_threshold)<EOL>writer.write(suite,self._output_var(self._suite_key))<EOL><DEDENT>def _write_strings(self,strings):<EOL><INDENT>variable=self._output_var(self._strings_key)<EOL>self._write('%s= []'%variable)<EOL>prefix='%s= %s.concat('%(variable,variable)<EOL>postfix=');'+os.linesep <EOL>threshold=self._split_threshold <EOL>for index in xrange(,len(strings),threshold):<EOL><INDENT>self._write_json(prefix,strings [index :index +threshold ],postfix)<EOL><DEDENT> <DEDENT>def _write_data(self,data):<EOL><INDENT>for key in data :<EOL><INDENT>self._write_json('%s= '%self._output_var(key),data [key ])<EOL><DEDENT> <DEDENT>def _write_settings_and_end_output_block(self,settings):<EOL><INDENT>self._write_json('%s= '%self._settings_attr,settings,<EOL>separator=False)<EOL>self._write(self._end_block,postfix='',separator=False)<EOL><DEDENT>def _output_var(self,key):<EOL><INDENT>return '%s["%s"]'%(self._output_attr,key)<EOL><DEDENT> <DEDENT>class SuiteWriter(object):<EOL><INDENT>def __init__(self,write_json,split_threshold):<EOL><INDENT>self._write_json=write_json <EOL>self._split_threshold=split_threshold <EOL><DEDENT>def write(self,suite,variable):<EOL><INDENT>mapping={}<EOL>self._write_parts_over_threshold(suite,mapping)<EOL>self._write_json('%s= '%variable,suite,mapping=mapping)<EOL><DEDENT>def _write_parts_over_threshold(self,data,mapping):<EOL><INDENT>if not isinstance(data,tuple):<EOL><INDENT>return <EOL><DEDENT>not_written=+sum(self._write_parts_over_threshold(item,mapping)<EOL>for item in data)<EOL>if not_written >self._split_threshold :<EOL><INDENT>self._write_part(data,mapping)<EOL>return <EOL><DEDENT>return not_written <EOL><DEDENT>def _write_part(self,data,mapping):<EOL><INDENT>part_name='window.sPart%d'%len(mapping)<EOL>self._write_json('%s= '%part_name,data,mapping=mapping)<EOL>mapping [data ]=part_name <EOL><DEDENT> <DEDENT>class SplitLogWriter(object):<EOL><INDENT>def __init__(self,output):<EOL><INDENT>self._writer=JsonWriter(output)<EOL><DEDENT>def write(self,keywords,strings,index,notify):<EOL><INDENT>self._writer.write_json('<STR_LIT>'%index,keywords)<EOL>self._writer.write_json('<STR_LIT>'%index,strings)<EOL>self._writer.write('<STR_LIT>'%notify)<EOL><DEDENT> <DEDENT><EOF><BOF>from os import listdir <EOL>from os.path import isdir <EOL>import importlib <EOL>import json <EOL>import sys <EOL>dirname='<STR_LIT>'<EOL>print '<STR_LIT>'+dirname <EOL>for algorithm in listdir('algorithms'):<EOL><INDENT>if isdir("algorithms/"+algorithm):<EOL><INDENT>m=importlib.import_module("algorithms."+algorithm +".main")<EOL>print 'Algorithm \"'+algorithm +'<STR_LIT>',<EOL>b=m.main(dirname)<EOL>jsonname="graphs/"+algorithm +".json"<EOL>print 'done. Save to',jsonname <EOL>with open(jsonname,'w')as f :<EOL><INDENT>f.write(b.graph)<EOL><DEDENT> <DEDENT> <DEDENT>with open("algorithms.json",'w')as f :<EOL><INDENT>f.write(json.dumps([i for i in listdir('algorithms')if isdir("algorithms/"+i)]))<EOL><DEDENT><EOF><BOF>from py2d.Math import *<EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import video <EOL>from common import anorm2,draw_str <EOL>from time import clock <EOL>lk_params=dict(winSize=(,),<EOL>maxLevel=,<EOL>criteria=(cv2.TERM_CRITERIA_EPS |cv2.TERM_CRITERIA_COUNT,,))<EOL>feature_params=dict(maxCorners=,<EOL>qualityLevel=,<EOL>minDistance=,<EOL>blockSize=)<EOL>class App :<EOL><INDENT>def __init__(self,video_src):<EOL><INDENT>self.track_len=<EOL>self.detect_interval=<EOL>self.tracks=[]<EOL>self.cam=video.create_capture(video_src)<EOL>self.frame_idx=<EOL><DEDENT>def run(self):<EOL><INDENT>while True :<EOL><INDENT>ret,frame=self.cam.read()<EOL>frame_gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)<EOL>vis=frame.copy()<EOL>if len(self.tracks)>:<EOL><INDENT>img0,img1=self.prev_gray,frame_gray <EOL>p0=np.float32([tr [-]for tr in self.tracks ]).reshape(-,,)<EOL>p1,st,err=cv2.calcOpticalFlowPyrLK(img0,img1,p0,None,**lk_params)<EOL>p0r,st,err=cv2.calcOpticalFlowPyrLK(img1,img0,p1,None,**lk_params)<EOL>d=abs(p0 -p0r).reshape(-,).max(-)<EOL>good=d <<EOL>new_tracks=[]<EOL>for tr,(x,y),good_flag in zip(self.tracks,p1.reshape(-,),good):<EOL><INDENT>if not good_flag :<EOL><INDENT>continue <EOL><DEDENT>tr.append((x,y))<EOL>if len(tr)>self.track_len :<EOL><INDENT>del tr []<EOL><DEDENT>new_tracks.append(tr)<EOL>cv2.circle(vis,(x,y),,(,,),-)<EOL><DEDENT>self.tracks=new_tracks <EOL>cv2.polylines(vis,[np.int32(tr)for tr in self.tracks ],False,(,,))<EOL>draw_str(vis,(,),'track count: %d'%len(self.tracks))<EOL><DEDENT>if self.frame_idx %self.detect_interval==:<EOL><INDENT>mask=np.zeros_like(frame_gray)<EOL>mask [:]=<EOL>for x,y in [np.int32(tr [-])for tr in self.tracks ]:<EOL><INDENT>cv2.circle(mask,(x,y),,,-)<EOL><DEDENT>p=cv2.goodFeaturesToTrack(frame_gray,mask=mask,**feature_params)<EOL>if p is not None :<EOL><INDENT>for x,y in np.float32(p).reshape(-,):<EOL><INDENT>self.tracks.append([(x,y)])<EOL><DEDENT> <DEDENT> <DEDENT>self.frame_idx +=<EOL>self.prev_gray=frame_gray <EOL>cv2.imshow('lk_track',vis)<EOL>ch=&cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>def main():<EOL><INDENT>import sys <EOL>try :video_src=sys.argv []<EOL>except :video_src=<EOL>print __doc__ <EOL>App(video_src).run()<EOL>cv2.destroyAllWindows()<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>main()<EOL><DEDENT><EOF><BOF>from zerotest.utils.io_helper import StringIO <EOL>from zerotest.record.formatter import Formatter <EOL>from zerotest.request import Request <EOL>from zerotest.response import Response <EOL>req=Request(scheme="http",method="get",params='<STR_LIT>',host="example.com",path="/test",<EOL>headers={"just":"header"},data="request")<EOL>res=Response(status=,headers={"responsed":"header"},body="response")<EOL>formatter=Formatter()<EOL>def test_formatter():<EOL><INDENT>writable=StringIO()<EOL>formatter.write_record(writable,req,res)<EOL>readable=StringIO(writable.getvalue())<EOL>request,response=formatter.read_record(readable)<EOL>assert req.__dict__==request.__dict__ <EOL>assert res.__dict__==response.__dict__ <EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from.datafilewriter import DataFileWriter <EOF><BOF>import cv2.cv as cv <EOL>import urllib2 <EOL>from sys import argv <EOL>def load_sample(name=None):<EOL><INDENT>if len(argv)>:<EOL><INDENT>img0=cv.LoadImage(argv [],cv.CV_LOAD_IMAGE_COLOR)<EOL><DEDENT>elif name is not None :<EOL><INDENT>try :<EOL><INDENT>img0=cv.LoadImage(name,cv.CV_LOAD_IMAGE_COLOR)<EOL><DEDENT>except IOError :<EOL><INDENT>urlbase='<STR_LIT>'<EOL>file=name.split('/')[-]<EOL>filedata=urllib2.urlopen(urlbase +file).read()<EOL>imagefiledata=cv.CreateMatHeader(,len(filedata),cv.CV_8UC1)<EOL>cv.SetData(imagefiledata,filedata,len(filedata))<EOL>img0=cv.DecodeImage(imagefiledata,cv.CV_LOAD_IMAGE_COLOR)<EOL><DEDENT> <DEDENT>return img0 <EOL><DEDENT><EOF><BOF>from urlparse import urlparse <EOL>from markdown import markdown <EOL>from pyembed.markdown import PyEmbedMarkdown <EOL>import bleach <EOL>from.extensions import LazyYoutubeExtension <EOL>from config import Config <EOL>def externallify_url(attrs,new=False):<EOL><INDENT> '<STR_LIT>'<EOL>p=urlparse(attrs ['href'])<EOL>if p.netloc.lower()not in Config.DOMAINS :<EOL><INDENT>attrs ['target']='_blank'<EOL>attrs ['class']='link-external'<EOL><DEDENT>else :<EOL><INDENT>attrs.pop('target',None)<EOL><DEDENT>return attrs <EOL><DEDENT>def dont_linkify_urls(attrs,new=False):<EOL><INDENT> '<STR_LIT>'<EOL>file_exts=('.py','.md','.sh')<EOL>txt=attrs ['_text']<EOL>if txt.startswith(('http://','https://')):<EOL><INDENT>return attrs <EOL><DEDENT>if txt.endswith(file_exts):<EOL><INDENT>return None <EOL><DEDENT>return attrs <EOL><DEDENT>def create_post_from_md(body):<EOL><INDENT> '<STR_LIT>'<EOL>no_link_text=markdown(<EOL>body,<EOL>output_format='html5',<EOL>extensions=[<EOL>'<STR_LIT>',<EOL>PyEmbedMarkdown(),<EOL>LazyYoutubeExtension()<EOL>])<EOL>return bleach.linkify(<EOL>no_link_text,<EOL>callbacks=[externallify_url,dont_linkify_urls ],<EOL>skip_pre=True )<EOL><DEDENT><EOF><BOF>import cv2 <EOL>import numpy as np <EOL>from cam import MyCam <EOL>from mix_image import mix_image <EOL>def buildpyr(img_in):<EOL><INDENT>h=img_in.shape []<EOL>w=img_in.shape []<EOL>d=img_in.shape []<EOL>img_out=np.full((h +h /,w,d),,np.uint8)<EOL>img_pyr=img_in <EOL>x,y=,<EOL>dx,dy=w,h <EOL>for i in range():<EOL><INDENT>img_out=mix_image(img_out,img_pyr,(x,y))<EOL>if i %==:<EOL><INDENT>y=y +dy <EOL><DEDENT>else :<EOL><INDENT>x=x +dx <EOL><DEDENT>dx,dy=dx /,dy /<EOL>img_pyr=cv2.pyrDown(img_pyr)<EOL><DEDENT>return img_out <EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>cam=MyCam()<EOL>cam.cam_loop(buildpyr)<EOL><DEDENT><EOF><BOF>import urllib2 <EOL>import sys <EOL>import cv2.cv as cv <EOL>import numpy <EOL>def srgb2lin(x):<EOL><INDENT>a=<EOL>return numpy.where(x <=,<EOL>x *(/),<EOL>numpy.power((x +a)*(/(+a)),))<EOL><DEDENT>def lin2srgb(x):<EOL><INDENT>a=<EOL>return numpy.where(x <=,<EOL>x *,(+a)*numpy.power(x,/)-a)<EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>if len(sys.argv)>:<EOL><INDENT>img0=cv.LoadImageM(sys.argv [],cv.CV_LOAD_IMAGE_COLOR)<EOL><DEDENT>else :<EOL><INDENT>url='<STR_LIT>'<EOL>filedata=urllib2.urlopen(url).read()<EOL>imagefiledata=cv.CreateMatHeader(,len(filedata),cv.CV_8UC1)<EOL>cv.SetData(imagefiledata,filedata,len(filedata))<EOL>img0=cv.DecodeImageM(imagefiledata,cv.CV_LOAD_IMAGE_COLOR)<EOL><DEDENT>cv.NamedWindow("original",)<EOL>cv.ShowImage("original",img0)<EOL>n=numpy.asarray(img0)/<EOL>cv.NamedWindow("negative")<EOL>cv.ShowImage("negative",cv.fromarray(-n))<EOL>cv.NamedWindow("linear")<EOL>cv.ShowImage("linear",cv.fromarray(srgb2lin(n)))<EOL>cv.NamedWindow("subwindow")<EOL>cv.ShowImage("subwindow",cv.fromarray(n [:,:]))<EOL>cv.NamedWindow("monochrome")<EOL>ln=srgb2lin(n)<EOL>red=ln [:,:,]<EOL>grn=ln [:,:,]<EOL>blu=ln [:,:,]<EOL>linear_mono=*red +*grn +*blu <EOL>cv.ShowImage("monochrome",cv.fromarray(lin2srgb(linear_mono)))<EOL>cv.NamedWindow("gaussian")<EOL>cv.Smooth(n,n,cv.CV_GAUSSIAN,,)<EOL>cv.ShowImage("gaussian",cv.fromarray(n))<EOL>cv.WaitKey()<EOL>cv.DestroyAllWindows()<EOL><DEDENT><EOF><BOF>import ctypes <EOL>import thread <EOL>import time <EOL>from threading import Timer <EOL>from robot.errors import TimeoutError <EOL>class Timeout(object):<EOL><INDENT>def __init__(self,timeout,timeout_error):<EOL><INDENT>self._runner_thread_id=thread.get_ident()<EOL>self._timeout_error=self._create_timeout_error_class(timeout_error)<EOL>self._timer=Timer(timeout,self._raise_timeout_error)<EOL>self._timeout_occurred=False <EOL><DEDENT>def _create_timeout_error_class(self,timeout_error):<EOL><INDENT>return type(TimeoutError.__name__,(TimeoutError,),<EOL>{'__unicode__':lambda self :timeout_error })<EOL><DEDENT>def execute(self,runnable):<EOL><INDENT>self._start_timer()<EOL>try :<EOL><INDENT>return runnable()<EOL><DEDENT>finally :<EOL><INDENT>self._stop_timer()<EOL><DEDENT> <DEDENT>def _start_timer(self):<EOL><INDENT>self._timer.start()<EOL><DEDENT>def _stop_timer(self):<EOL><INDENT>self._timer.cancel()<EOL>if self._timeout_occurred :<EOL><INDENT>self._cancel_exception()<EOL>raise self._timeout_error()<EOL><DEDENT> <DEDENT>def _raise_timeout_error(self):<EOL><INDENT>self._timeout_occurred=True <EOL>return_code=self._try_to_raise_timeout_error_in_runner_thread()<EOL>while return_code >:<EOL><INDENT>self._cancel_exception()<EOL>time.sleep()<EOL>return_code=self._try_to_raise_timeout_error_in_runner_thread()<EOL><DEDENT> <DEDENT>def _try_to_raise_timeout_error_in_runner_thread(self):<EOL><INDENT>return ctypes.pythonapi.PyThreadState_SetAsyncExc(<EOL>self._runner_thread_id,<EOL>ctypes.py_object(self._timeout_error))<EOL><DEDENT>def _cancel_exception(self):<EOL><INDENT>ctypes.pythonapi.PyThreadState_SetAsyncExc(self._runner_thread_id,None)<EOL><DEDENT> <DEDENT><EOF><BOF>import inspect <EOL>from robot import utils <EOL>class _RunKeywordRegister :<EOL><INDENT>def __init__(self):<EOL><INDENT>self._libs={}<EOL><DEDENT>def register_run_keyword(self,libname,keyword,args_to_process=None):<EOL><INDENT>if args_to_process is None :<EOL><INDENT>args_to_process=self._get_args_from_method(keyword)<EOL>keyword=keyword.__name__ <EOL><DEDENT>if libname not in self._libs :<EOL><INDENT>self._libs [libname ]=utils.NormalizedDict(ignore=['_'])<EOL><DEDENT>self._libs [libname ][keyword ]=int(args_to_process)<EOL><DEDENT>def get_args_to_process(self,libname,kwname):<EOL><INDENT>if libname in self._libs and kwname in self._libs [libname ]:<EOL><INDENT>return self._libs [libname ][kwname ]<EOL><DEDENT>return -<EOL><DEDENT>def is_run_keyword(self,libname,kwname):<EOL><INDENT>return self.get_args_to_process(libname,kwname)>=<EOL><DEDENT>def _get_args_from_method(self,method):<EOL><INDENT>if inspect.ismethod(method):<EOL><INDENT>return method.im_func.func_code.co_argcount -<EOL><DEDENT>elif inspect.isfunction(method):<EOL><INDENT>return method.func_code.co_argcount <EOL><DEDENT>raise ValueError('<STR_LIT>')<EOL><DEDENT> <DEDENT>RUN_KW_REGISTER=_RunKeywordRegister()<EOF><BOF>from robot.utils import normalize_tags,setter,Matcher <EOL>class Tags(object):<EOL><INDENT>def __init__(self,tags=None):<EOL><INDENT>self._tags=tags <EOL><DEDENT>@setter <EOL>def _tags(self,tags):<EOL><INDENT>if isinstance(tags,basestring):<EOL><INDENT>tags=[tags ]<EOL><DEDENT>return normalize_tags(tags or [])<EOL><DEDENT>def add(self,tags):<EOL><INDENT>self._tags=list(self)+list(Tags(tags))<EOL><DEDENT>def remove(self,tags):<EOL><INDENT>tags=TagPatterns(tags)<EOL>self._tags=[t for t in self if not tags.match(t)]<EOL><DEDENT>def match(self,tags):<EOL><INDENT>return TagPatterns(tags).match(self)<EOL><DEDENT>def __contains__(self,tags):<EOL><INDENT>return self.match(tags)<EOL><DEDENT>def __len__(self):<EOL><INDENT>return len(self._tags)<EOL><DEDENT>def __iter__(self):<EOL><INDENT>return iter(self._tags)<EOL><DEDENT>def __unicode__(self):<EOL><INDENT>return u'[%s]'%', '.join(self)<EOL><DEDENT>def __str__(self):<EOL><INDENT>return unicode(self).encode('UTF-8')<EOL><DEDENT> <DEDENT>class TagPatterns(object):<EOL><INDENT>def __init__(self,patterns):<EOL><INDENT>self._patterns=[TagPattern(p)for p in Tags(patterns)]<EOL><DEDENT>def match(self,tags):<EOL><INDENT>tags=tags if isinstance(tags,Tags)else Tags(tags)<EOL>return any(p.match(tags)for p in self._patterns)<EOL><DEDENT>def __contains__(self,tag):<EOL><INDENT>return self.match(tag)<EOL><DEDENT>def __len__(self):<EOL><INDENT>return len(self._patterns)<EOL><DEDENT>def __iter__(self):<EOL><INDENT>return iter(self._patterns)<EOL><DEDENT>def __getitem__(self,index):<EOL><INDENT>return self._patterns [index ]<EOL><DEDENT> <DEDENT>def TagPattern(pattern):<EOL><INDENT>pattern=pattern.replace('&','AND')<EOL>if 'NOT'in pattern :<EOL><INDENT>return _NotTagPattern(*pattern.split('NOT'))<EOL><DEDENT>if 'AND'in pattern :<EOL><INDENT>return _AndTagPattern(pattern.split('AND'))<EOL><DEDENT>return _SingleTagPattern(pattern)<EOL><DEDENT>class _SingleTagPattern(object):<EOL><INDENT>def __init__(self,pattern):<EOL><INDENT>self._matcher=Matcher(pattern,ignore=['_'])<EOL><DEDENT>def match(self,tags):<EOL><INDENT>return any(self._matcher.match(tag)for tag in tags)<EOL><DEDENT>def __unicode__(self):<EOL><INDENT>return self._matcher.pattern <EOL><DEDENT> <DEDENT>class _AndTagPattern(object):<EOL><INDENT>def __init__(self,patterns):<EOL><INDENT>self._patterns=[TagPattern(p)for p in patterns ]<EOL><DEDENT>def match(self,tags):<EOL><INDENT>return all(p.match(tags)for p in self._patterns)<EOL><DEDENT> <DEDENT>class _NotTagPattern(object):<EOL><INDENT>def __init__(self,must_match,*must_not_match):<EOL><INDENT>self._must=TagPattern(must_match)<EOL>self._must_not=[TagPattern(m)for m in must_not_match ]<EOL><DEDENT>def match(self,tags):<EOL><INDENT>return self._must.match(tags)and not any(p.match(tags)for p in self._must_not)<EOL><DEDENT> <DEDENT><EOF><BOF>from.core import *<EOL>__version__='0.3.1'<EOF><BOF>import sys <EOL>if sys.platform.startswith('java'):<EOL><INDENT>from java.lang import Object,Class <EOL>def unic(item,*args):<EOL><INDENT>if isinstance(item,Object)and not isinstance(item,Class):<EOL><INDENT>try :<EOL><INDENT>item=item.toString()<EOL><DEDENT>except :<EOL><INDENT>return _unrepresentable_object(item)<EOL><DEDENT> <DEDENT>return _unic(item,*args)<EOL><DEDENT> <DEDENT>elif sys.platform=='cli':<EOL><INDENT>def unic(item,*args):<EOL><INDENT>return _unic(item,*args)<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>from unicodedata import normalize <EOL>def unic(item,*args):<EOL><INDENT>return normalize('NFC',_unic(item,*args))<EOL><DEDENT> <DEDENT>def _unic(item,*args):<EOL><INDENT>try :<EOL><INDENT>return unicode(item,*args)<EOL><DEDENT>except UnicodeError :<EOL><INDENT>try :<EOL><INDENT>ascii_text=str(item).encode('string_escape')<EOL><DEDENT>except :<EOL><INDENT>return _unrepresentable_object(item)<EOL><DEDENT>else :<EOL><INDENT>return unicode(ascii_text)<EOL><DEDENT> <DEDENT>except :<EOL><INDENT>return _unrepresentable_object(item)<EOL><DEDENT> <DEDENT>def safe_repr(item):<EOL><INDENT>try :<EOL><INDENT>return unic(repr(item))<EOL><DEDENT>except UnicodeError :<EOL><INDENT>return repr(unic(item))<EOL><DEDENT>except :<EOL><INDENT>return _unrepresentable_object(item)<EOL><DEDENT> <DEDENT>if sys.platform=='cli':<EOL><INDENT>_safe_repr=safe_repr <EOL>def safe_repr(item):<EOL><INDENT>if isinstance(item,list):<EOL><INDENT>return '[%s]'%', '.join(safe_repr(i)for i in item)<EOL><DEDENT>ret=_safe_repr(item)<EOL>if isinstance(item,unicode)and not ret.startswith('u'):<EOL><INDENT>ret='u'+ret <EOL><DEDENT>return ret <EOL><DEDENT> <DEDENT>_unrepresentable_msg='<STR_LIT>'<EOL>def _unrepresentable_object(item):<EOL><INDENT>from robot.utils.error import get_error_message <EOL>return _unrepresentable_msg %(item.__class__.__name__,get_error_message())<EOL><DEDENT><EOF><BOF>from __future__ import with_statement <EOL>import os.path <EOL>from robot.errors import DataError <EOL>from robot.utils import ET,ETSource <EOL>from.model import LibraryDoc,KeywordDoc <EOL>class SpecDocBuilder(object):<EOL><INDENT>def build(self,path):<EOL><INDENT>spec=self._parse_spec(path)<EOL>libdoc=LibraryDoc(name=spec.get('name'),<EOL>type=spec.get('type'),<EOL>version=spec.find('version').text or '',<EOL>doc=spec.find('doc').text or '',<EOL>scope=spec.find('scope').text or '',<EOL>named_args=self._get_named_args(spec),<EOL>doc_format=spec.get('format','ROBOT'))<EOL>libdoc.inits=self._create_keywords(spec,'init')<EOL>libdoc.keywords=self._create_keywords(spec,'kw')<EOL>return libdoc <EOL><DEDENT>def _parse_spec(self,path):<EOL><INDENT>if not os.path.isfile(path):<EOL><INDENT>raise DataError('<STR_LIT>'%path)<EOL><DEDENT>with ETSource(path)as source :<EOL><INDENT>root=ET.parse(source).getroot()<EOL><DEDENT>if root.tag !='keywordspec':<EOL><INDENT>raise DataError('<STR_LIT>'%path)<EOL><DEDENT>return root <EOL><DEDENT>def _get_named_args(self,spec):<EOL><INDENT>elem=spec.find('namedargs')<EOL>if elem is None :<EOL><INDENT>return False <EOL><DEDENT>return elem.text=='yes'<EOL><DEDENT>def _create_keywords(self,spec,path):<EOL><INDENT>return [self._create_keyword(elem)for elem in spec.findall(path)]<EOL><DEDENT>def _create_keyword(self,elem):<EOL><INDENT>return KeywordDoc(name=elem.get('name',''),<EOL>args=[a.text for a in elem.findall('arguments/arg')],<EOL>doc=elem.find('doc').text or '')<EOL><DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>from common import Sketcher <EOL>class App :<EOL><INDENT>def __init__(self,fn):<EOL><INDENT>self.img=cv2.imread(fn)<EOL>h,w=self.img.shape [:]<EOL>self.markers=np.zeros((h,w),np.int32)<EOL>self.markers_vis=self.img.copy()<EOL>self.cur_marker=<EOL>self.colors=np.int32(list(np.ndindex(,,)))*<EOL>self.auto_update=True <EOL>self.sketch=Sketcher('img',[self.markers_vis,self.markers ],self.get_colors)<EOL><DEDENT>def get_colors(self):<EOL><INDENT>return map(int,self.colors [self.cur_marker ]),self.cur_marker <EOL><DEDENT>def watershed(self):<EOL><INDENT>m=self.markers.copy()<EOL>cv2.watershed(self.img,m)<EOL>overlay=self.colors [np.maximum(m,)]<EOL>vis=cv2.addWeighted(self.img,,overlay,,,dtype=cv2.CV_8UC3)<EOL>cv2.imshow('watershed',vis)<EOL><DEDENT>def run(self):<EOL><INDENT>while True :<EOL><INDENT>ch=&cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT>if ch >=ord('1')and ch <=ord('7'):<EOL><INDENT>self.cur_marker=ch -ord('0')<EOL>print 'marker: ',self.cur_marker <EOL><DEDENT>if ch==ord(' ')or(self.sketch.dirty and self.auto_update):<EOL><INDENT>self.watershed()<EOL>self.sketch.dirty=False <EOL><DEDENT>if ch in [ord('a'),ord('A')]:<EOL><INDENT>self.auto_update=not self.auto_update <EOL>print 'auto_update if',['off','on'][self.auto_update ]<EOL><DEDENT>if ch in [ord('r'),ord('R')]:<EOL><INDENT>self.markers [:]=<EOL>self.markers_vis [:]=self.img <EOL>self.sketch.show()<EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>import sys <EOL>try :fn=sys.argv []<EOL>except :fn='<STR_LIT>'<EOL>print __doc__ <EOL>App(fn).run()<EOL><DEDENT><EOF><BOF>import socket <EOL>def pickup_port():<EOL><INDENT>s=socket.socket()<EOL>s.bind(('127.0.0.1',))<EOL>port=s.getsockname()[-]<EOL>s.close()<EOL>return port <EOL><DEDENT><EOF><BOF>from django.test import TestCase <EOL>from buildservice.models import Build <EOL>from buildservice.templatetags import utils <EOL>class UtilsTemplateTagsTestCase(TestCase):<EOL><INDENT>def setUp(self):<EOL><INDENT>self.build=Build()<EOL><DEDENT>def test_build_icon_success(self):<EOL><INDENT>self.build.status='success'<EOL>self.assertEqual(utils.build_icon(self.build),'done')<EOL><DEDENT>def test_build_icon_pending(self):<EOL><INDENT>self.assertEqual(utils.build_icon(self.build),'alarm')<EOL><DEDENT>def test_build_icon_errored(self):<EOL><INDENT>self.build.status='errored'<EOL>self.assertEqual(utils.build_icon(self.build),'clear')<EOL><DEDENT>def test_build_icon_failure(self):<EOL><INDENT>self.build.status='failure'<EOL>self.assertEqual(utils.build_icon(self.build),'clear')<EOL><DEDENT>def test_build_icon_color_success(self):<EOL><INDENT>self.build.status='success'<EOL>self.assertEqual(utils.build_icon_color(self.build),'success')<EOL><DEDENT>def test_build_icon_color_pending(self):<EOL><INDENT>self.assertEqual(utils.build_icon_color(self.build),'warning')<EOL><DEDENT>def test_build_icon_color_errored(self):<EOL><INDENT>self.build.status='errored'<EOL>self.assertEqual(utils.build_icon_color(self.build),'danger')<EOL><DEDENT>def test_build_icon_color_failure(self):<EOL><INDENT>self.build.status='failure'<EOL>self.assertEqual(utils.build_icon_color(self.build),'danger')<EOL><DEDENT> <DEDENT><EOF><BOF>import unittest <EOL>from yapper import db,create_app <EOL>from yapper.blueprints.blog.models import Post,Tag,Category <EOL>from yapper.blueprints.user.models import User <EOL>class TagAddTestCase(unittest.TestCase):<EOL><INDENT>def setUp(self):<EOL><INDENT>self.app=create_app('test')<EOL>self.app_context=self.app.app_context()<EOL>self.app_context.push()<EOL>db.create_all()<EOL><DEDENT>def tearDown(self):<EOL><INDENT>db.session.remove()<EOL>db.drop_all()<EOL>self.app_context.pop()<EOL><DEDENT>def test_tag_creation(self):<EOL><INDENT>tag=Tag(name='node.js')<EOL>self.assertTrue(tag.id is None)<EOL>db.session.add(tag)<EOL>db.session.commit()<EOL>self.assertTrue(tag.id >=)<EOL><DEDENT>def test_category_creation(self):<EOL><INDENT>cat=Category(name='node.js')<EOL>self.assertTrue(cat.id is None)<EOL>db.session.add(cat)<EOL>db.session.commit()<EOL>self.assertTrue(cat.id >=)<EOL><DEDENT>def test_post_creation(self):<EOL><INDENT>u=User(<EOL>email=self.app.config ['FLASKY_ADMIN'],<EOL>password='testpass',<EOL>name='Admin')<EOL>tag=Tag(name='node.js')<EOL>cat=Category(name='node.js')<EOL>db.session.add(u)<EOL>db.session.add(tag)<EOL>db.session.add(cat)<EOL>db.session.commit()<EOL>post=Post(<EOL>author=u,<EOL>title='Test Post',<EOL>content='# Hello',<EOL>tags=[tag ],<EOL>categories=[cat ])<EOL>self.assertTrue(post.id is None)<EOL>db.session.add(post)<EOL>db.session.commit()<EOL>self.assertTrue(post.id >)<EOL>self.assertTrue(tag.posts.first().id==post.id)<EOL>self.assertTrue(cat.posts.first().id==post.id)<EOL>self.assertTrue(post.tags [].id==tag.id)<EOL>self.assertTrue(post.categories [].id==cat.id)<EOL><DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import sys <EOL>import threading <EOL>from robot.output import LOGGER,Message <EOL>from robot.running.timeouts import timeoutthread <EOL>LOGGING_THREADS=('MainThread',timeoutthread.TIMEOUT_THREAD_NAME)<EOL>def write(msg,level,html=False):<EOL><INDENT> '<STR_LIT>'<EOL>if threading.currentThread().getName()in LOGGING_THREADS :<EOL><INDENT>LOGGER.log_message(Message(msg,level,html))<EOL><DEDENT> <DEDENT>def trace(msg,html=False):<EOL><INDENT> '<STR_LIT>'<EOL>write(msg,'TRACE',html)<EOL><DEDENT>def debug(msg,html=False):<EOL><INDENT> '<STR_LIT>'<EOL>write(msg,'DEBUG',html)<EOL><DEDENT>def info(msg,html=False,also_console=False):<EOL><INDENT> '<STR_LIT>'<EOL>write(msg,'INFO',html)<EOL>if also_console :<EOL><INDENT>console(msg)<EOL><DEDENT> <DEDENT>def warn(msg,html=False):<EOL><INDENT> '<STR_LIT>'<EOL>write(msg,'WARN',html)<EOL><DEDENT>def console(msg,newline=True):<EOL><INDENT> '<STR_LIT>'<EOL>if newline :<EOL><INDENT>msg +='\n'<EOL><DEDENT>sys.__stdout__.write(msg)<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import sys <EOL>import urllib2 <EOL>import random <EOL>import cv2.cv as cv <EOL>def contour_iterator(contour):<EOL><INDENT>while contour :<EOL><INDENT>yield contour <EOL>contour=contour.h_next()<EOL><DEDENT> <DEDENT>class FitEllipse :<EOL><INDENT>def __init__(self,source_image,slider_pos):<EOL><INDENT>self.source_image=source_image <EOL>cv.CreateTrackbar("Threshold","Result",slider_pos,,self.process_image)<EOL>self.process_image(slider_pos)<EOL><DEDENT>def process_image(self,slider_pos):<EOL><INDENT> '<STR_LIT>'<EOL>stor=cv.CreateMemStorage()<EOL>image02=cv.CloneImage(self.source_image)<EOL>cv.Zero(image02)<EOL>image04=cv.CreateImage(cv.GetSize(self.source_image),cv.IPL_DEPTH_8U,)<EOL>cv.Zero(image04)<EOL>cv.Threshold(self.source_image,image02,slider_pos,,cv.CV_THRESH_BINARY)<EOL>cont=cv.FindContours(image02,<EOL>stor,<EOL>cv.CV_RETR_LIST,<EOL>cv.CV_CHAIN_APPROX_NONE,(,))<EOL>for c in contour_iterator(cont):<EOL><INDENT>if len(c)>=:<EOL><INDENT>PointArray2D32f=cv.CreateMat(,len(c),cv.CV_32FC2)<EOL>for(i,(x,y))in enumerate(c):<EOL><INDENT>PointArray2D32f [,i ]=(x,y)<EOL><DEDENT>gray=cv.CV_RGB(,,)<EOL>cv.DrawContours(image04,c,gray,gray,,,,(,))<EOL>(center,size,angle)=cv.FitEllipse2(PointArray2D32f)<EOL>center=(cv.Round(center []),cv.Round(center []))<EOL>size=(cv.Round(size []*),cv.Round(size []*))<EOL>color=cv.CV_RGB(random.randrange(),random.randrange(),random.randrange())<EOL>cv.Ellipse(image04,center,size,<EOL>angle,,,<EOL>color,,cv.CV_AA,)<EOL><DEDENT> <DEDENT>cv.ShowImage("Result",image04)<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>if len(sys.argv)>:<EOL><INDENT>source_image=cv.LoadImage(sys.argv [],cv.CV_LOAD_IMAGE_GRAYSCALE)<EOL><DEDENT>else :<EOL><INDENT>url='<STR_LIT>'<EOL>filedata=urllib2.urlopen(url).read()<EOL>imagefiledata=cv.CreateMatHeader(,len(filedata),cv.CV_8UC1)<EOL>cv.SetData(imagefiledata,filedata,len(filedata))<EOL>source_image=cv.DecodeImage(imagefiledata,cv.CV_LOAD_IMAGE_GRAYSCALE)<EOL><DEDENT>cv.NamedWindow("Source",)<EOL>cv.NamedWindow("Result",)<EOL>cv.ShowImage("Source",source_image)<EOL>fe=FitEllipse(source_image,)<EOL>print '<STR_LIT>'<EOL>cv.WaitKey()<EOL>cv.DestroyWindow("Source")<EOL>cv.DestroyWindow("Result")<EOL><DEDENT><EOF><BOF>import cv2 <EOL>from webcam_gui import webcam_gui <EOL>def imgproc(frame):<EOL><INDENT>gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)<EOL>cv2.imshow('gray',gray)<EOL>thresh1,thresh=cv2.threshold(gray,,,cv2.THRESH_BINARY)<EOL>cv2.imshow('thresh',thresh)<EOL>contours,hry=cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)<EOL>cpframe=frame.copy()<EOL>cv2.drawContours(cpframe,contours,-,(,,),)<EOL>cv2.imshow('cpframe',cpframe)<EOL>contours=[ctr for ctr in contours if cv2.contourArea(ctr)>]<EOL>contours=[cv2.approxPolyDP(ctr,,True)for ctr in contours ]<EOL>contours=[ctr for ctr in contours if cv2.isContourConvex(ctr)]<EOL>cv2.drawContours(frame,contours,-,(,,),)<EOL>return frame <EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>webcam_gui(imgproc)<DEDENT><EOF><BOF>from.controllers import user <EOF><BOF>import csv <EOL>from StringIO import StringIO <EOL>from pyspark import SparkConf,SparkContext <EOL>from pyspark.sql import SQLContext,Row <EOL>def split(line):<EOL><INDENT> '<STR_LIT>'<EOL>reader=csv.reader(StringIO(line))<EOL>return reader.next()<EOL><DEDENT>def main(sc,sqlc):<EOL><INDENT>rows=sc.textFile('<STR_LIT>').map(split)<EOL>customers=rows.map(lambda c :Row(id=int(c []),name=c [],state=c []))<EOL>schema=sqlc.inferSchema(customers)<EOL>schema.registerTempTable("customers")<EOL>maryland=sqlc.sql('<STR_LIT>')<EOL>print maryland.count()<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>conf=SparkConf().setAppName("Query Customers")<EOL>sc=SparkContext(conf=conf)<EOL>sqlc=SQLContext(sc)<EOL>main(sc,sqlc)<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import os <EOL>import itertools as it <EOL>from contextlib import contextmanager <EOL>image_extensions=['.bmp','.jpg','.jpeg','.png','.tif','.tiff','.pbm','.pgm','.ppm']<EOL>class Bunch(object):<EOL><INDENT>def __init__(self,**kw):<EOL><INDENT>self.__dict__.update(kw)<EOL><DEDENT>def __str__(self):<EOL><INDENT>return str(self.__dict__)<EOL><DEDENT> <DEDENT>def splitfn(fn):<EOL><INDENT>path,fn=os.path.split(fn)<EOL>name,ext=os.path.splitext(fn)<EOL>return path,name,ext <EOL><DEDENT>def anorm2(a):<EOL><INDENT>return(a *a).sum(-)<EOL><DEDENT>def anorm(a):<EOL><INDENT>return np.sqrt(anorm2(a))<EOL><DEDENT>def homotrans(H,x,y):<EOL><INDENT>xs=H [,]*x +H [,]*y +H [,]<EOL>ys=H [,]*x +H [,]*y +H [,]<EOL>s=H [,]*x +H [,]*y +H [,]<EOL>return xs /s,ys /s <EOL><DEDENT>def to_rect(a):<EOL><INDENT>a=np.ravel(a)<EOL>if len(a)==:<EOL><INDENT>a=(,,a [],a [])<EOL><DEDENT>return np.array(a,np.float64).reshape(,)<EOL><DEDENT>def rect2rect_mtx(src,dst):<EOL><INDENT>src,dst=to_rect(src),to_rect(dst)<EOL>cx,cy=(dst []-dst [])/(src []-src [])<EOL>tx,ty=dst []-src []*(cx,cy)<EOL>M=np.float64([[cx,,tx ],<EOL>[,cy,ty ],<EOL>[,,]])<EOL>return M <EOL><DEDENT>def lookat(eye,target,up=(,,)):<EOL><INDENT>fwd=np.asarray(target,np.float64)-eye <EOL>fwd /=anorm(fwd)<EOL>right=np.cross(fwd,up)<EOL>right /=anorm(right)<EOL>down=np.cross(fwd,right)<EOL>R=np.float64([right,down,fwd ])<EOL>tvec=-np.dot(R,eye)<EOL>return R,tvec <EOL><DEDENT>def mtx2rvec(R):<EOL><INDENT>w,u,vt=cv2.SVDecomp(R -np.eye())<EOL>p=vt []+u [:,]*w []<EOL>c=np.dot(vt [],p)<EOL>s=np.dot(vt [],p)<EOL>axis=np.cross(vt [],vt [])<EOL>return axis *np.arctan2(s,c)<EOL><DEDENT>def draw_str(dst,(x,y),s):<EOL><INDENT>cv2.putText(dst,s,(x +,y +),cv2.FONT_HERSHEY_PLAIN,,(,,),thickness=,lineType=cv2.CV_AA)<EOL>cv2.putText(dst,s,(x,y),cv2.FONT_HERSHEY_PLAIN,,(,,),lineType=cv2.CV_AA)<EOL><DEDENT>class Sketcher :<EOL><INDENT>def __init__(self,windowname,dests,colors_func):<EOL><INDENT>self.prev_pt=None <EOL>self.windowname=windowname <EOL>self.dests=dests <EOL>self.colors_func=colors_func <EOL>self.dirty=False <EOL>self.show()<EOL>cv2.setMouseCallback(self.windowname,self.on_mouse)<EOL><DEDENT>def show(self):<EOL><INDENT>cv2.imshow(self.windowname,self.dests [])<EOL><DEDENT>def on_mouse(self,event,x,y,flags,param):<EOL><INDENT>pt=(x,y)<EOL>if event==cv2.EVENT_LBUTTONDOWN :<EOL><INDENT>self.prev_pt=pt <EOL><DEDENT>elif event==cv2.EVENT_LBUTTONUP :<EOL><INDENT>self.prev_pt=None <EOL><DEDENT>if self.prev_pt and flags &cv2.EVENT_FLAG_LBUTTON :<EOL><INDENT>for dst,color in zip(self.dests,self.colors_func()):<EOL><INDENT>cv2.line(dst,self.prev_pt,pt,color,)<EOL><DEDENT>self.dirty=True <EOL>self.prev_pt=pt <EOL>self.show()<EOL><DEDENT> <DEDENT> <DEDENT>_jet_data={'red':((,,),(,,),(,,),(,,),(,,)),<EOL>'green':((,,),(,,),(,,),(,,),(,,),(,,)),<EOL>'blue':((,,),(,,),(,,),(,,),(,,))}<EOL>cmap_data={'jet':_jet_data }<EOL>def make_cmap(name,n=):<EOL><INDENT>data=cmap_data [name ]<EOL>xs=np.linspace(,,n)<EOL>channels=[]<EOL>eps=<EOL>for ch_name in ['blue','green','red']:<EOL><INDENT>ch_data=data [ch_name ]<EOL>xp,yp=[],[]<EOL>for x,y1,y2 in ch_data :<EOL><INDENT>xp +=[x,x +eps ]<EOL>yp +=[y1,y2 ]<EOL><DEDENT>ch=np.interp(xs,xp,yp)<EOL>channels.append(ch)<EOL><DEDENT>return np.uint8(np.array(channels).T *)<EOL><DEDENT>def nothing(*arg,**kw):<EOL><INDENT>pass <EOL><DEDENT>def clock():<EOL><INDENT>return cv2.getTickCount()/cv2.getTickFrequency()<EOL><DEDENT>@contextmanager <EOL>def Timer(msg):<EOL><INDENT>print msg,'...',<EOL>start=clock()<EOL>try :<EOL><INDENT>yield <EOL><DEDENT>finally :<EOL><INDENT>print "%.2f ms"%((clock()-start)*)<EOL><DEDENT> <DEDENT>class StatValue :<EOL><INDENT>def __init__(self,smooth_coef=):<EOL><INDENT>self.value=None <EOL>self.smooth_coef=smooth_coef <EOL><DEDENT>def update(self,v):<EOL><INDENT>if self.value is None :<EOL><INDENT>self.value=v <EOL><DEDENT>else :<EOL><INDENT>c=self.smooth_coef <EOL>self.value=c *self.value +(-c)*v <EOL><DEDENT> <DEDENT> <DEDENT>class RectSelector :<EOL><INDENT>def __init__(self,win,callback):<EOL><INDENT>self.win=win <EOL>self.callback=callback <EOL>cv2.setMouseCallback(win,self.onmouse)<EOL>self.drag_start=None <EOL>self.drag_rect=None <EOL><DEDENT>def onmouse(self,event,x,y,flags,param):<EOL><INDENT>x,y=np.int16([x,y ])<EOL>if event==cv2.EVENT_LBUTTONDOWN :<EOL><INDENT>self.drag_start=(x,y)<EOL><DEDENT>if self.drag_start :<EOL><INDENT>if flags &cv2.EVENT_FLAG_LBUTTON :<EOL><INDENT>xo,yo=self.drag_start <EOL>x0,y0=np.minimum([xo,yo ],[x,y ])<EOL>x1,y1=np.maximum([xo,yo ],[x,y ])<EOL>self.drag_rect=None <EOL>if x1 -x0 >and y1 -y0 >:<EOL><INDENT>self.drag_rect=(x0,y0,x1,y1)<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>rect=self.drag_rect <EOL>self.drag_start=None <EOL>self.drag_rect=None <EOL>if rect :<EOL><INDENT>self.callback(rect)<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>def draw(self,vis):<EOL><INDENT>if not self.drag_rect :<EOL><INDENT>return False <EOL><DEDENT>x0,y0,x1,y1=self.drag_rect <EOL>cv2.rectangle(vis,(x0,y0),(x1,y1),(,,),)<EOL>return True <EOL><DEDENT>@property <EOL>def dragging(self):<EOL><INDENT>return self.drag_rect is not None <EOL><DEDENT> <DEDENT>def grouper(n,iterable,fillvalue=None):<EOL><INDENT> '<STR_LIT>'<EOL>args=[iter(iterable)]*n <EOL>return it.izip_longest(fillvalue=fillvalue,*args)<EOL><DEDENT>def mosaic(w,imgs):<EOL><INDENT> '<STR_LIT>'<EOL>imgs=iter(imgs)<EOL>img0=imgs.next()<EOL>pad=np.zeros_like(img0)<EOL>imgs=it.chain([img0 ],imgs)<EOL>rows=grouper(w,imgs,pad)<EOL>return np.vstack(map(np.hstack,rows))<EOL><DEDENT>def getsize(img):<EOL><INDENT>h,w=img.shape [:]<EOL>return w,h <EOL><DEDENT>def mdot(*args):<EOL><INDENT>return reduce(np.dot,args)<EOL><DEDENT>def draw_keypoints(vis,keypoints,color=(,,)):<EOL><INDENT>for kp in keypoints :<EOL><INDENT>x,y=kp.pt <EOL>cv2.circle(vis,(int(x),int(y)),,color)<EOL><DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from django.conf import settings <EOL>from django.db import models <EOL>class OAuthToken(models.Model):<EOL><INDENT> '<STR_LIT>'<EOL>user=models.OneToOneField(<EOL>settings.AUTH_USER_MODEL,<EOL>on_delete=models.CASCADE,<EOL>related_name='oauth_token')<EOL>value=models.TextField()<EOL>created_at=models.DateTimeField(auto_now_add=True)<EOL>updated_at=models.DateTimeField(auto_now=True)<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import os <EOL>import pygit2 <EOL>from.models import Repository <EOL>import utils <EOL>def init(path=None,repo=None,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>if repo and path :<EOL><INDENT>raise TypeError('<STR_LIT>')<EOL><DEDENT>if path :<EOL><INDENT>if os.path.isdir(path):<EOL><INDENT>repo=pygit2.Repository(path)<EOL><DEDENT>else :<EOL><INDENT>bare=kwargs.pop('bare',True)<EOL>repo=pygit2.init_repository(path,bare)<EOL><DEDENT> <DEDENT>if not repo :<EOL><INDENT>raise TypeError('<STR_LIT>')<EOL><DEDENT>dumps=kwargs.pop('dumps',utils.import_json().dumps)<EOL>loads=kwargs.pop('loads',utils.import_json().loads)<EOL>return Repository(repo,dumps,loads)<EOL><DEDENT><EOF><BOF>from math import ceil,floor,factorial,pow,sqrt,log <EOL>if __name__=='__main__':<EOL><INDENT>from clime import now <EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from django.http import JsonResponse <EOL>from django.shortcuts import get_object_or_404 <EOL>from django.views.decorators.http import require_POST <EOL>from buildservice.errors import MissingToken,InvalidStatus <EOL>from buildservice.models import Build <EOL>from buildservice.utils.decorators import require_json,require_api_key <EOL>@require_json <EOL>@require_POST <EOL>@require_api_key <EOL>def update_build_status(request,repository_name,build_number):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>status=request.json ['status']<EOL><DEDENT>except(TypeError,KeyError):<EOL><INDENT>return JsonResponse({'error':'<STR_LIT>'},status=)<EOL><DEDENT>build=get_object_or_404(Build,repository__name=repository_name,number=build_number)<EOL>try :<EOL><INDENT>build.update_status(status)<EOL><DEDENT>except InvalidStatus as error :<EOL><INDENT>return JsonResponse({'error':str(error)},status=)<EOL><DEDENT>except MissingToken :<EOL><INDENT>return JsonResponse({'error':'No token.'},status=)<EOL><DEDENT>return JsonResponse({})<EOL><DEDENT><EOF><BOF>import numpy as np <EOL>import cv2 <EOL>import video <EOL>from common import nothing,clock,draw_str <EOL>MHI_DURATION=<EOL>DEFAULT_THRESHOLD=<EOL>MAX_TIME_DELTA=<EOL>MIN_TIME_DELTA=<EOL>def draw_motion_comp(vis,(x,y,w,h),angle,color):<EOL><INDENT>cv2.rectangle(vis,(x,y),(x +w,y +h),(,,))<EOL>r=min(w /,h /)<EOL>cx,cy=x +w /,y +h /<EOL>angle=angle *np.pi /<EOL>cv2.circle(vis,(cx,cy),r,color,)<EOL>cv2.line(vis,(cx,cy),(int(cx +np.cos(angle)*r),int(cy +np.sin(angle)*r)),color,)<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>import sys <EOL>try :video_src=sys.argv []<EOL>except :video_src=<EOL>cv2.namedWindow('motempl')<EOL>visuals=['input','frame_diff','motion_hist','grad_orient']<EOL>cv2.createTrackbar('visual','motempl',,len(visuals)-,nothing)<EOL>cv2.createTrackbar('threshold','motempl',DEFAULT_THRESHOLD,,nothing)<EOL>cam=video.create_capture(video_src,fallback='<STR_LIT>')<EOL>ret,frame=cam.read()<EOL>h,w=frame.shape [:]<EOL>prev_frame=frame.copy()<EOL>motion_history=np.zeros((h,w),np.float32)<EOL>hsv=np.zeros((h,w,),np.uint8)<EOL>hsv [:,:,]=<EOL>while True :<EOL><INDENT>ret,frame=cam.read()<EOL>frame_diff=cv2.absdiff(frame,prev_frame)<EOL>gray_diff=cv2.cvtColor(frame_diff,cv2.COLOR_BGR2GRAY)<EOL>thrs=cv2.getTrackbarPos('threshold','motempl')<EOL>ret,motion_mask=cv2.threshold(gray_diff,thrs,,cv2.THRESH_BINARY)<EOL>timestamp=clock()<EOL>cv2.updateMotionHistory(motion_mask,motion_history,timestamp,MHI_DURATION)<EOL>mg_mask,mg_orient=cv2.calcMotionGradient(motion_history,MAX_TIME_DELTA,MIN_TIME_DELTA,apertureSize=)<EOL>seg_mask,seg_bounds=cv2.segmentMotion(motion_history,timestamp,MAX_TIME_DELTA)<EOL>visual_name=visuals [cv2.getTrackbarPos('visual','motempl')]<EOL>if visual_name=='input':<EOL><INDENT>vis=frame.copy()<EOL><DEDENT>elif visual_name=='frame_diff':<EOL><INDENT>vis=frame_diff.copy()<EOL><DEDENT>elif visual_name=='motion_hist':<EOL><INDENT>vis=np.uint8(np.clip((motion_history -(timestamp -MHI_DURATION))/MHI_DURATION,,)*)<EOL>vis=cv2.cvtColor(vis,cv2.COLOR_GRAY2BGR)<EOL><DEDENT>elif visual_name=='grad_orient':<EOL><INDENT>hsv [:,:,]=mg_orient /<EOL>hsv [:,:,]=mg_mask *<EOL>vis=cv2.cvtColor(hsv,cv2.COLOR_HSV2BGR)<EOL><DEDENT>for i,rect in enumerate([(,,w,h)]+list(seg_bounds)):<EOL><INDENT>x,y,rw,rh=rect <EOL>area=rw *rh <EOL>if area <**:<EOL><INDENT>continue <EOL><DEDENT>silh_roi=motion_mask [y :y +rh,x :x +rw ]<EOL>orient_roi=mg_orient [y :y +rh,x :x +rw ]<EOL>mask_roi=mg_mask [y :y +rh,x :x +rw ]<EOL>mhi_roi=motion_history [y :y +rh,x :x +rw ]<EOL>if cv2.norm(silh_roi,cv2.NORM_L1)<area *:<EOL><INDENT>continue <EOL><DEDENT>angle=cv2.calcGlobalOrientation(orient_roi,mask_roi,mhi_roi,timestamp,MHI_DURATION)<EOL>color=((,,),(,,))[i==]<EOL>draw_motion_comp(vis,rect,angle,color)<EOL><DEDENT>draw_str(vis,(,),visual_name)<EOL>cv2.imshow('motempl',vis)<EOL>prev_frame=frame.copy()<EOL>if &cv2.waitKey()==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import sys <EOL>if __name__=='__main__':<EOL><INDENT>print '<STR_LIT>'<EOL>print '<STR_LIT>'<EOL>print <EOL>if len(sys.argv)>:<EOL><INDENT>fn=sys.argv []<EOL>print 'loading %s...'%fn <EOL>img=cv2.imread(fn)<EOL><DEDENT>else :<EOL><INDENT>sz=<EOL>print '<STR_LIT>'%(sz,sz)<EOL>img=np.zeros((sz,sz),np.uint8)<EOL>track=np.cumsum(np.random.rand(,)-,axis=)<EOL>track=np.int32(track *+(sz /,sz /))<EOL>cv2.polylines(img,[track ],,,,cv2.CV_AA)<EOL><DEDENT>small=img <EOL>for i in xrange():<EOL><INDENT>small=cv2.pyrDown(small)<EOL><DEDENT>def onmouse(event,x,y,flags,param):<EOL><INDENT>h,w=img.shape [:]<EOL>h1,w1=small.shape [:]<EOL>x,y=*x *h /h1,*y *h /h1 <EOL>zoom=cv2.getRectSubPix(img,(,),(x +,y +))<EOL>cv2.imshow('zoom',zoom)<EOL><DEDENT>cv2.imshow('preview',small)<EOL>cv2.setMouseCallback('preview',onmouse)<EOL>cv2.waitKey()<EOL>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>__author__='<STR_LIT>'<EOL>from urlparse import urlparse <EOL>import httplib2 <EOL>from apiclient.discovery import build <EOL>from oauth2client.appengine import StorageByKeyName <EOL>from oauth2client.client import AccessTokenRefreshError <EOL>import sessions <EOL>from model import Credentials <EOL>SESSION_SECRET=open('session.secret').read()<EOL>def get_full_url(request_handler,path):<EOL><INDENT> '<STR_LIT>'<EOL>pr=urlparse(request_handler.request.url)<EOL>return '%s://%s%s'%(pr.scheme,pr.netloc,path)<EOL><DEDENT>def load_session_credentials(request_handler):<EOL><INDENT> '<STR_LIT>'<EOL>session=sessions.LilCookies(request_handler,SESSION_SECRET)<EOL>userid=session.get_secure_cookie(name='userid')<EOL>if userid :<EOL><INDENT>return userid,StorageByKeyName(Credentials,userid,'credentials').get()<EOL><DEDENT>else :<EOL><INDENT>return None,None <EOL><DEDENT> <DEDENT>def store_userid(request_handler,userid):<EOL><INDENT> '<STR_LIT>'<EOL>session=sessions.LilCookies(request_handler,SESSION_SECRET)<EOL>session.set_secure_cookie(name='userid',value=userid)<EOL><DEDENT>def create_service(service,version,creds=None):<EOL><INDENT> '<STR_LIT>'<EOL>http=httplib2.Http()<EOL>if creds :<EOL><INDENT>creds.authorize(http)<EOL><DEDENT>return build(service,version,http=http)<EOL><DEDENT>def auth_required(handler_method):<EOL><INDENT> '<STR_LIT>'<EOL>def check_auth(self,*args):<EOL><INDENT>self.userid,self.credentials=load_session_credentials(self)<EOL>self.mirror_service=create_service('mirror','v1',self.credentials)<EOL>if self.credentials :<EOL><INDENT>try :<EOL><INDENT>self.credentials.refresh(httplib2.Http())<EOL>return handler_method(self,*args)<EOL><DEDENT>except AccessTokenRefreshError :<EOL><INDENT>store_userid(self,'')<EOL>credentials_entity=Credentials.get_by_key_name(self.userid)<EOL>if credentials_entity :<EOL><INDENT>credentials_entity.delete()<EOL><DEDENT> <DEDENT> <DEDENT>self.redirect('/auth')<EOL><DEDENT>return check_auth <EOL><DEDENT><EOF><BOF>from pyspark import SparkConf,SparkContext <EOL>from pyspark.mllib.clustering import LDA,LDAModel <EOL>from pyspark.mllib.linalg import Vectors <EOL>if __name__=='__main__':<EOL><INDENT>conf=SparkConf().setAppName("LDA")<EOL>sc=SparkContext(conf=conf)<EOL>data=sc.textFile('<STR_LIT>')<EOL>parsedData=data.map(lambda line :Vectors.dense([float(x)for x in line.strip().split(' ')]))<EOL>corpus=parsedData.zipWithIndex().map(lambda x :[x [],x []]).cache()<EOL>ldaModel=LDA.train(corpus,k=)<EOL>print('<STR_LIT>'+str(ldaModel.vocabSize())+" words):")<EOL>topics=ldaModel.topicsMatrix()<EOL>for topic in range():<EOL><INDENT>print("Topic "+str(topic)+":")<EOL>for word in range(,ldaModel.vocabSize()):<EOL><INDENT>print(" "+str(topics [word ][topic ]))<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>from __future__ import with_statement <EOL>from os.path import basename,splitext <EOL>import codecs <EOL>from robot.htmldata import HtmlFileWriter,ModelWriter,LOG,REPORT <EOL>from robot.utils import utf8open <EOL>from.jswriter import JsResultWriter,SplitLogWriter <EOL>class _LogReportWriter(object):<EOL><INDENT>def __init__(self,js_model):<EOL><INDENT>self._js_model=js_model <EOL><DEDENT>def _write_file(self,path,config,template):<EOL><INDENT>outfile=codecs.open(path,'wb',encoding='UTF-8')if isinstance(path,basestring)else path <EOL>with outfile :<EOL><INDENT>model_writer=RobotModelWriter(outfile,self._js_model,config)<EOL>writer=HtmlFileWriter(outfile,model_writer)<EOL>writer.write(template)<EOL><DEDENT> <DEDENT> <DEDENT>class LogWriter(_LogReportWriter):<EOL><INDENT>def write(self,path,config):<EOL><INDENT>self._write_file(path,config,LOG)<EOL>if self._js_model.split_results :<EOL><INDENT>self._write_split_logs(splitext(path)[])<EOL><DEDENT> <DEDENT>def _write_split_logs(self,base):<EOL><INDENT>for index,(keywords,strings)in enumerate(self._js_model.split_results):<EOL><INDENT>index +=<EOL>self._write_split_log(index,keywords,strings,'%s-%d.js'%(base,index))<EOL><DEDENT> <DEDENT>def _write_split_log(self,index,keywords,strings,path):<EOL><INDENT>with utf8open(path,'wb')as outfile :<EOL><INDENT>writer=SplitLogWriter(outfile)<EOL>writer.write(keywords,strings,index,basename(path))<EOL><DEDENT> <DEDENT> <DEDENT>class ReportWriter(_LogReportWriter):<EOL><INDENT>def write(self,path,config):<EOL><INDENT>self._write_file(path,config,REPORT)<EOL><DEDENT> <DEDENT>class RobotModelWriter(ModelWriter):<EOL><INDENT>def __init__(self,output,model,config):<EOL><INDENT>self._output=output <EOL>self._model=model <EOL>self._config=config <EOL><DEDENT>def write(self,line):<EOL><INDENT>JsResultWriter(self._output).write(self._model,self._config)<EOL><DEDENT> <DEDENT><EOF><BOF>import sys <EOL>import helpers <EOL>import threading <EOL>import random as global_random <EOL>import string <EOL>FEW=<EOL>LOTS=<EOL>MAX_DEPTH=<EOL>def random_number(r,j,l,min=-sys.maxint,max=sys.maxint):<EOL><INDENT>r.jumpahead(j +l)<EOL>return r.random()*(max -min)+min <EOL><DEDENT>def random_string(r,j,l,min=,max=):<EOL><INDENT>r.jumpahead(j +l)<EOL>return ''.join(r.choice(string.ascii_letters +<EOL>string.digits)<EOL>for i in xrange(r.randint(min,max)))<EOL><DEDENT>def random_array(r,j,l,min=,max=):<EOL><INDENT>if l >MAX_DEPTH :<EOL><INDENT>return []<EOL><DEDENT>r.jumpahead(j +l)<EOL>return [random_object(r,i,l +)for i in xrange(r.randint(min,max))]<EOL><DEDENT>def random_dict(r,j,l,min=,max=):<EOL><INDENT>if l >MAX_DEPTH :<EOL><INDENT>return {}<EOL><DEDENT>r.jumpahead(j +l)<EOL>return dict([(r.choice([random_string,random_number ])(r,i,l),<EOL>random_object(r,i,l +))<EOL>for i in xrange(r.randint(min,max))])<EOL><DEDENT>def random_object(r,j,l):<EOL><INDENT>r.jumpahead(j +l)<EOL>return r.choice([random_array,random_dict,random_string,random_number ])(r,j,l)<EOL><DEDENT>def commit(repo,num_commits):<EOL><INDENT>r=global_random.Random()<EOL>r.seed()<EOL>thread_id=threading.current_thread().ident <EOL>for i in xrange(num_commits):<EOL><INDENT>repo.commit(random_string(r,thread_id,),random_object(r,thread_id,))<EOL><DEDENT> <DEDENT>class TestRepoThreading(helpers.RepoTestCase):<EOL><INDENT>def do_with_threads(self,size,func,*args):<EOL><INDENT> '<STR_LIT>'<EOL>pool=[threading.Thread(target=func,args=args)for i in range(size)]<EOL>for thread in pool :<EOL><INDENT>thread.start()<EOL><DEDENT>return pool <EOL><DEDENT>def join_threads(self,pool):<EOL><INDENT>for thread in pool :<EOL><INDENT>thread.join()<EOL><DEDENT> <DEDENT>def test_commit_once_few(self):<EOL><INDENT> '<STR_LIT>'<EOL>pool=self.do_with_threads(FEW,commit,self.repo,)<EOL>self.join_threads(pool)<EOL><DEDENT>def test_commit_once_lots(self):<EOL><INDENT> '<STR_LIT>'<EOL>pool=self.do_with_threads(LOTS,commit,self.repo,)<EOL>self.join_threads(pool)<EOL><DEDENT>def test_commit_lots_few(self):<EOL><INDENT> '<STR_LIT>'<EOL>pool=self.do_with_threads(FEW,commit,self.repo,)<EOL>self.join_threads(pool)<EOL><DEDENT>def test_commit_lots_lots(self):<EOL><INDENT> '<STR_LIT>'<EOL>pool=self.do_with_threads(LOTS,commit,self.repo,)<EOL>self.join_threads(pool)<EOL><DEDENT> <DEDENT><EOF><BOF>from flask.views import MethodView <EOL>from yapper.lib.response import json_success <EOL>from..blog.models import Post <EOL>class PostAPI(MethodView):<EOL><INDENT>MODEL=Post <EOL>def get(self,m_id=None):<EOL><INDENT>if m_id :<EOL><INDENT>item=self.MODEL.query.get_or_404(m_id)<EOL>return json_success(data=item.to_json())<EOL><DEDENT>items=self.MODEL.query.order_by(<EOL>self.MODEL.created_at.desc()).limit()<EOL>resp=[]<EOL>for item in items :<EOL><INDENT>resp.append(item.to_json())<EOL><DEDENT>return json_success(data=resp)<EOL><DEDENT> <DEDENT><EOF><BOF>import json <EOL>import os <EOL>import sys <EOL>from ConfigParser import SafeConfigParser <EOL>from sqlalchemy import create_engine,Text,TypeDecorator <EOL>from sqlalchemy.ext.declarative import declarative_base <EOL>from sqlalchemy.orm import sessionmaker <EOL>def build_db_conn_string(cfg):<EOL><INDENT>if cfg.get("database","system").lower()=="sqlite":<EOL><INDENT>return '<STR_LIT>'.format(**{<EOL>"system":cfg.get("database","system"),<EOL>"db":cfg.get("database","database"),<EOL>})<EOL><DEDENT>return '<STR_LIT>'.format(**{<EOL>"system":cfg.get("database","system"),<EOL>"username":cfg.get("database","username"),<EOL>"password":cfg.get("database","password"),<EOL>"host":cfg.get("database","host"),<EOL>"db":cfg.get("database","database"),<EOL>})<EOL><DEDENT>class JSONSerialized(TypeDecorator):<EOL><INDENT>impl=Text <EOL>def process_bind_param(self,value,dialect):<EOL><INDENT>return json.dumps(value)<EOL><DEDENT>def process_result_value(self,value,dialect):<EOL><INDENT>return json.loads(value)<EOL><DEDENT> <DEDENT>cfg_file=SafeConfigParser()<EOL>path_to_cfg=os.path.dirname(__file__)<EOL>path_to_cfg=os.path.join(path_to_cfg,'<STR_LIT>')<EOL>cfg_file.read(path_to_cfg)<EOL>engine=create_engine(build_db_conn_string(cfg_file))<EOL>Base=declarative_base()<EOL>Session=sessionmaker(bind=engine)<EOL>db=Session()<EOF><BOF>'<STR_LIT>'<EOL>__author__='<STR_LIT>'<EOL>from oauth2client import util <EOL>from oauth2client.anyjson import simplejson <EOL>class Error(Exception):<EOL><INDENT> '<STR_LIT>'<EOL>pass <EOL><DEDENT>class HttpError(Error):<EOL><INDENT> '<STR_LIT>'<EOL>@util.positional()<EOL>def __init__(self,resp,content,uri=None):<EOL><INDENT>self.resp=resp <EOL>self.content=content <EOL>self.uri=uri <EOL><DEDENT>def _get_reason(self):<EOL><INDENT> '<STR_LIT>'<EOL>reason=self.resp.reason <EOL>try :<EOL><INDENT>data=simplejson.loads(self.content)<EOL>reason=data ['error']['message']<EOL><DEDENT>except(ValueError,KeyError):<EOL><INDENT>pass <EOL><DEDENT>if reason is None :<EOL><INDENT>reason=''<EOL><DEDENT>return reason <EOL><DEDENT>def __repr__(self):<EOL><INDENT>if self.uri :<EOL><INDENT>return '<STR_LIT>'%(<EOL>self.resp.status,self.uri,self._get_reason().strip())<EOL><DEDENT>else :<EOL><INDENT>return '<STR_LIT>'%(self.resp.status,self._get_reason())<EOL><DEDENT> <DEDENT>__str__=__repr__ <EOL><DEDENT>class InvalidJsonError(Error):<EOL><INDENT> '<STR_LIT>'<EOL>pass <EOL><DEDENT>class UnknownFileType(Error):<EOL><INDENT> '<STR_LIT>'<EOL>pass <EOL><DEDENT>class UnknownLinkType(Error):<EOL><INDENT> '<STR_LIT>'<EOL>pass <EOL><DEDENT>class UnknownApiNameOrVersion(Error):<EOL><INDENT> '<STR_LIT>'<EOL>pass <EOL><DEDENT>class UnacceptableMimeTypeError(Error):<EOL><INDENT> '<STR_LIT>'<EOL>pass <EOL><DEDENT>class MediaUploadSizeError(Error):<EOL><INDENT> '<STR_LIT>'<EOL>pass <EOL><DEDENT>class ResumableUploadError(HttpError):<EOL><INDENT> '<STR_LIT>'<EOL>pass <EOL><DEDENT>class InvalidChunkSizeError(Error):<EOL><INDENT> '<STR_LIT>'<EOL>pass <EOL><DEDENT>class BatchError(HttpError):<EOL><INDENT> '<STR_LIT>'<EOL>@util.positional()<EOL>def __init__(self,reason,resp=None,content=None):<EOL><INDENT>self.resp=resp <EOL>self.content=content <EOL>self.reason=reason <EOL><DEDENT>def __repr__(self):<EOL><INDENT>return '<STR_LIT>'%(self.resp.status,self.reason)<EOL><DEDENT>__str__=__repr__ <EOL><DEDENT>class UnexpectedMethodError(Error):<EOL><INDENT> '<STR_LIT>'<EOL>@util.positional()<EOL>def __init__(self,methodId=None):<EOL><INDENT> '<STR_LIT>'<EOL>super(UnexpectedMethodError,self).__init__(<EOL>'<STR_LIT>'%methodId)<EOL><DEDENT> <DEDENT>class UnexpectedBodyError(Error):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,expected,provided):<EOL><INDENT> '<STR_LIT>'<EOL>super(UnexpectedBodyError,self).__init__(<EOL>'<STR_LIT>'%(expected,provided))<EOL><DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import cv2.cv as cv <EOL>from common import draw_str <EOL>import getopt,sys <EOL>from itertools import count <EOL>help_message='<STR_LIT>'<EOL>if __name__=='__main__':<EOL><INDENT>print help_message <EOL>w,h=,<EOL>args,args_list=getopt.getopt(sys.argv [:],'o:',[])<EOL>args=dict(args)<EOL>out=None <EOL>if '-o'in args :<EOL><INDENT>fn=args ['-o']<EOL>out=cv2.VideoWriter(args ['-o'],cv.CV_FOURCC(*'DIB '),,(w,h),False)<EOL>print 'writing %s...'%fn <EOL><DEDENT>a=np.zeros((h,w),np.float32)<EOL>cv2.randu(a,np.array([]),np.array([]))<EOL>def process_scale(a_lods,lod):<EOL><INDENT>d=a_lods [lod ]-cv2.pyrUp(a_lods [lod +])<EOL>for i in xrange(lod):<EOL><INDENT>d=cv2.pyrUp(d)<EOL><DEDENT>v=cv2.GaussianBlur(d *d,(,),)<EOL>return np.sign(d),v <EOL><DEDENT>scale_num=<EOL>for frame_i in count():<EOL><INDENT>a_lods=[a ]<EOL>for i in xrange(scale_num):<EOL><INDENT>a_lods.append(cv2.pyrDown(a_lods [-]))<EOL><DEDENT>ms,vs=[],[]<EOL>for i in xrange(,scale_num):<EOL><INDENT>m,v=process_scale(a_lods,i)<EOL>ms.append(m)<EOL>vs.append(v)<EOL><DEDENT>mi=np.argmin(vs,)<EOL>a +=np.choose(mi,ms)*<EOL>a=(a -a.min())/a.ptp()<EOL>if out :<EOL><INDENT>out.write(a)<EOL><DEDENT>vis=a.copy()<EOL>draw_str(vis,(,),'frame %d'%frame_i)<EOL>cv2.imshow('a',vis)<EOL>if &cv2.waitKey()==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import cv2 <EOL>import numpy as np <EOL>from cam import MyCam <EOL>from fmatch import draw_match <EOL>print __doc__ <EOL>MIN_MATCH_COUNT=<EOL>sift=cv2.SIFT()<EOL>cam=MyCam()<EOL>cam.size=(,)<EOL>img1=cv2.imread('box.png',)<EOL>cv2.imshow('source',img1)<EOL>if img1.shape []*img1.shape []>cam.size []*cam.size []:<EOL><INDENT>img1=cv2.resize(img1,cam.size)<EOL><DEDENT>kp1,des1=sift.detectAndCompute(img1,None)<EOL>while True :<EOL><INDENT>img2=cv2.cvtColor(cam.read(),cv2.COLOR_BGR2GRAY)<EOL>k=cv2.waitKey()<EOL>if k==ord('s'):<EOL><INDENT>img1=img2.copy()<EOL>kp1,des1=sift.detectAndCompute(img1,None)<EOL>cv2.imwrite('campic.png',img1)<EOL><DEDENT>if k==ord('r'):<EOL><INDENT>print cam.frame_rate <EOL><DEDENT>elif k==:<EOL><INDENT>break <EOL><DEDENT>kp2,des2=sift.detectAndCompute(img2,None)<EOL>FLANN_INDEX_KDTREE=<EOL>index_params=dict(algorithm=FLANN_INDEX_KDTREE,trees=)<EOL>search_params=dict(checks=)<EOL>flann=cv2.FlannBasedMatcher(index_params,search_params)<EOL>matches=flann.knnMatch(des1,des2,k=)<EOL>good=[]<EOL>for m,n in matches :<EOL><INDENT>if m.distance <*n.distance :<EOL><INDENT>good.append(m)<EOL><DEDENT> <DEDENT>if len(good)>MIN_MATCH_COUNT :<EOL><INDENT>src_pts=np.float32([kp1 [m.queryIdx ].pt for m in good ]).reshape(-,,)<EOL>dst_pts=np.float32([kp2 [m.trainIdx ].pt for m in good ]).reshape(-,,)<EOL>M,mask=cv2.findHomography(src_pts,dst_pts,cv2.RANSAC,)<EOL>matchesMask=mask.ravel().tolist()<EOL>h,w=img1.shape <EOL>pts=np.float32([[,],[,h -],[w -,h -],[w -,]]).reshape(-,,)<EOL>dst=cv2.perspectiveTransform(pts,M)<EOL>cv2.polylines(img2,[np.int32(dst)],True,,)<EOL><DEDENT>else :<EOL><INDENT>print '<STR_LIT>'%(len(good),MIN_MATCH_COUNT)<EOL>matchesMask=None <EOL><DEDENT>draw_params=dict(matchColor=(,,),<EOL>singlePointColor=None,<EOL>matchesMask=matchesMask,<EOL>flags=)<EOL>img3=draw_match(img1,kp1,img2,kp2,good,None,**draw_params)<EOL>cv2.imshow('matches',img3)<EOL><DEDENT><EOF><BOF>from __future__ import unicode_literals <EOL>import json <EOL>from zerotest.request import Request <EOL>from zerotest.response import Response <EOL>class Formatter(object):<EOL><INDENT>def write_record(self,writeable,request,response):<EOL><INDENT>record=dict(request=request.__dict__,response=response.__dict__)<EOL>writeable.write(json.dumps(record))<EOL>writeable.write("\n")<EOL><DEDENT>def read_record(self,readable):<EOL><INDENT>line=readable.readline()<EOL>if not line :<EOL><INDENT>return None <EOL><DEDENT>record=json.loads(line)<EOL>request=Request()<EOL>request.__dict__.update(record ['request'])<EOL>response=Response()<EOL>response.__dict__.update(record ['response'])<EOL>return request,response <EOL><DEDENT> <DEDENT><EOF><BOF>import cv2 <EOL>def webcam_gui(filter_func,video_src=):<EOL><INDENT>cap=cv2.VideoCapture(video_src)<EOL>key_code=-<EOL>while(key_code==-):<EOL><INDENT>ret,frame=cap.read()<EOL>frame_out=filter_func(frame)<EOL>cv2.imshow('<STR_LIT>',frame_out)<EOL>key_code=cv2.waitKey()<EOL><DEDENT>cap.release()<EOL>cv2.destroyAllWindows()<EOL><DEDENT>def edge_filter(frame_in):<EOL><INDENT>frame_gray=cv2.cvtColor(frame_in,cv2.COLOR_BGR2GRAY)<EOL>frame_blur=cv2.blur(frame_gray,(,))<EOL>frame_out=cv2.Canny(frame_blur,,)<EOL>return frame_out <EOL><DEDENT>def gray_filter(frame_in):<EOL><INDENT>frame_out=cv2.cvtColor(frame_in,cv2.COLOR_BGR2GRAY)<EOL>return frame_out <EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>cv2.VideoCapture.set(CV_CAP_PROP_FPS,)<EOL>webcam_gui(edge_filter)<DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from glob import glob <EOL>if __name__=='__main__':<EOL><INDENT>print '<STR_LIT>'<EOL>for fn in glob('*.py'):<EOL><INDENT>loc={}<EOL>execfile(fn,loc)<EOL>if '__doc__'not in loc :<EOL><INDENT>print fn <EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>import cv2 <EOL>import numpy as np <EOL>from cam import OpenCV_Cam <EOL>def get_mask(img,lower,upper,blur=):<EOL><INDENT>if lower []<:<EOL><INDENT>offset=-lower []<EOL><DEDENT>else :<EOL><INDENT>offset=<EOL><DEDENT>lower []=lower []+offset <EOL>upper []=upper []+offset <EOL>hsv_img=cv2.cvtColor(img,cv2.COLOR_BGR2HSV)<EOL>hsv_img=cv2.blur(hsv_img,(blur,blur))<EOL>shift=np.full_like(img,,np.uint8)<EOL>shift [:,:,]=offset <EOL>hsv_img=hsv_img +shift <EOL>lower=np.array(lower,dtype="uint8")<EOL>upper=np.array(upper,dtype="uint8")<EOL>mask=cv2.inRange(hsv_img,lower,upper)<EOL>return mask <EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>cam=OpenCV_Cam()<EOL>red_bound=([-,,],[,,])<EOL>green_bound=([,,],[,,])<EOL>while True :<EOL><INDENT>image=cam.read()<EOL>red_mask=get_mask(image,*red_bound)<EOL>green_mask=get_mask(image,*green_bound)<EOL>masks=cv2.bitwise_or(red_mask,green_mask)<EOL>cv2.imshow('masks',np.hstack([red_mask,green_mask ]))<EOL>output=cv2.bitwise_and(image,image,mask=masks)<EOL>cv2.imshow("images",np.hstack([image,output ]))<EOL>k=cv2.waitKey()<EOL>if k==:<EOL><INDENT>break <DEDENT> <DEDENT> <DEDENT><EOF><BOF>import os <EOL>import sys <EOL>import copy <EOL>from robot import utils <EOL>from robot.errors import DataError <EOL>from robot.variables import GLOBAL_VARIABLES,is_scalar_var <EOL>from robot.common import UserErrorHandler <EOL>from robot.output import LOGGER <EOL>from robot.parsing.settings import Library,Variables,Resource <EOL>from.userkeyword import UserLibrary <EOL>from.importer import Importer,ImportCache <EOL>from.runkwregister import RUN_KW_REGISTER <EOL>from.handlers import _XTimesHandler <EOL>from.context import EXECUTION_CONTEXTS <EOL>STDLIB_NAMES=set(('BuiltIn','Collections','Dialogs','Easter',<EOL>'OperatingSystem','Remote','Reserved',<EOL>'Screenshot','String','Telnet','XML'))<EOL>IMPORTER=Importer()<EOL>class Namespace :<EOL><INDENT>_default_libraries=('BuiltIn','Reserved','Easter')<EOL>_deprecated_libraries={'BuiltIn':'<STR_LIT>',<EOL>'OperatingSystem':'<STR_LIT>'}<EOL>_library_import_by_path_endings=('.py','.java','.class','/',os.sep)<EOL>def __init__(self,suite,parent_vars):<EOL><INDENT>if suite is not None :<EOL><INDENT>LOGGER.info('<STR_LIT>'%suite.longname)<EOL><DEDENT>self.variables=self._create_variables(suite,parent_vars)<EOL>self.suite=suite <EOL>self.test=None <EOL>self.uk_handlers=[]<EOL>self.library_search_order=[]<EOL>self._testlibs={}<EOL>self._imported_resource_files=ImportCache()<EOL>self._imported_variable_files=ImportCache()<EOL><DEDENT>def handle_imports(self):<EOL><INDENT>self._import_default_libraries()<EOL>if self.suite.source :<EOL><INDENT>self._handle_imports(self.suite.imports)<EOL><DEDENT> <DEDENT>def _create_variables(self,suite,parent_vars):<EOL><INDENT>variables=_VariableScopes(suite,parent_vars)<EOL>variables ['${SUITE_NAME}']=suite.longname <EOL>variables ['${SUITE_SOURCE}']=suite.source <EOL>variables ['<STR_LIT>']=suite.doc <EOL>variables ['<STR_LIT>']=suite.metadata.copy()<EOL>return variables <EOL><DEDENT>def _import_default_libraries(self):<EOL><INDENT>for name in self._default_libraries :<EOL><INDENT>self.import_library(name)<EOL><DEDENT> <DEDENT>def _handle_imports(self,import_settings):<EOL><INDENT>for item in import_settings :<EOL><INDENT>try :<EOL><INDENT>if not item.name :<EOL><INDENT>raise DataError('<STR_LIT>'%item.type)<EOL><DEDENT>self._import(item)<EOL><DEDENT>except DataError,err :<EOL><INDENT>item.report_invalid_syntax(unicode(err))<EOL><DEDENT> <DEDENT> <DEDENT>def _import(self,import_setting):<EOL><INDENT>action={'Library':self._import_library,<EOL>'Resource':self._import_resource,<EOL>'Variables':self._import_variables }[import_setting.type ]<EOL>action(import_setting,self.variables.current)<EOL><DEDENT>def import_resource(self,name,overwrite=True):<EOL><INDENT>self._import_resource(Resource(None,name),overwrite=overwrite)<EOL><DEDENT>def _import_resource(self,import_setting,variables=None,overwrite=False):<EOL><INDENT>path=self._resolve_name(import_setting,variables)<EOL>if overwrite or path not in self._imported_resource_files :<EOL><INDENT>resource=IMPORTER.import_resource(path)<EOL>self.variables.set_from_variable_table(resource.variable_table,<EOL>overwrite)<EOL>self._imported_resource_files [path ]=UserLibrary(resource.keyword_table.keywords,resource.source)<EOL>self._handle_imports(resource.setting_table.imports)<EOL><DEDENT>else :<EOL><INDENT>LOGGER.info('<STR_LIT>'<EOL>%(path,self.suite.longname))<EOL><DEDENT> <DEDENT>def import_variables(self,name,args,overwrite=False,variables=None):<EOL><INDENT>self._import_variables(Variables(None,name,args),variables,overwrite)<EOL><DEDENT>def _import_variables(self,import_setting,variables,overwrite=False):<EOL><INDENT>path=self._resolve_name(import_setting,variables)<EOL>args=self._resolve_args(import_setting,variables)<EOL>if overwrite or(path,args)not in self._imported_variable_files :<EOL><INDENT>self._imported_variable_files.add((path,args))<EOL>self.variables.set_from_file(path,args,overwrite)<EOL><DEDENT>else :<EOL><INDENT>msg='<STR_LIT>'%path <EOL>if args :<EOL><INDENT>msg +='<STR_LIT>'%utils.seq2str2(args)<EOL><DEDENT>LOGGER.info('<STR_LIT>'<EOL>%(msg,self.suite.longname))<EOL><DEDENT> <DEDENT>def import_library(self,name,args=None,alias=None,variables=None):<EOL><INDENT>self._import_library(Library(None,name,args=args,alias=alias),variables)<EOL><DEDENT>def _import_library(self,import_setting,variables):<EOL><INDENT>name=self._resolve_name(import_setting,variables)<EOL>lib=IMPORTER.import_library(name,import_setting.args,<EOL>import_setting.alias,variables)<EOL>if lib.name in self._testlibs :<EOL><INDENT>LOGGER.info('<STR_LIT>'<EOL>%(lib.name,self.suite.longname))<EOL>return <EOL><DEDENT>self._testlibs [lib.name ]=lib <EOL>lib.start_suite()<EOL>if self.test :<EOL><INDENT>lib.start_test()<EOL><DEDENT>self._import_deprecated_standard_libs(lib.name)<EOL><DEDENT>def _resolve_name(self,import_setting,variables):<EOL><INDENT>name=import_setting.name <EOL>if variables :<EOL><INDENT>try :<EOL><INDENT>name=variables.replace_string(name)<EOL><DEDENT>except DataError,err :<EOL><INDENT>self._raise_replacing_vars_failed(import_setting,err)<EOL><DEDENT> <DEDENT>return self._get_path(name,import_setting.directory,import_setting.type)<EOL><DEDENT>def _raise_replacing_vars_failed(self,import_setting,err):<EOL><INDENT>raise DataError('<STR_LIT>'<EOL>%(import_setting.type,unicode(err)))<EOL><DEDENT>def _get_path(self,name,basedir,type):<EOL><INDENT>if type=='Library'and not self._is_library_by_path(name):<EOL><INDENT>return name.replace(' ','')<EOL><DEDENT>try :<EOL><INDENT>return self._resolve_path(name.replace('/',os.sep),basedir)<EOL><DEDENT>except DataError :<EOL><INDENT>self._raise_imported_does_not_exist(type,name)<EOL><DEDENT> <DEDENT>def _is_library_by_path(self,path):<EOL><INDENT>return path.lower().endswith(self._library_import_by_path_endings)<EOL><DEDENT>def _resolve_path(self,path,basedir):<EOL><INDENT>for base in [basedir ]+sys.path :<EOL><INDENT>if not(base and os.path.isdir(base)):<EOL><INDENT>continue <EOL><DEDENT>if not isinstance(base,unicode):<EOL><INDENT>base=utils.decode_from_system(base)<EOL><DEDENT>ret=os.path.abspath(os.path.join(base,path))<EOL>if os.path.isfile(ret):<EOL><INDENT>return ret <EOL><DEDENT>if os.path.isdir(ret)and os.path.isfile(os.path.join(ret,'__init__.py')):<EOL><INDENT>return ret <EOL><DEDENT> <DEDENT>raise DataError <EOL><DEDENT>def _raise_imported_does_not_exist(self,type,path):<EOL><INDENT>type={'Library':'Test library',<EOL>'Variables':'Variable file',<EOL>'Resource':'Resource file'}[type ]<EOL>raise DataError('<STR_LIT>'%(type,path))<EOL><DEDENT>def _resolve_args(self,import_setting,variables):<EOL><INDENT>if not variables :<EOL><INDENT>return import_setting.args <EOL><DEDENT>try :<EOL><INDENT>return variables.replace_list(import_setting.args)<EOL><DEDENT>except DataError,err :<EOL><INDENT>self._raise_replacing_vars_failed(import_setting,err)<EOL><DEDENT> <DEDENT>def _import_deprecated_standard_libs(self,name):<EOL><INDENT>if name in self._deprecated_libraries :<EOL><INDENT>self.import_library(self._deprecated_libraries [name ])<EOL><DEDENT> <DEDENT>def start_test(self,test):<EOL><INDENT>self.variables.start_test(test)<EOL>self.test=test <EOL>for lib in self._testlibs.values():<EOL><INDENT>lib.start_test()<EOL><DEDENT>self.variables ['${TEST_NAME}']=test.name <EOL>self.variables ['<STR_LIT>']=test.doc <EOL>self.variables ['@{TEST_TAGS}']=test.tags [:]<EOL><DEDENT>def end_test(self):<EOL><INDENT>self.test=None <EOL>self.variables.end_test()<EOL>self.uk_handlers=[]<EOL>for lib in self._testlibs.values():<EOL><INDENT>lib.end_test()<EOL><DEDENT> <DEDENT>def set_test_status_before_teardown(self,message,status):<EOL><INDENT>self.variables ['${TEST_MESSAGE}']=message <EOL>self.variables ['${TEST_STATUS}']=status <EOL><DEDENT>def end_suite(self):<EOL><INDENT>self.suite=None <EOL>self.variables.end_suite()<EOL>for lib in self._testlibs.values():<EOL><INDENT>lib.end_suite()<EOL><DEDENT> <DEDENT>def start_user_keyword(self,handler):<EOL><INDENT>self.variables.start_uk(handler)<EOL>self.uk_handlers.append(handler)<EOL><DEDENT>def end_user_keyword(self):<EOL><INDENT>self.variables.end_uk()<EOL>self.uk_handlers.pop()<EOL><DEDENT>def get_library_instance(self,libname):<EOL><INDENT>try :<EOL><INDENT>return self._testlibs [libname.replace(' ','')].get_instance()<EOL><DEDENT>except KeyError :<EOL><INDENT>raise DataError('<STR_LIT>'%libname)<EOL><DEDENT> <DEDENT>def get_handler(self,name):<EOL><INDENT>try :<EOL><INDENT>handler=self._get_handler(name)<EOL>if handler is None :<EOL><INDENT>raise DataError('<STR_LIT>'%name)<EOL><DEDENT> <DEDENT>except DataError,err :<EOL><INDENT>handler=UserErrorHandler(name,unicode(err))<EOL><DEDENT>self._replace_variables_from_user_handlers(handler)<EOL>return handler <EOL><DEDENT>def _replace_variables_from_user_handlers(self,handler):<EOL><INDENT>if hasattr(handler,'<STR_LIT>'):<EOL><INDENT>handler.replace_variables(self.variables)<EOL><DEDENT> <DEDENT>def _get_handler(self,name):<EOL><INDENT>handler=None <EOL>if not name :<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>if not isinstance(name,basestring):<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>if '.'in name :<EOL><INDENT>handler=self._get_explicit_handler(name)<EOL><DEDENT>if not handler :<EOL><INDENT>handler=self._get_implicit_handler(name)<EOL><DEDENT>if not handler :<EOL><INDENT>handler=self._get_bdd_style_handler(name)<EOL><DEDENT>if not handler :<EOL><INDENT>handler=self._get_x_times_handler(name)<EOL><DEDENT>return handler <EOL><DEDENT>def _get_x_times_handler(self,name):<EOL><INDENT>if not self._is_old_x_times_syntax(name):<EOL><INDENT>return None <EOL><DEDENT>return _XTimesHandler(self._get_handler('Repeat Keyword'),name)<EOL><DEDENT>def _is_old_x_times_syntax(self,name):<EOL><INDENT>if not name.lower().endswith('x'):<EOL><INDENT>return False <EOL><DEDENT>times=name [:-].strip()<EOL>if is_scalar_var(times):<EOL><INDENT>return True <EOL><DEDENT>try :<EOL><INDENT>int(times)<EOL><DEDENT>except ValueError :<EOL><INDENT>return False <EOL><DEDENT>else :<EOL><INDENT>return True <EOL><DEDENT> <DEDENT>def _get_bdd_style_handler(self,name):<EOL><INDENT>for prefix in ['given ','when ','then ','and ']:<EOL><INDENT>if name.lower().startswith(prefix):<EOL><INDENT>handler=self._get_handler(name [len(prefix):])<EOL>if handler :<EOL><INDENT>handler=copy.copy(handler)<EOL>handler.name=name <EOL><DEDENT>return handler <EOL><DEDENT> <DEDENT>return None <EOL><DEDENT>def _get_implicit_handler(self,name):<EOL><INDENT>for method in [self._get_handler_from_test_case_file_user_keywords,<EOL>self._get_handler_from_resource_file_user_keywords,<EOL>self._get_handler_from_library_keywords ]:<EOL><INDENT>handler=method(name)<EOL>if handler :<EOL><INDENT>return handler <EOL><DEDENT> <DEDENT>return None <EOL><DEDENT>def _get_handler_from_test_case_file_user_keywords(self,name):<EOL><INDENT>if self.suite.user_keywords.has_handler(name):<EOL><INDENT>return self.suite.user_keywords.get_handler(name)<EOL><DEDENT> <DEDENT>def _get_handler_from_resource_file_user_keywords(self,name):<EOL><INDENT>found=[lib.get_handler(name)for lib <EOL>in self._imported_resource_files.values()<EOL>if lib.has_handler(name)]<EOL>if not found :<EOL><INDENT>return None <EOL><DEDENT>if len(found)>:<EOL><INDENT>found=self._get_handler_based_on_library_search_order(found)<EOL><DEDENT>if len(found)==:<EOL><INDENT>return found []<EOL><DEDENT>self._raise_multiple_keywords_found(name,found)<EOL><DEDENT>def _get_handler_from_library_keywords(self,name):<EOL><INDENT>found=[lib.get_handler(name)for lib in self._testlibs.values()<EOL>if lib.has_handler(name)]<EOL>if not found :<EOL><INDENT>return None <EOL><DEDENT>if len(found)>:<EOL><INDENT>found=self._get_handler_based_on_library_search_order(found)<EOL><DEDENT>if len(found)==:<EOL><INDENT>found=self._filter_stdlib_handler(found [],found [])<EOL><DEDENT>if len(found)==:<EOL><INDENT>return found []<EOL><DEDENT>self._raise_multiple_keywords_found(name,found)<EOL><DEDENT>def _get_handler_based_on_library_search_order(self,handlers):<EOL><INDENT>for libname in self.library_search_order :<EOL><INDENT>for handler in handlers :<EOL><INDENT>if utils.eq(libname,handler.libname):<EOL><INDENT>return [handler ]<EOL><DEDENT> <DEDENT> <DEDENT>return handlers <EOL><DEDENT>def _filter_stdlib_handler(self,handler1,handler2):<EOL><INDENT>if handler1.library.orig_name in STDLIB_NAMES :<EOL><INDENT>standard,external=handler1,handler2 <EOL><DEDENT>elif handler2.library.orig_name in STDLIB_NAMES :<EOL><INDENT>standard,external=handler2,handler1 <EOL><DEDENT>else :<EOL><INDENT>return [handler1,handler2 ]<EOL><DEDENT>if not RUN_KW_REGISTER.is_run_keyword(external.library.orig_name,external.name):<EOL><INDENT>LOGGER.warn(<EOL>'<STR_LIT>'<EOL>'<STR_LIT>'<EOL>'<STR_LIT>'<EOL>'<STR_LIT>'<EOL>%(standard.name,<EOL>external.library.orig_name,standard.library.orig_name,<EOL>external.longname,standard.longname))<EOL><DEDENT>return [external ]<EOL><DEDENT>def _get_explicit_handler(self,name):<EOL><INDENT>libname,kwname=name.rsplit('.',)<EOL>libs=[lib for lib <EOL>in self._imported_resource_files.values()+self._testlibs.values()<EOL>if utils.eq(lib.name,libname)]<EOL>if not libs :<EOL><INDENT>return None <EOL><DEDENT>found=[lib.get_handler(kwname)for lib in libs <EOL>if lib.has_handler(kwname)]<EOL>if len(found)>:<EOL><INDENT>self._raise_multiple_keywords_found(name,found,implicit=False)<EOL><DEDENT>return found and found []or None <EOL><DEDENT>def _raise_multiple_keywords_found(self,name,found,implicit=True):<EOL><INDENT>error='<STR_LIT>'%name <EOL>if implicit :<EOL><INDENT>error +='<STR_LIT>'<EOL><DEDENT>names=sorted(handler.longname for handler in found)<EOL>error +="Found: %s"%utils.seq2str(names)<EOL>raise DataError(error)<EOL><DEDENT> <DEDENT>class _VariableScopes :<EOL><INDENT>def __init__(self,suite,parent_vars):<EOL><INDENT>if suite is not None :<EOL><INDENT>suite.variables.update(GLOBAL_VARIABLES)<EOL>self._suite=self.current=suite.variables <EOL><DEDENT>else :<EOL><INDENT>self._suite=self.current=None <EOL><DEDENT>self._parents=[]<EOL>if parent_vars is not None :<EOL><INDENT>self._parents.append(parent_vars.current)<EOL>self._parents.extend(parent_vars._parents)<EOL><DEDENT>self._test=None <EOL>self._uk_handlers=[]<EOL><DEDENT>def __len__(self):<EOL><INDENT>if self.current :<EOL><INDENT>return len(self.current)<EOL><DEDENT>return <EOL><DEDENT>def copy_all(self):<EOL><INDENT>vs=_VariableScopes(None,None)<EOL>vs._suite=self._suite <EOL>vs._test=self._test <EOL>vs._uk_handlers=self._uk_handlers [:]<EOL>vs._parents=self._parents [:]<EOL>vs.current=self.current <EOL>return vs <EOL><DEDENT>def replace_list(self,items):<EOL><INDENT>return self.current.replace_list(items)<EOL><DEDENT>def replace_scalar(self,items):<EOL><INDENT>return self.current.replace_scalar(items)<EOL><DEDENT>def replace_string(self,string):<EOL><INDENT>return self.current.replace_string(string)<EOL><DEDENT>def replace_from_beginning(self,args,how_many,extra_escapes=()):<EOL><INDENT>processed=[]<EOL>while len(processed)<how_many and args :<EOL><INDENT>processed.extend(self.current.replace_list([args.pop()]))<EOL><DEDENT>if len(processed)>how_many :<EOL><INDENT>processed [how_many :]=[self._escape(arg,extra_escapes)<EOL>for arg in processed [how_many :]]<EOL><DEDENT>return processed +args <EOL><DEDENT>def _escape(self,arg,extra_escapes):<EOL><INDENT>arg=utils.escape(arg)<EOL>if arg in extra_escapes :<EOL><INDENT>arg='\\'+arg <EOL><DEDENT>return arg <EOL><DEDENT>def set_from_file(self,path,args,overwrite=False):<EOL><INDENT>variables=self._suite.set_from_file(path,args,overwrite)<EOL>if self._test is not None :<EOL><INDENT>self._test._set_from_file(variables,overwrite=True,path=path)<EOL><DEDENT>for varz in self._uk_handlers :<EOL><INDENT>varz._set_from_file(variables,overwrite=True,path=path)<EOL><DEDENT>if self._uk_handlers :<EOL><INDENT>self.current._set_from_file(variables,overwrite=True,path=path)<EOL><DEDENT> <DEDENT>def set_from_variable_table(self,rawvariables,overwrite=False):<EOL><INDENT>self._suite.set_from_variable_table(rawvariables,overwrite)<EOL>if self._test is not None :<EOL><INDENT>self._test.set_from_variable_table(rawvariables,overwrite)<EOL><DEDENT>for varz in self._uk_handlers :<EOL><INDENT>varz.set_from_variable_table(rawvariables,overwrite)<EOL><DEDENT>if self._uk_handlers :<EOL><INDENT>self.current.set_from_variable_table(rawvariables,overwrite)<EOL><DEDENT> <DEDENT>def replace_meta(self,name,item,errors):<EOL><INDENT>error=None <EOL>for varz in [self.current ]+self._parents :<EOL><INDENT>try :<EOL><INDENT>if name=='Documentation':<EOL><INDENT>return varz.replace_string(item,ignore_errors=True)<EOL><DEDENT>elif isinstance(item,basestring):<EOL><INDENT>return varz.replace_string(item)<EOL><DEDENT>return varz.replace_list(item)<EOL><DEDENT>except DataError,error :<EOL><INDENT>pass <EOL><DEDENT> <DEDENT>errors.append('<STR_LIT>'<EOL>%(name,error))<EOL>return utils.unescape(item)<EOL><DEDENT>def __getitem__(self,name):<EOL><INDENT>return self.current [name ]<EOL><DEDENT>def __setitem__(self,name,value):<EOL><INDENT>self.current [name ]=value <EOL><DEDENT>def end_suite(self):<EOL><INDENT>self._suite=self._test=self.current=None <EOL><DEDENT>def start_test(self,test):<EOL><INDENT>self._test=self.current=self._suite.copy()<EOL><DEDENT>def end_test(self):<EOL><INDENT>self.current=self._suite <EOL><DEDENT>def start_uk(self,handler):<EOL><INDENT>self._uk_handlers.append(self.current)<EOL>self.current=self.current.copy()<EOL><DEDENT>def end_uk(self):<EOL><INDENT>self.current=self._uk_handlers.pop()<EOL><DEDENT>def set_global(self,name,value):<EOL><INDENT>GLOBAL_VARIABLES.__setitem__(name,value)<EOL>for ns in EXECUTION_CONTEXTS.namespaces :<EOL><INDENT>ns.variables.set_suite(name,value)<EOL><DEDENT> <DEDENT>def set_suite(self,name,value):<EOL><INDENT>self._suite.__setitem__(name,value)<EOL>self.set_test(name,value,False)<EOL><DEDENT>def set_test(self,name,value,fail_if_no_test=True):<EOL><INDENT>if self._test is not None :<EOL><INDENT>self._test.__setitem__(name,value)<EOL><DEDENT>elif fail_if_no_test :<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>for varz in self._uk_handlers :<EOL><INDENT>varz.__setitem__(name,value)<EOL><DEDENT>self.current.__setitem__(name,value)<EOL><DEDENT>def keys(self):<EOL><INDENT>return self.current.keys()<EOL><DEDENT>def has_key(self,key):<EOL><INDENT>return self.current.has_key(key)<EOL><DEDENT>__contains__=has_key <EOL>def contains(self,name,extended=False):<EOL><INDENT>return self.current.contains(name,extended)<EOL><DEDENT> <DEDENT><EOF><BOF>import textwrap <EOL>from robot.utils import MultiMatcher,encode_output <EOL>from robot.errors import DataError <EOL>class ConsoleViewer(object):<EOL><INDENT>def __init__(self,libdoc):<EOL><INDENT>self._libdoc=libdoc <EOL>self._keywords=KeywordMatcher(libdoc)<EOL><DEDENT>@classmethod <EOL>def handles(cls,command):<EOL><INDENT>return command.lower()in ['list','show','version']<EOL><DEDENT>@classmethod <EOL>def validate_command(cls,command,args):<EOL><INDENT>if not cls.handles(command):<EOL><INDENT>raise DataError('<STR_LIT>'%command)<EOL><DEDENT>if command.lower()=='version'and args :<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT> <DEDENT>def view(self,command,*args):<EOL><INDENT>self.validate_command(command,args)<EOL>getattr(self,command.lower())(*args)<EOL><DEDENT>def list(self,*patterns):<EOL><INDENT>for kw in self._keywords.search('*%s*'%p for p in patterns):<EOL><INDENT>self._console(kw.name)<EOL><DEDENT> <DEDENT>def show(self,*names):<EOL><INDENT>if MultiMatcher(names,match_if_no_patterns=True).match('intro'):<EOL><INDENT>self._show_intro(self._libdoc)<EOL>if self._libdoc.inits :<EOL><INDENT>self._show_inits(self._libdoc)<EOL><DEDENT> <DEDENT>for kw in self._keywords.search(names):<EOL><INDENT>self._show_keyword(kw)<EOL><DEDENT> <DEDENT>def version(self):<EOL><INDENT>self._console(self._libdoc.version or 'N/A')<EOL><DEDENT>def _console(self,msg):<EOL><INDENT>print encode_output(msg)<EOL><DEDENT>def _show_intro(self,lib):<EOL><INDENT>self._header(lib.name,underline='=')<EOL>named_args='supported'if lib.named_args else 'not supported'<EOL>self._data([('Version',lib.version),('Scope',lib.scope),('Named arguments',named_args)])<EOL>self._doc(lib.doc)<EOL><DEDENT>def _show_inits(self,lib):<EOL><INDENT>self._header('Importing',underline='-')<EOL>for init in lib.inits :<EOL><INDENT>self._show_keyword(init,show_name=False)<EOL><DEDENT> <DEDENT>def _show_keyword(self,kw,show_name=True):<EOL><INDENT>if show_name :<EOL><INDENT>self._header(kw.name,underline='-')<EOL><DEDENT>self._data([('Arguments','[%s]'%', '.join(kw.args))])<EOL>self._doc(kw.doc)<EOL><DEDENT>def _header(self,name,underline):<EOL><INDENT>self._console('%s\n%s'%(name,underline *len(name)))<EOL><DEDENT>def _data(self,items):<EOL><INDENT>ljust=max(len(name)for name,_ in items)+<EOL>for name,value in items :<EOL><INDENT>if value :<EOL><INDENT>text='%s%s'%((name +':').ljust(ljust),value)<EOL>self._console(self._wrap(text,subsequent_indent=' '*ljust))<EOL><DEDENT> <DEDENT> <DEDENT>def _doc(self,doc):<EOL><INDENT>self._console('')<EOL>for line in doc.splitlines():<EOL><INDENT>self._console(self._wrap(line))<EOL><DEDENT>if doc :<EOL><INDENT>self._console('')<EOL><DEDENT> <DEDENT>def _wrap(self,text,width=,**config):<EOL><INDENT>return '\n'.join(textwrap.wrap(text,width=width,**config))<EOL><DEDENT> <DEDENT>class KeywordMatcher(object):<EOL><INDENT>def __init__(self,libdoc):<EOL><INDENT>self._keywords=libdoc.keywords <EOL><DEDENT>def search(self,patterns):<EOL><INDENT>matcher=MultiMatcher(patterns,match_if_no_patterns=True)<EOL>for kw in self._keywords :<EOL><INDENT>if matcher.match(kw.name):<EOL><INDENT>yield kw <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT><EOF><BOF>from robot.utils import(format_assign_message,get_elapsed_time,<EOL>get_error_message,get_timestamp,plural_or_not)<EOL>from robot.errors import(DataError,ExecutionFailed,ExecutionFailures,<EOL>HandlerExecutionFailed)<EOL>from robot.common import BaseKeyword <EOL>from robot.variables import is_scalar_var,VariableAssigner <EOL>class Keywords(object):<EOL><INDENT>def __init__(self,steps,template=None):<EOL><INDENT>self._keywords=[]<EOL>self._templated=bool(template)<EOL>if self._templated :<EOL><INDENT>steps=[s.apply_template(template)for s in steps ]<EOL><DEDENT>for s in steps :<EOL><INDENT>self._add_step(s,template)<EOL><DEDENT> <DEDENT>def _add_step(self,step,template):<EOL><INDENT>if step.is_comment():<EOL><INDENT>return <EOL><DEDENT>if step.is_for_loop():<EOL><INDENT>keyword=ForLoop(step,template)<EOL><DEDENT>else :<EOL><INDENT>keyword=Keyword(step.keyword,step.args,step.assign)<EOL><DEDENT>self.add_keyword(keyword)<EOL><DEDENT>def add_keyword(self,keyword):<EOL><INDENT>self._keywords.append(keyword)<EOL><DEDENT>def run(self,context):<EOL><INDENT>errors=[]<EOL>for kw in self._keywords :<EOL><INDENT>try :<EOL><INDENT>kw.run(context)<EOL><DEDENT>except ExecutionFailed,err :<EOL><INDENT>errors.extend(err.get_errors())<EOL>if not err.can_continue(context.teardown,self._templated,<EOL>context.dry_run):<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT>if errors :<EOL><INDENT>raise ExecutionFailures(errors)<EOL><DEDENT> <DEDENT>def __nonzero__(self):<EOL><INDENT>return bool(self._keywords)<EOL><DEDENT>def __iter__(self):<EOL><INDENT>return iter(self._keywords)<EOL><DEDENT> <DEDENT>class Keyword(BaseKeyword):<EOL><INDENT>def __init__(self,name,args,assign=None,type='kw'):<EOL><INDENT>BaseKeyword.__init__(self,name,args,type=type)<EOL>self.assign=assign or []<EOL>self.handler_name=name <EOL><DEDENT>def run(self,context):<EOL><INDENT>handler=self._start(context)<EOL>try :<EOL><INDENT>return_value=self._run(handler,context)<EOL><DEDENT>except ExecutionFailed,err :<EOL><INDENT>self.status='FAIL'if not err.exit_for_loop else 'PASS'<EOL>self._end(context,error=err)<EOL>raise <EOL><DEDENT>else :<EOL><INDENT>if not(context.dry_run and handler.type=='library'):<EOL><INDENT>self.status='PASS'<EOL><DEDENT>self._end(context,return_value)<EOL>return return_value <EOL><DEDENT> <DEDENT>def _start(self,context):<EOL><INDENT>handler=context.get_handler(self.handler_name)<EOL>handler.init_keyword(context.get_current_vars())<EOL>self.name=self._get_name(handler.longname)<EOL>self.doc=handler.shortdoc <EOL>self.timeout=getattr(handler,'timeout','')<EOL>self.starttime=get_timestamp()<EOL>context.start_keyword(self)<EOL>if self.doc.startswith('*DEPRECATED*'):<EOL><INDENT>msg=self.doc.replace('*DEPRECATED*','',).strip()<EOL>name=self.name.split('}= ',)[-]<EOL>context.warn('<STR_LIT>'%(name,msg))<EOL><DEDENT>return handler <EOL><DEDENT>def _get_name(self,handler_longname):<EOL><INDENT>if not self.assign :<EOL><INDENT>return handler_longname <EOL><DEDENT>return '%s= %s'%(', '.join(a.rstrip('= ')for a in self.assign),<EOL>handler_longname)<EOL><DEDENT>def _run(self,handler,context):<EOL><INDENT>try :<EOL><INDENT>return handler.run(context,self.args [:])<EOL><DEDENT>except ExecutionFailed :<EOL><INDENT>raise <EOL><DEDENT>except :<EOL><INDENT>self._report_failure(context)<EOL><DEDENT> <DEDENT>def _end(self,context,return_value=None,error=None):<EOL><INDENT>self.endtime=get_timestamp()<EOL>self.elapsedtime=get_elapsed_time(self.starttime,self.endtime)<EOL>try :<EOL><INDENT>if not error or error.can_continue(context.teardown):<EOL><INDENT>self._set_variables(context,return_value)<EOL><DEDENT> <DEDENT>finally :<EOL><INDENT>context.end_keyword(self)<EOL><DEDENT> <DEDENT>def _set_variables(self,context,return_value):<EOL><INDENT>try :<EOL><INDENT>VariableAssigner(self.assign).assign(context,return_value)<EOL><DEDENT>except DataError,err :<EOL><INDENT>self.status='FAIL'<EOL>msg=unicode(err)<EOL>context.output.fail(msg)<EOL>raise ExecutionFailed(msg,syntax=True)<EOL><DEDENT> <DEDENT>def _report_failure(self,context):<EOL><INDENT>failure=HandlerExecutionFailed()<EOL>if not failure.exit_for_loop :<EOL><INDENT>context.output.fail(failure.full_message)<EOL>if failure.traceback :<EOL><INDENT>context.output.debug(failure.traceback)<EOL><DEDENT> <DEDENT>raise failure <EOL><DEDENT> <DEDENT>class ForLoop(BaseKeyword):<EOL><INDENT>def __init__(self,forstep,template=None):<EOL><INDENT>BaseKeyword.__init__(self,self._get_name(forstep),type='for')<EOL>self.vars=forstep.vars <EOL>self.items=forstep.items <EOL>self.range=forstep.range <EOL>self.keywords=Keywords(forstep.steps,template)<EOL>self._templated=bool(template)<EOL><DEDENT>def _get_name(self,data):<EOL><INDENT>return '%s %s [ %s ]'%(' | '.join(data.vars),<EOL>'IN'if not data.range else 'IN RANGE',<EOL>' | '.join(data.items))<EOL><DEDENT>def run(self,context):<EOL><INDENT>self.starttime=get_timestamp()<EOL>context.output.start_keyword(self)<EOL>try :<EOL><INDENT>self._validate()<EOL>self._run(context)<EOL><DEDENT>except ExecutionFailed,err :<EOL><INDENT>error=err <EOL><DEDENT>except DataError,err :<EOL><INDENT>msg=unicode(err)<EOL>context.output.fail(msg)<EOL>error=ExecutionFailed(msg,syntax=True)<EOL><DEDENT>else :<EOL><INDENT>error=None <EOL><DEDENT>self.status='PASS'if not error else 'FAIL'<EOL>self.endtime=get_timestamp()<EOL>self.elapsedtime=get_elapsed_time(self.starttime,self.endtime)<EOL>context.output.end_keyword(self)<EOL>if error :<EOL><INDENT>raise error <EOL><DEDENT> <DEDENT>def _validate(self):<EOL><INDENT>if not self.vars :<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>for var in self.vars :<EOL><INDENT>if not is_scalar_var(var):<EOL><INDENT>raise DataError('<STR_LIT>'%var)<EOL><DEDENT> <DEDENT>if not self.items :<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>if not self.keywords :<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT> <DEDENT>def _run(self,context):<EOL><INDENT>errors=[]<EOL>items,iteration_steps=self._get_items_and_iteration_steps(context)<EOL>for i in iteration_steps :<EOL><INDENT>values=items [i :i +len(self.vars)]<EOL>err=self._run_one_round(context,self.vars,values)<EOL>if err :<EOL><INDENT>if err.exit_for_loop :<EOL><INDENT>break <EOL><DEDENT>errors.extend(err.get_errors())<EOL>if not err.can_continue(context.teardown,self._templated,<EOL>context.dry_run):<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT>if errors :<EOL><INDENT>raise ExecutionFailures(errors)<EOL><DEDENT> <DEDENT>def _get_items_and_iteration_steps(self,context):<EOL><INDENT>if context.dry_run :<EOL><INDENT>return self.vars,[]<EOL><DEDENT>items=self._replace_vars_from_items(context.get_current_vars())<EOL>return items,range(,len(items),len(self.vars))<EOL><DEDENT>def _run_one_round(self,context,variables,values):<EOL><INDENT>foritem=_ForItem(variables,values)<EOL>context.output.start_keyword(foritem)<EOL>for var,value in zip(variables,values):<EOL><INDENT>context.get_current_vars()[var ]=value <EOL><DEDENT>try :<EOL><INDENT>self.keywords.run(context)<EOL><DEDENT>except ExecutionFailed,err :<EOL><INDENT>error=err <EOL><DEDENT>else :<EOL><INDENT>error=None <EOL><DEDENT>foritem.end('PASS'if not error or error.exit_for_loop else 'FAIL')<EOL>context.output.end_keyword(foritem)<EOL>return error <EOL><DEDENT>def _replace_vars_from_items(self,variables):<EOL><INDENT>items=variables.replace_list(self.items)<EOL>if self.range :<EOL><INDENT>items=self._get_range_items(items)<EOL><DEDENT>if len(items)%len(self.vars)==:<EOL><INDENT>return items <EOL><DEDENT>raise DataError('<STR_LIT>'<EOL>'<STR_LIT>'<EOL>%(len(self.vars),len(items),plural_or_not(items)))<EOL><DEDENT>def _get_range_items(self,items):<EOL><INDENT>try :<EOL><INDENT>items=[self._to_int_with_arithmetics(item)for item in items ]<EOL><DEDENT>except :<EOL><INDENT>raise DataError('<STR_LIT>'<EOL>%get_error_message())<EOL><DEDENT>if not <=len(items)<=:<EOL><INDENT>raise DataError('<STR_LIT>'<EOL>'got %d instead.'%len(items))<EOL><DEDENT>return range(*items)<EOL><DEDENT>def _to_int_with_arithmetics(self,item):<EOL><INDENT>item=str(item)<EOL>try :<EOL><INDENT>return int(item)<EOL><DEDENT>except ValueError :<EOL><INDENT>return int(eval(item))<EOL><DEDENT> <DEDENT> <DEDENT>class _ForItem(BaseKeyword):<EOL><INDENT>def __init__(self,vars,items):<EOL><INDENT>name=', '.join(format_assign_message(var,item)<EOL>for var,item in zip(vars,items))<EOL>BaseKeyword.__init__(self,name,type='foritem')<EOL>self.starttime=get_timestamp()<EOL><DEDENT>def end(self,status):<EOL><INDENT>self.status=status <EOL>self.endtime=get_timestamp()<EOL>self.elapsedtime=get_elapsed_time(self.starttime,self.endtime)<EOL><DEDENT> <DEDENT><EOF><BOF>__author__='Hari Jiang'<EOF><BOF>import numpy as np <EOL>import cv2 <EOL>import cv2.cv as cv <EOL>from video import create_capture <EOL>from common import clock,draw_str <EOL>help_message='<STR_LIT>'<EOL>def detect(img,cascade):<EOL><INDENT>rects=cascade.detectMultiScale(img,scaleFactor=,minNeighbors=,minSize=(,),flags=cv.CV_HAAR_SCALE_IMAGE)<EOL>if len(rects)==:<EOL><INDENT>return []<EOL><DEDENT>rects [:,:]+=rects [:,:]<EOL>return rects <EOL><DEDENT>def draw_rects(img,rects,color):<EOL><INDENT>for x1,y1,x2,y2 in rects :<EOL><INDENT>cv2.rectangle(img,(x1,y1),(x2,y2),color,)<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>import sys,getopt <EOL>print help_message <EOL>args,video_src=getopt.getopt(sys.argv [:],'',['cascade=','nested-cascade='])<EOL>try :video_src=video_src []<EOL>except :video_src=<EOL>args=dict(args)<EOL>cascade_fn=args.get('--cascade','<STR_LIT>')<EOL>nested_fn=args.get('<STR_LIT>','<STR_LIT>')<EOL>cascade=cv2.CascadeClassifier(cascade_fn)<EOL>nested=cv2.CascadeClassifier(nested_fn)<EOL>cam=create_capture(video_src,fallback='<STR_LIT>')<EOL>while True :<EOL><INDENT>ret,img=cam.read()<EOL>gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)<EOL>gray=cv2.equalizeHist(gray)<EOL>t=clock()<EOL>rects=detect(gray,cascade)<EOL>vis=img.copy()<EOL>draw_rects(vis,rects,(,,))<EOL>for x1,y1,x2,y2 in rects :<EOL><INDENT>roi=gray [y1 :y2,x1 :x2 ]<EOL>vis_roi=vis [y1 :y2,x1 :x2 ]<EOL>subrects=detect(roi.copy(),nested)<EOL>draw_rects(vis_roi,subrects,(,,))<EOL><DEDENT>dt=clock()-t <EOL>draw_str(vis,(,),'time: %.1f ms'%(dt *))<EOL>cv2.imshow('facedetect',vis)<EOL>if &cv2.waitKey()==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>from __future__ import unicode_literals <EOL>from django.db import migrations,models <EOL>class Migration(migrations.Migration):<EOL><INDENT>dependencies=[('buildservice','<STR_LIT>'),<EOL>]<EOL>operations=[<EOL>migrations.AddField(<EOL>model_name='repository',<EOL>name='default_branch',<EOL>field=models.CharField(default=b'master',max_length=),),<EOL>]<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>if __name__=='__main__':<EOL><INDENT>import sys <EOL>try :fn=sys.argv []<EOL>except :fn='<STR_LIT>'<EOL>img=cv2.imread(fn)<EOL>gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)<EOL>h,w=img.shape [:]<EOL>eigen=cv2.cornerEigenValsAndVecs(gray,,)<EOL>eigen=eigen.reshape(h,w,,)<EOL>flow=eigen [:,:,]<EOL>vis=img.copy()<EOL>vis [:]=(+np.uint32(vis))/<EOL>d=<EOL>points=np.dstack(np.mgrid [d /:w :d,d /:h :d ]).reshape(-,)<EOL>for x,y in points :<EOL><INDENT>vx,vy=np.int32(flow [y,x ]*d)<EOL>cv2.line(vis,(x -vx,y -vy),(x +vx,y +vy),(,,),,cv2.CV_AA)<EOL><DEDENT>cv2.imshow('input',img)<EOL>cv2.imshow('flow',vis)<EOL>cv2.waitKey()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>from time import clock <EOL>from numpy import pi,sin,cos <EOL>import common <EOL>class VideoSynthBase(object):<EOL><INDENT>def __init__(self,size=None,noise=,bg=None,**params):<EOL><INDENT>self.bg=None <EOL>self.frame_size=(,)<EOL>if bg is not None :<EOL><INDENT>self.bg=cv2.imread(bg,)<EOL>h,w=self.bg.shape [:]<EOL>self.frame_size=(w,h)<EOL><DEDENT>if size is not None :<EOL><INDENT>w,h=map(int,size.split('x'))<EOL>self.frame_size=(w,h)<EOL>self.bg=cv2.resize(self.bg,self.frame_size)<EOL><DEDENT>self.noise=float(noise)<EOL><DEDENT>def render(self,dst):<EOL><INDENT>pass <EOL><DEDENT>def read(self,dst=None):<EOL><INDENT>w,h=self.frame_size <EOL>if self.bg is None :<EOL><INDENT>buf=np.zeros((h,w,),np.uint8)<EOL><DEDENT>else :<EOL><INDENT>buf=self.bg.copy()<EOL><DEDENT>self.render(buf)<EOL>if self.noise >:<EOL><INDENT>noise=np.zeros((h,w,),np.int8)<EOL>cv2.randn(noise,np.zeros(),np.ones()**self.noise)<EOL>buf=cv2.add(buf,noise,dtype=cv2.CV_8UC3)<EOL><DEDENT>return True,buf <EOL><DEDENT>def isOpened(self):<EOL><INDENT>return True <EOL><DEDENT> <DEDENT>class Chess(VideoSynthBase):<EOL><INDENT>def __init__(self,**kw):<EOL><INDENT>super(Chess,self).__init__(**kw)<EOL>w,h=self.frame_size <EOL>self.grid_size=sx,sy=,<EOL>white_quads=[]<EOL>black_quads=[]<EOL>for i,j in np.ndindex(sy,sx):<EOL><INDENT>q=[[j,i,],[j +,i,],[j +,i +,],[j,i +,]]<EOL>[white_quads,black_quads ][(i +j)%].append(q)<EOL><DEDENT>self.white_quads=np.float32(white_quads)<EOL>self.black_quads=np.float32(black_quads)<EOL>fx=<EOL>self.K=np.float64([[fx *w,,*(w -)],<EOL>[,fx *w,*(h -)],<EOL>[,,]])<EOL>self.dist_coef=np.float64([-,,,])<EOL>self.t=<EOL><DEDENT>def draw_quads(self,img,quads,color=(,,)):<EOL><INDENT>img_quads=cv2.projectPoints(quads.reshape(-,),self.rvec,self.tvec,self.K,self.dist_coef)[]<EOL>img_quads.shape=quads.shape [:]+(,)<EOL>for q in img_quads :<EOL><INDENT>cv2.fillConvexPoly(img,np.int32(q *),color,cv2.CV_AA,shift=)<EOL><DEDENT> <DEDENT>def render(self,dst):<EOL><INDENT>t=self.t <EOL>self.t +=/<EOL>sx,sy=self.grid_size <EOL>center=np.array([*sx,*sy,])<EOL>phi=pi /+sin(t *)*pi /<EOL>c,s=cos(phi),sin(phi)<EOL>ofs=np.array([sin(*t),cos(*t),])*sx *<EOL>eye_pos=center +np.array([cos(t)*c,sin(t)*c,s ])*+ofs <EOL>target_pos=center +ofs <EOL>R,self.tvec=common.lookat(eye_pos,target_pos)<EOL>self.rvec=common.mtx2rvec(R)<EOL>self.draw_quads(dst,self.white_quads,(,,))<EOL>self.draw_quads(dst,self.black_quads,(,,))<EOL><DEDENT> <DEDENT>classes=dict(chess=Chess)<EOL>presets=dict(<EOL>empty='synth:',<EOL>lena='<STR_LIT>',<EOL>chess='<STR_LIT>')<EOL>def create_capture(source=,fallback=presets ['chess']):<EOL><INDENT> '<STR_LIT>'<EOL>source=str(source).strip()<EOL>chunks=source.split(':')<EOL>if len(chunks)>and len(chunks [])==and chunks [].isalpha():<EOL><INDENT>chunks []=chunks []+':'+chunks []<EOL>del chunks []<EOL><DEDENT>source=chunks []<EOL>try :source=int(source)<EOL>except ValueError :pass <EOL>params=dict(s.split('=')for s in chunks [:])<EOL>cap=None <EOL>if source=='synth':<EOL><INDENT>Class=classes.get(params.get('class',None),VideoSynthBase)<EOL>try :cap=Class(**params)<EOL>except :pass <EOL><DEDENT>else :<EOL><INDENT>cap=cv2.VideoCapture(source)<EOL>if 'size'in params :<EOL><INDENT>w,h=map(int,params ['size'].split('x'))<EOL>cap.set(cv2.cv.CV_CAP_PROP_FRAME_WIDTH,w)<EOL>cap.set(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT,h)<EOL><DEDENT> <DEDENT>if cap is None or not cap.isOpened():<EOL><INDENT>print '<STR_LIT>',source <EOL>if fallback is not None :<EOL><INDENT>return create_capture(fallback,None)<EOL><DEDENT> <DEDENT>return cap <EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>import sys <EOL>import getopt <EOL>print __doc__ <EOL>args,sources=getopt.getopt(sys.argv [:],'','shotdir=')<EOL>args=dict(args)<EOL>shotdir=args.get('--shotdir','.')<EOL>if len(sources)==:<EOL><INDENT>sources=[]<EOL><DEDENT>caps=map(create_capture,sources)<EOL>shot_idx=<EOL>while True :<EOL><INDENT>imgs=[]<EOL>for i,cap in enumerate(caps):<EOL><INDENT>ret,img=cap.read()<EOL>imgs.append(img)<EOL>cv2.imshow('capture %d'%i,img)<EOL><DEDENT>ch=&cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT>if ch==ord(' '):<EOL><INDENT>for i,img in enumerate(imgs):<EOL><INDENT>fn='<STR_LIT>'%(shotdir,i,shot_idx)<EOL>cv2.imwrite(fn,img)<EOL>print fn,'saved'<EOL><DEDENT>shot_idx +=<EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>import cv2 <EOL>import numpy as np <EOL>def equal(p0,p1,p2,tolerance):<EOL><INDENT>d1,d2=(p0 -p1).astype('float'),(p2 -p1).astype('float')<EOL>l1=np.sqrt(d1 []**+d1 []**)<EOL>l2=np.sqrt(d2 []**+d2 []**)<EOL>if l1 <=l2 *(+tolerance)and l1 >=l2 *(-tolerance):<EOL><INDENT>return True <EOL><DEDENT>else :<EOL><INDENT>return False <EOL><DEDENT> <DEDENT>def imgproc(frame):<EOL><INDENT>background=np.full_like(frame,)<EOL>background [:,:,]=<EOL>background [:,:,]=<EOL>img=frame -background <EOL>gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)<EOL>thresh1,thresh=cv2.threshold(gray,,,cv2.THRESH_BINARY)<EOL>contours,hry=cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)<EOL>cpframe=frame.copy()<EOL>squares=[]<EOL>quadrangles=[]<EOL>big_cycle=[]<EOL>white_small_cycle=[]<EOL>blue_small_cycle=[]<EOL>pink_oval=[]<EOL>white_oval=[]<EOL>yellow_oval=[]<EOL>capsule_3=[]<EOL>capsule_4=[]<EOL>for cnt in contours :<EOL><INDENT>cnt_len=cv2.arcLength(cnt,True)<EOL>cnt=cv2.approxPolyDP(cnt,*cnt_len,True)<EOL>if cv2.isContourConvex(cnt):<EOL><INDENT>if len(cnt)==:<EOL><INDENT>cnt=cnt.reshape(-,)<EOL>if equal(cnt [],cnt [],cnt [],):<EOL><INDENT>squares.append(cnt)<EOL><DEDENT>else :<EOL><INDENT>quadrangles.append(cnt)<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>cnt=cnt.reshape(-,)<EOL>rect=cv2.minAreaRect(cnt)<EOL>box=cv2.cv.BoxPoints(rect)<EOL>box=np.int0(box)<EOL>if equal(box [],box [],box [],):<EOL><INDENT>if cv2.contourArea(cnt)>:<EOL><INDENT>big_cycle.append(cnt)<EOL><DEDENT>else :<EOL><INDENT>cg=np.mean(cnt,axis=)<EOL>org=int(cg []),int(cg [])<EOL>rgb=img [org []][org []]<EOL>rgb_mean=np.average(rgb)<EOL>if rgb_mean >:<EOL><INDENT>white_small_cycle.append(cnt)<EOL><DEDENT>else :<EOL><INDENT>blue_small_cycle.append(cnt)<EOL><DEDENT> <DEDENT> <DEDENT>else :<EOL><INDENT>cv2.drawContours(cpframe,[box ],,(,,),)<EOL>cg=np.mean(cnt,axis=)<EOL>org=int(cg []),int(cg [])<EOL>rgb=img [org []][org []]<EOL>rgb_mean=np.average(rgb)<EOL>if rgb_mean >:<EOL><INDENT>pink_oval.append(cnt)<EOL><DEDENT>elif rgb []==:<EOL><INDENT>white_oval.append(cnt)<EOL><DEDENT>elif rgb_mean >:<EOL><INDENT>capsule_4.append(cnt)<EOL><DEDENT>elif rgb_mean <:<EOL><INDENT>yellow_oval.append(cnt)<EOL><DEDENT>else :<EOL><INDENT>capsule_3.append(cnt)<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>for ctr in squares :<EOL><INDENT>m=np.mean(ctr,axis=)<EOL>org=int(m []),int(m [])<EOL>cv2.putText(frame,"8",org,cv2.FONT_HERSHEY_SIMPLEX,,(,,),)<EOL><DEDENT>for ctr in quadrangles :<EOL><INDENT>m=np.mean(ctr,axis=)<EOL>org=int(m []),int(m [])<EOL>cv2.putText(frame,"2",org,cv2.FONT_HERSHEY_SIMPLEX,,(,,),)<EOL><DEDENT>for ctr in big_cycle :<EOL><INDENT>m=np.mean(ctr,axis=)<EOL>org=int(m []),int(m [])<EOL>cv2.putText(frame,"10",org,cv2.FONT_HERSHEY_SIMPLEX,,(,,),)<EOL><DEDENT>for ctr in blue_small_cycle :<EOL><INDENT>m=np.mean(ctr,axis=)<EOL>org=int(m []),int(m [])<EOL>cv2.putText(frame,"1",org,cv2.FONT_HERSHEY_SIMPLEX,,(,,),)<EOL><DEDENT>for ctr in white_small_cycle :<EOL><INDENT>m=np.mean(ctr,axis=)<EOL>org=int(m []),int(m [])<EOL>cv2.putText(frame,"9",org,cv2.FONT_HERSHEY_SIMPLEX,,(,,),)<EOL><DEDENT>for ctr in pink_oval :<EOL><INDENT>m=np.mean(ctr,axis=)<EOL>org=int(m []),int(m [])<EOL>cv2.putText(frame,"6",org,cv2.FONT_HERSHEY_SIMPLEX,,(,,),)<EOL><DEDENT>for ctr in white_oval :<EOL><INDENT>m=np.mean(ctr,axis=)<EOL>org=int(m []),int(m [])<EOL>cv2.putText(frame,"7",org,cv2.FONT_HERSHEY_SIMPLEX,,(,,),)<EOL><DEDENT>for ctr in capsule_4 :<EOL><INDENT>m=np.mean(ctr,axis=)<EOL>org=int(m []),int(m [])<EOL>cv2.putText(frame,"4",org,cv2.FONT_HERSHEY_SIMPLEX,,(,,),)<EOL><DEDENT>for ctr in yellow_oval :<EOL><INDENT>m=np.mean(ctr,axis=)<EOL>org=int(m []),int(m [])<EOL>cv2.putText(frame,"5",org,cv2.FONT_HERSHEY_SIMPLEX,,(,,),)<EOL><DEDENT>for ctr in capsule_3 :<EOL><INDENT>m=np.mean(ctr,axis=)<EOL>org=int(m []),int(m [])<EOL>cv2.putText(frame,"3",org,cv2.FONT_HERSHEY_SIMPLEX,,(,,),)<EOL><DEDENT>return frame <EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>pills=cv2.imread('pill.png')<EOL>cv2.imshow('pill challenge',imgproc(pills))<EOL>cv2.waitKey()<DEDENT><EOF><BOF>from robot.model import ItemList <EOL>from robot.utils import setter <EOL>from.message import Message <EOL>class ExecutionErrors(object):<EOL><INDENT>message_class=Message <EOL>def __init__(self,messages=None):<EOL><INDENT>self.messages=messages <EOL><DEDENT>@setter <EOL>def messages(self,msgs):<EOL><INDENT>return ItemList(self.message_class,items=msgs)<EOL><DEDENT>def add(self,other):<EOL><INDENT>self.messages.extend(other.messages)<EOL><DEDENT>def visit(self,visitor):<EOL><INDENT>visitor.visit_errors(self)<EOL><DEDENT>def __iter__(self):<EOL><INDENT>return iter(self.messages)<EOL><DEDENT>def __len__(self):<EOL><INDENT>return len(self.messages)<EOL><DEDENT> <DEDENT><EOF><BOF>import csv <EOL>from numpy import array <EOL>from StringIO import StringIO <EOL>from pyspark import SparkConf,SparkContext <EOL>from pyspark.mllib.classification import LogisticRegressionWithLBFGS,LogisticRegressionModel <EOL>from pyspark.mllib.regression import LabeledPoint <EOL>def parsePoint(tup):<EOL><INDENT> '<STR_LIT>'<EOL>values=[float(x)for x in tup [].split(';')]<EOL>return LabeledPoint(tup [],values [:])<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>conf=SparkConf().setAppName('<STR_LIT>')<EOL>sc=SparkContext(conf=conf)<EOL>print "Reading Data"+"\n"<EOL>red_wines=sc.textFile('<STR_LIT>')<EOL>white_wines=sc.textFile('<STR_LIT>')<EOL>red_wines_data=red_wines.zipWithIndex().filter(lambda s :s []>).map(lambda s :s [])<EOL>white_wines_data=white_wines.zipWithIndex().filter(lambda s :s []>).map(lambda s :s [])<EOL>labelled_white=white_wines_data.map(lambda s :(,s)).map(parsePoint)<EOL>labelled_red=red_wines_data.map(lambda s :(,s)).map(parsePoint)<EOL>all_wine=labelled_red.union(labelled_white)<EOL>print '<STR_LIT>'+str(all_wine.count())+" data points "+"\n"<EOL>model=LogisticRegressionWithLBFGS.train(all_wine)<EOL>print '<STR_LIT>'+"\n"<EOL>labelsAndPreds=all_wine.map(lambda p :(p.label,model.predict(p.features)))<EOL>trainErr=labelsAndPreds.filter(lambda(v,p):v !=p).count()/float(all_wine.count())<EOL>print('<STR_LIT>'+str(trainErr))+"\n"<DEDENT><EOF><BOF>'<STR_LIT>'<EOF><BOF>from fixture import Setup,Teardown <EOL>from timeouts import TestTimeout <EOL>class DefaultValues(object):<EOL><INDENT>def __init__(self,settings,parent_default_values=None):<EOL><INDENT>self._parent=parent_default_values <EOL>self._setup=settings.test_setup <EOL>self._teardown=settings.test_teardown <EOL>self._timeout=settings.test_timeout <EOL>self._force_tags=settings.force_tags <EOL>self._default_tags=settings.default_tags <EOL>self._test_template=settings.test_template <EOL><DEDENT>def get_setup(self,tc_setup):<EOL><INDENT>setup=tc_setup if tc_setup.is_set()else self._get_default_setup()<EOL>return Setup(setup.name,setup.args)<EOL><DEDENT>def _get_default_setup(self):<EOL><INDENT>if self._setup.is_set()or not self._parent :<EOL><INDENT>return self._setup <EOL><DEDENT>return self._parent._get_default_setup()<EOL><DEDENT>def get_teardown(self,tc_teardown):<EOL><INDENT>td=tc_teardown if tc_teardown.is_set()else self._get_default_teardown()<EOL>return Teardown(td.name,td.args)<EOL><DEDENT>def _get_default_teardown(self):<EOL><INDENT>if self._teardown.is_set()or not self._parent :<EOL><INDENT>return self._teardown <EOL><DEDENT>return self._parent._get_default_teardown()<EOL><DEDENT>def get_timeout(self,tc_timeout):<EOL><INDENT>timeout=tc_timeout if tc_timeout.is_set()else self._get_default_timeout()<EOL>return TestTimeout(timeout.value,timeout.message)<EOL><DEDENT>def _get_default_timeout(self):<EOL><INDENT>if self._timeout.is_set()or not self._parent :<EOL><INDENT>return self._timeout <EOL><DEDENT>return self._parent._get_default_timeout()<EOL><DEDENT>def get_tags(self,tc_tags):<EOL><INDENT>tags=tc_tags if tc_tags.is_set()else self._default_tags <EOL>return(tags +self._get_force_tags()).value <EOL><DEDENT>def _get_force_tags(self):<EOL><INDENT>if not self._parent :<EOL><INDENT>return self._force_tags <EOL><DEDENT>return self._force_tags +self._parent._get_force_tags()<EOL><DEDENT>def get_template(self,template):<EOL><INDENT>tmpl=(template if template.is_set()else self._test_template).value <EOL>return tmpl if tmpl and tmpl.upper()!='NONE'else None <EOL><DEDENT> <DEDENT><EOF><BOF>from django.contrib.auth import get_user_model <EOL>from django.contrib.auth.models import AnonymousUser <EOL>from django.test import TestCase <EOL>from github3.repos.repo import Repository as GithubRepository <EOL>from buildservice.models import Repository,Webhook <EOL>from buildservice.utils import views <EOL>class ViewsUtilsTestCase(TestCase):<EOL><INDENT>def test_group_repositories(self):<EOL><INDENT>u1r1=GithubRepository({'name':'u1/repo1','owner':{'login':'u1'}})<EOL>u1r2=GithubRepository({'name':'u1/repo2','owner':{'login':'u1'}})<EOL>o1r3=GithubRepository({'name':'org1/repo3','owner':{'login':'org1'}})<EOL>o1r4=GithubRepository({'name':'org1/repo4','owner':{'login':'org1'}})<EOL>o2r5=GithubRepository({'name':'org2/repo5','owner':{'login':'org2'}})<EOL>o3r6=GithubRepository({'name':'org3/repo6','owner':{'login':'org3'}})<EOL>repos=[u1r1,u1r2,o1r3,o1r4,o2r5,o3r6 ]<EOL>sections=views.group_repositories(repos)<EOL>self.assertEqual(sections,[('org1',[o1r3,o1r4 ]),('u1',[u1r1,u1r2 ]),('Other',[o2r5,o3r6 ])<EOL>])<EOL><DEDENT>def test_get_user_active_repositories_anonymous(self):<EOL><INDENT>self.assertEqual(views.get_user_active_repositories(AnonymousUser()),[])<EOL><DEDENT>def test_get_user_active_repositories_ok(self):<EOL><INDENT>user=get_user_model().objects.create_user(username='yop',password='yyy')<EOL>r1=Repository.objects.create(name='user/r1')<EOL>r2=Repository.objects.create(name='user/r2')<EOL>Repository.objects.create(name='user/r3')<EOL>r1.users.add(user)<EOL>r2.users.add(user)<EOL>Webhook.objects.create(repository=r1)<EOL>Webhook.objects.create(repository=r2,active=False)<EOL>self.assertEqual(list(views.get_user_active_repositories(user)),[r1 ])<EOL><DEDENT> <DEDENT><EOF><BOF>import unittest <EOL>from flask import url_for <EOL>from yapper import create_app,db <EOL>from yapper.blueprints.user.models import Role,User <EOL>class UserFormTestCase(unittest.TestCase):<EOL><INDENT>def setUp(self):<EOL><INDENT>self.app=create_app('test')<EOL>self.app_context=self.app.app_context()<EOL>self.client=self.app.test_client()<EOL>self.app_context.push()<EOL>db.create_all()<EOL>Role.insert_roles()<EOL>u=User(<EOL>email=self.app.config ['FLASKY_ADMIN'],<EOL>password='testpass',<EOL>name='Admin')<EOL>u2=User(<EOL>email='<STR_LIT>',<EOL>password='testpass',<EOL>name='Test User 2',<EOL>status=True )<EOL>u3=User(<EOL>email='<STR_LIT>',<EOL>password='testpass',<EOL>name='Test User 3',<EOL>status=True )<EOL>db.session.add_all([u,u2,u3 ])<EOL>db.session.commit()<EOL><DEDENT>def tearDown(self):<EOL><INDENT>db.session.remove()<EOL>db.drop_all()<EOL>self.app_context.pop()<EOL><DEDENT>def login(self,username,password):<EOL><INDENT>return self.client.post(url_for('user.login'),data=dict(<EOL>email=username,<EOL>password=password,<EOL>remember_me='y'),follow_redirects=True)<EOL><DEDENT>def logout(self):<EOL><INDENT>return self.client.get(url_for('user.logout'),follow_redirects=False)<EOL><DEDENT>def test_post_with_empty_field(self):<EOL><INDENT>rv=self.login(self.app.config ['FLASKY_ADMIN'],'testpass')<EOL>rv=self.client.post(url_for('blog.add'),data=dict(<EOL>title='Hello'),follow_redirects=False)<EOL>assert '<STR_LIT>'in rv.data <EOL><DEDENT>def test_post_create_via_form(self):<EOL><INDENT>rv=self.login('<STR_LIT>','testpass')<EOL>rv=self.client.post(url_for('blog.add'),data=dict(<EOL>title='Hello',<EOL>description='Hi',<EOL>body='# Hello World'),follow_redirects=True)<EOL>assert '<STR_LIT>'in rv.data <EOL><DEDENT>def test_post_deletable_by_author(self):<EOL><INDENT>rv=self.login('<STR_LIT>','testpass')<EOL>rv=self.client.post(url_for('blog.add'),data=dict(<EOL>title='Hello',<EOL>description='Hi',<EOL>body='### Hello World'),follow_redirects=True)<EOL>assert '<STR_LIT>'in rv.data <EOL>rv=self.client.delete(<EOL>url_for('blog.delete',pid=),follow_redirects=True)<EOL>assert rv.status_code==<EOL>assert 'Post deleted.'in rv.data <EOL><DEDENT>def test_post_by_u1_not_deletable_by_u2(self):<EOL><INDENT>rv=self.login('<STR_LIT>','testpass')<EOL>rv=self.client.post(url_for('blog.add'),data=dict(<EOL>title='Hello',<EOL>description='Hi',<EOL>body='### Hello World'),follow_redirects=True)<EOL>assert '<STR_LIT>'in rv.data <EOL>rv=self.logout()<EOL>assert rv.status_code==<EOL>rv=self.client.delete(<EOL>url_for('blog.delete',pid=),follow_redirects=True)<EOL>assert rv.status_code==<EOL><DEDENT>def test_any_post_deletable_by_admin(self):<EOL><INDENT>rv=self.login('<STR_LIT>','testpass')<EOL>rv=self.client.post(url_for('blog.add'),data=dict(<EOL>title='Hello',<EOL>description='Hi',<EOL>body='### Hello World'),follow_redirects=True)<EOL>assert rv.status_code==<EOL>assert 'Test User 2'in rv.data <EOL>rv=self.logout()<EOL>assert rv.status_code==<EOL>rv=self.login(self.app.config ['FLASKY_ADMIN'],'testpass')<EOL>rv=self.client.delete(<EOL>url_for('blog.delete',pid=),follow_redirects=True)<EOL>assert rv.status_code==<EOL>assert '<STR_LIT>'in rv.data <EOL>rv=self.client.get(<EOL>url_for('blog.get_post',pid=))<EOL>self.assertTrue(rv.status_code==)<EOL>rv=self.client.post(url_for('blog.add'),data=dict(<EOL>title='Hello',<EOL>description='Hi',<EOL>body='### Hello World'),follow_redirects=True)<EOL>self.assertTrue('<STR_LIT>'in rv.data)<EOL><DEDENT> <DEDENT><EOF><BOF>from robot.utils import html_escape <EOL>from.itemlist import ItemList <EOL>from.modelobject import ModelObject <EOL>class Message(ModelObject):<EOL><INDENT>__slots__=['message','level','html','timestamp','parent']<EOL>def __init__(self,message='',level='INFO',html=False,timestamp=None,<EOL>parent=None):<EOL><INDENT>self.message=message <EOL>self.level=level <EOL>self.html=html <EOL>self.timestamp=timestamp <EOL>self.parent=parent <EOL><DEDENT>@property <EOL>def html_message(self):<EOL><INDENT>return self.message if self.html else html_escape(self.message)<EOL><DEDENT>def visit(self,visitor):<EOL><INDENT>visitor.visit_message(self)<EOL><DEDENT>def __unicode__(self):<EOL><INDENT>return self.message <EOL><DEDENT> <DEDENT>class Messages(ItemList):<EOL><INDENT>__slots__=[]<EOL>def __init__(self,message_class=Message,parent=None,messages=None):<EOL><INDENT>ItemList.__init__(self,message_class,{'parent':parent },messages)<EOL><DEDENT> <DEDENT><EOF><BOF>import time <EOL>import sys <EOL>from subprocess import Popen,PIPE <EOL>import subprocess <EOL>import re <EOL>import json as m_json <EOL>import socket <EOL>import urllib <EOL>try :<EOL><INDENT>from urllib.parse import urlparse <EOL><DEDENT>except ImportError :<EOL><INDENT>from urlparse import urlparse <EOL><DEDENT>try :<EOL><INDENT>import urllib.request <EOL><DEDENT>except ImportError :<EOL><INDENT>import urllib2 <EOL><DEDENT>def get_ip(url):<EOL><INDENT>ip=socket.gethostbyname(url)<EOL>return ip <EOL><DEDENT>def ping(host):<EOL><INDENT>ping=subprocess.Popen(<EOL>["ping","-v","4",host ],<EOL>stdout=subprocess.PIPE,<EOL>stderr=subprocess.PIPE )<EOL>out,error=ping.communicate()<EOL>return out <EOL><DEDENT>def traceroute(url,*arg):<EOL><INDENT>while True :<EOL><INDENT>if 'http'not in url :<EOL><INDENT>url="http://"+url <EOL><DEDENT>elif "www"not in url :<EOL><INDENT>url="www."[:]+url [:]<EOL><DEDENT>else :<EOL><INDENT>url=url <EOL>break <EOL><DEDENT> <DEDENT>url=urlparse(url)<EOL>url=url.netloc <EOL>print(url)<EOL>p=Popen(['tracert',url ],stdout=PIPE)<EOL>while True :<EOL><INDENT>line=p.stdout.readline()<EOL>line2=str(line).replace('\\r','').replace('\\n','')<EOL>if len(arg)>:<EOL><INDENT>file=open(arg [],"a")<EOL>file.write(line2)<EOL>file.close()<EOL><DEDENT>print(line2)<EOL>if not line :<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT>def perform_whois(server,query):<EOL><INDENT>s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)<EOL>s.connect((server,))<EOL>s.send(query +'\r\n')<EOL>message=''<EOL>while len(message)<:<EOL><INDENT>raw=s.recv()<EOL>if(raw==''):<EOL><INDENT>break <EOL><DEDENT>message=message +raw <EOL><DEDENT>return message <EOL><DEDENT>def get_whois_data(domain):<EOL><INDENT>domain=domain.replace('http://','')<EOL>domain=domain.replace('www.','')<EOL>ext=domain [-:]<EOL>if(ext=='com'or ext=='org'or ext=='net'):<EOL><INDENT>whois='<STR_LIT>'<EOL>msg=perform_whois(whois,domain)<EOL>lines=msg.splitlines()<EOL>for line in lines :<EOL><INDENT>if ':'in line :<EOL><INDENT>words=line.split(':')<EOL>if 'Whois'in words []and 'whois.'in words []:<EOL><INDENT>whois=words [].strip()<EOL>break ;<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>else :<EOL><INDENT>ext=domain.split('.')[-]<EOL>whois='whois.iana.org'<EOL>msg=perform_whois(whois,ext)<EOL>lines=msg.splitlines()<EOL>for line in lines :<EOL><INDENT>if ':'in line :<EOL><INDENT>words=line.split(':')<EOL>if 'whois.'in words []and '<STR_LIT>'in words []:<EOL><INDENT>whois=words [].strip()<EOL>break ;<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>msg=perform_whois(whois,domain)<EOL>return msg <EOL><DEDENT>def download_page(url,*arg):<EOL><INDENT>version=(,)<EOL>cur_version=sys.version_info <EOL>if cur_version >=version :<EOL><INDENT>try :<EOL><INDENT>headers={}<EOL>headers ['User-Agent']='<STR_LIT>'<EOL>req=urllib.request.Request(url,headers=headers)<EOL>resp=urllib.request.urlopen(req)<EOL>page=str(resp.read())<EOL>if len(arg)>:<EOL><INDENT>file=open(arg [],"w")<EOL>file.write(page)<EOL>file.close()<EOL>return page <EOL><DEDENT>else :<EOL><INDENT>return page <EOL><DEDENT> <DEDENT>except Exception as e :<EOL><INDENT>print(str(e))<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>try :<EOL><INDENT>headers={}<EOL>headers ['User-Agent']='<STR_LIT>'<EOL>req=urllib2.Request(url,headers=headers)<EOL>response=urllib2.urlopen(req)<EOL>page=response.read()<EOL>if len(arg)>:<EOL><INDENT>file=open(arg [],"w")<EOL>file.write(page)<EOL>file.close()<EOL>return page <EOL><DEDENT>else :<EOL><INDENT>return page <EOL><DEDENT> <DEDENT>except :<EOL><INDENT>return "Page Not found"<EOL><DEDENT> <DEDENT> <DEDENT>def page_title(url):<EOL><INDENT>page=download_page(url)<EOL>start_title=page.find("<title")<EOL>end_start_title=page.find(">",start_title +)<EOL>stop_title=page.find("</title>",end_start_title +)<EOL>title=page [end_start_title +:stop_title ]<EOL>return(title)<EOL><DEDENT>def extension_scan(url):<EOL><INDENT>a=['.png','.jpg','.jpeg','.gif','.tif','.txt','.svg','.pdf']<EOL>j=<EOL>while j <(len(a)):<EOL><INDENT>if a [j ]in url :<EOL><INDENT>flag2=<EOL>break <EOL><DEDENT>else :<EOL><INDENT>flag2=<EOL>j=j +<EOL><DEDENT> <DEDENT>return flag2 <EOL><DEDENT>def url_normalize(url,seed_page):<EOL><INDENT>url=url.lower()<EOL>s=urlparse(url)<EOL>seed_page=seed_page.lower()<EOL>t=urlparse(seed_page)<EOL>flag=<EOL>if url=="/":<EOL><INDENT>url=seed_page <EOL>flag=<EOL>print(url)<EOL><DEDENT>if s.netloc=="":<EOL><INDENT>path=url.find('/')<EOL>if path !=-:<EOL><INDENT>url=url [path :]<EOL>url=seed_page +url <EOL>flag=<EOL>s=urlparse(url)<EOL><DEDENT>else :<EOL><INDENT>url=url <EOL>flag=<EOL><DEDENT> <DEDENT>if not s.scheme :<EOL><INDENT>url="http://"+url <EOL>flag=<EOL>s=urlparse(url)<EOL><DEDENT>if "#"in url :<EOL><INDENT>url=url [:url.find("#")]<EOL><DEDENT>if "?"in url :<EOL><INDENT>url=url [:url.find("?")]<EOL><DEDENT>if "www"not in url :<EOL><INDENT>url="www."[:]+url [:]<EOL>flag=<EOL>s=urlparse(url)<EOL><DEDENT>if 'http'not in url :<EOL><INDENT>url="http://"+url <EOL>flag=<EOL>s=urlparse(url)<EOL><DEDENT>if url [len(url)-]=="/":<EOL><INDENT>url=url [:-]<EOL>flag=<EOL><DEDENT>if s.netloc !=t.netloc :<EOL><INDENT>s=urlparse(url)<EOL>url=url <EOL>flag=<EOL><DEDENT>if flag==:<EOL><INDENT>return url <EOL><DEDENT>else :<EOL><INDENT>return "Invalid URL"<EOL><DEDENT> <DEDENT>def find_next_link(s):<EOL><INDENT>start_link=s.find("<a href")<EOL>if start_link==-:<EOL><INDENT>end_quote=<EOL>link="no_links"<EOL>return link,end_quote <EOL><DEDENT>else :<EOL><INDENT>start_quote=s.find('"',start_link)<EOL>end_quote=s.find('"',start_quote +)<EOL>link=str(s [start_quote +:end_quote ])<EOL>return link,end_quote <EOL><DEDENT> <DEDENT>def find_all_links(content):<EOL><INDENT>if content.startswith('http')or content.startswith('www'):<EOL><INDENT>url=content <EOL>if "http"not in url :<EOL><INDENT>url="http://"+url <EOL><DEDENT>if "www"not in url :<EOL><INDENT>url="www."[:]+url [:]<EOL><DEDENT>content=download_page(url)<EOL><DEDENT>page=content <EOL>links=[]<EOL>while True :<EOL><INDENT>link,end_link=find_next_link(page)<EOL>if link=="no_links":<EOL><INDENT>break <EOL><DEDENT>else :<EOL><INDENT>links.append(link)<EOL>page=page [end_link :]<EOL><DEDENT> <DEDENT>return links <EOL><DEDENT>def url_parse(url,seed_page):<EOL><INDENT>url=url.lower().replace(' ','%20')<EOL>s=urlparse(url)<EOL>t=urlparse(seed_page)<EOL>i=<EOL>while i <=:<EOL><INDENT>if url=="/":<EOL><INDENT>url=seed_page <EOL>flag=<EOL><DEDENT>elif not s.scheme :<EOL><INDENT>url="http://"+url <EOL>flag=<EOL><DEDENT>elif "#"in url :<EOL><INDENT>url=url [:url.find("#")]<EOL><DEDENT>elif "?"in url :<EOL><INDENT>url=url [:url.find("?")]<EOL><DEDENT>elif s.netloc=="":<EOL><INDENT>url=seed_page +s.path <EOL>flag=<EOL><DEDENT>elif "www"not in url :<EOL><INDENT>url="www."[:]+url [:]<EOL>flag=<EOL><DEDENT>elif url [len(url)-]=="/":<EOL><INDENT>url=url [:-]<EOL>flag=<EOL><DEDENT>elif s.netloc !=t.netloc :<EOL><INDENT>url=url <EOL>flag=<EOL>break <EOL><DEDENT>else :<EOL><INDENT>url=url <EOL>flag=<EOL>break <EOL><DEDENT>i=i +<EOL>s=urlparse(url)<EOL><DEDENT>return(url,flag)<EOL><DEDENT>def web_crawl(*arg):<EOL><INDENT>to_crawl=[arg []]<EOL>crawled=[]<EOL>a=urlparse(arg [])<EOL>seed_page=a.scheme +"://"+a.netloc <EOL>i=;<EOL>while to_crawl :<EOL><INDENT>urll=to_crawl.pop()<EOL>urll,flag=url_parse(urll,seed_page)<EOL>flag2=extension_scan(urll)<EOL>if flag2==:<EOL><INDENT>pass <EOL><DEDENT>else :<EOL><INDENT>if urll in crawled :<EOL><INDENT>pass <EOL><DEDENT>else :<EOL><INDENT>print("\n"+urll)<EOL>if len(arg)>:<EOL><INDENT>delay=arg []<EOL>time.sleep(delay)<EOL><DEDENT>to_crawl=to_crawl +find_all_links(download_page(urll))<EOL>crawled.append(urll)<EOL>n=<EOL>j=<EOL>while j <(len(to_crawl)-n):<EOL><INDENT>if to_crawl [j ]in to_crawl [j +:(len(to_crawl)-)]:<EOL><INDENT>to_crawl.pop(j)<EOL>n=n +<EOL><DEDENT>else :<EOL><INDENT>pass <EOL><DEDENT>j=j +<EOL><DEDENT> <DEDENT>i=i +<EOL>print('<STR_LIT>'+str(i))<EOL>print('<STR_LIT>'+str(len(to_crawl)))<EOL>print('<STR_LIT>'+str(len(crawled)))<EOL>if len(arg)>:<EOL><INDENT>if arg []=="write_log":<EOL><INDENT>file=open('log.txt','a')<EOL>file.write("URL: "+urll +"\n")<EOL>file.write('<STR_LIT>'+str(i)+"\n")<EOL>file.write('<STR_LIT>'+str(len(to_crawl))+"\n")<EOL>file.write('<STR_LIT>'+str(len(crawled))+"\n\n")<EOL>file.close()<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>return ''<EOL><DEDENT>def web_crawl_in_domain(*arg):<EOL><INDENT>to_crawl=[arg []]<EOL>crawled=[]<EOL>a=urlparse(arg [])<EOL>seed_page=a.scheme +"://"+a.netloc <EOL>i=;<EOL>while to_crawl :<EOL><INDENT>urll=to_crawl.pop()<EOL>urll,flag=url_parse(urll,seed_page)<EOL>flag2=extension_scan(urll)<EOL>if flag==or flag2==:<EOL><INDENT>pass <EOL><DEDENT>else :<EOL><INDENT>if urll in crawled :<EOL><INDENT>pass <EOL><DEDENT>else :<EOL><INDENT>print("\n"+urll)<EOL>if len(arg)>:<EOL><INDENT>delay=arg []<EOL>time.sleep(delay)<EOL><DEDENT>to_crawl=to_crawl +find_all_links(download_page(urll))<EOL>crawled.append(urll)<EOL>n=<EOL>j=<EOL>while j <(len(to_crawl)-n):<EOL><INDENT>if to_crawl [j ]in to_crawl [j +:(len(to_crawl)-)]:<EOL><INDENT>to_crawl.pop(j)<EOL>n=n +<EOL><DEDENT>else :<EOL><INDENT>pass <EOL><DEDENT>j=j +<EOL><DEDENT> <DEDENT>i=i +<EOL>print('<STR_LIT>'+str(i))<EOL>print('<STR_LIT>'+str(len(to_crawl)))<EOL>print('<STR_LIT>'+str(len(crawled)))<EOL>if len(arg)>:<EOL><INDENT>if arg []=="write_log":<EOL><INDENT>file=open('log.txt','a')<EOL>file.write("URL: "+urll +"\n")<EOL>file.write('<STR_LIT>'+str(i)+"\n")<EOL>file.write('<STR_LIT>'+str(len(to_crawl))+"\n")<EOL>file.write('<STR_LIT>'+str(len(crawled))+"\n\n")<EOL>file.close()<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>return ''<EOL><DEDENT>def remove_html_tags(page):<EOL><INDENT>pure_text=(re.sub(r'<.+?>','',page))<EOL>return pure_text <EOL><DEDENT>def clean_page(page):<EOL><INDENT>while True :<EOL><INDENT>script_start=page.find("<script")<EOL>script_end=page.find("</script>")<EOL>if '<script'in page :<EOL><INDENT>script_section=page [script_start :script_end +]<EOL>page=page.replace(script_section,'')<EOL><DEDENT>else :<EOL><INDENT>break <EOL><DEDENT> <DEDENT>pure_text=(re.sub(r'<.+?>','',page))<EOL>return pure_text <EOL><DEDENT>def get_next_heading(s,heading_type):<EOL><INDENT>start_link=s.find("<"+heading_type)<EOL>if start_link==-:<EOL><INDENT>end_quote=<EOL>link="no_headings"<EOL>return link,end_quote <EOL><DEDENT>else :<EOL><INDENT>start_quote=s.find('>',start_link +)<EOL>end_quote=s.find('</'+heading_type +'>',start_quote +)<EOL>link=str(s [start_quote +:end_quote ])<EOL>return link,end_quote <EOL><DEDENT> <DEDENT>def get_all_headings_as_list(url,heading_type):<EOL><INDENT>links=[]<EOL>page=download_page(url)<EOL>while True :<EOL><INDENT>link,end_link=get_next_heading(page,heading_type)<EOL>link=link.replace('\n',' ')<EOL>link=re.sub(r'<.+?>','',link)<EOL>if link=="no_headings":<EOL><INDENT>break <EOL><DEDENT>else :<EOL><INDENT>links.append(link)<EOL>page=page [end_link :]<EOL><DEDENT> <DEDENT>return links <EOL><DEDENT>def get_all_headings(*arg):<EOL><INDENT>url=arg []<EOL>lists=get_all_headings_as_list(url,arg [])<EOL>if len(arg)>:<EOL><INDENT>if arg []=='list':<EOL><INDENT>print(lists)<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>for i in lists :<EOL><INDENT>print(i)<EOL><DEDENT> <DEDENT> <DEDENT>def get_next_paragraph(s):<EOL><INDENT>start_link=s.find("<p")<EOL>if start_link==-:<EOL><INDENT>end_quote=<EOL>link="no_links"<EOL>return link,end_quote <EOL><DEDENT>else :<EOL><INDENT>start_quote=s.find('>',start_link +)<EOL>end_quote=s.find('</p>',start_quote +)<EOL>link=str(s [start_quote +:end_quote ])<EOL>return link,end_quote <EOL><DEDENT> <DEDENT>def get_all_paragraphs_as_list(url):<EOL><INDENT>links=[]<EOL>page=download_page(url)<EOL>while True :<EOL><INDENT>link,end_link=get_next_paragraph(page)<EOL>link=link.replace('\n',' ')<EOL>link=re.sub(r'<.+?>','',link)<EOL>if link=="no_links":<EOL><INDENT>break <EOL><DEDENT>else :<EOL><INDENT>links.append(link)<EOL>page=page [end_link :]<EOL><DEDENT> <DEDENT>return links <EOL><DEDENT>def get_all_paragraphs(url):<EOL><INDENT>lists=get_all_paragraphs_as_list(url)<EOL>for i in lists :<EOL><INDENT>print(i)<EOL><DEDENT> <DEDENT>def get_next_images_link(s):<EOL><INDENT>start_line=s.find("<img")<EOL>if start_line==-:<EOL><INDENT>end_quote=<EOL>link="no_links"<EOL>return link,end_quote <EOL><DEDENT>else :<EOL><INDENT>start_link=s.find('src=',start_line)<EOL>end_link=s.find('"',start_link +)<EOL>link=str(s [start_link +:end_link ])<EOL>return link,end_link <EOL><DEDENT> <DEDENT>def get_all_images_links(url):<EOL><INDENT>page=download_page(url)<EOL>links=[]<EOL>while True :<EOL><INDENT>link,end_link=get_next_images_link(page)<EOL>if link=="no_links":<EOL><INDENT>break <EOL><DEDENT>else :<EOL><INDENT>links.append(link)<EOL>page=page [end_link :]<EOL><DEDENT> <DEDENT>return links <EOL><DEDENT>def get_all_images(*arg):<EOL><INDENT>url=arg []<EOL>import urllib <EOL>links=get_all_images_links(url)<EOL>print(links)<EOL>if len(arg)>and arg []=="download":<EOL><INDENT>s=urlparse(url)<EOL>seed_page=s.scheme +'://'+s.netloc <EOL>i=<EOL>while i <len(links):<EOL><INDENT>link,flag=url_parse(links [i ],seed_page)<EOL>print('<STR_LIT>'+link)<EOL>try :<EOL><INDENT>file=urllib.URLopener()<EOL>file.retrieve(link,str("img "+str(i)+".jpg"))<EOL><DEDENT>except :<EOL><INDENT>pass <EOL><DEDENT>i=i +<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>pass <EOL><DEDENT> <DEDENT>def get_next_image_link(s):<EOL><INDENT>start_line=s.find('rg_di')<EOL>if start_line==-:<EOL><INDENT>end_quote=<EOL>link="no_images"<EOL>return link,end_quote <EOL><DEDENT>else :<EOL><INDENT>start_line=s.find('"class="rg_di"')<EOL>start_content=s.find('imgurl=',start_line +)<EOL>end_content=s.find('&amp;',start_content +)<EOL>content_raw=str(s [start_content +:end_content ])<EOL>return content_raw,end_content <EOL><DEDENT> <DEDENT>def get_all_image_links(page):<EOL><INDENT>items=[]<EOL>while True :<EOL><INDENT>item,end_content=get_next_image_link(page)<EOL>if item=="no_images":<EOL><INDENT>break <EOL><DEDENT>else :<EOL><INDENT>items.append(item)<EOL>page=page [end_content :]<EOL><DEDENT> <DEDENT>return items <EOL><DEDENT>def download_google_images(*arg):<EOL><INDENT>import urllib <EOL>search_keyword=arg []<EOL>result=(str(type(search_keyword)))<EOL>if 'list'in result :<EOL><INDENT>i=<EOL>while i <len(search_keyword):<EOL><INDENT>items=[]<EOL>iteration="Item no.: "+str(i +)+" -->"+" Item name= "+str(search_keyword [i ])<EOL>print(iteration)<EOL>search_keywords=search_keyword [i ]<EOL>search=search_keywords.replace(' ','%20')<EOL>url='<STR_LIT>'+search +'<STR_LIT>'<EOL>raw_html=(download_page(url))<EOL>items=items +(get_all_image_links(raw_html))<EOL>print("Image Links= "+str(items))<EOL>print('<STR_LIT>'+str(len(items)))<EOL>print("\n")<EOL>i=i +<EOL>info=open('output.txt','a')<EOL>info.write(str(i)+': '+str(search_keyword [i -])+": "+str(items)+"\n\n\n")<EOL>info.close()<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>items=[]<EOL>iteration="Item name= "+str(search_keyword)<EOL>print(iteration)<EOL>search=search_keyword.replace(' ','%20')<EOL>url='<STR_LIT>'+search +'<STR_LIT>'<EOL>raw_html=(download_page(url))<EOL>items=items +(get_all_image_links(raw_html))<EOL>print("Image Links= "+str(items))<EOL>print('<STR_LIT>'+str(len(items)))<EOL>print("\n")<EOL>info=open('output.txt','a')<EOL>info.write(str(search_keyword)+": "+str(items)+"\n\n\n")<EOL>info.close()<EOL>if len(arg)>and arg []=="download":<EOL><INDENT>i=<EOL>while i <len(items):<EOL><INDENT>link=items [i ]<EOL>try :<EOL><INDENT>file=urllib.URLopener()<EOL>file.retrieve(link,str("img "+str(i)+".jpg"))<EOL>print("downloaded --> "+link)<EOL><DEDENT>except :<EOL><INDENT>pass <EOL><DEDENT>i=i +<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>pass <EOL><DEDENT> <DEDENT> <DEDENT>def save_wikipedia_article(url,*arg):<EOL><INDENT>raw_page=download_page(url)<EOL>start_heading=raw_page.find('<STR_LIT>')<EOL>end_start_heading=raw_page.find('>',start_heading +)<EOL>end_heading=raw_page.find('</h1>',end_start_heading +)<EOL>heading=raw_page [end_start_heading +:end_heading ]<EOL>page=heading +'\n\n'<EOL>raw_page=raw_page [end_heading +:]<EOL>para_count=<EOL>while True :<EOL><INDENT>find_paragraph=raw_page.find('<p>')<EOL>find_heading=raw_page.find('<STR_LIT>')<EOL>if find_paragraph==-or find_heading==-:<EOL><INDENT>break <EOL><DEDENT>else :<EOL><INDENT>if find_paragraph <find_heading :<EOL><INDENT>start_paragraph=raw_page.find('<p>')<EOL>end_paragraph=raw_page.find('</p>',start_paragraph +)<EOL>paragraph_raw=raw_page [start_paragraph +:end_paragraph ]<EOL>paragraph_2=(re.sub(r'<.+?>','',paragraph_raw))<EOL>paragraph=(re.sub(r'\[.*?\]','',paragraph_2))<EOL>para_count +=<EOL>if para_count <:<EOL><INDENT>page=page +'\n'+paragraph <EOL><DEDENT>else :<EOL><INDENT>page=page +'\n\n'+paragraph <EOL><DEDENT>raw_page=raw_page [end_paragraph :]<EOL><DEDENT>else :<EOL><INDENT>start_heading=raw_page.find('<STR_LIT>')<EOL>end_start_heading=raw_page.find('>',start_heading +)<EOL>end_heading=raw_page.find('</span>',start_heading +)<EOL>heading_raw=raw_page [end_start_heading +:end_heading ]<EOL>heading=(re.sub(r'<.+?>','',heading_raw))<EOL>para_count=<EOL>page=page +'\n\n'+heading +':'<EOL>raw_page=raw_page [end_heading :]<EOL><DEDENT> <DEDENT> <DEDENT>if len(arg)>:<EOL><INDENT>file=open(arg [],'w')<EOL>file.write(page)<EOL>file.close()<EOL>return page <EOL><DEDENT>else :<EOL><INDENT>return page <EOL><DEDENT> <DEDENT>def wikipedia_url_parse(url):<EOL><INDENT>seed_page='<STR_LIT>'<EOL>try :<EOL><INDENT>from urllib.parse import urlparse <EOL><DEDENT>except ImportError :<EOL><INDENT>from urlparse import urlparse <EOL><DEDENT>url=url <EOL>s=urlparse(url)<EOL>seed_page_n=seed_page <EOL>i=<EOL>flag=<EOL>while i <=:<EOL><INDENT>if url=="/":<EOL><INDENT>url=seed_page_n <EOL>flag=<EOL><DEDENT>elif not s.scheme :<EOL><INDENT>url="http://"+url <EOL>flag=<EOL><DEDENT>elif "#"in url :<EOL><INDENT>url=url [:url.find("#")]<EOL>flag=<EOL><DEDENT>elif "?"in url :<EOL><INDENT>url=url [:url.find("?")]<EOL>flag=<EOL><DEDENT>elif s.netloc=="":<EOL><INDENT>url=seed_page +s.path <EOL>flag=<EOL><DEDENT>elif url [len(url)-]=="/":<EOL><INDENT>url=url [:-]<EOL>flag=<EOL><DEDENT>else :<EOL><INDENT>url=url <EOL>flag=<EOL>break <EOL><DEDENT>i=i +<EOL>s=urlparse(url)<EOL><DEDENT>return(url,flag)<EOL><DEDENT>def wikipedia_crawl(starting_page,*arg):<EOL><INDENT>to_crawl=[starting_page ]<EOL>crawled=[]<EOL>i=<EOL>while i <arg []:<EOL><INDENT>urll=to_crawl.pop()<EOL>urll,flag=wikipedia_url_parse(urll)<EOL>flag2=extension_scan(urll)<EOL>time.sleep()<EOL>if flag==or flag2==:<EOL><INDENT>pass <EOL><DEDENT>else :<EOL><INDENT>if urll in crawled :<EOL><INDENT>pass <EOL><DEDENT>else :<EOL><INDENT>raw_html=download_page(urll)<EOL>start_heading=raw_html.find('<STR_LIT>')<EOL>end_start_heading=raw_html.find('>',start_heading +)<EOL>end_heading=raw_html.find('</h1>',end_start_heading +)<EOL>heading=raw_html [end_start_heading +:end_heading ]<EOL>heading=heading.replace('<i>','').replace('</i>','')<EOL>print("Title= "+heading)<EOL>print("Link= "+urll)<EOL>to_crawl=to_crawl +find_all_links(raw_html)<EOL>if len(to_crawl)>:<EOL><INDENT>to_crawl=to_crawl [:]<EOL><DEDENT>crawled.append(urll)<EOL>n=<EOL>j=<EOL>while j <(len(to_crawl)-n):<EOL><INDENT>if to_crawl [j ]in to_crawl [j +:(len(to_crawl)-)]:<EOL><INDENT>to_crawl.pop(j)<EOL>n=n +<EOL><DEDENT>else :<EOL><INDENT>pass <EOL><DEDENT>j=j +<EOL><DEDENT> <DEDENT>i=i +<EOL>print('<STR_LIT>'+str(i)+' | '+"To Crawl= "+str(len(to_crawl))+' | '+"Crawled= "+str(len(crawled))+'\n')<EOL>if len(arg)>:<EOL><INDENT>file=open(arg [],'a')<EOL>file.write("Title= "+heading +"\n")<EOL>file.write("Link= "+urll +"\n")<EOL>file.write('<STR_LIT>'+str(i)+' | '+"To Crawl= "+str(len(to_crawl))+' | '+"Crawled= "+str(len(crawled))+'\n\n')<EOL>file.close()<EOL><DEDENT> <DEDENT> <DEDENT>return ""<EOL><DEDENT>def google_search(query):<EOL><INDENT>query=urllib.urlencode({'q':query })<EOL>response=urllib.urlopen('<STR_LIT>'+query).read()<EOL>json=m_json.loads(response)<EOL>results=json ['responseData']['results']<EOL>for result in results :<EOL><INDENT>title=result ['title'].replace('<b>','').replace('</b>','')<EOL>link=result ['url']<EOL>print(title +'; '+link)<EOL><DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import inspect <EOL>def json(s):<EOL><INDENT> '<STR_LIT>'<EOL>import json <EOL>return json.loads(s)<EOL><DEDENT>def autotype(s):<EOL><INDENT> '<STR_LIT>'<EOL>if not isinstance(s,str):<EOL><INDENT>return s <EOL><DEDENT>if s.isdigit():<EOL><INDENT>return int(s)<EOL><DEDENT>try :<EOL><INDENT>return float(s)<EOL><DEDENT>except ValueError :<EOL><INDENT>return s <EOL><DEDENT> <DEDENT>def getargspec(func):<EOL><INDENT> '<STR_LIT>'<EOL>if inspect.isfunction(func):<EOL><INDENT>return inspect.getargspec(func)<EOL><DEDENT>if inspect.ismethod(func):<EOL><INDENT>argspec=inspect.getargspec(func)<EOL>argspec [].pop()<EOL>return argspec <EOL><DEDENT>def strbetween(s,a,b):<EOL><INDENT>return s [s.find(a):s.rfind(b)]<EOL><DEDENT>argspecdoc=(inspect.getdoc(func)or '').split('\n')[]<EOL>argpart=strbetween(argspecdoc,'(',')')<EOL>args=argpart.split(',')<EOL>args=(arg.strip('()[]')for arg in args)<EOL>args=[arg for arg in args if arg ]<EOL>defaultpart=strbetween(argspecdoc,'[',']')<EOL>defaultcount=len([d for d in defaultpart.split(',')if d.strip('[]')])<EOL>return(args,None,None,(None,)*defaultcount or None)<EOL><DEDENT><EOF><BOF>from robot.errors import DataError <EOL>from robot.utils import XmlWriter,NullMarkupWriter,get_timestamp,unic <EOL>from robot.version import get_full_version <EOL>from.loggerhelper import IsLogged <EOL>class XmlLogger(object):<EOL><INDENT>def __init__(self,path,log_level='TRACE',generator='Robot'):<EOL><INDENT>self._log_message_is_logged=IsLogged(log_level)<EOL>self._error_message_is_logged=IsLogged('WARN')<EOL>self._writer=self._get_writer(path,generator)<EOL>self._errors=[]<EOL><DEDENT>def _get_writer(self,path,generator):<EOL><INDENT>if path=='NONE':<EOL><INDENT>return NullMarkupWriter()<EOL><DEDENT>try :<EOL><INDENT>writer=XmlWriter(path,encoding='UTF-8')<EOL><DEDENT>except EnvironmentError,err :<EOL><INDENT>raise DataError('<STR_LIT>'%(path,err.strerror))<EOL><DEDENT>writer.start('robot',{'generator':get_full_version(generator),<EOL>'generated':get_timestamp()})<EOL>return writer <EOL><DEDENT>def close(self):<EOL><INDENT>self.start_errors()<EOL>for msg in self._errors :<EOL><INDENT>self._write_message(msg)<EOL><DEDENT>self.end_errors()<EOL>self._writer.end('robot')<EOL>self._writer.close()<EOL><DEDENT>def set_log_level(self,level):<EOL><INDENT>return self._log_message_is_logged.set_level(level)<EOL><DEDENT>def message(self,msg):<EOL><INDENT>if self._error_message_is_logged(msg.level):<EOL><INDENT>self._errors.append(msg)<EOL><DEDENT> <DEDENT>def log_message(self,msg):<EOL><INDENT>if self._log_message_is_logged(msg.level):<EOL><INDENT>self._write_message(msg)<EOL><DEDENT> <DEDENT>def _write_message(self,msg):<EOL><INDENT>attrs={'timestamp':msg.timestamp or 'N/A','level':msg.level }<EOL>if msg.html :<EOL><INDENT>attrs ['html']='yes'<EOL><DEDENT>self._writer.element('msg',msg.message,attrs)<EOL><DEDENT>def start_keyword(self,kw):<EOL><INDENT>self._writer.start('kw',{'name':kw.name,'type':kw.type,<EOL>'timeout':str(kw.timeout)})<EOL>self._writer.element('doc',kw.doc)<EOL>self._write_list('arguments','arg',(unic(a)for a in kw.args))<EOL><DEDENT>def end_keyword(self,kw):<EOL><INDENT>self._write_status(kw)<EOL>self._writer.end('kw')<EOL><DEDENT>def start_test(self,test):<EOL><INDENT>self._writer.start('test',{'id':test.id,'name':test.name,<EOL>'timeout':str(test.timeout)})<EOL><DEDENT>def end_test(self,test):<EOL><INDENT>self._writer.element('doc',test.doc)<EOL>self._write_list('tags','tag',test.tags)<EOL>self._write_status(test,test.message,<EOL>{'critical':'yes'if test.critical else 'no'})<EOL>self._writer.end('test')<EOL><DEDENT>def start_suite(self,suite):<EOL><INDENT>attrs={'id':suite.id,'name':suite.name }<EOL>if suite.source :<EOL><INDENT>attrs ['source']=suite.source <EOL><DEDENT>self._writer.start('suite',attrs)<EOL><DEDENT>def end_suite(self,suite):<EOL><INDENT>self._writer.element('doc',suite.doc)<EOL>self._writer.start('metadata')<EOL>for name,value in suite.metadata.items():<EOL><INDENT>self._writer.element('item',value,{'name':name })<EOL><DEDENT>self._writer.end('metadata')<EOL>self._write_status(suite,suite.message)<EOL>self._writer.end('suite')<EOL><DEDENT>def start_statistics(self,stats):<EOL><INDENT>self._writer.start('statistics')<EOL><DEDENT>def end_statistics(self,stats):<EOL><INDENT>self._writer.end('statistics')<EOL><DEDENT>def start_total_stats(self,total_stats):<EOL><INDENT>self._writer.start('total')<EOL><DEDENT>def end_total_stats(self,total_stats):<EOL><INDENT>self._writer.end('total')<EOL><DEDENT>def start_tag_stats(self,tag_stats):<EOL><INDENT>self._writer.start('tag')<EOL><DEDENT>def end_tag_stats(self,tag_stats):<EOL><INDENT>self._writer.end('tag')<EOL><DEDENT>def start_suite_stats(self,tag_stats):<EOL><INDENT>self._writer.start('suite')<EOL><DEDENT>def end_suite_stats(self,tag_stats):<EOL><INDENT>self._writer.end('suite')<EOL><DEDENT>def total_stat(self,stat):<EOL><INDENT>self._stat(stat)<EOL><DEDENT>def suite_stat(self,stat):<EOL><INDENT>self._stat(stat,stat.longname,<EOL>attrs={'id':stat.id,'name':stat.name })<EOL><DEDENT>def tag_stat(self,stat):<EOL><INDENT>self._stat(stat,attrs={'info':self._get_tag_stat_info(stat),<EOL>'links':self._get_tag_links(stat),<EOL>'doc':stat.doc,<EOL>'combined':stat.combined })<EOL><DEDENT>def _get_tag_links(self,stat):<EOL><INDENT>return ':::'.join(':'.join([title,url ])for url,title in stat.links)<EOL><DEDENT>def _stat(self,stat,name=None,attrs=None):<EOL><INDENT>attrs=attrs or {}<EOL>attrs ['pass']=str(stat.passed)<EOL>attrs ['fail']=str(stat.failed)<EOL>self._writer.element('stat',name or stat.name,attrs)<EOL><DEDENT>def _get_tag_stat_info(self,stat):<EOL><INDENT>if stat.critical :<EOL><INDENT>return 'critical'<EOL><DEDENT>if stat.non_critical :<EOL><INDENT>return 'non-critical'<EOL><DEDENT>if stat.combined :<EOL><INDENT>return 'combined'<EOL><DEDENT>return ''<EOL><DEDENT>def start_errors(self):<EOL><INDENT>self._writer.start('errors')<EOL><DEDENT>def end_errors(self):<EOL><INDENT>self._writer.end('errors')<EOL><DEDENT>def _write_list(self,container_tag,item_tag,items):<EOL><INDENT>self._writer.start(container_tag)<EOL>for item in items :<EOL><INDENT>self._writer.element(item_tag,item)<EOL><DEDENT>self._writer.end(container_tag)<EOL><DEDENT>def _write_status(self,item,message=None,extra_attrs=None):<EOL><INDENT>attrs={'status':item.status,'starttime':item.starttime or 'N/A',<EOL>'endtime':item.endtime or 'N/A'}<EOL>if not(item.starttime and item.endtime):<EOL><INDENT>attrs ['elapsedtime']=str(item.elapsedtime)<EOL><DEDENT>if extra_attrs :<EOL><INDENT>attrs.update(extra_attrs)<EOL><DEDENT>self._writer.element('status',message,attrs)<EOL><DEDENT> <DEDENT><EOF><BOF>import os <EOL>from robot import utils <EOL>from robot.errors import DataError,FrameworkError <EOL>from robot.output import LOGGER,loggerhelper <EOL>class _BaseSettings(object):<EOL><INDENT>_cli_opts={'Name':('name',None),<EOL>'Doc':('doc',None),<EOL>'Metadata':('metadata',[]),<EOL>'TestNames':('test',[]),<EOL>'SuiteNames':('suite',[]),<EOL>'SetTag':('settag',[]),<EOL>'Include':('include',[]),<EOL>'Exclude':('exclude',[]),<EOL>'Critical':('critical',None),<EOL>'NonCritical':('noncritical',None),<EOL>'OutputDir':('outputdir',utils.abspath('.')),<EOL>'Log':('log','log.html'),<EOL>'Report':('report','report.html'),<EOL>'XUnitFile':('xunitfile','NONE'),<EOL>'SplitLog':('splitlog',False),<EOL>'<STR_LIT>':('<STR_LIT>',False),<EOL>'LogTitle':('logtitle',None),<EOL>'ReportTitle':('reporttitle',None),<EOL>'<STR_LIT>':('<STR_LIT>',('#99FF66','#99FF66','#FF3333')),<EOL>'SuiteStatLevel':('suitestatlevel',-),<EOL>'TagStatInclude':('tagstatinclude',[]),<EOL>'TagStatExclude':('tagstatexclude',[]),<EOL>'TagStatCombine':('tagstatcombine',[]),<EOL>'TagDoc':('tagdoc',[]),<EOL>'TagStatLink':('tagstatlink',[]),<EOL>'RemoveKeywords':('removekeywords',[]),<EOL>'NoStatusRC':('nostatusrc',False),<EOL>'MonitorColors':('monitorcolors','AUTO'),<EOL>'StdOut':('stdout',None),<EOL>'StdErr':('stderr',None)}<EOL>_output_opts=['Output','Log','Report','DebugFile','XUnitFile']<EOL>def __init__(self,options=None,log=True):<EOL><INDENT>self._opts={}<EOL>self._cli_opts=self._cli_opts.copy()<EOL>self._cli_opts.update(self._extra_cli_opts)<EOL>self._process_cli_opts(options or {},log)<EOL>if log :LOGGER.info('Settings:\n%s'%unicode(self))<EOL><DEDENT>def _process_cli_opts(self,opts,log):<EOL><INDENT>for name,(cli_name,default)in self._cli_opts.items():<EOL><INDENT>value=opts.get(cli_name,default)<EOL>if value in [None,[]]:<EOL><INDENT>value=default <EOL><DEDENT>elif default==[]and isinstance(value,basestring):<EOL><INDENT>value=[value ]<EOL><DEDENT>self [name ]=self._process_value(name,value,log)<EOL><DEDENT> <DEDENT>def __setitem__(self,name,value):<EOL><INDENT>if name not in self._cli_opts :<EOL><INDENT>raise KeyError('<STR_LIT>'%name)<EOL><DEDENT>self._opts [name ]=value <EOL><DEDENT>def _process_value(self,name,value,log):<EOL><INDENT>if name=='LogLevel':<EOL><INDENT>return self._process_log_level(value)<EOL><DEDENT>if value==self._get_default_value(name):<EOL><INDENT>return value <EOL><DEDENT>if name in ['Name','Doc','LogTitle','ReportTitle']:<EOL><INDENT>if name=='Doc':value=self._escape(value)<EOL>return value.replace('_',' ')<EOL><DEDENT>if name in ['Metadata','TagDoc']:<EOL><INDENT>if name=='Metadata':value=[self._escape(v)for v in value ]<EOL>return [self._process_metadata_or_tagdoc(v)for v in value ]<EOL><DEDENT>if name in ['Include','Exclude']:<EOL><INDENT>return [v.replace('AND','&').replace('_',' ')for v in value ]<EOL><DEDENT>if name in self._output_opts and utils.eq(value,'NONE'):<EOL><INDENT>return 'NONE'<EOL><DEDENT>if name=='OutputDir':<EOL><INDENT>return utils.abspath(value)<EOL><DEDENT>if name in ['SuiteStatLevel','MonitorWidth']:<EOL><INDENT>return self._convert_to_positive_integer_or_default(name,value)<EOL><DEDENT>if name in ['Listeners','VariableFiles']:<EOL><INDENT>return [self._split_args_from_name_or_path(item)for item in value ]<EOL><DEDENT>if name=='<STR_LIT>':<EOL><INDENT>return self._process_report_background(value)<EOL><DEDENT>if name=='TagStatCombine':<EOL><INDENT>return [self._process_tag_stat_combine(v)for v in value ]<EOL><DEDENT>if name=='TagStatLink':<EOL><INDENT>return [v for v in [self._process_tag_stat_link(v)for v in value ]if v ]<EOL><DEDENT>if name=='RemoveKeywords':<EOL><INDENT>return [v.upper()for v in value ]<EOL><DEDENT>return value <EOL><DEDENT>def _process_log_level(self,level):<EOL><INDENT>level,visible_level=self._split_log_level(level.upper())<EOL>self._opts ['VisibleLogLevel']=visible_level <EOL>return level <EOL><DEDENT>def _split_log_level(self,level):<EOL><INDENT>if ':'in level :<EOL><INDENT>level,visible_level=level.split(':',)<EOL><DEDENT>else :<EOL><INDENT>visible_level=level <EOL><DEDENT>self._validate_log_level_and_default(level,visible_level)<EOL>return level,visible_level <EOL><DEDENT>def _validate_log_level_and_default(self,log_level,default):<EOL><INDENT>if log_level not in loggerhelper.LEVELS :<EOL><INDENT>raise DataError('<STR_LIT>'%log_level)<EOL><DEDENT>if default not in loggerhelper.LEVELS :<EOL><INDENT>raise DataError('<STR_LIT>'%default)<EOL><DEDENT>if not loggerhelper.IsLogged(log_level)(default):<EOL><INDENT>raise DataError('<STR_LIT>'<EOL>"log level '%s'"%(default,log_level))<EOL><DEDENT> <DEDENT>def __getitem__(self,name):<EOL><INDENT>if name not in self._opts :<EOL><INDENT>raise KeyError('<STR_LIT>'%name)<EOL><DEDENT>if name in self._output_opts :<EOL><INDENT>return self._get_output_file(name)<EOL><DEDENT>return self._opts [name ]<EOL><DEDENT>def _get_output_file(self,type_):<EOL><INDENT> '<STR_LIT>'<EOL>name=self._opts [type_ ]<EOL>if self._outputfile_disabled(type_,name):<EOL><INDENT>return 'NONE'<EOL><DEDENT>name=self._process_output_name(name,type_)<EOL>path=utils.abspath(os.path.join(self ['OutputDir'],name))<EOL>self._create_output_dir(os.path.dirname(path),type_)<EOL>return path <EOL><DEDENT>def _process_output_name(self,name,type_):<EOL><INDENT>base,ext=os.path.splitext(name)<EOL>if self ['<STR_LIT>']:<EOL><INDENT>base='%s-%s'%(base,utils.get_start_timestamp('','-',''))<EOL><DEDENT>ext=self._get_output_extension(ext,type_)<EOL>return base +ext <EOL><DEDENT>def _get_output_extension(self,ext,type_):<EOL><INDENT>if ext !='':<EOL><INDENT>return ext <EOL><DEDENT>if type_ in ['Output','XUnitFile']:<EOL><INDENT>return '.xml'<EOL><DEDENT>if type_ in ['Log','Report']:<EOL><INDENT>return '.html'<EOL><DEDENT>if type_=='DebugFile':<EOL><INDENT>return '.txt'<EOL><DEDENT>raise FrameworkError('<STR_LIT>'%type_)<EOL><DEDENT>def _create_output_dir(self,path,type_):<EOL><INDENT>try :<EOL><INDENT>if not os.path.exists(path):<EOL><INDENT>os.makedirs(path)<EOL><DEDENT> <DEDENT>except EnvironmentError,err :<EOL><INDENT>raise DataError('<STR_LIT>'<EOL>%(type_.lower(),path,err.strerror))<EOL><DEDENT> <DEDENT>def _process_metadata_or_tagdoc(self,value):<EOL><INDENT>value=value.replace('_',' ')<EOL>if ':'in value :<EOL><INDENT>return value.split(':',)<EOL><DEDENT>return value,''<EOL><DEDENT>def _process_report_background(self,colors):<EOL><INDENT>if colors.count(':')not in [,]:<EOL><INDENT>LOGGER.error('<STR_LIT>'%colors)<EOL>return self._get_default_value('<STR_LIT>')<EOL><DEDENT>colors=colors.split(':')<EOL>if len(colors)==:<EOL><INDENT>return colors [],colors [],colors []<EOL><DEDENT>return tuple(colors)<EOL><DEDENT>def _process_tag_stat_combine(self,value):<EOL><INDENT>for replwhat,replwith in [('&','AND'),('AND',' AND '),('NOT',' NOT ')]:<EOL><INDENT>value=value.replace(replwhat,replwith)<EOL><DEDENT>if ':'not in value :<EOL><INDENT>return value,''<EOL><DEDENT>pattern,title=value.rsplit(':',)<EOL>return pattern,title.replace('_',' ')<EOL><DEDENT>def _process_tag_stat_link(self,value):<EOL><INDENT>tokens=value.split(':')<EOL>if len(tokens)>=:<EOL><INDENT>return tokens [],':'.join(tokens [:-]),tokens [-]<EOL><DEDENT>LOGGER.error('<STR_LIT>'<EOL>'<STR_LIT>'%value)<EOL>return None <EOL><DEDENT>def _convert_to_positive_integer_or_default(self,name,value):<EOL><INDENT>value=self._convert_to_integer(name,value)<EOL>return value if value >else self._get_default_value(name)<EOL><DEDENT>def _convert_to_integer(self,name,value):<EOL><INDENT>try :<EOL><INDENT>return int(value)<EOL><DEDENT>except ValueError :<EOL><INDENT>LOGGER.error('<STR_LIT>'<EOL>'<STR_LIT>'%(name.lower(),value))<EOL>return self._get_default_value(name)<EOL><DEDENT> <DEDENT>def _get_default_value(self,name):<EOL><INDENT>return self._cli_opts [name ][]<EOL><DEDENT>def _split_args_from_name_or_path(self,name):<EOL><INDENT>if ':'not in name or os.path.exists(name):<EOL><INDENT>args=[]<EOL><DEDENT>else :<EOL><INDENT>args=name.split(':')<EOL>name=args.pop()<EOL>if len(name)==and args [].startswith(('/','\\')):<EOL><INDENT>name=name +':'+args.pop()<EOL><DEDENT> <DEDENT>if os.path.exists(name):<EOL><INDENT>name=os.path.abspath(name)<EOL><DEDENT>return name,args <EOL><DEDENT>def __contains__(self,setting):<EOL><INDENT>return setting in self._cli_opts <EOL><DEDENT>def __unicode__(self):<EOL><INDENT>return '\n'.join('%s: %s'%(name,self._opts [name ])<EOL>for name in sorted(self._opts))<EOL><DEDENT>@property <EOL>def output(self):<EOL><INDENT>return self._get_file('Output')<EOL><DEDENT>@property <EOL>def log(self):<EOL><INDENT>return self._get_file('Log')<EOL><DEDENT>@property <EOL>def report(self):<EOL><INDENT>return self._get_file('Report')<EOL><DEDENT>@property <EOL>def xunit(self):<EOL><INDENT>return self._get_file('XUnitFile')<EOL><DEDENT>def _get_file(self,name):<EOL><INDENT>value=self [name ]<EOL>return value if value !='NONE'else None <EOL><DEDENT>@property <EOL>def split_log(self):<EOL><INDENT>return self ['SplitLog']<EOL><DEDENT>@property <EOL>def status_rc(self):<EOL><INDENT>return not self ['NoStatusRC']<EOL><DEDENT> <DEDENT>class RobotSettings(_BaseSettings):<EOL><INDENT>_extra_cli_opts={'Output':('output','output.xml'),<EOL>'LogLevel':('loglevel','INFO'),<EOL>'RunMode':('runmode',[]),<EOL>'RunEmptySuite':('runemptysuite',False),<EOL>'WarnOnSkipped':('<STR_LIT>',False),<EOL>'Variables':('variable',[]),<EOL>'VariableFiles':('variablefile',[]),<EOL>'Listeners':('listener',[]),<EOL>'MonitorWidth':('monitorwidth',),<EOL>'MonitorMarkers':('monitormarkers','AUTO'),<EOL>'DebugFile':('debugfile','NONE')}<EOL>def is_rebot_needed(self):<EOL><INDENT>return not('NONE'==self ['Log']==self ['Report']==self ['XUnitFile'])<EOL><DEDENT>def get_rebot_datasource_and_settings(self):<EOL><INDENT>datasource=self ['Output']<EOL>settings=RebotSettings(log=False)<EOL>settings._opts.update(self._opts)<EOL>for name in ['Variables','VariableFiles','Listeners']:<EOL><INDENT>del(settings._opts [name ])<EOL><DEDENT>for name in ['Include','Exclude','TestNames','SuiteNames','Metadata']:<EOL><INDENT>settings._opts [name ]=[]<EOL><DEDENT>for name in ['Name','Doc']:<EOL><INDENT>settings._opts [name ]=None <EOL><DEDENT>settings._opts ['Output']='NONE'<EOL>settings._opts ['LogLevel']='TRACE'<EOL>settings._opts ['<STR_LIT>']=self ['RunEmptySuite']<EOL>return datasource,settings <EOL><DEDENT>def _outputfile_disabled(self,type_,name):<EOL><INDENT>if name=='NONE':<EOL><INDENT>return True <EOL><DEDENT>return self._opts ['Output']=='NONE'and type_ !='DebugFile'<EOL><DEDENT>def _escape(self,value):<EOL><INDENT>return utils.escape(value)<EOL><DEDENT> <DEDENT>class RebotSettings(_BaseSettings):<EOL><INDENT>_extra_cli_opts={'Output':('output','NONE'),<EOL>'LogLevel':('loglevel','TRACE'),<EOL>'<STR_LIT>':('<STR_LIT>',False),<EOL>'StartTime':('starttime',None),<EOL>'EndTime':('endtime',None)}<EOL>def _outputfile_disabled(self,type_,name):<EOL><INDENT>return name=='NONE'<EOL><DEDENT>def _escape(self,value):<EOL><INDENT>return value <EOL><DEDENT>@property <EOL>def suite_config(self):<EOL><INDENT>return {<EOL>'name':self ['Name'],<EOL>'doc':self ['Doc'],<EOL>'metadata':dict(self ['Metadata']),<EOL>'set_tags':self ['SetTag'],<EOL>'include_tags':self ['Include'],<EOL>'exclude_tags':self ['Exclude'],<EOL>'include_suites':self ['SuiteNames'],<EOL>'include_tests':self ['TestNames'],<EOL>'<STR_LIT>':self ['<STR_LIT>'],<EOL>'remove_keywords':self ['RemoveKeywords'],<EOL>'log_level':self ['LogLevel'],<EOL>'critical':self ['Critical'],<EOL>'noncritical':self ['NonCritical'],<EOL>'starttime':self ['StartTime'],<EOL>'endtime':self ['EndTime']<EOL>}<EOL><DEDENT>@property <EOL>def statistics_config(self):<EOL><INDENT>return {<EOL>'<STR_LIT>':self ['SuiteStatLevel'],<EOL>'<STR_LIT>':self ['TagStatInclude'],<EOL>'<STR_LIT>':self ['TagStatExclude'],<EOL>'<STR_LIT>':self ['TagStatCombine'],<EOL>'tag_stat_link':self ['TagStatLink'],<EOL>'tag_doc':self ['TagDoc'],<EOL>}<EOL><DEDENT>@property <EOL>def log_config(self):<EOL><INDENT>if not self.log :<EOL><INDENT>return {}<EOL><DEDENT>return {<EOL>'title':utils.html_escape(self ['LogTitle']or ''),<EOL>'reportURL':self._url_from_path(self.log,self.report),<EOL>'splitLogBase':os.path.basename(os.path.splitext(self.log)[]),<EOL>'defaultLevel':self ['VisibleLogLevel']<EOL>}<EOL><DEDENT>@property <EOL>def report_config(self):<EOL><INDENT>if not self.report :<EOL><INDENT>return {}<EOL><DEDENT>return {<EOL>'title':utils.html_escape(self ['ReportTitle']or ''),<EOL>'logURL':self._url_from_path(self.report,self.log),<EOL>'background':self._resolve_background_colors(),<EOL>}<EOL><DEDENT>def _url_from_path(self,source,destination):<EOL><INDENT>if not destination :<EOL><INDENT>return None <EOL><DEDENT>return utils.get_link_path(destination,os.path.dirname(source))<EOL><DEDENT>def _resolve_background_colors(self):<EOL><INDENT>colors=self ['<STR_LIT>']<EOL>return {'pass':colors [],'nonCriticalFail':colors [],'fail':colors []}<EOL><DEDENT> <DEDENT><EOF><BOF>import cv2.cv as cv <EOL>import sys <EOL>import urllib2 <EOL>if __name__=="__main__":<EOL><INDENT>cv.NamedWindow("win")<EOL>if len(sys.argv)>:<EOL><INDENT>filename=sys.argv []<EOL>im=cv.LoadImage(filename,cv.CV_LOAD_IMAGE_GRAYSCALE)<EOL>im3=cv.LoadImage(filename,cv.CV_LOAD_IMAGE_COLOR)<EOL><DEDENT>else :<EOL><INDENT>try :<EOL><INDENT>fileName='<STR_LIT>'<EOL>im=cv.LoadImageM(fileName,False)<EOL>im3=cv.LoadImageM(fileName,True)<EOL><DEDENT>except :<EOL><INDENT>url='<STR_LIT>'<EOL>filedata=urllib2.urlopen(url).read()<EOL>imagefiledata=cv.CreateMatHeader(,len(filedata),cv.CV_8UC1)<EOL>cv.SetData(imagefiledata,filedata,len(filedata))<EOL>im=cv.DecodeImageM(imagefiledata,cv.CV_LOAD_IMAGE_GRAYSCALE)<EOL>im3=cv.DecodeImageM(imagefiledata,cv.CV_LOAD_IMAGE_COLOR)<EOL><DEDENT> <DEDENT>chessboard_dim=(,)<EOL>found_all,corners=cv.FindChessboardCorners(im,chessboard_dim)<EOL>print found_all,len(corners)<EOL>cv.DrawChessboardCorners(im3,chessboard_dim,corners,found_all)<EOL>cv.ShowImage("win",im3);<EOL>cv.WaitKey()<EOL>cv.DestroyAllWindows()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import cv2 <EOL>import numpy as np <EOL>import glob <EOL>from time import sleep <EOL>with np.load('<STR_LIT>')as X :<EOL><INDENT>mtx,dist,_,_=[X [i ]for i in('mtx','dist','rvecs','tvecs')]<EOL><DEDENT>print 'data loaded...'<EOL>def draw(img,corners,imgpts):<EOL><INDENT>corner=tuple(corners [].ravel())<EOL>cv2.line(img,corner,tuple(imgpts [].ravel()),(,,),)<EOL>cv2.line(img,corner,tuple(imgpts [].ravel()),(,,),)<EOL>cv2.line(img,corner,tuple(imgpts [].ravel()),(,,),)<EOL>return img <EOL><DEDENT>shp=(,)<EOL>criteria=(cv2.TERM_CRITERIA_EPS +cv2.TERM_CRITERIA_MAX_ITER,,)<EOL>objp=np.zeros((shp []*shp [],),np.float32)<EOL>objp [:,:]=np.mgrid [:shp [],:shp []].T.reshape(-,)<EOL>axis=np.float32([[,,],[,,],[,,-]]).reshape(-,)<EOL>camera=cv2.VideoCapture()<EOL>if not camera.isOpened():<EOL><INDENT>camera=cv2.VideoCapture()<EOL><DEDENT>chbd=cv2.imread('chessboard.jpg')<EOL>cv2.imshow('chessboard',chbd)<EOL>print chbd.shape <EOL>while True :<EOL><INDENT>img=camera.read()[]<EOL>img=cv2.flip(img,)<EOL>gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)<EOL>ret,corners=cv2.findChessboardCorners(gray,shp,None)<EOL>if ret==True :<EOL><INDENT>cv2.cornerSubPix(gray,corners,(,),(-,-),criteria)<EOL>rvecs,tvecs,inliers=cv2.solvePnPRansac(objp,corners,mtx,dist)<EOL>imgpts,jac=cv2.projectPoints(axis,rvecs,tvecs,mtx,dist)<EOL>img=draw(img,corners,imgpts)<EOL><DEDENT>cv2.imshow('img',img)<EOL>k=cv2.waitKey()&<EOL>if k==:<EOL><INDENT>break <EOL><DEDENT>elif k==ord('s'):<EOL><INDENT>cv2.imwrite('result.png',img)<EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOF><BOF>'<STR_LIT>'<EOL>__author__='<STR_LIT>'<EOL>import base64 <EOL>import errno <EOL>import logging <EOL>import os <EOL>import threading <EOL>from anyjson import simplejson <EOL>from oauth2client.client import Storage as BaseStorage <EOL>from oauth2client.client import Credentials <EOL>from oauth2client import util <EOL>from locked_file import LockedFile <EOL>logger=logging.getLogger(__name__)<EOL>_multistores={}<EOL>_multistores_lock=threading.Lock()<EOL>class Error(Exception):<EOL><INDENT> '<STR_LIT>'<EOL>pass <EOL><DEDENT>class NewerCredentialStoreError(Error):<EOL><INDENT> '<STR_LIT>'<EOL>pass <EOL><DEDENT>@util.positional()<EOL>def get_credential_storage(filename,client_id,user_agent,scope,<EOL>warn_on_readonly=True):<EOL><INDENT> '<STR_LIT>'<EOL>key={'clientId':client_id,'userAgent':user_agent,<EOL>'scope':util.scopes_to_string(scope)}<EOL>return get_credential_storage_custom_key(<EOL>filename,key,warn_on_readonly=warn_on_readonly)<EOL><DEDENT>@util.positional()<EOL>def get_credential_storage_custom_string_key(<EOL>filename,key_string,warn_on_readonly=True):<EOL><INDENT> '<STR_LIT>'<EOL>key_dict={'key':key_string }<EOL>return get_credential_storage_custom_key(<EOL>filename,key_dict,warn_on_readonly=warn_on_readonly)<EOL><DEDENT>@util.positional()<EOL>def get_credential_storage_custom_key(<EOL>filename,key_dict,warn_on_readonly=True):<EOL><INDENT> '<STR_LIT>'<EOL>filename=os.path.expanduser(filename)<EOL>_multistores_lock.acquire()<EOL>try :<EOL><INDENT>multistore=_multistores.setdefault(<EOL>filename,_MultiStore(filename,warn_on_readonly=warn_on_readonly))<EOL><DEDENT>finally :<EOL><INDENT>_multistores_lock.release()<EOL><DEDENT>key=util.dict_to_tuple_key(key_dict)<EOL>return multistore._get_storage(key)<EOL><DEDENT>class _MultiStore(object):<EOL><INDENT> '<STR_LIT>'<EOL>@util.positional()<EOL>def __init__(self,filename,warn_on_readonly=True):<EOL><INDENT> '<STR_LIT>'<EOL>self._file=LockedFile(filename,'r+b','rb')<EOL>self._thread_lock=threading.Lock()<EOL>self._read_only=False <EOL>self._warn_on_readonly=warn_on_readonly <EOL>self._create_file_if_needed()<EOL>self._data=None <EOL><DEDENT>class _Storage(BaseStorage):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,multistore,key):<EOL><INDENT>self._multistore=multistore <EOL>self._key=key <EOL><DEDENT>def acquire_lock(self):<EOL><INDENT> '<STR_LIT>'<EOL>self._multistore._lock()<EOL><DEDENT>def release_lock(self):<EOL><INDENT> '<STR_LIT>'<EOL>self._multistore._unlock()<EOL><DEDENT>def locked_get(self):<EOL><INDENT> '<STR_LIT>'<EOL>credential=self._multistore._get_credential(self._key)<EOL>if credential :<EOL><INDENT>credential.set_store(self)<EOL><DEDENT>return credential <EOL><DEDENT>def locked_put(self,credentials):<EOL><INDENT> '<STR_LIT>'<EOL>self._multistore._update_credential(self._key,credentials)<EOL><DEDENT>def locked_delete(self):<EOL><INDENT> '<STR_LIT>'<EOL>self._multistore._delete_credential(self._key)<EOL><DEDENT> <DEDENT>def _create_file_if_needed(self):<EOL><INDENT> '<STR_LIT>'<EOL>if not os.path.exists(self._file.filename()):<EOL><INDENT>old_umask=os.umask()<EOL>try :<EOL><INDENT>open(self._file.filename(),'a+b').close()<EOL><DEDENT>finally :<EOL><INDENT>os.umask(old_umask)<EOL><DEDENT> <DEDENT> <DEDENT>def _lock(self):<EOL><INDENT> '<STR_LIT>'<EOL>self._thread_lock.acquire()<EOL>self._file.open_and_lock()<EOL>if not self._file.is_locked():<EOL><INDENT>self._read_only=True <EOL>if self._warn_on_readonly :<EOL><INDENT>logger.warn('<STR_LIT>'<EOL>'<STR_LIT>'<EOL>'<STR_LIT>'%self._file.filename())<EOL><DEDENT> <DEDENT>if os.path.getsize(self._file.filename())==:<EOL><INDENT>logger.debug('<STR_LIT>')<EOL>self._data={}<EOL>self._write()<EOL><DEDENT>elif not self._read_only or self._data is None :<EOL><INDENT>self._refresh_data_cache()<EOL><DEDENT> <DEDENT>def _unlock(self):<EOL><INDENT> '<STR_LIT>'<EOL>self._file.unlock_and_close()<EOL>self._thread_lock.release()<EOL><DEDENT>def _locked_json_read(self):<EOL><INDENT> '<STR_LIT>'<EOL>assert self._thread_lock.locked()<EOL>self._file.file_handle().seek()<EOL>return simplejson.load(self._file.file_handle())<EOL><DEDENT>def _locked_json_write(self,data):<EOL><INDENT> '<STR_LIT>'<EOL>assert self._thread_lock.locked()<EOL>if self._read_only :<EOL><INDENT>return <EOL><DEDENT>self._file.file_handle().seek()<EOL>simplejson.dump(data,self._file.file_handle(),sort_keys=True,indent=)<EOL>self._file.file_handle().truncate()<EOL><DEDENT>def _refresh_data_cache(self):<EOL><INDENT> '<STR_LIT>'<EOL>self._data={}<EOL>try :<EOL><INDENT>raw_data=self._locked_json_read()<EOL><DEDENT>except Exception :<EOL><INDENT>logger.warn('<STR_LIT>'<EOL>'<STR_LIT>')<EOL>return <EOL><DEDENT>version=<EOL>try :<EOL><INDENT>version=raw_data ['file_version']<EOL><DEDENT>except Exception :<EOL><INDENT>logger.warn('<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT>if version >:<EOL><INDENT>raise NewerCredentialStoreError(<EOL>'<STR_LIT>'<EOL>'<STR_LIT>'%version)<EOL><DEDENT>credentials=[]<EOL>try :<EOL><INDENT>credentials=raw_data ['data']<EOL><DEDENT>except(TypeError,KeyError):<EOL><INDENT>pass <EOL><DEDENT>for cred_entry in credentials :<EOL><INDENT>try :<EOL><INDENT>(key,credential)=self._decode_credential_from_json(cred_entry)<EOL>self._data [key ]=credential <EOL><DEDENT>except :<EOL><INDENT>logger.info('<STR_LIT>',exc_info=True)<EOL><DEDENT> <DEDENT> <DEDENT>def _decode_credential_from_json(self,cred_entry):<EOL><INDENT> '<STR_LIT>'<EOL>raw_key=cred_entry ['key']<EOL>key=util.dict_to_tuple_key(raw_key)<EOL>credential=None <EOL>credential=Credentials.new_from_json(simplejson.dumps(cred_entry ['credential']))<EOL>return(key,credential)<EOL><DEDENT>def _write(self):<EOL><INDENT> '<STR_LIT>'<EOL>raw_data={'file_version':}<EOL>raw_creds=[]<EOL>raw_data ['data']=raw_creds <EOL>for(cred_key,cred)in self._data.items():<EOL><INDENT>raw_key=dict(cred_key)<EOL>raw_cred=simplejson.loads(cred.to_json())<EOL>raw_creds.append({'key':raw_key,'credential':raw_cred })<EOL><DEDENT>self._locked_json_write(raw_data)<EOL><DEDENT>def _get_credential(self,key):<EOL><INDENT> '<STR_LIT>'<EOL>return self._data.get(key,None)<EOL><DEDENT>def _update_credential(self,key,cred):<EOL><INDENT> '<STR_LIT>'<EOL>self._data [key ]=cred <EOL>self._write()<EOL><DEDENT>def _delete_credential(self,key):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>del self._data [key ]<EOL><DEDENT>except KeyError :<EOL><INDENT>pass <EOL><DEDENT>self._write()<EOL><DEDENT>def _get_storage(self,key):<EOL><INDENT> '<STR_LIT>'<EOL>return self._Storage(self,key)<EOL><DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from.model import BaseTestSuite,BaseTestCase <EOL>from.keyword import BaseKeyword <EOL>from.handlers import UserErrorHandler <EOL>from.libraries import BaseLibrary <EOL>from.statistics import Statistics <EOF><BOF>from getpass import getuser <EOL>from random import randrange <EOL>from itertools import product <EOL>import mosql.util <EOL>import mosql.mysql <EOL>import mosql.std <EOL>def connect_to_postgresql():<EOL><INDENT>import psycopg2 <EOL>conn=psycopg2.connect(user=getuser())<EOL>cur=conn.cursor()<EOL>cur.execute('<STR_LIT>')<EOL>server_encoding,=cur.fetchone()<EOL>assert server_encoding=='UTF8'<EOL>cur.execute('<STR_LIT>')<EOL>client_encoding,=cur.fetchone()<EOL>assert client_encoding=='UTF8'<EOL>cur.close()<EOL>return conn <EOL><DEDENT>def make_identifier(s):<EOL><INDENT>if isinstance(s,unicode):<EOL><INDENT>s=s.encode('utf-8')<EOL><DEDENT>return mosql.util.delimit_identifier(<EOL>mosql.util.escape_identifier(s))<EOL><DEDENT>DENO=<EOL>POSTGRESQL_SLICE_SIZE=<EOL>def gen_slice_for_postgresql(s):<EOL><INDENT>for i in xrange(,len(s),POSTGRESQL_SLICE_SIZE):<EOL><INDENT>yield s [i :i +POSTGRESQL_SLICE_SIZE ]<EOL><DEDENT> <DEDENT>def test_identifier_in_postgresql():<EOL><INDENT>mosql.std.patch()<EOL>conn=connect_to_postgresql()<EOL>cur=conn.cursor()<EOL>expected_text=u''.join(unichr(i)for i in xrange(,))<EOL>expected_text +=u''.join(unichr(i)for i in xrange(,+))<EOL>for sliced_expected_text in gen_slice_for_postgresql(expected_text):<EOL><INDENT>if randrange(DENO)!=:continue <EOL>cur.execute('<STR_LIT>'.format(make_identifier(sliced_expected_text)))<EOL>cur.execute('<STR_LIT>')<EOL>fetched_bytes,=cur.fetchone()<EOL>fetched_text=fetched_bytes.decode('utf-8')<EOL>assert fetched_text==sliced_expected_text <EOL>conn.rollback()<EOL><DEDENT>ascii_chars=[unichr(i)for i in xrange(,+)]<EOL>expected_text=u''.join(a +b for a,b in product(ascii_chars,ascii_chars))<EOL>for sliced_expected_text in gen_slice_for_postgresql(expected_text):<EOL><INDENT>if randrange(DENO)!=:continue <EOL>cur.execute('<STR_LIT>'.format(make_identifier(sliced_expected_text)))<EOL>cur.execute('<STR_LIT>')<EOL>fetched_bytes,=cur.fetchone()<EOL>fetched_text=fetched_bytes.decode('utf-8')<EOL>assert fetched_text==sliced_expected_text <EOL>conn.rollback()<EOL><DEDENT>cur.close()<EOL>conn.close()<EOL><DEDENT>def connect_to_mysql():<EOL><INDENT>import MySQLdb <EOL>conn=MySQLdb.connect(user='root',db='root')<EOL>cur=conn.cursor()<EOL>cur.execute('<STR_LIT>')<EOL>_,character_set_connection=cur.fetchone()<EOL>assert character_set_connection=='utf8'<EOL>cur.close()<EOL>return conn <EOL><DEDENT>MYSQL_SLICE_SIZE=<EOL>def gen_slice_for_mysql(s):<EOL><INDENT>for i in xrange(,len(s),MYSQL_SLICE_SIZE):<EOL><INDENT>yield s [i :i +MYSQL_SLICE_SIZE ]<EOL><DEDENT> <DEDENT>MYSQL_SPACE_CHAR_SET=set('<STR_LIT>')<EOL>def fix_mysql_space_char(s):<EOL><INDENT>to_check_pos=-<EOL>while s [to_check_pos ]in MYSQL_SPACE_CHAR_SET :<EOL><INDENT>to_check_pos -=<EOL><DEDENT>if to_check_pos==-:<EOL><INDENT>return s <EOL><DEDENT>pos=to_check_pos +<EOL>return s [pos :]+s [:pos ]<EOL><DEDENT>def test_identifier_in_mysql():<EOL><INDENT>mosql.mysql.patch()<EOL>conn=connect_to_mysql()<EOL>cur=conn.cursor()<EOL>expected_text=u''.join(unichr(i)for i in xrange(,))<EOL>expected_text +=u''.join(unichr(i)for i in xrange(,+))<EOL>for sliced_expected_text in gen_slice_for_mysql(expected_text):<EOL><INDENT>if randrange(DENO)!=:continue <EOL>sliced_expected_text=fix_mysql_space_char(sliced_expected_text)<EOL>cur.execute('<STR_LIT>'.format(make_identifier(sliced_expected_text)))<EOL>cur.execute('<STR_LIT>')<EOL>fetched_bytes,_,_,_,_,_=cur.fetchone()<EOL>fetched_text=fetched_bytes.decode('utf-8')<EOL>assert fetched_text==sliced_expected_text <EOL>cur.execute('<STR_LIT>')<EOL><DEDENT>ascii_chars=[unichr(i)for i in xrange(,+)]<EOL>expected_text=u''.join(a +b for a,b in product(ascii_chars,ascii_chars))<EOL>for sliced_expected_text in gen_slice_for_mysql(expected_text):<EOL><INDENT>if randrange(DENO)!=:continue <EOL>sliced_expected_text=fix_mysql_space_char(sliced_expected_text)<EOL>cur.execute('<STR_LIT>'.format(make_identifier(sliced_expected_text)))<EOL>cur.execute('<STR_LIT>')<EOL>fetched_bytes,_,_,_,_,_=cur.fetchone()<EOL>fetched_text=fetched_bytes.decode('utf-8')<EOL>assert fetched_text==sliced_expected_text <EOL>cur.execute('<STR_LIT>')<EOL><DEDENT>cur.close()<EOL>conn.close()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from buildservice.models import OAuthToken,Webhook <EOL>def create_user_token(user,repo=None):<EOL><INDENT> '<STR_LIT>'<EOL>token=OAuthToken.objects.create(user=user,value='the_token')<EOL>if repo :<EOL><INDENT>Webhook.objects.create(repository=repo)<EOL><DEDENT>return token <EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>from common import nothing <EOL>def blur_edge(img,d=):<EOL><INDENT>h,w=img.shape [:]<EOL>img_pad=cv2.copyMakeBorder(img,d,d,d,d,cv2.BORDER_WRAP)<EOL>img_blur=cv2.GaussianBlur(img_pad,(*d +,*d +),-)[d :-d,d :-d ]<EOL>y,x=np.indices((h,w))<EOL>dist=np.dstack([x,w -x -,y,h -y -]).min(-)<EOL>w=np.minimum(np.float32(dist)/d,)<EOL>return img *w +img_blur *(-w)<EOL><DEDENT>def motion_kernel(angle,d,sz=):<EOL><INDENT>kern=np.ones((,d),np.float32)<EOL>c,s=np.cos(angle),np.sin(angle)<EOL>A=np.float32([[c,-s,],[s,c,]])<EOL>sz2=sz //<EOL>A [:,]=(sz2,sz2)-np.dot(A [:,:],((d -)*,))<EOL>kern=cv2.warpAffine(kern,A,(sz,sz),flags=cv2.INTER_CUBIC)<EOL>return kern <EOL><DEDENT>def defocus_kernel(d,sz=):<EOL><INDENT>kern=np.zeros((sz,sz),np.uint8)<EOL>cv2.circle(kern,(sz,sz),d,,-,cv2.CV_AA,shift=)<EOL>kern=np.float32(kern)/<EOL>return kern <EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>import sys,getopt <EOL>opts,args=getopt.getopt(sys.argv [:],'',['circle','angle=','d=','snr='])<EOL>opts=dict(opts)<EOL>try :fn=args []<EOL>except :fn='<STR_LIT>'<EOL>win='deconvolution'<EOL>img=cv2.imread(fn,)<EOL>img=np.float32(img)/<EOL>cv2.imshow('input',img)<EOL>img=blur_edge(img)<EOL>IMG=cv2.dft(img,flags=cv2.DFT_COMPLEX_OUTPUT)<EOL>defocus='--circle'in opts <EOL>def update(_):<EOL><INDENT>ang=np.deg2rad(cv2.getTrackbarPos('angle',win))<EOL>d=cv2.getTrackbarPos('d',win)<EOL>noise=**(-*cv2.getTrackbarPos('SNR(db)',win))<EOL>if defocus :<EOL><INDENT>psf=defocus_kernel(d)<EOL><DEDENT>else :<EOL><INDENT>psf=motion_kernel(ang,d)<EOL><DEDENT>cv2.imshow('psf',psf)<EOL>psf /=psf.sum()<EOL>psf_pad=np.zeros_like(img)<EOL>kh,kw=psf.shape <EOL>psf_pad [:kh,:kw ]=psf <EOL>PSF=cv2.dft(psf_pad,flags=cv2.DFT_COMPLEX_OUTPUT,nonzeroRows=kh)<EOL>PSF2=(PSF **).sum(-)<EOL>iPSF=PSF /(PSF2 +noise)[...,np.newaxis ]<EOL>RES=cv2.mulSpectrums(IMG,iPSF,)<EOL>res=cv2.idft(RES,flags=cv2.DFT_SCALE |cv2.DFT_REAL_OUTPUT)<EOL>res=np.roll(res,-kh //,)<EOL>res=np.roll(res,-kw //,)<EOL>cv2.imshow(win,res)<EOL><DEDENT>cv2.namedWindow(win)<EOL>cv2.namedWindow('psf',)<EOL>cv2.createTrackbar('angle',win,int(opts.get('--angle',)),,update)<EOL>cv2.createTrackbar('d',win,int(opts.get('--d',)),,update)<EOL>cv2.createTrackbar('SNR(db)',win,int(opts.get('--snr',)),,update)<EOL>update(None)<EOL>while True :<EOL><INDENT>ch=cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT>if ch==ord(' '):<EOL><INDENT>defocus=not defocus <EOL>update(None)<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>from flask import render_template <EOL>from.import main_blueprint <EOL>@main_blueprint.errorhandler()<EOL>def page_not_found(e):<EOL><INDENT>return render_template('404.html'),<EOL><DEDENT>@main_blueprint.errorhandler()<EOL>def page_not_allowed(e):<EOL><INDENT>return render_template('403.html'),<EOL><DEDENT><EOF><BOF>__version__="1.1"<EOL>GOOGLE_AUTH_URI='<STR_LIT>'<EOL>GOOGLE_REVOKE_URI='<STR_LIT>'<EOL>GOOGLE_TOKEN_URI='<STR_LIT>'<EOF><BOF>'<STR_LIT>'<EOL>import urllib2 <EOL>import cv2.cv as cv <EOL>from math import cos,sin,sqrt <EOL>import sys <EOL>if __name__=="__main__":<EOL><INDENT>A=[[,],[,]]<EOL>img=cv.CreateImage((,),,)<EOL>kalman=cv.CreateKalman(,,)<EOL>state=cv.CreateMat(,,cv.CV_32FC1)<EOL>process_noise=cv.CreateMat(,,cv.CV_32FC1)<EOL>measurement=cv.CreateMat(,,cv.CV_32FC1)<EOL>rng=cv.RNG(-)<EOL>code=-L <EOL>cv.Zero(measurement)<EOL>cv.NamedWindow("Kalman",)<EOL>while True :<EOL><INDENT>cv.RandArr(rng,state,cv.CV_RAND_NORMAL,cv.RealScalar(),cv.RealScalar())<EOL>kalman.transition_matrix [,]=<EOL>kalman.transition_matrix [,]=<EOL>kalman.transition_matrix [,]=<EOL>kalman.transition_matrix [,]=<EOL>cv.SetIdentity(kalman.measurement_matrix,cv.RealScalar())<EOL>cv.SetIdentity(kalman.process_noise_cov,cv.RealScalar())<EOL>cv.SetIdentity(kalman.measurement_noise_cov,cv.RealScalar())<EOL>cv.SetIdentity(kalman.error_cov_post,cv.RealScalar())<EOL>cv.RandArr(rng,kalman.state_post,cv.CV_RAND_NORMAL,cv.RealScalar(),cv.RealScalar())<EOL>while True :<EOL><INDENT>def calc_point(angle):<EOL><INDENT>return(cv.Round(img.width /+img.width /*cos(angle)),<EOL>cv.Round(img.height /-img.width /*sin(angle)))<EOL><DEDENT>state_angle=state [,]<EOL>state_pt=calc_point(state_angle)<EOL>prediction=cv.KalmanPredict(kalman)<EOL>predict_angle=prediction [,]<EOL>predict_pt=calc_point(predict_angle)<EOL>cv.RandArr(rng,measurement,cv.CV_RAND_NORMAL,cv.RealScalar(),<EOL>cv.RealScalar(sqrt(kalman.measurement_noise_cov [,])))<EOL>cv.MatMulAdd(kalman.measurement_matrix,state,measurement,measurement)<EOL>measurement_angle=measurement [,]<EOL>measurement_pt=calc_point(measurement_angle)<EOL>def draw_cross(center,color,d):<EOL><INDENT>cv.Line(img,(center []-d,center []-d),(center []+d,center []+d),color,,cv.CV_AA,)<EOL>cv.Line(img,(center []+d,center []-d),(center []-d,center []+d),color,,cv.CV_AA,)<EOL><DEDENT>cv.Zero(img)<EOL>draw_cross(state_pt,cv.CV_RGB(,,),)<EOL>draw_cross(measurement_pt,cv.CV_RGB(,,),)<EOL>draw_cross(predict_pt,cv.CV_RGB(,,),)<EOL>cv.Line(img,state_pt,measurement_pt,cv.CV_RGB(,,),,cv.CV_AA,)<EOL>cv.Line(img,state_pt,predict_pt,cv.CV_RGB(,,),,cv.CV_AA,)<EOL>cv.KalmanCorrect(kalman,measurement)<EOL>cv.RandArr(rng,process_noise,cv.CV_RAND_NORMAL,cv.RealScalar(),<EOL>cv.RealScalar(sqrt(kalman.process_noise_cov [,])))<EOL>cv.MatMulAdd(kalman.transition_matrix,state,process_noise,state)<EOL>cv.ShowImage("Kalman",img)<EOL>code=cv.WaitKey()%<EOL>if code !=-:<EOL><INDENT>break <EOL><DEDENT> <DEDENT>if code in [,ord('q'),ord('Q')]:<EOL><INDENT>break <EOL><DEDENT> <DEDENT>cv.DestroyWindow("Kalman")<EOL><DEDENT><EOF><BOF>import urllib2 <EOL>from math import sqrt <EOL>import cv2.cv as cv <EOL>thresh=<EOL>img=None <EOL>img0=None <EOL>storage=None <EOL>wndname='<STR_LIT>'<EOL>def angle(pt1,pt2,pt0):<EOL><INDENT>dx1=pt1.x -pt0.x <EOL>dy1=pt1.y -pt0.y <EOL>dx2=pt2.x -pt0.x <EOL>dy2=pt2.y -pt0.y <EOL>return(dx1 *dx2 +dy1 *dy2)/sqrt((dx1 *dx1 +dy1 *dy1)*(dx2 *dx2 +dy2 *dy2)+)<EOL><DEDENT>def findSquares4(img,storage):<EOL><INDENT>N=<EOL>sz=(img.width &-,img.height &-)<EOL>timg=cv.CloneImage(img);<EOL>gray=cv.CreateImage(sz,,)<EOL>pyr=cv.CreateImage((sz.width /,sz.height /),,)<EOL>squares=cv.CreateSeq(,sizeof_CvSeq,sizeof_CvPoint,storage)<EOL>squares=CvSeq_CvPoint.cast(squares)<EOL>subimage=cv.GetSubRect(timg,cv.Rect(,,sz.width,sz.height))<EOL>cv.PyrDown(subimage,pyr,)<EOL>cv.PyrUp(pyr,subimage,)<EOL>tgray=cv.CreateImage(sz,,)<EOL>for c in range():<EOL><INDENT>channels=[None,None,None ]<EOL>channels [c ]=tgray <EOL>cv.Split(subimage,channels [],channels [],channels [],None)<EOL>for l in range(N):<EOL><INDENT>if(l==):<EOL><INDENT>cv.Canny(tgray,gray,,thresh,)<EOL>cv.Dilate(gray,gray,None,)<EOL><DEDENT>else :<EOL><INDENT>cv.Threshold(tgray,gray,(l +)*/N,,cv.CV_THRESH_BINARY)<EOL><DEDENT>count,contours=cv.FindContours(gray,storage,sizeof_CvContour,<EOL>cv.CV_RETR_LIST,cv.CV_CHAIN_APPROX_SIMPLE,(,))<EOL>if not contours :<EOL><INDENT>continue <EOL><DEDENT>for contour in contours.hrange():<EOL><INDENT>result=cv.ApproxPoly(contour,sizeof_CvContour,storage,<EOL>cv.CV_POLY_APPROX_DP,cv.ContourPerimeter(contours)*,)<EOL>if(result.total==and <EOL>abs(cv.ContourArea(result))>and <EOL>cv.CheckContourConvexity(result)):<EOL><INDENT>s=<EOL>for i in range():<EOL><INDENT>if(i >=):<EOL><INDENT>t=abs(angle(result [i ],result [i -],result [i -]))<EOL>if s <t :<EOL><INDENT>s=t <EOL><DEDENT> <DEDENT> <DEDENT>if(s <):<EOL><INDENT>for i in range():<EOL><INDENT>squares.append(result [i ])<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>return squares <EOL><DEDENT>def drawSquares(img,squares):<EOL><INDENT>cpy=cv.CloneImage(img)<EOL>i=<EOL>while i <squares.total :<EOL><INDENT>pt=[]<EOL>pt.append(squares [i ])<EOL>pt.append(squares [i +])<EOL>pt.append(squares [i +])<EOL>pt.append(squares [i +])<EOL>cv.PolyLine(cpy,[pt ],,cv.CV_RGB(,,),,cv.CV_AA,)<EOL>i +=<EOL><DEDENT>cv.ShowImage(wndname,cpy)<EOL><DEDENT>def on_trackbar(a):<EOL><INDENT>if(img):<EOL><INDENT>drawSquares(img,findSquares4(img,storage))<EOL><DEDENT> <DEDENT>names=["../c/pic1.png","../c/pic2.png","../c/pic3.png",<EOL>"../c/pic4.png","../c/pic5.png","../c/pic6.png"]<EOL>if __name__=="__main__":<EOL><INDENT>storage=cv.CreateMemStorage()<EOL>for name in names :<EOL><INDENT>img0=cv.LoadImage(name,)<EOL>if not img0 :<EOL><INDENT>print '<STR_LIT>'%name <EOL>continue <EOL><DEDENT>img=cv.CloneImage(img0)<EOL>cv.NamedWindow(wndname,)<EOL>cv.CreateTrackbar("canny thresh",wndname,thresh,,on_trackbar)<EOL>on_trackbar()<EOL>c=cv.WaitKey()%<EOL>cv.ClearMemStorage(storage)<EOL>if(c=='\x1b'):<EOL><INDENT>break <EOL><DEDENT> <DEDENT>cv.DestroyWindow(wndname)<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import threading <EOL>import string <EOL>import vim <EOL>import time <EOL>import os <EOL>import filepirate <EOL>POLL_INTERVAL=<EOL>DUMMY_FILEPIRATE=False <EOL>DUMMY_FILEPIRATE_DELAY=<EOL>PROMPT='> '<EOL>SPINNER_DELAY=<EOL>BUFFER_OPTIONS=[<EOL>'<STR_LIT>',<EOL>'buftype=nofile',<EOL>'nomodifiable',<EOL>'noswapfile',<EOL>'nowrap',<EOL>'nonumber',<EOL>'nolist',<EOL>'foldcolumn=0',<EOL>'foldlevel=99',<EOL>'nocursorline',<EOL>'nospell',<EOL>'nobuflisted',<EOL>'textwidth=0'<EOL>]<EOL>GLOBAL_OPTIONS={<EOL>'showcmd':False,<EOL>}<EOL>KEYS={<EOL>'insert':string.letters +string.digits +'.',<EOL>'normal':{<EOL>'<STR_LIT>':'<CR>',<EOL>'<STR_LIT>':'<STR_LIT>',<EOL>'filepirate_up':'<Up>',<EOL>'filepirate_down':'<Down>',<EOL>'filepirate_bs':'<BS>',<EOL>'<STR_LIT>':'<C-R>'},<EOL>'dualmode_normal':{<EOL>'<STR_LIT>':'<CR>',<EOL>'<STR_LIT>':'<STR_LIT>',<EOL>'filepirate_up':'',<EOL>'filepirate_down':'',<EOL>'filepirate_bs':'',<EOL>'<STR_LIT>':'<C-R>',<EOL>'<STR_LIT>':'i'},<EOL>'dualmode_insert':{<EOL>'<STR_LIT>':'<CR>',<EOL>'<STR_LIT>':'<STR_LIT>',<EOL>'filepirate_up':'<Up>',<EOL>'filepirate_down':'<Down>',<EOL>'filepirate_bs':'<BS>',<EOL>'<STR_LIT>':'<C-R>',<EOL>'<STR_LIT>':'<Char-27>'},<EOL>}<EOL>CONFIGURABLES={'<STR_LIT>':(int,),<EOL>'<STR_LIT>':(int,),<EOL>'<STR_LIT>':(dict,{}),<EOL>'<STR_LIT>':(dict,{})}<EOL>SPINNER=r'/-\|'<EOL>MODE_INSERT=<EOL>MODE_NORMAL=<EOL>MODE_NOMODE=<EOL>CUSTOM_KEY_MODE_SUFFIX={MODE_INSERT :'_insert',MODE_NORMAL :'_normal',MODE_NOMODE :''}<EOL>class ConfigLoadError(Exception):<EOL><INDENT>pass <EOL><DEDENT>class FilePirateThread(threading.Thread):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,max_results):<EOL><INDENT>threading.Thread.__init__(self)<EOL>self.daemon=True <EOL>self.search_terms=[]<EOL>self.lock=threading.Lock()<EOL>self.event=threading.Event()<EOL>self.results=None <EOL>self.rescan_requested=False <EOL>if DUMMY_FILEPIRATE :<EOL><INDENT>self.do_search=self.do_search_dummy <EOL>self.dummy_counter=<EOL><DEDENT>else :<EOL><INDENT>self.do_search=self.do_search_fp <EOL>self.pirates=filepirate.FilePirates(max_results)<EOL><DEDENT> <DEDENT>def run(self):<EOL><INDENT>while True :<EOL><INDENT>self.lock.acquire()<EOL>if not self.search_terms :<EOL><INDENT>self.lock.release()<EOL>self.event.wait()<EOL><DEDENT>else :<EOL><INDENT>self.lock.release()<EOL><DEDENT>self.lock.acquire()<EOL>if self.search_terms :<EOL><INDENT>term=self.search_terms [-]<EOL>self.search_terms=[]<EOL>self.event.clear()<EOL>self.lock.release()<EOL>self.results=None <EOL>results=self.do_search(term)<EOL>if not self.search_terms :<EOL><INDENT>self.results=results <EOL><DEDENT> <DEDENT>else :<EOL><INDENT>self.event.clear()<EOL>self.lock.release()<EOL><DEDENT> <DEDENT> <DEDENT>def do_search_fp(self,term):<EOL><INDENT>try :<EOL><INDENT>pirate=self.pirates.get(os.getcwd())<EOL><DEDENT>except Exception as e :<EOL><INDENT>return ["ERROR: %s"%(str(e))]<EOL><DEDENT>if self.rescan_requested :<EOL><INDENT>pirate.rescan()<EOL>self.rescan_requested=False <EOL><DEDENT>try :<EOL><INDENT>results=pirate.get_candidates(term)<EOL><DEDENT>except Exception as e :<EOL><INDENT>return ["ERROR: %s"%(str(e))]<EOL><DEDENT>results=[result [:]if result.startswith('./')else result for result in results ]<EOL>return results <EOL><DEDENT>def do_search_dummy(self,term):<EOL><INDENT>self.dummy_counter +=<EOL>time.sleep(DUMMY_FILEPIRATE_DELAY)<EOL>self.rescan_requested=False <EOL>return ['<STR_LIT>'%(self.dummy_counter,term)for i in range()]<EOL><DEDENT>def search(self,term):<EOL><INDENT>self.lock.acquire()<EOL>self.search_terms.append(term)<EOL>self.event.set()<EOL>self.lock.release()<EOL><DEDENT>def rescan(self):<EOL><INDENT>self.rescan_requested=True <EOL><DEDENT> <DEDENT>class VimAsync(object):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self):<EOL><INDENT>self.running=False <EOL>self.clear()<EOL>self.saved_updatetime=int(vim.eval('&updatetime'))<EOL><DEDENT>def clear(self):<EOL><INDENT>self.callback=None <EOL>self.callback_args=None <EOL><DEDENT>def start(self,callback,*args):<EOL><INDENT>self.callback=callback <EOL>self.callback_args=args <EOL>if not self.running :<EOL><INDENT>self.saved_updatetime=int(vim.eval('&updatetime'))<EOL>vim.command('<STR_LIT>'%(POLL_INTERVAL))<EOL>vim.command('<STR_LIT>')<EOL>vim.command('<STR_LIT>')<EOL>self.running=True <EOL><DEDENT> <DEDENT>def stop(self):<EOL><INDENT>vim.command('<STR_LIT>'%(self.saved_updatetime))<EOL>vim.command('<STR_LIT>')<EOL>self.running=False <EOL>self.clear()<EOL><DEDENT>def from_vim(self):<EOL><INDENT>assert self.running <EOL>self.callback(*self.callback_args)<EOL>vim.command('<STR_LIT>')<EOL><DEDENT> <DEDENT>class VimFilePirate(object):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self):<EOL><INDENT>self.buf=None <EOL>self.async=VimAsync()<EOL>self.fp=None <EOL>self.searching=False <EOL>self.stored_vim_globals={}<EOL>self.previous_window_number=None <EOL>self.search_start_time=<EOL>self.reset()<EOL><DEDENT>def reset(self):<EOL><INDENT>self.term=''<EOL>self.spinner_character=' '<EOL>self.spinner_position=<EOL>self.mode=MODE_NOMODE <EOL><DEDENT>def buffer_create(self):<EOL><INDENT>self.config_load()<EOL>window_height=self.config ['<STR_LIT>']+<EOL>vim.command('<STR_LIT>'%(window_height))<EOL>for option in BUFFER_OPTIONS :<EOL><INDENT>vim.command('setlocal '+option)<EOL><DEDENT>assert 'FilePirate'in vim.current.buffer.name <EOL>if self.config ['<STR_LIT>']:<EOL><INDENT>self.mode=MODE_INSERT <EOL><DEDENT>else :<EOL><INDENT>self.mode=MODE_NOMODE <EOL><DEDENT>self.buffer_register_keys()<EOL>self.buf=vim.current.buffer <EOL>self.draw_search_line()<EOL>self.unlock_buffer()<EOL>for idx in range(self.config ['<STR_LIT>']):<EOL><INDENT>if len(self.buf)-<idx :<EOL><INDENT>self.buf.append('')<EOL><DEDENT> <DEDENT>self.lock_buffer()<EOL>vim.current.window.cursor=(,)<EOL><DEDENT>def config_load(self):<EOL><INDENT>self.config={}<EOL>for key,keyinfo in CONFIGURABLES.items():<EOL><INDENT>key_class,key_default=keyinfo <EOL>if vim.eval('exists("%s")'%(key))!='0':<EOL><INDENT>value=vim.eval('%s'%(key))<EOL>try :<EOL><INDENT>if key_class is int :<EOL><INDENT>value=int(value)<EOL><DEDENT>elif key_class is dict :<EOL><INDENT>pass <EOL><DEDENT>else :<EOL><INDENT>raise NotImplementedError(key_class)<EOL><DEDENT> <DEDENT>except Exception as e :<EOL><INDENT>raise ConfigLoadError('<STR_LIT>'%(key,str(e)))<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>value=key_default <EOL><DEDENT>self.config [key ]=value <EOL><DEDENT> <DEDENT>def _buffer_register_keys_standard(self):<EOL><INDENT>for key in KEYS ['insert']:<EOL><INDENT>ascii_val=ord(key)<EOL>vim.command('<STR_LIT>'%(ascii_val,ascii_val))<EOL><DEDENT> <DEDENT>def _buffer_unregister_keys_standard(self):<EOL><INDENT>for key in KEYS ['insert']:<EOL><INDENT>ascii_val=ord(key)<EOL>vim.command('<STR_LIT>'%(ascii_val))<EOL><DEDENT> <DEDENT>def _maybe_get_custom_key_mapping(self,cmd,keyname):<EOL><INDENT>key_customisation_name='g:%s%s'%(cmd,CUSTOM_KEY_MODE_SUFFIX [self.mode ])<EOL>if vim.eval('exists("%s")'%(key_customisation_name))!='0':<EOL><INDENT>keyname=vim.eval('%s'%(key_customisation_name))<EOL><DEDENT>return keyname <EOL><DEDENT>def _buffer_register_keys_special(self,keys):<EOL><INDENT>for cmd,keyname in keys.items():<EOL><INDENT>keyname=self._maybe_get_custom_key_mapping(cmd,keyname)<EOL>if keyname :<EOL><INDENT>vim.command('<STR_LIT>'%(keyname,cmd))<EOL><DEDENT> <DEDENT> <DEDENT>def _buffer_unregister_keys_special(self,keys):<EOL><INDENT>for cmd,keyname in keys.items():<EOL><INDENT>keyname=self._maybe_get_custom_key_mapping(cmd,keyname)<EOL>if keyname :<EOL><INDENT>vim.command('<STR_LIT>'%(keyname))<EOL><DEDENT> <DEDENT> <DEDENT>def _buffer_register_keys_extra(self,keys):<EOL><INDENT>for keyname,cmd in keys.items():<EOL><INDENT>vim.command('<STR_LIT>'%(keyname,cmd))<EOL><DEDENT> <DEDENT>def _buffer_unregister_keys_extra(self,keys):<EOL><INDENT>for keyname in keys.keys():<EOL><INDENT>vim.command('<STR_LIT>'%(keyname))<EOL><DEDENT> <DEDENT>def buffer_register_keys(self):<EOL><INDENT>if self.mode==MODE_INSERT :<EOL><INDENT>self._buffer_register_keys_standard()<EOL>self._buffer_register_keys_special(KEYS ['dualmode_insert'])<EOL>self._buffer_register_keys_extra(self.config ['<STR_LIT>'])<EOL><DEDENT>elif self.mode==MODE_NORMAL :<EOL><INDENT>self._buffer_register_keys_special(KEYS ['dualmode_normal'])<EOL>self._buffer_register_keys_extra(self.config ['<STR_LIT>'])<EOL><DEDENT>else :<EOL><INDENT>assert self.mode==MODE_NOMODE <EOL>self._buffer_register_keys_standard()<EOL>self._buffer_register_keys_special(KEYS ['normal'])<EOL><DEDENT> <DEDENT>def buffer_unregister_keys(self):<EOL><INDENT>if self.mode==MODE_INSERT :<EOL><INDENT>self._buffer_unregister_keys_standard()<EOL>self._buffer_unregister_keys_special(KEYS ['dualmode_insert'])<EOL>self._buffer_unregister_keys_extra(self.config ['<STR_LIT>'])<EOL><DEDENT>elif self.mode==MODE_NORMAL :<EOL><INDENT>self._buffer_unregister_keys_special(KEYS ['dualmode_normal'])<EOL>self._buffer_unregister_keys_extra(self.config ['<STR_LIT>'])<EOL><DEDENT>else :<EOL><INDENT>assert self.mode==MODE_NOMODE <EOL>self._buffer_unregister_keys_standard()<EOL>self._buffer_unregister_keys_special(KEYS ['normal'])<EOL><DEDENT> <DEDENT>def search_poll(self):<EOL><INDENT>if self.searching is True :<EOL><INDENT>if self.fp and self.fp.results is not None :<EOL><INDENT>self.spinner_character=' '<EOL>self.async.stop()<EOL>self.searching=False <EOL>self.draw_search_line()<EOL>self.show_results(self.fp.results)<EOL><DEDENT>else :<EOL><INDENT>self.advance_spinner()<EOL><DEDENT> <DEDENT> <DEDENT>def advance_spinner(self):<EOL><INDENT>if time.time()-self.search_start_time >SPINNER_DELAY :<EOL><INDENT>self.spinner_character=SPINNER [self.spinner_position ]<EOL>self.spinner_position=(self.spinner_position +)%len(SPINNER)<EOL>self.draw_search_line()<EOL><DEDENT> <DEDENT>def draw_search_line(self):<EOL><INDENT>self.unlock_buffer()<EOL>self.buf []=self.spinner_character +PROMPT +self.term <EOL>self.lock_buffer()<EOL><DEDENT>def lock_buffer(self):<EOL><INDENT>vim.command('<STR_LIT>')<EOL><DEDENT>def unlock_buffer(self):<EOL><INDENT>vim.command('<STR_LIT>')<EOL><DEDENT>def show_results(self,results):<EOL><INDENT>self.unlock_buffer()<EOL>for idx,result in enumerate(results):<EOL><INDENT>self.buf [idx +]=' '+result <EOL><DEDENT>for idx in range(len(results),self.config ['<STR_LIT>']):<EOL><INDENT>self.buf [idx +]=''<EOL><DEDENT>self.lock_buffer()<EOL><DEDENT>def set_global_options(self):<EOL><INDENT> '<STR_LIT>'<EOL>for opt in GLOBAL_OPTIONS :<EOL><INDENT>self.stored_vim_globals [opt ]=bool(vim.eval('&'+opt))<EOL>setter=opt if GLOBAL_OPTIONS [opt ]else 'no'+opt <EOL>vim.command('set '+setter)<EOL><DEDENT> <DEDENT>def reset_global_options(self):<EOL><INDENT> '<STR_LIT>'<EOL>for opt in self.stored_vim_globals :<EOL><INDENT>setter=opt if self.stored_vim_globals [opt ]else 'no'+opt <EOL>vim.command('set '+setter)<EOL><DEDENT> <DEDENT>def filepirate_open(self):<EOL><INDENT> '<STR_LIT>'<EOL>self.previous_window_number=vim.eval("winnr()")<EOL>self.reset()<EOL>self.buffer_create()<EOL>self.set_global_options()<EOL><DEDENT>def filepirate_close(self):<EOL><INDENT> '<STR_LIT>'<EOL>self.async.stop()<EOL>self.reset_global_options()<EOL>vim.command("close");<EOL>vim.command('<STR_LIT>'%(self.buf.number))<EOL>vim.command('<STR_LIT>'%self.previous_window_number)<EOL><DEDENT>def filepirate_key(self,ascii):<EOL><INDENT> '<STR_LIT>'<EOL>self.search(self.term +chr(ascii))<EOL><DEDENT>def search(self,term):<EOL><INDENT> '<STR_LIT>'<EOL>if self.fp is None :<EOL><INDENT>self.fp=FilePirateThread(self.config ['<STR_LIT>'])<EOL>self.fp.start()<EOL><DEDENT>if not self.searching :<EOL><INDENT>self.spinner_character=' '<EOL>self.search_start_time=time.time()<EOL><DEDENT>self.term=term <EOL>self.draw_search_line()<EOL>self.async.start(self.search_poll)<EOL>self.fp.search(self.term)<EOL>self.searching=True <EOL><DEDENT>def filepirate_accept(self,line_number=None):<EOL><INDENT> '<STR_LIT>'<EOL>if line_number is None :<EOL><INDENT>y,x=vim.current.window.cursor <EOL>filename=self.buf [y -][:]<EOL><DEDENT>else :<EOL><INDENT>filename=self.buf [line_number +][:]<EOL><DEDENT>filename=filename.replace(' ',r'\ ')<EOL>self.filepirate_close()<EOL>vim.command('e %s'%(filename))<EOL><DEDENT>def filepirate_cancel(self):<EOL><INDENT> '<STR_LIT>'<EOL>self.filepirate_close()<EOL><DEDENT>def filepirate_up(self):<EOL><INDENT> '<STR_LIT>'<EOL>y,x=vim.current.window.cursor <EOL>if y >:<EOL><INDENT>y -=<EOL>vim.current.window.cursor=(y,x)<EOL><DEDENT> <DEDENT>def filepirate_down(self):<EOL><INDENT> '<STR_LIT>'<EOL>y,x=vim.current.window.cursor <EOL>if y <self.config ['<STR_LIT>']:<EOL><INDENT>y +=<EOL>vim.current.window.cursor=(y,x)<EOL><DEDENT> <DEDENT>def filepirate_bs(self):<EOL><INDENT> " Backspace "<EOL>if len(self.term)>:<EOL><INDENT>self.search(self.term [:-])<EOL><DEDENT> <DEDENT>def filepirate_rescan(self):<EOL><INDENT> '<STR_LIT>'<EOL>print "rescan"<EOL>self.fp.rescan()<EOL>if self.term :<EOL><INDENT>self.search(self.term)<EOL><DEDENT> <DEDENT>def filepirate_enter_insert_mode(self):<EOL><INDENT>pass <EOL><DEDENT>def filepirate_enter_normal_mode(self):<EOL><INDENT>self.buffer_unregister_keys()<EOL>self.mode=MODE_NORMAL <EOL>self.buffer_register_keys()<EOL><DEDENT>def filepirate_enter_insert_mode(self):<EOL><INDENT>self.buffer_unregister_keys()<EOL>self.mode=MODE_INSERT <EOL>self.buffer_register_keys()<EOL><DEDENT> <DEDENT>vim_file_pirate=VimFilePirate()<EOL>filepirate_open=vim_file_pirate.filepirate_open <EOL>filepirate_key=vim_file_pirate.filepirate_key <EOL>filepirate_callback=vim_file_pirate.async.from_vim <EOL>filepirate_accept=vim_file_pirate.filepirate_accept <EOL>filepirate_cancel=vim_file_pirate.filepirate_cancel <EOL>filepirate_up=vim_file_pirate.filepirate_up <EOL>filepirate_down=vim_file_pirate.filepirate_down <EOL>filepirate_bs=vim_file_pirate.filepirate_bs <EOL>filepirate_rescan=vim_file_pirate.filepirate_rescan <EOL>filepirate_enter_insert_mode=vim_file_pirate.filepirate_enter_insert_mode <EOL>filepirate_enter_normal_mode=vim_file_pirate.filepirate_enter_normal_mode <EOF><BOF>'<STR_LIT>'<EOL>__author__='<STR_LIT>'<EOL>import base64 <EOL>import cgi <EOL>import httplib2 <EOL>import logging <EOL>import os <EOL>import pickle <EOL>import time <EOL>from google.appengine.api import app_identity <EOL>from google.appengine.api import memcache <EOL>from google.appengine.api import users <EOL>from google.appengine.ext import db <EOL>from google.appengine.ext import webapp <EOL>from google.appengine.ext.webapp.util import login_required <EOL>from google.appengine.ext.webapp.util import run_wsgi_app <EOL>from oauth2client import GOOGLE_AUTH_URI <EOL>from oauth2client import GOOGLE_REVOKE_URI <EOL>from oauth2client import GOOGLE_TOKEN_URI <EOL>from oauth2client import clientsecrets <EOL>from oauth2client import util <EOL>from oauth2client import xsrfutil <EOL>from oauth2client.anyjson import simplejson <EOL>from oauth2client.client import AccessTokenRefreshError <EOL>from oauth2client.client import AssertionCredentials <EOL>from oauth2client.client import Credentials <EOL>from oauth2client.client import Flow <EOL>from oauth2client.client import OAuth2WebServerFlow <EOL>from oauth2client.client import Storage <EOL>try :<EOL><INDENT>from google.appengine.ext import ndb <EOL><DEDENT>except ImportError :<EOL><INDENT>ndb=None <EOL><DEDENT>logger=logging.getLogger(__name__)<EOL>OAUTH2CLIENT_NAMESPACE='oauth2client#ns'<EOL>XSRF_MEMCACHE_ID='xsrf_secret_key'<EOL>def _safe_html(s):<EOL><INDENT> '<STR_LIT>'<EOL>return cgi.escape(s,quote=).replace("'",'&#39;')<EOL><DEDENT>class InvalidClientSecretsError(Exception):<EOL><INDENT> '<STR_LIT>'<EOL><DEDENT>class InvalidXsrfTokenError(Exception):<EOL><INDENT> '<STR_LIT>'<EOL><DEDENT>class SiteXsrfSecretKey(db.Model):<EOL><INDENT> '<STR_LIT>'<EOL>secret=db.StringProperty()<EOL><DEDENT>if ndb is not None :<EOL><INDENT>class SiteXsrfSecretKeyNDB(ndb.Model):<EOL><INDENT> '<STR_LIT>'<EOL>secret=ndb.StringProperty()<EOL>@classmethod <EOL>def _get_kind(cls):<EOL><INDENT> '<STR_LIT>'<EOL>return '<STR_LIT>'<EOL><DEDENT> <DEDENT> <DEDENT>def _generate_new_xsrf_secret_key():<EOL><INDENT> '<STR_LIT>'<EOL>return os.urandom().encode("hex")<EOL><DEDENT>def xsrf_secret_key():<EOL><INDENT> '<STR_LIT>'<EOL>secret=memcache.get(XSRF_MEMCACHE_ID,namespace=OAUTH2CLIENT_NAMESPACE)<EOL>if not secret :<EOL><INDENT>model=SiteXsrfSecretKey.get_or_insert(key_name='site')<EOL>if not model.secret :<EOL><INDENT>model.secret=_generate_new_xsrf_secret_key()<EOL>model.put()<EOL><DEDENT>secret=model.secret <EOL>memcache.add(XSRF_MEMCACHE_ID,secret,namespace=OAUTH2CLIENT_NAMESPACE)<EOL><DEDENT>return str(secret)<EOL><DEDENT>class AppAssertionCredentials(AssertionCredentials):<EOL><INDENT> '<STR_LIT>'<EOL>@util.positional()<EOL>def __init__(self,scope,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>self.scope=util.scopes_to_string(scope)<EOL>super(AppAssertionCredentials,self).__init__(None)<EOL><DEDENT>@classmethod <EOL>def from_json(cls,json):<EOL><INDENT>data=simplejson.loads(json)<EOL>return AppAssertionCredentials(data ['scope'])<EOL><DEDENT>def _refresh(self,http_request):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>scopes=self.scope.split()(token,_)=app_identity.get_access_token(scopes)<EOL><DEDENT>except app_identity.Error,e :<EOL><INDENT>raise AccessTokenRefreshError(str(e))<EOL><DEDENT>self.access_token=token <EOL><DEDENT> <DEDENT>class FlowProperty(db.Property):<EOL><INDENT> '<STR_LIT>'<EOL>data_type=Flow <EOL>def get_value_for_datastore(self,model_instance):<EOL><INDENT>flow=super(FlowProperty,<EOL>self).get_value_for_datastore(model_instance)<EOL>return db.Blob(pickle.dumps(flow))<EOL><DEDENT>def make_value_from_datastore(self,value):<EOL><INDENT>if value is None :<EOL><INDENT>return None <EOL><DEDENT>return pickle.loads(value)<EOL><DEDENT>def validate(self,value):<EOL><INDENT>if value is not None and not isinstance(value,Flow):<EOL><INDENT>raise db.BadValueError('<STR_LIT>'<EOL>'<STR_LIT>'%(self.name,value))<EOL><DEDENT>return super(FlowProperty,self).validate(value)<EOL><DEDENT>def empty(self,value):<EOL><INDENT>return not value <EOL><DEDENT> <DEDENT>if ndb is not None :<EOL><INDENT>class FlowNDBProperty(ndb.PickleProperty):<EOL><INDENT> '<STR_LIT>'<EOL>def _validate(self,value):<EOL><INDENT> '<STR_LIT>'<EOL>logger.info('<STR_LIT>',type(value))<EOL>if value is not None and not isinstance(value,Flow):<EOL><INDENT>raise TypeError('<STR_LIT>'<EOL>'<STR_LIT>'%(self._name,value))<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>class CredentialsProperty(db.Property):<EOL><INDENT> '<STR_LIT>'<EOL>data_type=Credentials <EOL>def get_value_for_datastore(self,model_instance):<EOL><INDENT>logger.info("get: Got type "+str(type(model_instance)))<EOL>cred=super(CredentialsProperty,<EOL>self).get_value_for_datastore(model_instance)<EOL>if cred is None :<EOL><INDENT>cred=''<EOL><DEDENT>else :<EOL><INDENT>cred=cred.to_json()<EOL><DEDENT>return db.Blob(cred)<EOL><DEDENT>def make_value_from_datastore(self,value):<EOL><INDENT>logger.info("make: Got type "+str(type(value)))<EOL>if value is None :<EOL><INDENT>return None <EOL><DEDENT>if len(value)==:<EOL><INDENT>return None <EOL><DEDENT>try :<EOL><INDENT>credentials=Credentials.new_from_json(value)<EOL><DEDENT>except ValueError :<EOL><INDENT>credentials=None <EOL><DEDENT>return credentials <EOL><DEDENT>def validate(self,value):<EOL><INDENT>value=super(CredentialsProperty,self).validate(value)<EOL>logger.info('<STR_LIT>'+str(type(value)))<EOL>if value is not None and not isinstance(value,Credentials):<EOL><INDENT>raise db.BadValueError('<STR_LIT>'<EOL>'<STR_LIT>'%(self.name,value))<EOL><DEDENT>return value <EOL><DEDENT> <DEDENT>if ndb is not None :<EOL><INDENT>class CredentialsNDBProperty(ndb.BlobProperty):<EOL><INDENT> '<STR_LIT>'<EOL>def _validate(self,value):<EOL><INDENT> '<STR_LIT>'<EOL>logger.info('<STR_LIT>',type(value))<EOL>if value is not None and not isinstance(value,Credentials):<EOL><INDENT>raise TypeError('<STR_LIT>'<EOL>'<STR_LIT>'%(self._name,value))<EOL><DEDENT> <DEDENT>def _to_base_type(self,value):<EOL><INDENT> '<STR_LIT>'<EOL>if value is None :<EOL><INDENT>return ''<EOL><DEDENT>else :<EOL><INDENT>return value.to_json()<EOL><DEDENT> <DEDENT>def _from_base_type(self,value):<EOL><INDENT> '<STR_LIT>'<EOL>if not value :<EOL><INDENT>return None <EOL><DEDENT>try :<EOL><INDENT>credentials=Credentials.new_from_json(value)<EOL><DEDENT>except ValueError :<EOL><INDENT>credentials=None <EOL><DEDENT>return credentials <EOL><DEDENT> <DEDENT> <DEDENT>class StorageByKeyName(Storage):<EOL><INDENT> '<STR_LIT>'<EOL>@util.positional()<EOL>def __init__(self,model,key_name,property_name,cache=None):<EOL><INDENT> '<STR_LIT>'<EOL>self._model=model <EOL>self._key_name=key_name <EOL>self._property_name=property_name <EOL>self._cache=cache <EOL><DEDENT>def _is_ndb(self):<EOL><INDENT> '<STR_LIT>'<EOL>if isinstance(self._model,type):<EOL><INDENT>if ndb is not None and issubclass(self._model,ndb.Model):<EOL><INDENT>return True <EOL><DEDENT>elif issubclass(self._model,db.Model):<EOL><INDENT>return False <EOL><DEDENT> <DEDENT>raise TypeError('<STR_LIT>'%(self._model,))<EOL><DEDENT>def _get_entity(self):<EOL><INDENT> '<STR_LIT>'<EOL>if self._is_ndb():<EOL><INDENT>return self._model.get_by_id(self._key_name)<EOL><DEDENT>else :<EOL><INDENT>return self._model.get_by_key_name(self._key_name)<EOL><DEDENT> <DEDENT>def _delete_entity(self):<EOL><INDENT> '<STR_LIT>'<EOL>if self._is_ndb():<EOL><INDENT>ndb.Key(self._model,self._key_name).delete()<EOL><DEDENT>else :<EOL><INDENT>entity_key=db.Key.from_path(self._model.kind(),self._key_name)<EOL>db.delete(entity_key)<EOL><DEDENT> <DEDENT>def locked_get(self):<EOL><INDENT> '<STR_LIT>'<EOL>if self._cache :<EOL><INDENT>json=self._cache.get(self._key_name)<EOL>if json :<EOL><INDENT>return Credentials.new_from_json(json)<EOL><DEDENT> <DEDENT>credentials=None <EOL>entity=self._get_entity()<EOL>if entity is not None :<EOL><INDENT>credentials=getattr(entity,self._property_name)<EOL>if credentials and hasattr(credentials,'set_store'):<EOL><INDENT>credentials.set_store(self)<EOL>if self._cache :<EOL><INDENT>self._cache.set(self._key_name,credentials.to_json())<EOL><DEDENT> <DEDENT> <DEDENT>return credentials <EOL><DEDENT>def locked_put(self,credentials):<EOL><INDENT> '<STR_LIT>'<EOL>entity=self._model.get_or_insert(self._key_name)<EOL>setattr(entity,self._property_name,credentials)<EOL>entity.put()<EOL>if self._cache :<EOL><INDENT>self._cache.set(self._key_name,credentials.to_json())<EOL><DEDENT> <DEDENT>def locked_delete(self):<EOL><INDENT> '<STR_LIT>'<EOL>if self._cache :<EOL><INDENT>self._cache.delete(self._key_name)<EOL><DEDENT>self._delete_entity()<EOL><DEDENT> <DEDENT>class CredentialsModel(db.Model):<EOL><INDENT> '<STR_LIT>'<EOL>credentials=CredentialsProperty()<EOL><DEDENT>if ndb is not None :<EOL><INDENT>class CredentialsNDBModel(ndb.Model):<EOL><INDENT> '<STR_LIT>'<EOL>credentials=CredentialsNDBProperty()<EOL>@classmethod <EOL>def _get_kind(cls):<EOL><INDENT> '<STR_LIT>'<EOL>return '<STR_LIT>'<EOL><DEDENT> <DEDENT> <DEDENT>def _build_state_value(request_handler,user):<EOL><INDENT> '<STR_LIT>'<EOL>uri=request_handler.request.url <EOL>token=xsrfutil.generate_token(xsrf_secret_key(),user.user_id(),<EOL>action_id=str(uri))<EOL>return uri +':'+token <EOL><DEDENT>def _parse_state_value(state,user):<EOL><INDENT> '<STR_LIT>'<EOL>uri,token=state.rsplit(':',)<EOL>if not xsrfutil.validate_token(xsrf_secret_key(),token,user.user_id(),<EOL>action_id=uri):<EOL><INDENT>raise InvalidXsrfTokenError()<EOL><DEDENT>return uri <EOL><DEDENT>class OAuth2Decorator(object):<EOL><INDENT> '<STR_LIT>'<EOL>@util.positional()<EOL>def __init__(self,client_id,client_secret,scope,<EOL>auth_uri=GOOGLE_AUTH_URI,<EOL>token_uri=GOOGLE_TOKEN_URI,<EOL>revoke_uri=GOOGLE_REVOKE_URI,<EOL>user_agent=None,<EOL>message=None,<EOL>callback_path='/oauth2callback',<EOL>token_response_param=None,<EOL>**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>self.flow=None <EOL>self.credentials=None <EOL>self._client_id=client_id <EOL>self._client_secret=client_secret <EOL>self._scope=util.scopes_to_string(scope)<EOL>self._auth_uri=auth_uri <EOL>self._token_uri=token_uri <EOL>self._revoke_uri=revoke_uri <EOL>self._user_agent=user_agent <EOL>self._kwargs=kwargs <EOL>self._message=message <EOL>self._in_error=False <EOL>self._callback_path=callback_path <EOL>self._token_response_param=token_response_param <EOL><DEDENT>def _display_error_message(self,request_handler):<EOL><INDENT>request_handler.response.out.write('<html><body>')<EOL>request_handler.response.out.write(_safe_html(self._message))<EOL>request_handler.response.out.write('</body></html>')<EOL><DEDENT>def oauth_required(self,method):<EOL><INDENT> '<STR_LIT>'<EOL>def check_oauth(request_handler,*args,**kwargs):<EOL><INDENT>if self._in_error :<EOL><INDENT>self._display_error_message(request_handler)<EOL>return <EOL><DEDENT>user=users.get_current_user()<EOL>if not user :<EOL><INDENT>request_handler.redirect(users.create_login_url(<EOL>request_handler.request.uri))<EOL>return <EOL><DEDENT>self._create_flow(request_handler)<EOL>self.flow.params ['state']=_build_state_value(request_handler,user)<EOL>self.credentials=StorageByKeyName(<EOL>CredentialsModel,user.user_id(),'credentials').get()<EOL>if not self.has_credentials():<EOL><INDENT>return request_handler.redirect(self.authorize_url())<EOL><DEDENT>try :<EOL><INDENT>return method(request_handler,*args,**kwargs)<EOL><DEDENT>except AccessTokenRefreshError :<EOL><INDENT>return request_handler.redirect(self.authorize_url())<EOL><DEDENT> <DEDENT>return check_oauth <EOL><DEDENT>def _create_flow(self,request_handler):<EOL><INDENT> '<STR_LIT>'<EOL>if self.flow is None :<EOL><INDENT>redirect_uri=request_handler.request.relative_url(<EOL>self._callback_path)<EOL>self.flow=OAuth2WebServerFlow(self._client_id,self._client_secret,<EOL>self._scope,redirect_uri=redirect_uri,<EOL>user_agent=self._user_agent,<EOL>auth_uri=self._auth_uri,<EOL>token_uri=self._token_uri,<EOL>revoke_uri=self._revoke_uri,<EOL>**self._kwargs)<EOL><DEDENT> <DEDENT>def oauth_aware(self,method):<EOL><INDENT> '<STR_LIT>'<EOL>def setup_oauth(request_handler,*args,**kwargs):<EOL><INDENT>if self._in_error :<EOL><INDENT>self._display_error_message(request_handler)<EOL>return <EOL><DEDENT>user=users.get_current_user()<EOL>if not user :<EOL><INDENT>request_handler.redirect(users.create_login_url(<EOL>request_handler.request.uri))<EOL>return <EOL><DEDENT>self._create_flow(request_handler)<EOL>self.flow.params ['state']=_build_state_value(request_handler,user)<EOL>self.credentials=StorageByKeyName(<EOL>CredentialsModel,user.user_id(),'credentials').get()<EOL>return method(request_handler,*args,**kwargs)<EOL><DEDENT>return setup_oauth <EOL><DEDENT>def has_credentials(self):<EOL><INDENT> '<STR_LIT>'<EOL>return self.credentials is not None and not self.credentials.invalid <EOL><DEDENT>def authorize_url(self):<EOL><INDENT> '<STR_LIT>'<EOL>url=self.flow.step1_get_authorize_url()<EOL>return str(url)<EOL><DEDENT>def http(self):<EOL><INDENT> '<STR_LIT>'<EOL>return self.credentials.authorize(httplib2.Http())<EOL><DEDENT>@property <EOL>def callback_path(self):<EOL><INDENT> '<STR_LIT>'<EOL>return self._callback_path <EOL><DEDENT>def callback_handler(self):<EOL><INDENT> '<STR_LIT>'<EOL>decorator=self <EOL>class OAuth2Handler(webapp.RequestHandler):<EOL><INDENT> '<STR_LIT>'<EOL>@login_required <EOL>def get(self):<EOL><INDENT>error=self.request.get('error')<EOL>if error :<EOL><INDENT>errormsg=self.request.get('<STR_LIT>',error)<EOL>self.response.out.write(<EOL>'<STR_LIT>'%_safe_html(errormsg))<EOL><DEDENT>else :<EOL><INDENT>user=users.get_current_user()<EOL>decorator._create_flow(self)<EOL>credentials=decorator.flow.step2_exchange(self.request.params)<EOL>StorageByKeyName(<EOL>CredentialsModel,user.user_id(),'credentials').put(credentials)<EOL>redirect_uri=_parse_state_value(str(self.request.get('state')),<EOL>user)<EOL>if decorator._token_response_param and credentials.token_response :<EOL><INDENT>resp_json=simplejson.dumps(credentials.token_response)<EOL>redirect_uri=util._add_query_parameter(<EOL>redirect_uri,decorator._token_response_param,resp_json)<EOL><DEDENT>self.redirect(redirect_uri)<EOL><DEDENT> <DEDENT> <DEDENT>return OAuth2Handler <EOL><DEDENT>def callback_application(self):<EOL><INDENT> '<STR_LIT>'<EOL>return webapp.WSGIApplication([(self.callback_path,self.callback_handler())<EOL>])<EOL><DEDENT> <DEDENT>class OAuth2DecoratorFromClientSecrets(OAuth2Decorator):<EOL><INDENT> '<STR_LIT>'<EOL>@util.positional()<EOL>def __init__(self,filename,scope,message=None,cache=None):<EOL><INDENT> '<STR_LIT>'<EOL>client_type,client_info=clientsecrets.loadfile(filename,cache=cache)<EOL>if client_type not in [<EOL>clientsecrets.TYPE_WEB,clientsecrets.TYPE_INSTALLED ]:<EOL><INDENT>raise InvalidClientSecretsError(<EOL>'<STR_LIT>')<EOL><DEDENT>constructor_kwargs={<EOL>'auth_uri':client_info ['auth_uri'],<EOL>'token_uri':client_info ['token_uri'],<EOL>'message':message,<EOL>}<EOL>revoke_uri=client_info.get('revoke_uri')<EOL>if revoke_uri is not None :<EOL><INDENT>constructor_kwargs ['revoke_uri']=revoke_uri <EOL><DEDENT>super(OAuth2DecoratorFromClientSecrets,self).__init__(<EOL>client_info ['client_id'],client_info ['client_secret'],<EOL>scope,**constructor_kwargs)<EOL>if message is not None :<EOL><INDENT>self._message=message <EOL><DEDENT>else :<EOL><INDENT>self._message='<STR_LIT>'<EOL><DEDENT> <DEDENT> <DEDENT>@util.positional()<EOL>def oauth2decorator_from_clientsecrets(filename,scope,<EOL>message=None,cache=None):<EOL><INDENT> '<STR_LIT>'<EOL>return OAuth2DecoratorFromClientSecrets(filename,scope,<EOL>message=message,cache=cache)<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import sys <EOL>BLUE=[,,]<EOL>RED=[,,]<EOL>GREEN=[,,]<EOL>BLACK=[,,]<EOL>WHITE=[,,]<EOL>DRAW_BG={'color':BLACK,'val':}<EOL>DRAW_FG={'color':WHITE,'val':}<EOL>DRAW_PR_FG={'color':GREEN,'val':}<EOL>DRAW_PR_BG={'color':RED,'val':}<EOL>rect=(,,,)<EOL>drawing=False <EOL>rectangle=False <EOL>rect_over=False <EOL>rect_or_mask=<EOL>value=DRAW_FG <EOL>thickness=<EOL>def onmouse(event,x,y,flags,param):<EOL><INDENT>global img,img2,drawing,value,mask,rectangle,rect,rect_or_mask,ix,iy,rect_over <EOL>if event==cv2.EVENT_RBUTTONDOWN :<EOL><INDENT>rectangle=True <EOL>ix,iy=x,y <EOL><DEDENT>elif event==cv2.EVENT_MOUSEMOVE :<EOL><INDENT>if rectangle==True :<EOL><INDENT>img=img2.copy()<EOL>cv2.rectangle(img,(ix,iy),(x,y),BLUE,)<EOL>rect=(min(ix,x),min(iy,y),abs(ix -x),abs(iy -y))<EOL>rect_or_mask=<EOL><DEDENT> <DEDENT>elif event==cv2.EVENT_RBUTTONUP :<EOL><INDENT>rectangle=False <EOL>rect_over=True <EOL>cv2.rectangle(img,(ix,iy),(x,y),BLUE,)<EOL>rect=(min(ix,x),min(iy,y),abs(ix -x),abs(iy -y))<EOL>rect_or_mask=<EOL>print '<STR_LIT>'<EOL><DEDENT>if event==cv2.EVENT_LBUTTONDOWN :<EOL><INDENT>if rect_over==False :<EOL><INDENT>print '<STR_LIT>'<EOL><DEDENT>else :<EOL><INDENT>drawing=True <EOL>cv2.circle(img,(x,y),thickness,value ['color'],-)<EOL>cv2.circle(mask,(x,y),thickness,value ['val'],-)<EOL><DEDENT> <DEDENT>elif event==cv2.EVENT_MOUSEMOVE :<EOL><INDENT>if drawing==True :<EOL><INDENT>cv2.circle(img,(x,y),thickness,value ['color'],-)<EOL>cv2.circle(mask,(x,y),thickness,value ['val'],-)<EOL><DEDENT> <DEDENT>elif event==cv2.EVENT_LBUTTONUP :<EOL><INDENT>if drawing==True :<EOL><INDENT>drawing=False <EOL>cv2.circle(img,(x,y),thickness,value ['color'],-)<EOL>cv2.circle(mask,(x,y),thickness,value ['val'],-)<EOL><DEDENT> <DEDENT> <DEDENT>print __doc__ <EOL>if len(sys.argv)==:<EOL><INDENT>filename=sys.argv []<EOL><DEDENT>else :<EOL><INDENT>print '<STR_LIT>'<EOL>print '<STR_LIT>'<EOL>filename='<STR_LIT>'<EOL><DEDENT>img=cv2.imread(filename)<EOL>img2=img.copy()<EOL>mask=np.zeros(img.shape [:],dtype=np.uint8)<EOL>output=np.zeros(img.shape,np.uint8)<EOL>cv2.namedWindow('output')<EOL>cv2.namedWindow('input')<EOL>cv2.setMouseCallback('input',onmouse)<EOL>cv2.moveWindow('input',img.shape []+,)<EOL>print '<STR_LIT>'<EOL>print '<STR_LIT>'<EOL>while():<EOL><INDENT>cv2.imshow('output',output)<EOL>cv2.imshow('input',img)<EOL>k=&cv2.waitKey()<EOL>if k==:<EOL><INDENT>break <EOL><DEDENT>elif k==ord('0'):<EOL><INDENT>print '<STR_LIT>'<EOL>value=DRAW_BG <EOL><DEDENT>elif k==ord('1'):<EOL><INDENT>print '<STR_LIT>'<EOL>value=DRAW_FG <EOL><DEDENT>elif k==ord('2'):<EOL><INDENT>value=DRAW_PR_BG <EOL><DEDENT>elif k==ord('3'):<EOL><INDENT>value=DRAW_PR_FG <EOL><DEDENT>elif k==ord('s'):<EOL><INDENT>bar=np.zeros((img.shape [],,),np.uint8)<EOL>res=np.hstack((img2,bar,img,bar,output))<EOL>cv2.imwrite('<STR_LIT>',res)<EOL>print '<STR_LIT>'<EOL><DEDENT>elif k==ord('r'):<EOL><INDENT>print "resetting \n"<EOL>rect=(,,,)<EOL>drawing=False <EOL>rectangle=False <EOL>rect_or_mask=<EOL>rect_over=False <EOL>value=DRAW_FG <EOL>img=img2.copy()<EOL>mask=np.zeros(img.shape [:],dtype=np.uint8)<EOL>output=np.zeros(img.shape,np.uint8)<EOL><DEDENT>elif k==ord('n'):<EOL><INDENT>print '<STR_LIT>'<EOL>if(rect_or_mask==):<EOL><INDENT>bgdmodel=np.zeros((,),np.float64)<EOL>fgdmodel=np.zeros((,),np.float64)<EOL>cv2.grabCut(img2,mask,rect,bgdmodel,fgdmodel,,cv2.GC_INIT_WITH_RECT)<EOL>rect_or_mask=<EOL><DEDENT>elif rect_or_mask==:<EOL><INDENT>bgdmodel=np.zeros((,),np.float64)<EOL>fgdmodel=np.zeros((,),np.float64)<EOL>cv2.grabCut(img2,mask,rect,bgdmodel,fgdmodel,,cv2.GC_INIT_WITH_MASK)<EOL><DEDENT> <DEDENT>mask2=np.where((mask==)+(mask==),,).astype('uint8')<EOL>output=cv2.bitwise_and(img2,img2,mask=mask2)<EOL><DEDENT>cv2.destroyAllWindows()<EOF><BOF>import numpy as np <EOL>import cv2 <EOL>import os <EOL>import sys <EOL>import video <EOL>from common import mosaic <EOL>from digits import *<EOL>def main():<EOL><INDENT>try :<EOL><INDENT>src=sys.argv []<EOL><DEDENT>except :<EOL><INDENT>src=<EOL><DEDENT>cap=video.create_capture(src)<EOL>classifier_fn='digits_svm.dat'<EOL>if not os.path.exists(classifier_fn):<EOL><INDENT>print '<STR_LIT>'%classifier_fn <EOL>return <EOL><DEDENT>model=SVM()<EOL>model.load(classifier_fn)<EOL>while True :<EOL><INDENT>ret,frame=cap.read()<EOL>gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)<EOL>bin=cv2.adaptiveThreshold(gray,,cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY_INV,,)<EOL>bin=cv2.medianBlur(bin,)<EOL>_,contours,heirs=cv2.findContours(bin.copy(),cv2.RETR_CCOMP,cv2.CHAIN_APPROX_SIMPLE)<EOL>try :<EOL><INDENT>heirs=heirs []<EOL><DEDENT>except :<EOL><INDENT>heirs=[]<EOL><DEDENT>for cnt,heir in zip(contours,heirs):<EOL><INDENT>_,_,_,outer_i=heir <EOL>if outer_i >=:<EOL><INDENT>continue <EOL><DEDENT>x,y,w,h=cv2.boundingRect(cnt)<EOL>if not(<=h <=and w <=*h):<EOL><INDENT>continue <EOL><DEDENT>pad=max(h -w,)<EOL>x,w=x -pad /,w +pad <EOL>cv2.rectangle(frame,(x,y),(x +w,y +h),(,,))<EOL>bin_roi=bin [y :,x :][:h,:w ]<EOL>gray_roi=gray [y :,x :][:h,:w ]<EOL>m=bin_roi !=<EOL>if not <m.mean()<:<EOL><INDENT>continue <EOL><DEDENT> '<STR_LIT>'<EOL>s=*float(h)/SZ <EOL>m=cv2.moments(bin_roi)<EOL>c1=np.float32([m ['m10'],m ['m01']])/m ['m00']<EOL>c0=np.float32([SZ /,SZ /])<EOL>t=c1 -s *c0 <EOL>A=np.zeros((,),np.float32)<EOL>A [:,:]=np.eye()*s <EOL>A [:,]=t <EOL>bin_norm=cv2.warpAffine(bin_roi,A,(SZ,SZ),flags=cv2.WARP_INVERSE_MAP |cv2.INTER_LINEAR)<EOL>bin_norm=deskew(bin_norm)<EOL>if x +w +SZ <frame.shape []and y +SZ <frame.shape []:<EOL><INDENT>frame [y :,x +w :][:SZ,:SZ ]=bin_norm [...,np.newaxis ]<EOL><DEDENT>sample=preprocess_hog([bin_norm ])<EOL>digit=model.predict(sample)[]<EOL>cv2.putText(frame,'%d'%digit,(x,y),cv2.FONT_HERSHEY_PLAIN,,(,,),thickness=)<EOL><DEDENT>cv2.imshow('frame',frame)<EOL>cv2.imshow('bin',bin)<EOL>ch=cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>main()<EOL><DEDENT><EOF><BOF>from.tags import TagPatterns <EOL>class Criticality(object):<EOL><INDENT>def __init__(self,critical_tags=None,non_critical_tags=None):<EOL><INDENT>self.critical_tags=TagPatterns(critical_tags)<EOL>self.non_critical_tags=TagPatterns(non_critical_tags)<EOL><DEDENT>def tag_is_critical(self,tag):<EOL><INDENT>return self.critical_tags.match(tag)<EOL><DEDENT>def tag_is_non_critical(self,tag):<EOL><INDENT>return self.non_critical_tags.match(tag)<EOL><DEDENT>def test_is_critical(self,test):<EOL><INDENT>if self.critical_tags and not self.critical_tags.match(test.tags):<EOL><INDENT>return False <EOL><DEDENT>return not self.non_critical_tags.match(test.tags)<EOL><DEDENT>def __nonzero__(self):<EOL><INDENT>return bool(self.critical_tags or self.non_critical_tags)<EOL><DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from django.conf import settings <EOL>import github3 <EOL>from buildservice.errors import CannotCreateHook <EOL>def get_user_repos(token):<EOL><INDENT> '<STR_LIT>'<EOL>client=_github_login(token)<EOL>return client.iter_repos()<EOL><DEDENT>def create_webhook(token,repo,url):<EOL><INDENT> '<STR_LIT>'<EOL>client=_github_login(token)<EOL>owner,repository=repo.split('/')<EOL>repo=client.repository(owner,repository)<EOL>hook=repo.create_hook(<EOL>settings.GITHUB_HOOK_NAME,<EOL>{<EOL>"url":url,"content_type":"json",<EOL>"secret":settings.GITHUB_HOOK_SECRET,<EOL>"insecure_ssl":"0"<EOL>},<EOL>events=settings.GITHUB_HOOK_EVENTS,<EOL>active=True )<EOL>if not hook :<EOL><INDENT>raise CannotCreateHook('<STR_LIT>'%(owner,repository))<EOL><DEDENT>return hook.id <EOL><DEDENT>def delete_webhook(token,repo,hook_id):<EOL><INDENT> '<STR_LIT>'<EOL>client=_github_login(token)<EOL>owner,repository=repo.split('/')<EOL>repo=client.repository(owner,repository)<EOL>hook=repo.hook(hook_id)<EOL>if hook :<EOL><INDENT>hook.delete()<EOL><DEDENT> <DEDENT>def create_status(token,repo,sha,state,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>client=_github_login(token)<EOL>owner,repository=repo.split('/')<EOL>repo=client.repository(owner,repository)<EOL>repo.create_status(<EOL>sha,state,<EOL>context=settings.BUILDSERVICE_STATUS_CONTEXT,<EOL>**kwargs )<EOL><DEDENT>def _github_login(token):<EOL><INDENT> '<STR_LIT>'<EOL>if settings.DEBUG and settings.GITHUB_USER_ID :<EOL><INDENT>return github3.login(settings.GITHUB_USER_ID,password=settings.GITHUB_USER_PASSWORD)<EOL><DEDENT>return github3.login(token=token)<EOL><DEDENT><EOF><BOF>import csv <EOL>from operator import add <EOL>from datetime import datetime <EOL>from StringIO import StringIO <EOL>from collections import namedtuple <EOL>from pyspark import SparkConf,SparkContext <EOL>DATE_FMT='<STR_LIT>'<EOL>Order=namedtuple('Order',('id','upc','customer_id','date'))<EOL>def parse(row):<EOL><INDENT> '<STR_LIT>'<EOL>row []=int(row [])<EOL>row []=int(row [])<EOL>row []=datetime.strptime(row [],DATE_FMT)<EOL>return Order(*row)<EOL><DEDENT>def split(line):<EOL><INDENT> '<STR_LIT>'<EOL>reader=csv.reader(StringIO(line))<EOL>return reader.next()<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>conf=SparkConf().setMaster("local[*]").setAppName("Sales Report")<EOL>sc=SparkContext(conf=conf)<EOL>orders=sc.textFile('<STR_LIT>')<EOL>orders=orders.map(split).map(parse)<EOL>orders=orders.filter(lambda order :order.date.year==)<EOL>orders.cache()<EOL>months=orders.map(lambda order :((order.date.year,order.date.month),))<EOL>products=orders.filter(lambda order :order.upc=="098668274321")<EOL>months=months.reduceByKey(add)<EOL>for(year,month),count in months.collect():<EOL><INDENT>print "%s: %d"%(month,count)<EOL><DEDENT> <DEDENT><EOF><BOF>import sys,os <EOL>extensions=[]<EOL>templates_path=['_templates']<EOL>source_suffix='.rst'<EOL>master_doc='index'<EOL>project='<STR_LIT>'<EOL>copyright='<STR_LIT>'<EOL>version='1.0'<EOL>release='1.0'<EOL>exclude_patterns=['_build']<EOL>pygments_style='sphinx'<EOL>html_theme='default'<EOL>html_static_path=['_static']<EOL>htmlhelp_basename='<STR_LIT>'<EOL>latex_elements={<EOL>}<EOL>latex_documents=[('index','<STR_LIT>','<STR_LIT>',<EOL>'<STR_LIT>','manual'),<EOL>]<EOL>man_pages=[('index','sciencebookclub','<STR_LIT>',<EOL>['<STR_LIT>'],)<EOL>]<EOL>texinfo_documents=[('index','ScienceBookclub','<STR_LIT>',<EOL>'<STR_LIT>','ScienceBookclub','<STR_LIT>',<EOL>'Miscellaneous'),<EOL>]<EOF><BOF>import cv2 <EOL>if __name__=='__main__':<EOL><INDENT>import sys <EOL>try :<EOL><INDENT>param=sys.argv []<EOL><DEDENT>except :<EOL><INDENT>param=""<EOL><DEDENT>if("--build"==param):<EOL><INDENT>print cv2.getBuildInformation()<EOL><DEDENT>elif("--help"==param):<EOL><INDENT>print '<STR_LIT>'<EOL>print '<STR_LIT>'<EOL><DEDENT>else :<EOL><INDENT>print '<STR_LIT>'<EOL><DEDENT> <DEDENT><EOF><BOF>class _AbstractWinformsDialog :<EOL><INDENT>def __init__(self):<EOL><INDENT>raise RuntimeError('<STR_LIT>')<EOL><DEDENT> <DEDENT>class MessageDialog(_AbstractWinformsDialog):<EOL><INDENT>def __init__(self,message):<EOL><INDENT>_AbstractWinformsDialog.__init__(self)<EOL><DEDENT> <DEDENT>class InputDialog(_AbstractWinformsDialog):<EOL><INDENT>def __init__(self,message,default):<EOL><INDENT>_AbstractWinformsDialog.__init__(self)<EOL><DEDENT> <DEDENT>class SelectionDialog(_AbstractWinformsDialog):<EOL><INDENT>def __init__(self,message,options):<EOL><INDENT>_AbstractWinformsDialog.__init__(self)<EOL><DEDENT> <DEDENT>class PassFailDialog(_AbstractWinformsDialog):<EOL><INDENT>def __init__(self,message):<EOL><INDENT>_AbstractWinformsDialog.__init__(self)<EOL><DEDENT> <DEDENT><EOF><BOF>VERSION=(,,)<EOL>__author__='<STR_LIT>'<EOL>__version__='.'.join(str(v)for v in VERSION)<EOF><BOF>'<STR_LIT>'<EOL>import argparse <EOL>from scaffold import projectfolders,projectfiles <EOL>import os <EOL>parser=argparse.ArgumentParser(description='<STR_LIT>',epilog='<STR_LIT>')<EOL>parser.add_argument('-p','--project',required=True,nargs=,help='<STR_LIT>')<EOL>parser.add_argument('-d','--dir',required=False,nargs=,help='<STR_LIT>')<EOL>args=parser.parse_args()<EOL>cur_dir=os.getcwd()<EOL>if args.dir !=None :<EOL><INDENT>cur_dir=args.dir []<EOL><DEDENT>def main():<EOL><INDENT>try :<EOL><INDENT>projectfolders.create_folders(args.project [],cur_dir)<EOL>projectfiles.create_files(args.project [],cur_dir)<EOL><DEDENT>except IOError as e :<EOL><INDENT>print(e.strerror)<EOL><DEDENT> <DEDENT>if __name__=="__main__":<EOL><INDENT>main()<EOL><DEDENT><EOF><BOF>import cv2 <EOL>import numpy as np <EOL>img=cv2.imread('adipose.jpg',)<EOL>img=cv2.medianBlur(img,)<EOL>cimg=cv2.cvtColor(img,cv2.COLOR_GRAY2BGR)<EOL>circles=cv2.HoughCircles(img,cv2.cv.CV_HOUGH_GRADIENT,,,<EOL>param1=,param2=,minRadius=,maxRadius=)<EOL>circles=np.uint16(np.around(circles))<EOL>for i in circles [,:]:<EOL><INDENT>cv2.circle(cimg,(i [],i []),i [],(,,),)<EOL><DEDENT>cv2.imshow('<STR_LIT>',cimg)<EOL>cv2.waitKey()<EOL>cv2.destroyAllWindows()<EOF><BOF>from operator import itemgetter <EOL>from robot.utils import compress_text <EOL>class StringIndex(long):<EOL><INDENT>def __str__(self):<EOL><INDENT>return long.__str__(self).rstrip('L')<EOL><DEDENT>def __nonzero__(self):<EOL><INDENT>return bool(long(self))<EOL><DEDENT> <DEDENT>class StringCache(object):<EOL><INDENT>_compress_threshold=<EOL>_use_compressed_threshold=<EOL>_zero_index=StringIndex()<EOL>def __init__(self):<EOL><INDENT>self._cache={'*':self._zero_index }<EOL><DEDENT>def add(self,text):<EOL><INDENT>if not text :<EOL><INDENT>return self._zero_index <EOL><DEDENT>text=self._encode(text)<EOL>if text not in self._cache :<EOL><INDENT>self._cache [text ]=StringIndex(len(self._cache))<EOL><DEDENT>return self._cache [text ]<EOL><DEDENT>def _encode(self,text):<EOL><INDENT>raw=self._raw(text)<EOL>if raw in self._cache or len(raw)<self._compress_threshold :<EOL><INDENT>return raw <EOL><DEDENT>compressed=compress_text(text)<EOL>if len(compressed)*self._use_compressed_threshold <len(raw):<EOL><INDENT>return compressed <EOL><DEDENT>return raw <EOL><DEDENT>def _raw(self,text):<EOL><INDENT>return '*'+text <EOL><DEDENT>def dump(self):<EOL><INDENT>return tuple(item []for item in sorted(self._cache.iteritems(),<EOL>key=itemgetter()))<EOL><DEDENT> <DEDENT><EOF><BOF>"""OAuth views"""<EOL>from django.conf import settings <EOL>from django.contrib.auth.decorators import login_required <EOL>from django.http import HttpResponseBadRequest <EOL>from django.shortcuts import redirect <EOL>from requests_oauthlib import OAuth2Session <EOL>from buildservice.models import OAuthToken,Repository <EOL>@login_required <EOL>def login(request):<EOL><INDENT> '<STR_LIT>'<EOL>github=OAuth2Session(settings.GITHUB_CLIENT_ID,scope=settings.GITHUB_SCOPES)<EOL>authorization_url,state=github.authorization_url(settings.GITHUB_AUTHORIZATION_BASE_URL)<EOL>request.session ['oauth_state']=state <EOL>return redirect(authorization_url)<EOL><DEDENT>@login_required <EOL>def callback(request):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>oauth_state=request.session ['oauth_state']<EOL><DEDENT>except KeyError :<EOL><INDENT>return HttpResponseBadRequest('<STR_LIT>')<EOL><DEDENT>github=OAuth2Session(settings.GITHUB_CLIENT_ID,state=oauth_state)<EOL>token=github.fetch_token(<EOL>settings.GITHUB_TOKEN_URL,<EOL>client_secret=settings.GITHUB_CLIENT_SECRET,<EOL>authorization_response=request.build_absolute_uri())<EOL>try :<EOL><INDENT>OAuthToken.objects.create(user=request.user,value=token ['access_token'])<EOL><DEDENT>except(KeyError,TypeError):<EOL><INDENT>return HttpResponseBadRequest('<STR_LIT>')<EOL><DEDENT>Repository.add_user_to_known_repositories(request.user)<EOL>return redirect("home")<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import os <EOL>import sys <EOL>import glob <EOL>import argparse <EOL>from math import *<EOL>drag_start=None <EOL>sel=(,,,)<EOL>def onmouse(event,x,y,flags,param):<EOL><INDENT>global drag_start,sel <EOL>if event==cv2.EVENT_LBUTTONDOWN :<EOL><INDENT>drag_start=x,y <EOL>sel=,,,<EOL><DEDENT>elif event==cv2.EVENT_LBUTTONUP :<EOL><INDENT>if sel []>sel []and sel []>sel []:<EOL><INDENT>patch=gray [sel []:sel [],sel []:sel []]<EOL>result=cv2.matchTemplate(gray,patch,cv2.TM_CCOEFF_NORMED)<EOL>result=np.abs(result)**<EOL>val,result=cv2.threshold(result,,,cv2.THRESH_TOZERO)<EOL>result8=cv2.normalize(result,None,,,cv2.NORM_MINMAX,cv2.CV_8U)<EOL>cv2.imshow("result",result8)<EOL><DEDENT>drag_start=None <EOL><DEDENT>elif drag_start :<EOL><INDENT>if flags &cv2.EVENT_FLAG_LBUTTON :<EOL><INDENT>minpos=min(drag_start [],x),min(drag_start [],y)<EOL>maxpos=max(drag_start [],x),max(drag_start [],y)<EOL>sel=minpos [],minpos [],maxpos [],maxpos []<EOL>img=cv2.cvtColor(gray,cv2.COLOR_GRAY2BGR)<EOL>cv2.rectangle(img,(sel [],sel []),(sel [],sel []),(,,),)<EOL>cv2.imshow("gray",img)<EOL><DEDENT>else :<EOL><INDENT>print '<STR_LIT>'<EOL>drag_start=None <EOL><DEDENT> <DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>parser=argparse.ArgumentParser(description='<STR_LIT>')<EOL>parser.add_argument("-i","--input",default='./',help='<STR_LIT>')<EOL>args=parser.parse_args()<EOL>path=args.input <EOL>cv2.namedWindow("gray",)<EOL>cv2.setMouseCallback("gray",onmouse)<EOL>'<STR_LIT>'<EOL>for infile in glob.glob(os.path.join(path,'*.*')):<EOL><INDENT>ext=os.path.splitext(infile)[][:]<EOL>if ext=="png"or ext=="jpg"or ext=="bmp"or ext=="tiff"or ext=="pbm":<EOL><INDENT>print infile <EOL>img=cv2.imread(infile,)<EOL>if img==None :<EOL><INDENT>continue <EOL><DEDENT>sel=(,,,)<EOL>drag_start=None <EOL>gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)<EOL>cv2.imshow("gray",gray)<EOL>if(cv2.waitKey()&)==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from.testsuite import TestSuite <EOL>from.testcase import TestCase <EOL>from.keyword import Keyword <EOL>from.message import Message <EOL>from.tags import Tags,TagPatterns <EOL>from.criticality import Criticality <EOL>from.namepatterns import SuiteNamePatterns,TestNamePatterns <EOL>from.visitor import SuiteVisitor,SkipAllVisitor <EOL>from.totalstatistics import TotalStatisticsBuilder <EOL>from.statistics import Statistics <EOL>from.itemlist import ItemList <EOF><BOF>import os <EOL>from robot.result.visitor import ResultVisitor <EOL>from robot.utils import XmlWriter <EOL>class XUnitWriter(object):<EOL><INDENT>def __init__(self,execution_result):<EOL><INDENT>self._execution_result=execution_result <EOL><DEDENT>def write(self,output):<EOL><INDENT>writer=XUnitFileWriter(XmlWriter(output,encoding='UTF-8'))<EOL>self._execution_result.visit(writer)<EOL><DEDENT> <DEDENT>class XUnitFileWriter(ResultVisitor):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,xml_writer):<EOL><INDENT>self._writer=xml_writer <EOL>self._root_suite=None <EOL><DEDENT>def start_suite(self,suite):<EOL><INDENT>if self._root_suite :<EOL><INDENT>return <EOL><DEDENT>self._root_suite=suite <EOL>attrs={'name':suite.name,<EOL>'tests':str(suite.statistics.all.total),<EOL>'errors':'0',<EOL>'failures':str(suite.statistics.all.failed),<EOL>'skip':'0'}<EOL>self._writer.start('testsuite',attrs)<EOL><DEDENT>def end_suite(self,suite):<EOL><INDENT>if suite is self._root_suite :<EOL><INDENT>self._writer.end('testsuite')<EOL><DEDENT> <DEDENT>def start_test(self,test):<EOL><INDENT>attrs={'classname':test.parent.longname,<EOL>'name':test.name,<EOL>'time':self._time_as_seconds(test.elapsedtime)}<EOL>self._writer.start('testcase',attrs)<EOL>if not test.passed :<EOL><INDENT>test.visit(TestFailureWriter(self._writer))<EOL><DEDENT> <DEDENT>def _time_as_seconds(self,millis):<EOL><INDENT>return str(int(round(millis,-)/))<EOL><DEDENT>def end_test(self,test):<EOL><INDENT>self._writer.end('testcase')<EOL><DEDENT>def visit_keyword(self,kw):<EOL><INDENT>pass <EOL><DEDENT>def end_result(self,result):<EOL><INDENT>self._writer.close()<EOL><DEDENT> <DEDENT>class TestFailureWriter(ResultVisitor):<EOL><INDENT>def __init__(self,writer):<EOL><INDENT>self._writer=writer <EOL><DEDENT>def start_test(self,test):<EOL><INDENT>self._writer.start('failure',{'message':test.message,<EOL>'type':'AssertionError'},newline=False)<EOL><DEDENT>def end_test(self,test):<EOL><INDENT>self._writer.end('failure')<EOL><DEDENT>def visit_message(self,msg):<EOL><INDENT> '<STR_LIT>'<EOL>if msg.level=='DEBUG':<EOL><INDENT>self._writer.content(msg.message +os.linesep)<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>from zerotest.response import Response <EOL>def test_response__str__():<EOL><INDENT>response=Response(,{"just test":"hope pass"},"happy test!")<EOL>assert str(response)=='<STR_LIT>'<EOL><DEDENT><EOF><BOF>import sys <EOL>import random <EOL>import urllib2 <EOL>import cv2.cv as cv <EOL>im=None ;<EOL>mask=None ;<EOL>color_img=None ;<EOL>gray_img0=None ;<EOL>gray_img=None ;<EOL>ffill_case=;<EOL>lo_diff=<EOL>up_diff=;<EOL>connectivity=;<EOL>is_color=;<EOL>is_mask=;<EOL>new_mask_val=;<EOL>def update_lo(pos):<EOL><INDENT>lo_diff=pos <EOL><DEDENT>def update_up(pos):<EOL><INDENT>up_diff=pos <EOL><DEDENT>def on_mouse(event,x,y,flags,param):<EOL><INDENT>if(not color_img):<EOL><INDENT>return ;<EOL><DEDENT>if event==cv.CV_EVENT_LBUTTONDOWN :<EOL><INDENT>my_mask=None <EOL>seed=(x,y);<EOL>if ffill_case==:<EOL><INDENT>lo=up=<EOL>flags=connectivity +(new_mask_val <<)<EOL><DEDENT>else :<EOL><INDENT>lo=lo_diff ;<EOL>up=up_diff ;<EOL>flags=connectivity +(new_mask_val <<)+cv.CV_FLOODFILL_FIXED_RANGE <EOL><DEDENT>b=random.randint(,)<EOL>g=random.randint(,)<EOL>r=random.randint(,)<EOL>if(is_mask):<EOL><INDENT>my_mask=mask <EOL>cv.Threshold(mask,mask,,,cv.CV_THRESH_BINARY);<EOL><DEDENT>if(is_color):<EOL><INDENT>color=cv.CV_RGB(r,g,b);<EOL>comp=cv.FloodFill(color_img,seed,color,cv.CV_RGB(lo,lo,lo),<EOL>cv.CV_RGB(up,up,up),flags,my_mask);<EOL>cv.ShowImage("image",color_img);<EOL><DEDENT>else :<EOL><INDENT>brightness=cv.RealScalar((r *+g *+b +)/);<EOL>comp=cv.FloodFill(gray_img,seed,brightness,cv.RealScalar(lo),<EOL>cv.RealScalar(up),flags,my_mask);<EOL>cv.ShowImage("image",gray_img);<EOL><DEDENT>print '<STR_LIT>'%comp []<EOL>if(is_mask):<EOL><INDENT>cv.ShowImage("mask",mask);<EOL><DEDENT> <DEDENT> <DEDENT>if __name__=="__main__":<EOL><INDENT>if len(sys.argv)>:<EOL><INDENT>im=cv.LoadImage(sys.argv [],cv.CV_LOAD_IMAGE_COLOR)<EOL><DEDENT>else :<EOL><INDENT>url='<STR_LIT>'<EOL>filedata=urllib2.urlopen(url).read()<EOL>imagefiledata=cv.CreateMatHeader(,len(filedata),cv.CV_8UC1)<EOL>cv.SetData(imagefiledata,filedata,len(filedata))<EOL>im=cv.DecodeImage(imagefiledata,cv.CV_LOAD_IMAGE_COLOR)<EOL><DEDENT>print "Hot keys:"<EOL>print '<STR_LIT>'<EOL>print '<STR_LIT>'<EOL>print '<STR_LIT>'<EOL>print '<STR_LIT>'<EOL>print '<STR_LIT>'<EOL>print '<STR_LIT>'<EOL>print '<STR_LIT>'<EOL>print '<STR_LIT>'<EOL>print '<STR_LIT>'<EOL>color_img=cv.CloneImage(im);<EOL>gray_img0=cv.CreateImage((color_img.width,color_img.height),,);<EOL>cv.CvtColor(color_img,gray_img0,cv.CV_BGR2GRAY);<EOL>gray_img=cv.CloneImage(gray_img0);<EOL>mask=cv.CreateImage((color_img.width +,color_img.height +),,);<EOL>cv.NamedWindow("image",);<EOL>cv.CreateTrackbar("lo_diff","image",lo_diff,,update_lo);<EOL>cv.CreateTrackbar("up_diff","image",up_diff,,update_up);<EOL>cv.SetMouseCallback("image",on_mouse);<EOL>while True :<EOL><INDENT>if(is_color):<EOL><INDENT>cv.ShowImage("image",color_img);<EOL><DEDENT>else :<EOL><INDENT>cv.ShowImage("image",gray_img);<EOL><DEDENT>c=cv.WaitKey()%<EOL>if c==:<EOL><INDENT>print("Exiting...");<EOL>sys.exit()<EOL><DEDENT>elif c==ord('c'):<EOL><INDENT>if(is_color):<EOL><INDENT>print('<STR_LIT>');<EOL>cv.CvtColor(color_img,gray_img,cv.CV_BGR2GRAY);<EOL>is_color=;<EOL><DEDENT>else :<EOL><INDENT>print('<STR_LIT>');<EOL>cv.Copy(im,color_img,None);<EOL>cv.Zero(mask);<EOL>is_color=;<EOL><DEDENT> <DEDENT>elif c==ord('m'):<EOL><INDENT>if(is_mask):<EOL><INDENT>cv.DestroyWindow("mask");<EOL>is_mask=;<EOL><DEDENT>else :<EOL><INDENT>cv.NamedWindow("mask",);<EOL>cv.Zero(mask);<EOL>cv.ShowImage("mask",mask);<EOL>is_mask=;<EOL><DEDENT> <DEDENT>elif c==ord('r'):<EOL><INDENT>print('<STR_LIT>');<EOL>cv.Copy(im,color_img,None);<EOL>cv.Copy(gray_img0,gray_img,None);<EOL>cv.Zero(mask);<EOL><DEDENT>elif c==ord('s'):<EOL><INDENT>print('<STR_LIT>');<EOL>ffill_case=;<EOL><DEDENT>elif c==ord('f'):<EOL><INDENT>print('<STR_LIT>');<EOL>ffill_case=;<EOL><DEDENT>elif c==ord('g'):<EOL><INDENT>print('<STR_LIT>');<EOL>ffill_case=;<EOL><DEDENT>elif c==ord('4'):<EOL><INDENT>print('<STR_LIT>');<EOL>connectivity=;<EOL><DEDENT>elif c==ord('8'):<EOL><INDENT>print('<STR_LIT>');<EOL>connectivity=;<EOL><DEDENT> <DEDENT>cv.DestroyAllWindows()<EOL><DEDENT><EOF><BOF>import json <EOL>import pytest <EOL>from zerotest.fuzzy_matcher import FuzzyMatchWarning <EOL>from zerotest.response import Response <EOL>from zerotest.response_matcher import ResponseMatcher <EOL>def test_compare():<EOL><INDENT>matcher=ResponseMatcher()<EOL>r1=Response(status=,headers={"a":"1"},body="ok")<EOL>r2=Response(status=,headers={"a":"1"},body="ok")<EOL>matcher.match_responses(r1,r2)<EOL>r2.body="not ok"<EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT>r2.body="ok"<EOL>r2.status=<EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT>r2.status=<EOL>r2.headers ['b']=<EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT>del r2.headers ['b']<EOL>matcher.match_responses(r1,r2)<EOL><DEDENT>def test_ignore_headers_compare():<EOL><INDENT>matcher=ResponseMatcher(ignore_headers=['c','d','e'])<EOL>r1=Response(status=,headers={"a":"1","c":"not"},body="ok")<EOL>r2=Response(status=,headers={"a":"1","c":"same"},body="ok")<EOL>matcher.match_responses(r1,r2)<EOL>r1.headers ['d']="ignored should"<EOL>matcher.match_responses(r1,r2)<EOL>r2.headers ['e']="ignored should"<EOL>matcher.match_responses(r1,r2)<EOL>r1.headers ['g']="not ignored"<EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT> <DEDENT>def test_ignore_all_headers_compare():<EOL><INDENT>matcher=ResponseMatcher(ignore_all_headers=True)<EOL>r1=Response(status=,headers={"a":"1","c":"not"},body="ok")<EOL>r2=Response(status=,headers={"a":"1","c":"same","d":},body="ok")<EOL>matcher.match_responses(r1,r2)<EOL><DEDENT>def test_ignore_fields_compare():<EOL><INDENT>matcher=ResponseMatcher(ignore_fields=['<STR_LIT>','id'])<EOL>r1=Response(status=,headers={},body=json.dumps({"id":,"name":"test"}))<EOL>r2=Response(status=,headers={},body=json.dumps({"id":,"name":"test"}))<EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT>r1.headers ['content-type']='<STR_LIT>'<EOL>r2.headers ['CONTENT-TYPE']='<STR_LIT>'<EOL>matcher.match_responses(r1,r2)<EOL>r1.body=json.dumps({'<STR_LIT>':'now','record':{'created_at':'111'}})<EOL>r2.body=json.dumps({"record":{'created_at':'111'}})<EOL>matcher.match_responses(r1,r2)<EOL>r1.body=json.dumps({'<STR_LIT>':'now','some_record':{'created_at':'111'}})<EOL>r2.body=json.dumps({"some_record":{'created_at':'111'}})<EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT>r1.body=json.dumps({'<STR_LIT>':'now'})<EOL>r2.body=json.dumps({"some_record":{'created_at':'112'}})<EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT>r1.body=json.dumps({"some_record":[{'created_at':'1123','id':'0'}]})<EOL>r2.body=json.dumps({"some_record":[{'created_at':'112','id':'1'}]})<EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT>r1.body=json.dumps({"some_record":[{'created_at':'1123','id':'0'},{'created_at':'3322'}]})<EOL>r2.body=json.dumps({"some_record":[{'created_at':'112','id':'1'},{'created_at':'tomorrow'}]})<EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT>r1.body=json.dumps({"some_record":[{'created_at':'1123','id':'1'},{'created_at':'3322'}]})<EOL>r2.body=json.dumps({"some_record":[{'created_at':'112','id':'1'},{'created_at':'tomorrow'}]})<EOL>matcher.match_responses(r1,r2)<EOL><DEDENT>def test_fuzzy_compare():<EOL><INDENT>matcher=ResponseMatcher(fuzzy_match=True)<EOL>allow_none_matcher=ResponseMatcher(fuzzy_match=True,fuzzy_match_options={"allow_none":True })<EOL>allow_blank_matcher=ResponseMatcher(fuzzy_match=True,fuzzy_match_options={"allow_blank":True })<EOL>r1=Response(status=,headers={},body=json.dumps({"id":,"name":"test"}))<EOL>r2=Response(status=,headers={},body=json.dumps({"id":,"name":"test","some_field":}))<EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT>r2.body=json.dumps({"id":,"name":"test"})<EOL>r1.headers ['content-type']='<STR_LIT>'<EOL>r2.headers ['CONTENT-TYPE']='<STR_LIT>'<EOL>matcher.match_responses(r1,r2)<EOL>r2.body=json.dumps({"id":"42","name":"test42"})<EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT>r2.body=json.dumps({"id":,"name":})<EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT>r2.body=json.dumps({"id":"42","name":})<EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT>r2.body=json.dumps({"id":,"name":"test42"})<EOL>matcher.match_responses(r1,r2)<EOL>r2.headers ['use-less-header']=True <EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT>r2.headers.pop('use-less-header')<EOL>r1.body=json.dumps({"id":,"name":"test","followers":[]})<EOL>r2.body=json.dumps({"id":,"name":"test42","followers":[,,]})<EOL>matcher.match_responses(r1,r2)<EOL>r1.body=json.dumps({"id":,"name":"test","followers":["1","2"]})<EOL>r2.body=json.dumps({"id":,"name":"test42","followers":[,,]})<EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT>r1.body=json.dumps({"id":,"name":"test","followers":[,]})<EOL>matcher.match_responses(r1,r2)<EOL>r1.body=json.dumps(<EOL>{<EOL>"id":,"name":"test","children":<EOL>[{"id":,"name":"test2"},{"id":,"name":"test3"}],<EOL>"parent":{"id":,"name":"test0"}<EOL>})<EOL>r2.body=json.dumps(<EOL>{<EOL>"id":,"name":"test","children":<EOL>[{"id":,"name":"test4"}],<EOL>"parent":{"id":,"name":"test5"}<EOL>})<EOL>matcher.match_responses(r1,r2)<EOL>r2.body=json.dumps(<EOL>{<EOL>"id":,"name":"test","children":<EOL>[{"id":,"name":"test4"},{"id":"what?"}],<EOL>"parent":{"id":,"name":"test5"}<EOL>})<EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT>r2.body=json.dumps(<EOL>{<EOL>"id":,"name":"test","children":<EOL>[{"id":,"name":"test4"},{}],<EOL>"parent":{"id":"5","name":"test5"}<EOL>})<EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT>r2.body=json.dumps(<EOL>{<EOL>"id":,"name":"test","children":<EOL>[{"id":,"name":"test4"},{}],<EOL>"parent":{"id":"5","name":"test5"}<EOL>})<EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT>r2.body=json.dumps(<EOL>{<EOL>"id":,"name":"test","children":<EOL>[{"id":,"name":"test4"}],<EOL>"parent":{}<EOL>})<EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT>with pytest.warns(FuzzyMatchWarning):<EOL><INDENT>allow_blank_matcher.match_responses(r1,r2)<EOL><DEDENT>r2.body=json.dumps(<EOL>{<EOL>"id":,"name":"test","children":<EOL>[{"id":,"name":"test4"}],<EOL>"parent":None <EOL>})<EOL>with pytest.raises(AssertionError):<EOL><INDENT>matcher.match_responses(r1,r2)<EOL><DEDENT>with pytest.raises(AssertionError):<EOL><INDENT>allow_blank_matcher.match_responses(r1,r2)<EOL><DEDENT>with pytest.warns(FuzzyMatchWarning):<EOL><INDENT>allow_none_matcher.match_responses(r1,r2)<EOL><DEDENT>r2.body=json.dumps(<EOL>{<EOL>"id":,"name":"test","children":<EOL>[],<EOL>"parent":{"id":,"name":"test5"}<EOL>})<EOL>matcher.match_responses(r1,r2)<EOL><DEDENT><EOF><BOF>import sys <EOL>from robot import utils <EOL>from.highlighting import AnsiHighlighter,Highlighter,NoHighlighting <EOL>from.loggerhelper import IsLogged <EOL>class CommandLineMonitor(object):<EOL><INDENT>def __init__(self,width=,colors='AUTO',markers='AUTO',stdout=None,<EOL>stderr=None):<EOL><INDENT>self._writer=CommandLineWriter(width,colors,markers,stdout,stderr)<EOL>self._is_logged=IsLogged('WARN')<EOL>self._started=False <EOL>self._started_keywords=<EOL>self._running_test=False <EOL><DEDENT>def start_suite(self,suite):<EOL><INDENT>if not self._started :<EOL><INDENT>self._writer.suite_separator()<EOL>self._started=True <EOL><DEDENT>self._writer.info(suite.longname,suite.doc,start_suite=True)<EOL>self._writer.suite_separator()<EOL><DEDENT>def end_suite(self,suite):<EOL><INDENT>self._writer.info(suite.longname,suite.doc)<EOL>self._writer.status(suite.status)<EOL>self._writer.message(suite.get_full_message())<EOL>self._writer.suite_separator()<EOL><DEDENT>def start_test(self,test):<EOL><INDENT>self._writer.info(test.name,test.doc)<EOL>self._running_test=True <EOL><DEDENT>def end_test(self,test):<EOL><INDENT>self._writer.status(test.status,clear=True)<EOL>self._writer.message(test.message)<EOL>self._writer.test_separator()<EOL>self._running_test=False <EOL><DEDENT>def start_keyword(self,kw):<EOL><INDENT>self._started_keywords +=<EOL><DEDENT>def end_keyword(self,kw):<EOL><INDENT>self._started_keywords -=<EOL>if self._running_test and not self._started_keywords :<EOL><INDENT>self._writer.keyword_marker(kw)<EOL><DEDENT> <DEDENT>def message(self,msg):<EOL><INDENT>if self._is_logged(msg.level):<EOL><INDENT>self._writer.error(msg.message,msg.level,clear=self._running_test)<EOL><DEDENT> <DEDENT>def output_file(self,name,path):<EOL><INDENT>self._writer.output(name,path)<EOL><DEDENT> <DEDENT>class CommandLineWriter(object):<EOL><INDENT>_status_length=len('| PASS |')<EOL>def __init__(self,width=,colors='AUTO',markers='AUTO',stdout=None,<EOL>stderr=None):<EOL><INDENT>self._width=width <EOL>self._stdout=stdout or sys.__stdout__ <EOL>self._stderr=stderr or sys.__stderr__ <EOL>self._highlighter=StatusHighlighter(colors,self._stdout,self._stderr)<EOL>self._keyword_marker=KeywordMarker(markers,self._stdout,self._highlighter)<EOL>self._last_info=None <EOL><DEDENT>def info(self,name,doc,start_suite=False):<EOL><INDENT>width,separator=self._get_info_width_and_separator(start_suite)<EOL>self._last_info=self._get_info(name,doc,width)+separator <EOL>self._write(self._last_info,newline=False)<EOL>self._keyword_marker.reset_count()<EOL><DEDENT>def _get_info_width_and_separator(self,start_suite):<EOL><INDENT>if start_suite :<EOL><INDENT>return self._width,'\n'<EOL><DEDENT>return self._width -self._status_length -,' '<EOL><DEDENT>def _get_info(self,name,doc,width):<EOL><INDENT>if utils.get_console_length(name)>width :<EOL><INDENT>return utils.pad_console_length(name,width)<EOL><DEDENT>info=name if not doc else '%s :: %s'%(name,doc.splitlines()[])<EOL>return utils.pad_console_length(info,width)<EOL><DEDENT>def suite_separator(self):<EOL><INDENT>self._fill('=')<EOL><DEDENT>def test_separator(self):<EOL><INDENT>self._fill('-')<EOL><DEDENT>def _fill(self,char):<EOL><INDENT>self._write(char *self._width)<EOL><DEDENT>def status(self,status,clear=False):<EOL><INDENT>if self._should_clear_markers(clear):<EOL><INDENT>self._clear_status()<EOL><DEDENT>self._highlight('| ',status,' |')<EOL><DEDENT>def _should_clear_markers(self,clear):<EOL><INDENT>return clear and self._keyword_marker.marking_enabled <EOL><DEDENT>def _clear_status(self):<EOL><INDENT>self._clear_info_line()<EOL>self._rewrite_info()<EOL><DEDENT>def _clear_info_line(self):<EOL><INDENT>self._write('\r'+' '*self._width +'\r',newline=False)<EOL>self._keyword_marker.reset_count()<EOL><DEDENT>def _rewrite_info(self):<EOL><INDENT>self._write(self._last_info,newline=False)<EOL><DEDENT>def message(self,message):<EOL><INDENT>if message :<EOL><INDENT>self._write(message.strip())<EOL><DEDENT> <DEDENT>def keyword_marker(self,kw):<EOL><INDENT>if self._keyword_marker.marker_count==self._status_length :<EOL><INDENT>self._clear_status()<EOL>self._keyword_marker.reset_count()<EOL><DEDENT>self._keyword_marker.mark(kw)<EOL><DEDENT>def error(self,message,level,clear=False):<EOL><INDENT>if self._should_clear_markers(clear):<EOL><INDENT>self._clear_info_line()<EOL><DEDENT>self._highlight('[ ',level,' ] '+message,error=True)<EOL>if self._should_clear_markers(clear):<EOL><INDENT>self._rewrite_info()<EOL><DEDENT> <DEDENT>def output(self,name,path):<EOL><INDENT>self._write('%-8s %s'%(name +':',path))<EOL><DEDENT>def _write(self,text,newline=True,error=False):<EOL><INDENT>stream=self._stdout if not error else self._stderr <EOL>if newline :<EOL><INDENT>text +='\n'<EOL><DEDENT>stream.write(utils.encode_output(text))<EOL>stream.flush()<EOL><DEDENT>def _highlight(self,before,status,after,newline=True,error=False):<EOL><INDENT>stream=self._stdout if not error else self._stderr <EOL>self._write(before,newline=False,error=error)<EOL>self._highlighter.highlight_status(status,stream)<EOL>self._write(after,newline=newline,error=error)<EOL><DEDENT> <DEDENT>class StatusHighlighter(object):<EOL><INDENT>def __init__(self,colors,*streams):<EOL><INDENT>self._highlighters=dict((stream,self._get_highlighter(stream,colors))<EOL>for stream in streams)<EOL><DEDENT>def _get_highlighter(self,stream,colors):<EOL><INDENT>auto=Highlighter if utils.isatty(stream)else NoHighlighting <EOL>highlighter={'AUTO':auto,<EOL>'ON':Highlighter,<EOL>'FORCE':Highlighter,<EOL>'OFF':NoHighlighting,<EOL>'ANSI':AnsiHighlighter }.get(colors.upper(),auto)<EOL>return highlighter(stream)<EOL><DEDENT>def highlight_status(self,status,stream):<EOL><INDENT>highlighter=self._start_status_highlighting(status,stream)<EOL>stream.write(status)<EOL>highlighter.reset()<EOL><DEDENT>def _start_status_highlighting(self,status,stream):<EOL><INDENT>highlighter=self._highlighters [stream ]<EOL>{'PASS':highlighter.green,<EOL>'FAIL':highlighter.red,<EOL>'ERROR':highlighter.red,<EOL>'WARN':highlighter.yellow }[status ]()<EOL>return highlighter <EOL><DEDENT>def highlight(self,text,color,stream):<EOL><INDENT>highlighter=self._highlighters [stream ]<EOL>getattr(highlighter,color)()<EOL>stream.write(text)<EOL>stream.flush()<EOL>highlighter.reset()<EOL><DEDENT> <DEDENT>class KeywordMarker(object):<EOL><INDENT>def __init__(self,markers,stdout,highlighter):<EOL><INDENT>self._stdout=stdout <EOL>self._highlighter=highlighter <EOL>self.marking_enabled=self._marking_enabled(markers,stdout)<EOL>self.marker_count=<EOL><DEDENT>def _marking_enabled(self,markers,stdout):<EOL><INDENT>auto=utils.isatty(stdout)<EOL>return {'AUTO':auto,<EOL>'ON':True,<EOL>'OFF':False }.get(markers.upper(),auto)<EOL><DEDENT>def mark(self,kw):<EOL><INDENT>if self.marking_enabled :<EOL><INDENT>marker,color=('.','green')if kw.passed else('F','red')<EOL>self._highlighter.highlight(marker,color,self._stdout)<EOL>self.marker_count +=<EOL><DEDENT> <DEDENT>def reset_count(self):<EOL><INDENT>self.marker_count=<EOL><DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import itertools as it <EOL>from common import draw_str <EOL>w,h=,<EOL>def toint(p):<EOL><INDENT>return tuple(map(int,p))<EOL><DEDENT>def sample_line(p1,p2,n,noise=):<EOL><INDENT>p1=np.float32(p1)<EOL>t=np.random.rand(n,)<EOL>return p1 +(p2 -p1)*t +np.random.normal(size=(n,))*noise <EOL><DEDENT>dist_func_names=it.cycle('<STR_LIT>'.split())<EOL>cur_func_name=dist_func_names.next()<EOL>def update(_=None):<EOL><INDENT>noise=cv2.getTrackbarPos('noise','fit line')<EOL>n=cv2.getTrackbarPos('point n','fit line')<EOL>r=cv2.getTrackbarPos('outlier %','fit line')/<EOL>outn=int(n *r)<EOL>p0,p1=(,),(w -,h -)<EOL>img=np.zeros((h,w,),np.uint8)<EOL>cv2.line(img,toint(p0),toint(p1),(,,))<EOL>if n >:<EOL><INDENT>line_points=sample_line(p0,p1,n -outn,noise)<EOL>outliers=np.random.rand(outn,)*(w,h)<EOL>points=np.vstack([line_points,outliers ])<EOL>for p in line_points :<EOL><INDENT>cv2.circle(img,toint(p),,(,,),-)<EOL><DEDENT>for p in outliers :<EOL><INDENT>cv2.circle(img,toint(p),,(,,),-)<EOL><DEDENT>func=getattr(cv2.cv,cur_func_name)<EOL>vx,vy,cx,cy=cv2.fitLine(np.float32(points),func,,,)<EOL>cv2.line(img,(int(cx -vx *w),int(cy -vy *w)),(int(cx +vx *w),int(cy +vy *w)),(,,))<EOL><DEDENT>draw_str(img,(,),cur_func_name)<EOL>cv2.imshow('fit line',img)<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>cv2.namedWindow('fit line')<EOL>cv2.createTrackbar('noise','fit line',,,update)<EOL>cv2.createTrackbar('point n','fit line',,,update)<EOL>cv2.createTrackbar('outlier %','fit line',,,update)<EOL>while True :<EOL><INDENT>update()<EOL>ch=cv2.waitKey()<EOL>if ch==ord('f'):<EOL><INDENT>cur_func_name=dist_func_names.next()<EOL><DEDENT>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>from setuptools import setup,find_packages <EOL>import clime <EOL>setup(<EOL>name='clime',<EOL>version=clime.__version__,<EOL>description='<STR_LIT>',<EOL>long_description=open('README.rst').read(),<EOL>author='Mosky',<EOL>url='<STR_LIT>',<EOL>author_email='<STR_LIT>',<EOL>license='MIT',<EOL>platforms='any',<EOL>classifiers=[<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>],<EOL>packages=find_packages(),<EOL>entry_points={<EOL>'console_scripts':[<EOL>'<STR_LIT>'<EOL>]<EOL>}<EOL>)<EOF><BOF>import urllib2 <EOL>import sys <EOL>import cv2.cv as cv <EOL>import numpy <EOL>if __name__=="__main__":<EOL><INDENT>cv.NamedWindow("camera",)<EOL>capture=cv.CaptureFromCAM()<EOL>paste=cv.CreateMat(,,cv.CV_8UC3)<EOL>topleft=numpy.asarray(cv.GetSubRect(paste,(,,,)))<EOL>topright=numpy.asarray(cv.GetSubRect(paste,(,,,)))<EOL>bottomleft=numpy.asarray(cv.GetSubRect(paste,(,,,)))<EOL>bottomright=numpy.asarray(cv.GetSubRect(paste,(,,,)))<EOL>while True :<EOL><INDENT>img=cv.GetMat(cv.QueryFrame(capture))<EOL>n=(numpy.asarray(img)).astype(numpy.uint8)<EOL>red=n [:,:,]<EOL>grn=n [:,:,]<EOL>blu=n [:,:,]<EOL>topleft [:,:,]=-grn <EOL>topleft [:,:,]=red <EOL>topleft [:,:,]=blu <EOL>topright [:,:,]=blu <EOL>topright [:,:,]=-red <EOL>topright [:,:,]=grn <EOL>bottomright [:,:,]=red <EOL>bottomright [:,:,]=grn <EOL>bottomright [:,:,]=-blu <EOL>fgrn=grn.astype(numpy.float32)<EOL>fred=red.astype(numpy.float32)<EOL>bottomleft [:,:,]=blu <EOL>bottomleft [:,:,]=(abs(fgrn -fred)).astype(numpy.uint8)<EOL>bottomleft [:,:,]=red <EOL>cv.ShowImage("camera",paste)<EOL>if cv.WaitKey()==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT>cv.DestroyAllWindows()<EOL><DEDENT><EOF><BOF>import sys <EOL>from.import _chp_csv_path,_db_path <EOL>from.util import Directory <EOL>def build(chp_csv_path=None,db_path=None):<EOL><INDENT>if chp_csv_path is None :<EOL><INDENT>chp_csv_path=_chp_csv_path <EOL><DEDENT>if db_path is None :<EOL><INDENT>db_path=_db_path <EOL><DEDENT>dir_=Directory(db_path)<EOL>with open(chp_csv_path)as csv_f :<EOL><INDENT>dir_.load_chp_csv(csv_f)<EOL><DEDENT> <DEDENT>def build_cmd(chp_csv_path=None,db_path=None):<EOL><INDENT> '<STR_LIT>'<EOL>print '<STR_LIT>',<EOL>sys.stdout.flush()<EOL>build(chp_csv_path,db_path)<EOL>print 'Done.'<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>try :<EOL><INDENT>import clime <EOL><DEDENT>except ImportError :<EOL><INDENT>build(*sys.argv [:])<EOL><DEDENT>else :<EOL><INDENT>clime.start(white_pattern=clime.CMD_SUFFIX)<EOL><DEDENT> <DEDENT><EOF><BOF>import Cookie <EOL>import datetime <EOL>import time <EOL>import email.utils <EOL>import calendar <EOL>import base64 <EOL>import hashlib <EOL>import hmac <EOL>import re <EOL>import logging <EOL>class LilCookies :<EOL><INDENT>@staticmethod <EOL>def _utf8(s):<EOL><INDENT>if isinstance(s,unicode):<EOL><INDENT>return s.encode("utf-8")<EOL><DEDENT>assert isinstance(s,str)<EOL>return s <EOL><DEDENT>@staticmethod <EOL>def _time_independent_equals(a,b):<EOL><INDENT>if len(a)!=len(b):<EOL><INDENT>return False <EOL><DEDENT>result=<EOL>for x,y in zip(a,b):<EOL><INDENT>result |=ord(x)^ord(y)<EOL><DEDENT>return result==<EOL><DEDENT>@staticmethod <EOL>def _signature_from_secret(cookie_secret,*parts):<EOL><INDENT> '<STR_LIT>'<EOL>hash=hmac.new(cookie_secret,digestmod=hashlib.sha1)<EOL>for part in parts :hash.update(part)<EOL>return hash.hexdigest()<EOL><DEDENT>@staticmethod <EOL>def _signed_cookie_value(cookie_secret,name,value):<EOL><INDENT> '<STR_LIT>'<EOL>timestamp=str(int(time.time()))<EOL>value=base64.b64encode(value)<EOL>signature=LilCookies._signature_from_secret(cookie_secret,name,value,timestamp)<EOL>return "|".join([value,timestamp,signature ])<EOL><DEDENT>@staticmethod <EOL>def _verified_cookie_value(cookie_secret,name,signed_value):<EOL><INDENT> '<STR_LIT>'<EOL>value=signed_value <EOL>if not value :return None <EOL>parts=value.split("|")<EOL>if len(parts)!=:return None <EOL>signature=LilCookies._signature_from_secret(cookie_secret,name,parts [],parts [])<EOL>if not LilCookies._time_independent_equals(parts [],signature):<EOL><INDENT>logging.warning('<STR_LIT>',value)<EOL>return None <EOL><DEDENT>timestamp=int(parts [])<EOL>if timestamp <time.time()-*:<EOL><INDENT>logging.warning('<STR_LIT>',value)<EOL>return None <EOL><DEDENT>try :<EOL><INDENT>return base64.b64decode(parts [])<EOL><DEDENT>except :<EOL><INDENT>return None <EOL><DEDENT> <DEDENT>def __init__(self,handler,cookie_secret):<EOL><INDENT> '<STR_LIT>'<EOL>if len(cookie_secret)<:<EOL><INDENT>raise ValueError('<STR_LIT>'%cookie_secret)<EOL><DEDENT>self.handler=handler <EOL>self.request=handler.request <EOL>self.response=handler.response <EOL>self.cookie_secret=cookie_secret <EOL><DEDENT>def cookies(self):<EOL><INDENT> '<STR_LIT>'<EOL>if not hasattr(self,"_cookies"):<EOL><INDENT>self._cookies=Cookie.BaseCookie()<EOL>if "Cookie"in self.request.headers :<EOL><INDENT>try :<EOL><INDENT>self._cookies.load(self.request.headers ["Cookie"])<EOL><DEDENT>except :<EOL><INDENT>self.clear_all_cookies()<EOL><DEDENT> <DEDENT> <DEDENT>return self._cookies <EOL><DEDENT>def get_cookie(self,name,default=None):<EOL><INDENT> '<STR_LIT>'<EOL>if name in self.cookies():<EOL><INDENT>return self._cookies [name ].value <EOL><DEDENT>return default <EOL><DEDENT>def set_cookie(self,name,value,domain=None,expires=None,path="/",<EOL>expires_days=None,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>name=LilCookies._utf8(name)<EOL>value=LilCookies._utf8(value)<EOL>if re.search(r"[\x00-\x20]",name +value):<EOL><INDENT>raise ValueError('<STR_LIT>'%(name,value))<EOL><DEDENT>if not hasattr(self,"_new_cookies"):<EOL><INDENT>self._new_cookies=[]<EOL><DEDENT>new_cookie=Cookie.BaseCookie()<EOL>self._new_cookies.append(new_cookie)<EOL>new_cookie [name ]=value <EOL>if domain :<EOL><INDENT>new_cookie [name ]["domain"]=domain <EOL><DEDENT>if expires_days is not None and not expires :<EOL><INDENT>expires=datetime.datetime.utcnow()+datetime.timedelta(days=expires_days)<EOL><DEDENT>if expires :<EOL><INDENT>timestamp=calendar.timegm(expires.utctimetuple())<EOL>new_cookie [name ]["expires"]=email.utils.formatdate(<EOL>timestamp,localtime=False,usegmt=True)<EOL><DEDENT>if path :<EOL><INDENT>new_cookie [name ]["path"]=path <EOL><DEDENT>for k,v in kwargs.iteritems():<EOL><INDENT>new_cookie [name ][k ]=v <EOL><DEDENT>for vals in new_cookie.values():<EOL><INDENT>self.response.headers.add('Set-Cookie',vals.OutputString(None))<EOL><DEDENT> <DEDENT>def clear_cookie(self,name,path="/",domain=None):<EOL><INDENT> '<STR_LIT>'<EOL>expires=datetime.datetime.utcnow()-datetime.timedelta(days=)<EOL>self.set_cookie(name,value="",path=path,expires=expires,<EOL>domain=domain)<EOL><DEDENT>def clear_all_cookies(self):<EOL><INDENT> '<STR_LIT>'<EOL>for name in self.cookies().iterkeys():<EOL><INDENT>self.clear_cookie(name)<EOL><DEDENT> <DEDENT>def set_secure_cookie(self,name,value,expires_days=,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>value=LilCookies._signed_cookie_value(self.cookie_secret,name,value)<EOL>self.set_cookie(name,value,expires_days=expires_days,**kwargs)<EOL><DEDENT>def get_secure_cookie(self,name,value=None):<EOL><INDENT> '<STR_LIT>'<EOL>if value is None :value=self.get_cookie(name)<EOL>return LilCookies._verified_cookie_value(self.cookie_secret,name,value)<EOL><DEDENT>def _cookie_signature(self,*parts):<EOL><INDENT>return LilCookies._signature_from_secret(self.cookie_secret)<EOL><DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from itertools import groupby <EOL>from collections import deque <EOL>from threading import Lock <EOL>from.compat import izip <EOL>class Database(object):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,module=None,*conn_args,**conn_kargs):<EOL><INDENT>if module is not None :<EOL><INDENT>self.getconn=lambda :module.connect(*conn_args,**conn_kargs)<EOL><DEDENT>else :<EOL><INDENT>self.getconn=None <EOL><DEDENT>self.putconn=lambda conn :conn.close()<EOL>self.getcur=lambda conn :conn.cursor()<EOL>self.putcur=lambda cur :cur.close()<EOL>self.to_keep_conn=False <EOL>self._conn=None <EOL>self._cur_stack=deque()<EOL>self._lock=Lock()<EOL><DEDENT>def __enter__(self):<EOL><INDENT>with self._lock :<EOL><INDENT>if not self._conn :<EOL><INDENT>assert callable(self.getconn),'<STR_LIT>'<EOL>self._conn=self.getconn()<EOL><DEDENT>cur=self.getcur(self._conn)<EOL>self._cur_stack.append(cur)<EOL>return cur <EOL><DEDENT> <DEDENT>def __exit__(self,exc_type,exc_val,exc_tb):<EOL><INDENT>with self._lock :<EOL><INDENT>cur=self._cur_stack.pop()<EOL>self.putcur(cur)<EOL>if exc_type :<EOL><INDENT>self._conn.rollback()<EOL><DEDENT>else :<EOL><INDENT>self._conn.commit()<EOL><DEDENT>if self._conn and not self._cur_stack and not self.to_keep_conn :<EOL><INDENT>self.putconn(self._conn)<EOL>self._conn=None <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>def extract_col_names(cur):<EOL><INDENT> '<STR_LIT>'<EOL>return [desc []for desc in cur.description ]<EOL><DEDENT>def one_to_dict(cur=None,row=None,col_names=None):<EOL><INDENT> '<STR_LIT>'<EOL>if col_names is None :<EOL><INDENT>assert cur is not None,'<STR_LIT>'<EOL>col_names=extract_col_names(cur)<EOL><DEDENT>if row is None :<EOL><INDENT>assert cur is not None,'<STR_LIT>'<EOL>row=cur.fetchone()<EOL><DEDENT>return dict(izip(col_names,row))<EOL><DEDENT>def all_to_dicts(cur=None,rows=None,col_names=None):<EOL><INDENT> '<STR_LIT>'<EOL>if col_names is None :<EOL><INDENT>assert cur is not None,'<STR_LIT>'<EOL>col_names=extract_col_names(cur)<EOL><DEDENT>if rows is None :<EOL><INDENT>assert cur is not None,'<STR_LIT>'<EOL>rows=cur <EOL><DEDENT>return [dict(izip(col_names,row))for row in rows ]<EOL><DEDENT>def group(by_col_names,cur=None,rows=None,col_names=None,to_dict=False):<EOL><INDENT> '<STR_LIT>'<EOL>if col_names is None :<EOL><INDENT>assert cur is not None,'<STR_LIT>'<EOL>col_names=extract_col_names(cur)<EOL><DEDENT>if rows is None :<EOL><INDENT>assert cur is not None,'<STR_LIT>'<EOL>rows=cur <EOL><DEDENT>name_index_map=dict((name,idx)for idx,name in enumerate(col_names))<EOL>key_indexes=tuple(name_index_map.get(name)for name in by_col_names)<EOL>key_func=lambda row :tuple(row [i ]for i in key_indexes)<EOL>for key_values,rows_islice in groupby(rows,key_func):<EOL><INDENT>row=[list(col)for col in izip(*rows_islice)]<EOL>for key_index,key_value in izip(key_indexes,key_values):<EOL><INDENT>row [key_index ]=key_value <EOL><DEDENT>if to_dict :<EOL><INDENT>yield one_to_dict(row=row,col_names=col_names)<EOL><DEDENT>else :<EOL><INDENT>yield tuple(row)<EOL><DEDENT> <DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>import doctest <EOL>doctest.testmod()<EOL><DEDENT><EOF><BOF>from postbox import Gmail <EOL>with Gmail(user='<STR_LIT>')as gmail :<EOL><INDENT>gmail.send(<EOL>from_='<STR_LIT>',<EOL>to='<STR_LIT>',<EOL>subject='<STR_LIT>',<EOL>body=':D',)<EOL>gmail.send(<EOL>from_='<STR_LIT>',<EOL>to=[<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>'<EOL>],<EOL>cc=[<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>'<EOL>],<EOL>subject='<STR_LIT>',<EOL>body=':D',)<EOL>gmail.send(<EOL>from_='<STR_LIT>',<EOL>to='<STR_LIT>',<EOL>reply_to='<STR_LIT>',<EOL>subject='<STR_LIT>',<EOL>body=':D',)<EOL><DEDENT><EOF><BOF>import os <EOL>import sys <EOL>from java.lang import String <EOL>if sys.version_info [:]<(,,):<EOL><INDENT>os._orig_listdir=os.listdir <EOL>def listdir(path):<EOL><INDENT>items=os._orig_listdir(path)<EOL>if isinstance(path,unicode):<EOL><INDENT>items=[unicode(String(i).toString())for i in items ]<EOL><DEDENT>return items <EOL><DEDENT>os.listdir=listdir <EOL><DEDENT><EOF><BOF>import hashlib <EOL>class CacheEntry :<EOL><INDENT>def __init__(self,stored_hash,data):<EOL><INDENT>self.stored_hash=stored_hash <EOL>self.data=data <EOL><DEDENT> <DEDENT>class ScannerCache :<EOL><INDENT>def __init__(self):<EOL><INDENT>self.cache={}<EOL><DEDENT>def compute_hash(self,file_path,preread_lines=None):<EOL><INDENT>md5=hashlib.md5()<EOL>if preread_lines is None :<EOL><INDENT>with open(file_path,'rb')as f :<EOL><INDENT>preread_lines=f.readlines()<EOL><DEDENT> <DEDENT>for line in preread_lines :<EOL><INDENT>md5.update(line)<EOL><DEDENT>return md5.digest()<EOL><DEDENT>def get_cached_data(self,file_path,preread_lines=None):<EOL><INDENT>if not file_path in self.cache :<EOL><INDENT>return None,None <EOL><DEDENT>entry=self.cache [file_path ]<EOL>try :<EOL><INDENT>current_hash=self.compute_hash(file_path,preread_lines)<EOL><DEDENT>except IOError :<EOL><INDENT>del self.cache [file_path ]<EOL>return None,None <EOL><DEDENT>if entry.stored_hash !=current_hash :<EOL><INDENT>return None,current_hash <EOL><DEDENT>return entry.data,current_hash <EOL><DEDENT>def put_data(self,file_path,data,precomputed_hash=None):<EOL><INDENT>if precomputed_hash is None :<EOL><INDENT>precomputed_hash=self.compute_hash(file_path)<EOL><DEDENT>self.cache [file_path ]=CacheEntry(precomputed_hash,data)<EOL><DEDENT> <DEDENT><EOF><BOF>class SuiteRunErrors(object):<EOL><INDENT>_NO_ERROR=None <EOL>_exit_on_failure_error=('<STR_LIT>'<EOL>'<STR_LIT>')<EOL>_exit_on_fatal_error='<STR_LIT>'<EOL>_parent_suite_init_error='<STR_LIT>'<EOL>_parent_suite_setup_error='<STR_LIT>'<EOL>def __init__(self,run_mode_is_exit_on_failure=False,run_mode_skip_teardowns_on_exit=False):<EOL><INDENT>self._run_mode_is_exit_on_failure=run_mode_is_exit_on_failure <EOL>self._run_mode_skip_teardowns_on_exit=run_mode_skip_teardowns_on_exit <EOL>self._earlier_init_errors=[]<EOL>self._earlier_setup_errors=[]<EOL>self._earlier_suite_setup_executions=[]<EOL>self._init_current_errors()<EOL>self._exit_runmode=self._exit_fatal=False <EOL>self._current_suite_setup_executed=False <EOL><DEDENT>@property <EOL>def exit(self):<EOL><INDENT>return self._exit_fatal or self._exit_runmode <EOL><DEDENT>def _init_current_errors(self):<EOL><INDENT>self._current_init_err=self._current_setup_err=self._NO_ERROR <EOL><DEDENT>def start_suite(self):<EOL><INDENT>self._earlier_init_errors.append(self._current_init_err)<EOL>self._earlier_setup_errors.append(self._current_setup_err)<EOL>self._earlier_suite_setup_executions.append(self._current_suite_setup_executed)<EOL>self._init_current_errors()<EOL>self._current_suite_setup_executed=False <EOL><DEDENT>def end_suite(self):<EOL><INDENT>self._current_setup_err=self._earlier_setup_errors.pop()<EOL>self._current_init_err=self._earlier_init_errors.pop()<EOL>self._current_suite_setup_executed=self._earlier_suite_setup_executions.pop()<EOL><DEDENT>def is_suite_setup_allowed(self):<EOL><INDENT>return self._current_init_err is self._NO_ERROR and not self._earlier_errors()<EOL><DEDENT>def is_suite_teardown_allowed(self):<EOL><INDENT>if not self.is_test_teardown_allowed():<EOL><INDENT>return False <EOL><DEDENT>if self._current_suite_setup_executed :<EOL><INDENT>return True <EOL><DEDENT>return self._current_init_err is self._NO_ERROR and not self._earlier_errors()<EOL><DEDENT>def is_test_teardown_allowed(self):<EOL><INDENT>if not self._run_mode_skip_teardowns_on_exit :<EOL><INDENT>return True <EOL><DEDENT>return not(self._exit_fatal or self._exit_runmode)<EOL><DEDENT>def _earlier_errors(self):<EOL><INDENT>if self._exit_runmode or self._exit_fatal :<EOL><INDENT>return True <EOL><DEDENT>for err in self._earlier_setup_errors +self._earlier_init_errors :<EOL><INDENT>if err is not self._NO_ERROR :<EOL><INDENT>return True <EOL><DEDENT> <DEDENT>return False <EOL><DEDENT>def suite_init_err(self,error_message):<EOL><INDENT>self._current_init_err=error_message <EOL><DEDENT>def setup_executed(self):<EOL><INDENT>self._current_suite_setup_executed=True <EOL><DEDENT>def suite_setup_err(self,err):<EOL><INDENT>if err.exit :<EOL><INDENT>self._exit_fatal=True <EOL><DEDENT>self._current_setup_err=unicode(err)<EOL><DEDENT>def suite_error(self):<EOL><INDENT>if self._earlier_init_erros_occurred():<EOL><INDENT>return self._parent_suite_init_error <EOL><DEDENT>if self._earlier_setup_errors_occurred():<EOL><INDENT>return self._parent_suite_setup_error <EOL><DEDENT>if self._current_init_err :<EOL><INDENT>return self._current_init_err <EOL><DEDENT>if self._current_setup_err :<EOL><INDENT>return '<STR_LIT>'%self._current_setup_err <EOL><DEDENT>return ''<EOL><DEDENT>def _earlier_init_erros_occurred(self):<EOL><INDENT>return any(self._earlier_init_errors)<EOL><DEDENT>def _earlier_setup_errors_occurred(self):<EOL><INDENT>return any(self._earlier_setup_errors)<EOL><DEDENT>def child_error(self):<EOL><INDENT>if self._current_init_err or self._earlier_init_erros_occurred():<EOL><INDENT>return self._parent_suite_init_error <EOL><DEDENT>if self._current_setup_err or self._earlier_setup_errors_occurred():<EOL><INDENT>return self._parent_suite_setup_error <EOL><DEDENT>if self._exit_runmode :<EOL><INDENT>return self._exit_on_failure_error <EOL><DEDENT>if self._exit_fatal :<EOL><INDENT>return self._exit_on_fatal_error <EOL><DEDENT>return None <EOL><DEDENT>def test_failed(self,exit=False,critical=False):<EOL><INDENT>if critical and self._run_mode_is_exit_on_failure :<EOL><INDENT>self._exit_runmode=True <EOL><DEDENT>if exit :<EOL><INDENT>self._exit_fatal=True <EOL><DEDENT> <DEDENT> <DEDENT>class TestRunErrors(object):<EOL><INDENT>def __init__(self,err):<EOL><INDENT>self._parent_err=err.child_error()if err else None <EOL>self._init_err=None <EOL>self._setup_err=None <EOL>self._kw_err=None <EOL>self._teardown_err=None <EOL><DEDENT>def is_allowed_to_run(self):<EOL><INDENT>return not bool(self._parent_err or self._init_err)<EOL><DEDENT>def init_err(self,err):<EOL><INDENT>self._init_err=err <EOL><DEDENT>def setup_err(self,err):<EOL><INDENT>self._setup_err=err <EOL><DEDENT>def setup_failed(self):<EOL><INDENT>return bool(self._setup_err)<EOL><DEDENT>def kw_err(self,error):<EOL><INDENT>self._kw_err=error <EOL><DEDENT>def teardown_err(self,err):<EOL><INDENT>self._teardown_err=err <EOL><DEDENT>def teardown_failed(self):<EOL><INDENT>return bool(self._teardown_err)<EOL><DEDENT>def get_message(self):<EOL><INDENT>if self._setup_err :<EOL><INDENT>return '<STR_LIT>'%self._setup_err <EOL><DEDENT>return self._kw_err <EOL><DEDENT>def get_teardown_message(self,message):<EOL><INDENT>if message=='':<EOL><INDENT>return '<STR_LIT>'%self._teardown_err <EOL><DEDENT>return '<STR_LIT>'%(message,self._teardown_err)<EOL><DEDENT>def parent_or_init_error(self):<EOL><INDENT>return self._parent_err or self._init_err <EOL><DEDENT> <DEDENT>class KeywordRunErrors(object):<EOL><INDENT>def __init__(self):<EOL><INDENT>self.teardown_error=None <EOL><DEDENT>def get_message(self):<EOL><INDENT>if not self._teardown_err :<EOL><INDENT>return self._kw_err <EOL><DEDENT>if not self._kw_err :<EOL><INDENT>return '<STR_LIT>'%self._teardown_err <EOL><DEDENT>return '<STR_LIT>'%(self._kw_err,<EOL>self._teardown_err)<EOL><DEDENT>def teardown_err(self,err):<EOL><INDENT>self.teardown_error=err <EOL><DEDENT> <DEDENT><EOF><BOF>print '<STR_LIT>'<EOL>import cv2.cv as cv <EOL>_SIZE=<EOL>_DEFAULT_LEVEL=<EOL>_red=(,,,);<EOL>_green=(,,,);<EOL>_white=cv.RealScalar()<EOL>_black=cv.RealScalar()<EOL>def on_trackbar(position):<EOL><INDENT>contours_image=cv.CreateImage((_SIZE,_SIZE),,)<EOL>levels=position -<EOL>_contours=contours <EOL>if levels <=:<EOL><INDENT>_contours=contours.h_next().h_next().h_next()<EOL><DEDENT>cv.SetZero(contours_image)<EOL>cv.DrawContours(contours_image,_contours,<EOL>_red,_green,<EOL>levels,,cv.CV_AA,(,))<EOL>cv.ShowImage("contours",contours_image)<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>image=cv.CreateImage((_SIZE,_SIZE),,)<EOL>cv.SetZero(image)<EOL>for i in range():<EOL><INDENT>dx=(i %)*-<EOL>dy=(i /)*<EOL>cv.Ellipse(image,(dx +,dy +),(,),,,,_white,-,,)<EOL>cv.Ellipse(image,(dx +,dy +),(,),,,,_black,-,,)<EOL>cv.Ellipse(image,(dx +,dy +),(,),,,,_black,-,,)<EOL>cv.Ellipse(image,(dx +,dy +),(,),,,,_white,-,,)<EOL>cv.Ellipse(image,(dx +,dy +),(,),,,,_white,-,,)<EOL>cv.Ellipse(image,(dx +,dy +),(,),,,,_black,-,,)<EOL>cv.Ellipse(image,(dx +,dy +),(,),,,,_black,-,,)<EOL>cv.Ellipse(image,(dx +,dy +),(,),,,,_black,-,,)<EOL>cv.Ellipse(image,(dx +,dy +),(,),,,,_black,-,,)<EOL>cv.Ellipse(image,(dx +,dy +),(,),,,,_white,-,,)<EOL>cv.Ellipse(image,(dx +,dy +),(,),,,,_white,-,,)<EOL><DEDENT>cv.NamedWindow("image",)<EOL>cv.ShowImage("image",image)<EOL>storage=cv.CreateMemStorage()<EOL>contours=cv.FindContours(image,<EOL>storage,<EOL>cv.CV_RETR_TREE,<EOL>cv.CV_CHAIN_APPROX_SIMPLE,(,))<EOL>contours=cv.ApproxPoly(contours,<EOL>storage,<EOL>cv.CV_POLY_APPROX_DP,,)<EOL>cv.NamedWindow("contours",)<EOL>cv.CreateTrackbar("levels+3","contours",,,on_trackbar)<EOL>on_trackbar(_DEFAULT_LEVEL)<EOL>cv.WaitKey()<EOL>cv.DestroyAllWindows()<EOL><DEDENT><EOF><BOF>import unittest <EOL>from.test_sqlite import TestSQLite <EOL>if __name__=='__main__':<EOL><INDENT>unittest.main()<EOL><DEDENT><EOF><BOF>from operator import mul <EOL>def dot(x,y):<EOL><INDENT> '<STR_LIT>'<EOL>return sum(map(mul,x,y))<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>from clime import now <EOL><DEDENT><EOF><BOF>import re <EOL>_ESCAPE_RE=re.compile('<STR_LIT>')<EOL>_SEQS_TO_BE_ESCAPED=('\\','${','@{','%{','&{','*{','=')<EOL>def escape(item):<EOL><INDENT>if not isinstance(item,basestring):<EOL><INDENT>return item <EOL><DEDENT>for seq in _SEQS_TO_BE_ESCAPED :<EOL><INDENT>if seq in item :<EOL><INDENT>item=item.replace(seq,'\\'+seq)<EOL><DEDENT> <DEDENT>return item <EOL><DEDENT>def unescape(item):<EOL><INDENT>if not isinstance(item,basestring):<EOL><INDENT>return item <EOL><DEDENT>result=[]<EOL>unprocessed=item <EOL>while True :<EOL><INDENT>res=_ESCAPE_RE.search(unprocessed)<EOL>if res is None :<EOL><INDENT>result.append(unprocessed)<EOL>break <EOL><DEDENT>result.append(unprocessed [:res.start()])<EOL>escapes=res.group()<EOL>nextchars=res.group()<EOL>unprocessed=unprocessed [res.end():]<EOL>result.append('\\'*(len(escapes)/))<EOL>if len(escapes)%==or len(nextchars)==or nextchars []not in ['n','r','t']:<EOL><INDENT>result.append(nextchars)<EOL><DEDENT>elif nextchars []=='n':<EOL><INDENT>if len(nextchars)==or nextchars []==' ':<EOL><INDENT>result.append('\n')<EOL><DEDENT>else :<EOL><INDENT>result.append('\n'+nextchars [])<EOL><DEDENT> <DEDENT>elif nextchars []=='r':<EOL><INDENT>result.append('\r'+nextchars [:])<EOL><DEDENT>else :<EOL><INDENT>result.append('\t'+nextchars [:])<EOL><DEDENT> <DEDENT>return ''.join(result)<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import cv2 <EOL>import numpy as np <EOL>bins=np.arange().reshape(,)<EOL>def hist_curve(im):<EOL><INDENT>h=np.zeros((,,))<EOL>if len(im.shape)==:<EOL><INDENT>color=[(,,)]<EOL><DEDENT>elif im.shape []==:<EOL><INDENT>color=[(,,),(,,),(,,)]<EOL><DEDENT>for ch,col in enumerate(color):<EOL><INDENT>hist_item=cv2.calcHist([im ],[ch ],None,[],[,])<EOL>cv2.normalize(hist_item,hist_item,,,cv2.NORM_MINMAX)<EOL>hist=np.int32(np.around(hist_item))<EOL>pts=np.int32(np.column_stack((bins,hist)))<EOL>cv2.polylines(h,[pts ],False,col)<EOL><DEDENT>y=np.flipud(h)<EOL>return y <EOL><DEDENT>def hist_lines(im):<EOL><INDENT>h=np.zeros((,,))<EOL>if len(im.shape)!=:<EOL><INDENT>print '<STR_LIT>'<EOL>im=cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)<EOL><DEDENT>hist_item=cv2.calcHist([im ],[],None,[],[,])<EOL>cv2.normalize(hist_item,hist_item,,,cv2.NORM_MINMAX)<EOL>hist=np.int32(np.around(hist_item))<EOL>for x,y in enumerate(hist):<EOL><INDENT>cv2.line(h,(x,),(x,y),(,,))<EOL><DEDENT>y=np.flipud(h)<EOL>return y <EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>import sys <EOL>if len(sys.argv)>:<EOL><INDENT>fname=sys.argv []<EOL><DEDENT>else :<EOL><INDENT>fname='<STR_LIT>'<EOL>print '<STR_LIT>'<EOL><DEDENT>im=cv2.imread(fname)<EOL>if im is None :<EOL><INDENT>print '<STR_LIT>',fname <EOL>sys.exit()<EOL><DEDENT>gray=cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)<EOL>print '<STR_LIT>'<EOL>cv2.imshow('image',im)<EOL>while True :<EOL><INDENT>k=cv2.waitKey()&<EOL>if k==ord('a'):<EOL><INDENT>curve=hist_curve(im)<EOL>cv2.imshow('histogram',curve)<EOL>cv2.imshow('image',im)<EOL>print 'a'<EOL><DEDENT>elif k==ord('b'):<EOL><INDENT>print 'b'<EOL>lines=hist_lines(im)<EOL>cv2.imshow('histogram',lines)<EOL>cv2.imshow('image',gray)<EOL><DEDENT>elif k==ord('c'):<EOL><INDENT>print 'c'<EOL>equ=cv2.equalizeHist(gray)<EOL>lines=hist_lines(equ)<EOL>cv2.imshow('histogram',lines)<EOL>cv2.imshow('image',equ)<EOL><DEDENT>elif k==ord('d'):<EOL><INDENT>print 'd'<EOL>curve=hist_curve(gray)<EOL>cv2.imshow('histogram',curve)<EOL>cv2.imshow('image',gray)<EOL><DEDENT>elif k==ord('e'):<EOL><INDENT>print 'e'<EOL>norm=cv2.normalize(gray,alpha=,beta=,norm_type=cv2.NORM_MINMAX)<EOL>lines=hist_lines(norm)<EOL>cv2.imshow('histogram',lines)<EOL>cv2.imshow('image',norm)<EOL><DEDENT>elif k==:<EOL><INDENT>print 'ESC'<EOL>cv2.destroyAllWindows()<EOL>break <EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>try :<EOL><INDENT>from setuptools import setup <EOL>kw={'<STR_LIT>':[<EOL>'pygit2>=0.16.1',<EOL>'<STR_LIT>'<EOL>]}<EOL><DEDENT>except ImportError :<EOL><INDENT>from distutils.core import setup <EOL>print '<STR_LIT>'<EOL>kw={}<EOL><DEDENT>execfile('<STR_LIT>')<EOL>packages=['jsongit']<EOL>setup(<EOL>name='jsongit',<EOL>version=__version__,<EOL>description='Git for JSON',<EOL>long_description=open('README.rst').read(),<EOL>author='John Krauss',<EOL>author_email='<STR_LIT>',<EOL>url='<STR_LIT>',<EOL>packages=packages,<EOL>license='BSD',<EOL>classifiers=(<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>'),<EOL>**kw )<EOF><BOF>def repeat(message,times=,count=False):<EOL><INDENT> '<STR_LIT>'<EOL>s=message *times <EOL>return len(s)if count else s <EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>import clime.now <EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import pygame <EOL>from pygame.locals import *<EOL>from py2d.Math import *<EOL>from examples.Logo import PY2D_LOGO <EOL>from examples import Example,SCREEN_WIDTH,SCREEN_HEIGHT <EOL>try :<EOL><INDENT>import pymunk as pm <EOL>import pymunk.constraint as pmc <EOL>class LogoPhysics(Example):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,runner):<EOL><INDENT>self.runner=runner <EOL>self.title='<STR_LIT>'<EOL>p=PY2D_LOGO [][]<EOL>y=PY2D_LOGO [][]<EOL>d=PY2D_LOGO [-][]<EOL>self.w=d.right -p.left <EOL>self.h=y.bottom -p.top <EOL>self.colors=[,,,,]<EOL>transform=Transform.move(SCREEN_WIDTH /,)*Transform.scale(,)*Transform.move(-self.w /-p.left,-self.h /-p.top)<EOL>logo_scaled=[[Polygon.from_pointlist([transform *p for p in poly ])for poly in letter ]for letter in PY2D_LOGO ]<EOL>self.logo_polys=[Polygon.convex_decompose(letter [],letter [:])for letter in logo_scaled ]<EOL>self.fill=False <EOL>self.space=pm.Space()<EOL>self.space.gravity=(,)<EOL>self.space.damping=<EOL>tray=pm.Body()<EOL>tray_left=pm.Segment(pm.Body(),(,),(,SCREEN_HEIGHT),)<EOL>tray_right=pm.Segment(pm.Body(),(SCREEN_WIDTH,),(SCREEN_WIDTH,SCREEN_HEIGHT),)<EOL>tray_bottom=pm.Poly(pm.Body(),[(,SCREEN_HEIGHT /),(SCREEN_WIDTH,SCREEN_HEIGHT),(,SCREEN_HEIGHT)])<EOL>tray_bottom.elasticity=<EOL>tray_bottom.friction=<EOL>self.space.add_static(tray_left,tray_right,tray_bottom)<EOL>self.letters=[]<EOL><DEDENT>def make_logo(self):<EOL><INDENT>for letter in range(len(self.logo_polys)):<EOL><INDENT>self.letters.append([])<EOL>mass=<EOL>body=pm.Body(mass,)<EOL>cps=[p.get_centerpoint()for p in self.logo_polys [letter ]]<EOL>cp_x=sum((p.x for p in cps))/len(self.logo_polys [letter ])<EOL>cp_y=sum((p.y for p in cps))/len(self.logo_polys [letter ])<EOL>body.position=cp_x,cp_y <EOL>self.space.add(body)<EOL>for poly in self.logo_polys [letter ]:<EOL><INDENT>pt=Polygon.from_tuples([(v.x -cp_x,v.y -cp_y)for v in poly ])<EOL>verts=[(v.x,v.y)for v in pt ]<EOL>shape=pm.Poly(body,verts)<EOL>shape.elasticity=<EOL>self.letters [letter ].append((pt,body))<EOL>self.space.add(shape)<EOL><DEDENT> <DEDENT> '<STR_LIT>'<EOL><DEDENT>def update(self,time_elapsed):<EOL><INDENT>self.space.step(time_elapsed /)<EOL>if self.runner.keys [K_f ]:<EOL><INDENT>self.runner.keys [K_f ]=False <EOL>self.fill=not self.fill <EOL><DEDENT>if self.runner.keys [K_l ]:<EOL><INDENT>self.runner.keys [K_l ]=False <EOL>self.make_logo()<EOL><DEDENT> <DEDENT>def render(self):<EOL><INDENT>pygame.draw.polygon(self.runner.screen,,[(,SCREEN_HEIGHT /),(SCREEN_WIDTH,SCREEN_HEIGHT),(,SCREEN_HEIGHT)])<EOL>for polys,color in zip(range(len(self.letters)),self.colors):<EOL><INDENT>for poly,body in self.letters [polys ]:<EOL><INDENT>t=Transform.move(body.position.x,body.position.y)*Transform.rotate(body.angle)<EOL>points=[(t *p).as_tuple()for p in poly.points ]<EOL>pygame.draw.polygon(self.runner.screen,color,points,if self.fill else)<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>except ImportError :<EOL><INDENT>pass <EOL><DEDENT><EOF><BOF>import sys <EOL>sys.path.append("core")<EOL>from threading import Thread <EOL>import os <EOL>import os.path <EOL>import re <EOL>global context <EOL>global moveConfig <EOL>global shadowList <EOL>global threads <EOL>global moduleToMove <EOL>global t <EOL>global onModuleMoved <EOL>def moveModuleInView(activeContext,onModuleMovedCallBack):<EOL><INDENT>global onModuleMoved <EOL>onModuleMoved=onModuleMovedCallBack <EOL>global context <EOL>context=activeContext <EOL>global moduleToMove <EOL>moduleToMove=context.getModuleByFullPath(context.window.active_view().file_name())<EOL>if moduleToMove is None :<EOL><INDENT>return <EOL><DEDENT>global moveConfig <EOL>global shadowList <EOL>moveConfig={<EOL>"type":moduleToMove.type,<EOL>"fullPath":moduleToMove.getFullPath(),<EOL>"name":moduleToMove.name [:moduleToMove.name.find(".")],<EOL>"importString":moduleToMove.package +moduleToMove.name.split(moduleToMove.ext)[]<EOL>}<EOL>if moveConfig ["type"]=="script":<EOL><INDENT>packages=context.getScriptPackages()<EOL><DEDENT>elif moveConfig ["type"]=="text":<EOL><INDENT>packages=context.getTextPackages()<EOL><DEDENT>context.window.show_quick_panel(packages,onPackageSelected,)<EOL>shadowList=packages <EOL><DEDENT>def onPackageSelected(selectionIndex):<EOL><INDENT>global moveConfig <EOL>global shadowList <EOL>moduleSuggestiong=shadowList [selectionIndex ]<EOL>if selectionIndex==-:<EOL><INDENT>return <EOL><DEDENT>if selectionIndex==:<EOL><INDENT>moduleSuggestiong=""<EOL><DEDENT>if moveConfig ["type"]=="script":<EOL><INDENT>packagePath=context.getBaseDir()+context.settings ["script_folder"]+"/"+moduleSuggestiong <EOL>if os.path.exists(packagePath)==True :<EOL><INDENT>moveConfig ["packageBase"]=context.settings ["script_folder"]<EOL><DEDENT> <DEDENT>elif moveConfig ["type"]=="text":<EOL><INDENT>packagePath=context.getBaseDir()+context.settings ["text_folder"]+"/"+moduleSuggestiong <EOL>if os.path.exists(packagePath)==True :<EOL><INDENT>moveConfig ["packageBase"]=context.settings ["text_folder"]<EOL><DEDENT> <DEDENT>context.window.show_input_panel('<STR_LIT>',moduleSuggestiong +moveConfig ["name"],onNameDone,onNameChange,onNamceCancle)<EOL><DEDENT>def onNameDone(inputString):<EOL><INDENT>global moveConfig <EOL>global onModuleMoved <EOL>global context <EOL>moveConfig ["newImportString"]=inputString <EOL>moveConfig ["newName"]=inputString [inputString.rfind("/")+:]<EOL>moveModule()<EOL>onModuleMoved()<EOL>updateModules()<EOL>pass <EOL><DEDENT>def moveModule():<EOL><INDENT>global moduleToMove <EOL>global context <EOL>global moveConfig <EOL>context.window.run_command("close_file")<EOL>if moduleToMove.type is "text":<EOL><INDENT>current=context.settings ["text_folder"]+"/"+moveConfig ["importString"]<EOL>new=context.settings ["text_folder"]+"/"+moveConfig ["newImportString"]<EOL><DEDENT>else :<EOL><INDENT>current=context.settings ["script_folder"]+"/"+moveConfig ["importString"]<EOL>new=context.settings ["script_folder"]+"/"+moveConfig ["newImportString"]<EOL><DEDENT>newFullPath=moduleToMove.getFullPath().replace(current,new)<EOL>dir=os.path.dirname(newFullPath)<EOL>if not os.path.exists(dir):<EOL><INDENT>os.makedirs(dir)<EOL><DEDENT>os.rename(moduleToMove.getFullPath(),newFullPath)<EOL>context.window.open_file(newFullPath)<EOL>pass <EOL><DEDENT>def onNameChange(input):<EOL><INDENT>pass <EOL><DEDENT>def onNamceCancle(input):<EOL><INDENT>pass <EOL><DEDENT>def updateModules():<EOL><INDENT>global moveConfig <EOL>global context <EOL>global moduleToMove <EOL>global t <EOL>if moduleToMove.type is "text":<EOL><INDENT>pass <EOL><DEDENT>modulesList=context.getScriptModules()<EOL>if moduleToMove in modulesList :<EOL><INDENT>modulesList.remove(moduleToMove)<EOL><DEDENT>count=<EOL>t=Thread(target=update,args=(modulesList,moveConfig,updateDone))<EOL>t.start()<EOL><DEDENT>def updateDone():<EOL><INDENT>pass <EOL><DEDENT>def update(modules,moveConfig,callback):<EOL><INDENT>global moduleToMove <EOL>for module in modules :<EOL><INDENT>f=open(module.getFullPath(),"r")<EOL>data=f.read()<EOL>f.close();<EOL>if data.find("define([")is not -and data.find(moveConfig ["importString"])is not -:<EOL><INDENT>updateModule(module,data,moveConfig)<EOL><DEDENT> <DEDENT>callback();<EOL>pass <EOL><DEDENT>def updateModule(module,data,moveConfig):<EOL><INDENT>data=data.replace("'"+moveConfig ["importString"]+"'","'"+moveConfig ["newImportString"]+"'",)<EOL>if moveConfig ["name"]is not moveConfig ["newName"]:<EOL><INDENT>data=re.sub('\\b'+moveConfig ["name"]+'\\b',moveConfig ["newName"],data)<EOL><DEDENT>f=open(module.getFullPath(),"w+")<EOL>f.write(data)<EOL>f.close()<EOL>pass <EOL><DEDENT><EOF><BOF>import networkx as nx <EOL>import json <EOL>from networkx.readwrite import json_graph <EOL>import matplotlib.pyplot as plt <EOL>def buildGraph(simList,plot=False):<EOL><INDENT>g=distanceGraph(simList)<EOL>trim(g,)<EOL>if plot :<EOL><INDENT>nx.draw_networkx(g,with_labels=True)<EOL>plt.show()<EOL><DEDENT>return json.dumps(json_graph.node_link_data(g))<EOL><DEDENT>def trim(graph,threshold=):<EOL><INDENT>thr=threshold *graph.size()<EOL>for i,a in enumerate(sorted(nx.to_edgelist(graph),key=(lambda x :x []['weight']))):<EOL><INDENT>if i >thr :<EOL><INDENT>graph.remove_edge(a [],a [])<EOL><DEDENT> <DEDENT> <DEDENT>def distanceGraph(simList):<EOL><INDENT>G=nx.DiGraph()<EOL>for sim,dep,x1,x2 in simList :<EOL><INDENT>distance=/sim <EOL>if dep==:<EOL><INDENT>G.add_edge(x1,x2,weight=distance)<EOL><DEDENT>else :<EOL><INDENT>G.add_edge(x2,x1,weight=distance)<EOL><DEDENT> <DEDENT>return G <EOL><DEDENT><EOF><BOF>import cv2 <EOL>def webcam_gui(filter_func,video_src=):<EOL><INDENT>cap=cv2.VideoCapture(video_src)<EOL>key_code=-<EOL>while(key_code==-):<EOL><INDENT>t=cv2.getTickCount()<EOL>ret,frame=cap.read()<EOL>fps=cv2.getTickFrequency()/(cv2.getTickCount()-t)<EOL>print("Frame rate: "+str(fps))<EOL>frame_out=filter_func(frame)<EOL>cv2.imshow('<STR_LIT>',frame_out)<EOL>key_code=cv2.waitKey()<EOL><DEDENT>cap.release()<EOL>cv2.destroyAllWindows()<EOL><DEDENT>def edge_filter(frame_in):<EOL><INDENT>frame_gray=cv2.cvtColor(frame_in,cv2.COLOR_BGR2GRAY)<EOL>frame_blur=cv2.blur(frame_gray,(,))<EOL>frame_out=cv2.Canny(frame_blur,,)<EOL>return frame_out <EOL><DEDENT>def gray_filter(frame_in):<EOL><INDENT>frame_out=cv2.cvtColor(frame_in,cv2.COLOR_BGR2GRAY)<EOL>return frame_out <EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>webcam_gui(gray_filter,video_src=)<EOL><DEDENT><EOF><BOF>import numpy as np <EOL>from numpy import random <EOL>import cv2 <EOL>def make_gaussians(cluster_n,img_size):<EOL><INDENT>points=[]<EOL>ref_distrs=[]<EOL>for i in xrange(cluster_n):<EOL><INDENT>mean=(+*random.rand())*img_size <EOL>a=(random.rand(,)-)*img_size *<EOL>cov=np.dot(a.T,a)+img_size **np.eye()<EOL>n=+random.randint()<EOL>pts=random.multivariate_normal(mean,cov,n)<EOL>points.append(pts)<EOL>ref_distrs.append((mean,cov))<EOL><DEDENT>points=np.float32(np.vstack(points))<EOL>return points,ref_distrs <EOL><DEDENT>def draw_gaussain(img,mean,cov,color):<EOL><INDENT>x,y=np.int32(mean)<EOL>w,u,vt=cv2.SVDecomp(cov)<EOL>ang=np.arctan2(u [,],u [,])*(/np.pi)<EOL>s1,s2=np.sqrt(w)*<EOL>cv2.ellipse(img,(x,y),(s1,s2),ang,,,color,,cv2.LINE_AA)<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>cluster_n=<EOL>img_size=<EOL>print '<STR_LIT>'<EOL>while True :<EOL><INDENT>print '<STR_LIT>'<EOL>points,ref_distrs=make_gaussians(cluster_n,img_size)<EOL>print 'EM(opencv)...'<EOL>em=cv2.EM(cluster_n,cv2.EM_COV_MAT_GENERIC)<EOL>em.train(points)<EOL>means=em.getMat('means')<EOL>covs=em.getMatVector('covs')<EOL>found_distrs=zip(means,covs)<EOL>print 'ready!\n'<EOL>img=np.zeros((img_size,img_size,),np.uint8)<EOL>for x,y in np.int32(points):<EOL><INDENT>cv2.circle(img,(x,y),,(,,),-)<EOL><DEDENT>for m,cov in ref_distrs :<EOL><INDENT>draw_gaussain(img,m,cov,(,,))<EOL><DEDENT>for m,cov in found_distrs :<EOL><INDENT>draw_gaussain(img,m,cov,(,,))<EOL><DEDENT>cv2.imshow('<STR_LIT>',img)<EOL>ch=&cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>"""The models"""<EOL>from.build import Build <EOL>from.oauth_token import OAuthToken <EOL>from.repository import Repository <EOL>from.webhook import Webhook <EOF><BOF>import re <EOL>from robot.utils import NormalizedDict <EOL>from.criticality import Criticality <EOL>from.stats import TagStat,CombinedTagStat <EOL>from.tags import TagPatterns <EOL>class TagStatistics(object):<EOL><INDENT>def __init__(self,combined_stats):<EOL><INDENT>self.tags=NormalizedDict(ignore=['_'])<EOL>self.combined=combined_stats <EOL><DEDENT>def visit(self,visitor):<EOL><INDENT>visitor.visit_tag_statistics(self)<EOL><DEDENT>def __iter__(self):<EOL><INDENT>return iter(sorted(self.tags.values()+self.combined))<EOL><DEDENT> <DEDENT>class TagStatisticsBuilder(object):<EOL><INDENT>def __init__(self,criticality=None,included=None,excluded=None,<EOL>combined=None,docs=None,links=None):<EOL><INDENT>self._included=TagPatterns(included)<EOL>self._excluded=TagPatterns(excluded)<EOL>self._info=TagStatInfo(criticality,docs,links)<EOL>self.stats=TagStatistics(self._info.get_combined_stats(combined))<EOL><DEDENT>def add_test(self,test):<EOL><INDENT>self._add_tags_to_statistics(test)<EOL>self._add_to_combined_statistics(test)<EOL><DEDENT>def _add_tags_to_statistics(self,test):<EOL><INDENT>for tag in test.tags :<EOL><INDENT>if self._is_included(tag):<EOL><INDENT>if tag not in self.stats.tags :<EOL><INDENT>self.stats.tags [tag ]=self._info.get_stat(tag)<EOL><DEDENT>self.stats.tags [tag ].add_test(test)<EOL><DEDENT> <DEDENT> <DEDENT>def _is_included(self,tag):<EOL><INDENT>if self._included and not self._included.match(tag):<EOL><INDENT>return False <EOL><DEDENT>return not self._excluded.match(tag)<EOL><DEDENT>def _add_to_combined_statistics(self,test):<EOL><INDENT>for comb in self.stats.combined :<EOL><INDENT>if comb.match(test.tags):<EOL><INDENT>comb.add_test(test)<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>class TagStatInfo(object):<EOL><INDENT>def __init__(self,criticality=None,docs=None,links=None):<EOL><INDENT>self._criticality=criticality or Criticality()<EOL>self._docs=[TagStatDoc(*doc)for doc in docs or []]<EOL>self._links=[TagStatLink(*link)for link in links or []]<EOL><DEDENT>def get_stat(self,tag):<EOL><INDENT>return TagStat(tag,self.get_doc(tag),self.get_links(tag),<EOL>self._criticality.tag_is_critical(tag),<EOL>self._criticality.tag_is_non_critical(tag))<EOL><DEDENT>def get_combined_stats(self,combined=None):<EOL><INDENT>return [self.get_combined_stat(*comb)for comb in combined or []]<EOL><DEDENT>def get_combined_stat(self,pattern,name=None):<EOL><INDENT>name=name or pattern <EOL>return CombinedTagStat(pattern,name,self.get_doc(name),<EOL>self.get_links(name))<EOL><DEDENT>def get_doc(self,tag):<EOL><INDENT>return ' & '.join(doc.text for doc in self._docs if doc.match(tag))<EOL><DEDENT>def get_links(self,tag):<EOL><INDENT>return [link.get_link(tag)for link in self._links if link.match(tag)]<EOL><DEDENT> <DEDENT>class TagStatDoc(object):<EOL><INDENT>def __init__(self,pattern,doc):<EOL><INDENT>self._matcher=TagPatterns(pattern)<EOL>self.text=doc <EOL><DEDENT>def match(self,tag):<EOL><INDENT>return self._matcher.match(tag)<EOL><DEDENT> <DEDENT>class TagStatLink(object):<EOL><INDENT>_match_pattern_tokenizer=re.compile('(\*|\?+)')<EOL>def __init__(self,pattern,link,title):<EOL><INDENT>self._regexp=self._get_match_regexp(pattern)<EOL>self._link=link <EOL>self._title=title.replace('_',' ')<EOL><DEDENT>def match(self,tag):<EOL><INDENT>return self._regexp.match(tag)is not None <EOL><DEDENT>def get_link(self,tag):<EOL><INDENT>match=self._regexp.match(tag)<EOL>if not match :<EOL><INDENT>return None <EOL><DEDENT>link,title=self._replace_groups(self._link,self._title,match)<EOL>return link,title <EOL><DEDENT>def _replace_groups(self,link,title,match):<EOL><INDENT>for index,group in enumerate(match.groups()):<EOL><INDENT>placefolder='%%%d'%(index +)<EOL>link=link.replace(placefolder,group)<EOL>title=title.replace(placefolder,group)<EOL><DEDENT>return link,title <EOL><DEDENT>def _get_match_regexp(self,pattern):<EOL><INDENT>pattern='^%s$'%''.join(self._yield_match_pattern(pattern))<EOL>return re.compile(pattern,re.IGNORECASE)<EOL><DEDENT>def _yield_match_pattern(self,pattern):<EOL><INDENT>for token in self._match_pattern_tokenizer.split(pattern):<EOL><INDENT>if token.startswith('?'):<EOL><INDENT>yield '(%s)'%('.'*len(token))<EOL><DEDENT>elif token=='*':<EOL><INDENT>yield '(.*)'<EOL><DEDENT>else :<EOL><INDENT>yield re.escape(token)<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT><EOF><BOF>from robot.version import get_version <EOL>from robot.utils import plural_or_not,seq2str,seq2str2,unic <EOL>from robot.utils.asserts import assert_equals <EOL>class _List :<EOL><INDENT>def convert_to_list(self,item):<EOL><INDENT> '<STR_LIT>'<EOL>return list(item)<EOL><DEDENT>def append_to_list(self,list_,*values):<EOL><INDENT> '<STR_LIT>'<EOL>for value in values :<EOL><INDENT>list_.append(value)<EOL><DEDENT> <DEDENT>def insert_into_list(self,list_,index,value):<EOL><INDENT> '<STR_LIT>'<EOL>list_.insert(self._index_to_int(index),value)<EOL><DEDENT>def combine_lists(self,*lists):<EOL><INDENT> '<STR_LIT>'<EOL>ret=[]<EOL>for item in lists :<EOL><INDENT>ret.extend(item)<EOL><DEDENT>return ret <EOL><DEDENT>def set_list_value(self,list_,index,value):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>list_ [self._index_to_int(index)]=value <EOL><DEDENT>except IndexError :<EOL><INDENT>self._index_error(list_,index)<EOL><DEDENT> <DEDENT>def remove_values_from_list(self,list_,*values):<EOL><INDENT> '<STR_LIT>'<EOL>for value in values :<EOL><INDENT>while value in list_ :<EOL><INDENT>list_.remove(value)<EOL><DEDENT> <DEDENT> <DEDENT>def remove_from_list(self,list_,index):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>return list_.pop(self._index_to_int(index))<EOL><DEDENT>except IndexError :<EOL><INDENT>self._index_error(list_,index)<EOL><DEDENT> <DEDENT>def remove_duplicates(self,list_):<EOL><INDENT> '<STR_LIT>'<EOL>ret=[]<EOL>for item in list_ :<EOL><INDENT>if item not in ret :<EOL><INDENT>ret.append(item)<EOL><DEDENT> <DEDENT>removed=len(list_)-len(ret)<EOL>print '<STR_LIT>'%(removed,plural_or_not(removed))<EOL>return ret <EOL><DEDENT>def get_from_list(self,list_,index):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>return list_ [self._index_to_int(index)]<EOL><DEDENT>except IndexError :<EOL><INDENT>self._index_error(list_,index)<EOL><DEDENT> <DEDENT>def get_slice_from_list(self,list_,start=,end=None):<EOL><INDENT> '<STR_LIT>'<EOL>start=self._index_to_int(start,True)<EOL>if end is not None :<EOL><INDENT>end=self._index_to_int(end)<EOL><DEDENT>return list_ [start :end ]<EOL><DEDENT>def count_values_in_list(self,list_,value,start=,end=None):<EOL><INDENT> '<STR_LIT>'<EOL>return self.get_slice_from_list(list_,start,end).count(value)<EOL><DEDENT>def get_index_from_list(self,list_,value,start=,end=None):<EOL><INDENT> '<STR_LIT>'<EOL>if start=='':<EOL><INDENT>start=<EOL><DEDENT>list_=self.get_slice_from_list(list_,start,end)<EOL>try :<EOL><INDENT>return int(start)+list_.index(value)<EOL><DEDENT>except ValueError :<EOL><INDENT>return -<EOL><DEDENT> <DEDENT>def copy_list(self,list_):<EOL><INDENT> '<STR_LIT>'<EOL>return list_ [:]<EOL><DEDENT>def reverse_list(self,list_):<EOL><INDENT> '<STR_LIT>'<EOL>list_.reverse()<EOL><DEDENT>def sort_list(self,list_):<EOL><INDENT> '<STR_LIT>'<EOL>list_.sort()<EOL><DEDENT>def list_should_contain_value(self,list_,value,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>default='<STR_LIT>'%(seq2str2(list_),value)<EOL>_verify_condition(value in list_,default,msg)<EOL><DEDENT>def list_should_not_contain_value(self,list_,value,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>default='<STR_LIT>'%(seq2str2(list_),value)<EOL>_verify_condition(value not in list_,default,msg)<EOL><DEDENT>def list_should_not_contain_duplicates(self,list_,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>if not isinstance(list_,list):<EOL><INDENT>list_=list(list_)<EOL><DEDENT>dupes=[]<EOL>for item in list_ :<EOL><INDENT>if item not in dupes :<EOL><INDENT>count=list_.count(item)<EOL>if count >:<EOL><INDENT>print '<STR_LIT>'%(item,count)<EOL>dupes.append(item)<EOL><DEDENT> <DEDENT> <DEDENT>if dupes :<EOL><INDENT>if not msg :<EOL><INDENT>msg='<STR_LIT>'%seq2str(dupes)<EOL><DEDENT>raise AssertionError(msg)<EOL><DEDENT> <DEDENT>def lists_should_be_equal(self,list1,list2,msg=None,values=True,<EOL>names=None):<EOL><INDENT> '<STR_LIT>'<EOL>len1=len(list1)<EOL>len2=len(list2)<EOL>default='<STR_LIT>'%(len1,len2)<EOL>_verify_condition(len1==len2,default,msg,values)<EOL>names=self._get_list_index_name_mapping(names,len1)<EOL>diffs=list(self._yield_list_diffs(list1,list2,names))<EOL>default='<STR_LIT>'+'\n'.join(diffs)<EOL>_verify_condition(diffs==[],default,msg,values)<EOL><DEDENT>def _get_list_index_name_mapping(self,names,list_length):<EOL><INDENT>if not names :<EOL><INDENT>return {}<EOL><DEDENT>if isinstance(names,dict):<EOL><INDENT>return dict((int(index),names [index ])for index in names)<EOL><DEDENT>return dict(zip(range(list_length),names))<EOL><DEDENT>def _yield_list_diffs(self,list1,list2,names):<EOL><INDENT>for index,(item1,item2)in enumerate(zip(list1,list2)):<EOL><INDENT>name='(%s)'%names [index ]if index in names else ''<EOL>try :<EOL><INDENT>assert_equals(item1,item2,msg='Index %d%s'%(index,name))<EOL><DEDENT>except AssertionError,err :<EOL><INDENT>yield unic(err)<EOL><DEDENT> <DEDENT> <DEDENT>def list_should_contain_sub_list(self,list1,list2,msg=None,values=True):<EOL><INDENT> '<STR_LIT>'<EOL>diffs=', '.join(unic(item)for item in list2 if item not in list1)<EOL>default='<STR_LIT>'+diffs <EOL>_verify_condition(diffs=='',default,msg,values)<EOL><DEDENT>def log_list(self,list_,level='INFO'):<EOL><INDENT> '<STR_LIT>'<EOL>print '*%s* '%level.upper(),<EOL>if len(list_)==:<EOL><INDENT>print 'List is empty'<EOL><DEDENT>elif len(list_)==:<EOL><INDENT>print '<STR_LIT>'%list_ []<EOL><DEDENT>else :<EOL><INDENT>print '<STR_LIT>'%len(list_)<EOL>for index,item in enumerate(list_):<EOL><INDENT>print '%s: %s'%(index,item)<EOL><DEDENT> <DEDENT> <DEDENT>def _index_to_int(self,index,empty_to_zero=False):<EOL><INDENT>if empty_to_zero and not index :<EOL><INDENT>return <EOL><DEDENT>try :<EOL><INDENT>return int(index)<EOL><DEDENT>except ValueError :<EOL><INDENT>raise ValueError('<STR_LIT>'%index)<EOL><DEDENT> <DEDENT>def _index_error(self,list_,index):<EOL><INDENT>raise IndexError('<STR_LIT>'<EOL>%(index,len(list_)-))<EOL><DEDENT> <DEDENT>class _Dictionary :<EOL><INDENT>def create_dictionary(self,*key_value_pairs):<EOL><INDENT> '<STR_LIT>'<EOL>if len(key_value_pairs)%!=:<EOL><INDENT>raise ValueError('<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT>return self.set_to_dictionary({},*key_value_pairs)<EOL><DEDENT>def set_to_dictionary(self,dictionary,*key_value_pairs):<EOL><INDENT> '<STR_LIT>'<EOL>if len(key_value_pairs)%!=:<EOL><INDENT>raise ValueError('<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT>for i in range(,len(key_value_pairs),):<EOL><INDENT>dictionary [key_value_pairs [i ]]=key_value_pairs [i +]<EOL><DEDENT>return dictionary <EOL><DEDENT>def remove_from_dictionary(self,dictionary,*keys):<EOL><INDENT> '<STR_LIT>'<EOL>for key in keys :<EOL><INDENT>try :<EOL><INDENT>value=dictionary.pop(key)<EOL>print '<STR_LIT>'%(key,value)<EOL><DEDENT>except KeyError :<EOL><INDENT>print '<STR_LIT>'%(key)<EOL><DEDENT> <DEDENT> <DEDENT>def keep_in_dictionary(self,dictionary,*keys):<EOL><INDENT> '<STR_LIT>'<EOL>remove_keys=[k for k in dictionary if k not in keys ]<EOL>self.remove_from_dictionary(dictionary,*remove_keys)<EOL><DEDENT>def copy_dictionary(self,dictionary):<EOL><INDENT> '<STR_LIT>'<EOL>return dictionary.copy()<EOL><DEDENT>def get_dictionary_keys(self,dictionary):<EOL><INDENT> '<STR_LIT>'<EOL>return sorted(dictionary)<EOL><DEDENT>def get_dictionary_values(self,dictionary):<EOL><INDENT> '<STR_LIT>'<EOL>return [dictionary [k ]for k in self.get_dictionary_keys(dictionary)]<EOL><DEDENT>def get_dictionary_items(self,dictionary):<EOL><INDENT> '<STR_LIT>'<EOL>ret=[]<EOL>for key in self.get_dictionary_keys(dictionary):<EOL><INDENT>ret.extend((key,dictionary [key ]))<EOL><DEDENT>return ret <EOL><DEDENT>def get_from_dictionary(self,dictionary,key):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>return dictionary [key ]<EOL><DEDENT>except KeyError :<EOL><INDENT>raise RuntimeError('<STR_LIT>'%key)<EOL><DEDENT> <DEDENT>def dictionary_should_contain_key(self,dictionary,key,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>default='<STR_LIT>'%key <EOL>_verify_condition(dictionary.has_key(key),default,msg)<EOL><DEDENT>def dictionary_should_not_contain_key(self,dictionary,key,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>default='<STR_LIT>'%key <EOL>_verify_condition(not dictionary.has_key(key),default,msg)<EOL><DEDENT>def dictionary_should_contain_value(self,dictionary,value,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>default='<STR_LIT>'%value <EOL>_verify_condition(value in dictionary.values(),default,msg)<EOL><DEDENT>def dictionary_should_not_contain_value(self,dictionary,value,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>default='<STR_LIT>'%value <EOL>_verify_condition(not value in dictionary.values(),default,msg)<EOL><DEDENT>def dictionaries_should_be_equal(self,dict1,dict2,msg=None,values=True):<EOL><INDENT> '<STR_LIT>'<EOL>keys=self._keys_should_be_equal(dict1,dict2,msg,values)<EOL>self._key_values_should_be_equal(keys,dict1,dict2,msg,values)<EOL><DEDENT>def dictionary_should_contain_sub_dictionary(self,dict1,dict2,msg=None,<EOL>values=True):<EOL><INDENT> '<STR_LIT>'<EOL>keys=self.get_dictionary_keys(dict2)<EOL>diffs=[unic(k)for k in keys if k not in dict1 ]<EOL>default='<STR_LIT>'%', '.join(diffs)<EOL>_verify_condition(diffs==[],default,msg,values)<EOL>self._key_values_should_be_equal(keys,dict1,dict2,msg,values)<EOL><DEDENT>def log_dictionary(self,dictionary,level='INFO'):<EOL><INDENT> '<STR_LIT>'<EOL>print '*%s* '%level.upper(),<EOL>if len(dictionary)==:<EOL><INDENT>print '<STR_LIT>'<EOL><DEDENT>elif len(dictionary)==:<EOL><INDENT>print '<STR_LIT>'<EOL><DEDENT>else :<EOL><INDENT>print '<STR_LIT>'%len(dictionary)<EOL><DEDENT>for key in self.get_dictionary_keys(dictionary):<EOL><INDENT>print '%s: %s'%(key,dictionary [key ])<EOL><DEDENT> <DEDENT>def _keys_should_be_equal(self,dict1,dict2,msg,values):<EOL><INDENT>keys1=self.get_dictionary_keys(dict1)<EOL>keys2=self.get_dictionary_keys(dict2)<EOL>miss1=[unic(k)for k in keys2 if k not in dict1 ]<EOL>miss2=[unic(k)for k in keys1 if k not in dict2 ]<EOL>error=[]<EOL>if miss1 :<EOL><INDENT>error +=['<STR_LIT>'<EOL>%', '.join(miss1)]<EOL><DEDENT>if miss2 :<EOL><INDENT>error +=['<STR_LIT>'<EOL>%', '.join(miss2)]<EOL><DEDENT>_verify_condition(error==[],'\n'.join(error),msg,values)<EOL>return keys1 <EOL><DEDENT>def _key_values_should_be_equal(self,keys,dict1,dict2,msg,values):<EOL><INDENT>diffs=list(self._yield_dict_diffs(keys,dict1,dict2))<EOL>default='<STR_LIT>'+'\n'.join(diffs)<EOL>_verify_condition(diffs==[],default,msg,values)<EOL><DEDENT>def _yield_dict_diffs(self,keys,dict1,dict2):<EOL><INDENT>for key in keys :<EOL><INDENT>try :<EOL><INDENT>assert_equals(dict1 [key ],dict2 [key ],msg='Key %s'%(key,))<EOL><DEDENT>except AssertionError,err :<EOL><INDENT>yield unic(err)<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>class Collections(_List,_Dictionary):<EOL><INDENT> '<STR_LIT>'<EOL>ROBOT_LIBRARY_SCOPE='GLOBAL'<EOL>ROBOT_LIBRARY_VERSION=get_version()<EOL><DEDENT>def _verify_condition(condition,default_msg,given_msg,include_default=False):<EOL><INDENT>if not condition :<EOL><INDENT>if not given_msg :<EOL><INDENT>raise AssertionError(default_msg)<EOL><DEDENT>if _include_default_message(include_default):<EOL><INDENT>raise AssertionError(given_msg +'\n'+default_msg)<EOL><DEDENT>raise AssertionError(given_msg)<EOL><DEDENT> <DEDENT>def _include_default_message(include):<EOL><INDENT>if isinstance(include,basestring):<EOL><INDENT>return include.lower()not in ['no values','false']<EOL><DEDENT>return bool(include)<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import cv2 <EOL>import video <EOL>import sys <EOL>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>try :<EOL><INDENT>fn=sys.argv []<EOL><DEDENT>except :<EOL><INDENT>fn=<EOL><DEDENT>def nothing(*arg):<EOL><INDENT>pass <EOL><DEDENT>cv2.namedWindow('edge')<EOL>cv2.createTrackbar('thrs1','edge',,,nothing)<EOL>cv2.createTrackbar('thrs2','edge',,,nothing)<EOL>cap=video.create_capture(fn)<EOL>while True :<EOL><INDENT>flag,img=cap.read()<EOL>gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)<EOL>thrs1=cv2.getTrackbarPos('thrs1','edge')<EOL>thrs2=cv2.getTrackbarPos('thrs2','edge')<EOL>edge=cv2.Canny(gray,thrs1,thrs2,apertureSize=)<EOL>vis=img.copy()<EOL>vis /=<EOL>vis [edge !=]=(,,)<EOL>cv2.imshow('edge',vis)<EOL>ch=cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>import os <EOL>from.markuputils import html_escape,xml_escape,attribute_escape <EOL>class _MarkupWriter(object):<EOL><INDENT>def __init__(self,output,line_separator=os.linesep,encoding=None):<EOL><INDENT> '<STR_LIT>'<EOL>if isinstance(output,basestring):<EOL><INDENT>output=open(output,'w')<EOL><DEDENT>self.output=output <EOL>self._line_separator=line_separator <EOL>self._encode=self._create_encoder(encoding)<EOL>self._preamble()<EOL><DEDENT>def _create_encoder(self,encoding):<EOL><INDENT>if encoding is None :<EOL><INDENT>return lambda text :text <EOL><DEDENT>return lambda text :text.encode(encoding)<EOL><DEDENT>def start(self,name,attrs=None,newline=True):<EOL><INDENT>self._write('<%s %s>'%(name,self._format_attrs(attrs))<EOL>if attrs else '<%s>'%name,newline)<EOL><DEDENT>def _format_attrs(self,attrs):<EOL><INDENT>return ' '.join('%s="%s"'%(name,attribute_escape(attrs [name ]))<EOL>for name in self._order_attrs(attrs))<EOL><DEDENT>def content(self,content=None,escape=True):<EOL><INDENT>if content :<EOL><INDENT>self._write(self._escape(content)if escape else content)<EOL><DEDENT> <DEDENT>def end(self,name,newline=True):<EOL><INDENT>self._write('</%s>'%name,newline)<EOL><DEDENT>def element(self,name,content=None,attrs=None,escape=True,<EOL>newline=True):<EOL><INDENT>self.start(name,attrs,newline=False)<EOL>self.content(content,escape)<EOL>self.end(name,newline)<EOL><DEDENT>def close(self):<EOL><INDENT> '<STR_LIT>'<EOL>self.output.close()<EOL><DEDENT>def _write(self,text,newline=False):<EOL><INDENT>self.output.write(self._encode(text))<EOL>if newline :<EOL><INDENT>self.output.write(self._line_separator)<EOL><DEDENT> <DEDENT> <DEDENT>class HtmlWriter(_MarkupWriter):<EOL><INDENT>def _preamble(self):<EOL><INDENT>pass <EOL><DEDENT>def _escape(self,content):<EOL><INDENT>return html_escape(content)<EOL><DEDENT>def _order_attrs(self,attrs):<EOL><INDENT>return sorted(attrs)<EOL><DEDENT> <DEDENT>class XmlWriter(_MarkupWriter):<EOL><INDENT>def _preamble(self):<EOL><INDENT>self._write('<STR_LIT>',newline=True)<EOL><DEDENT>def _escape(self,text):<EOL><INDENT>return xml_escape(text)<EOL><DEDENT>def _order_attrs(self,attrs):<EOL><INDENT>return attrs <EOL><DEDENT> <DEDENT>class NullMarkupWriter(object):<EOL><INDENT> '<STR_LIT>'<EOL>__init__=start=content=element=end=close=lambda *args :None <EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from.model import TestData,TestCaseFile,TestDataDirectory,ResourceFile <EOL>from.import populators <EOL>VALID_EXTENSIONS=tuple(populators.READERS)<EOL>def disable_curdir_processing(method):<EOL><INDENT> '<STR_LIT>'<EOL>def decorated(*args,**kwargs):<EOL><INDENT>original=populators.PROCESS_CURDIR <EOL>populators.PROCESS_CURDIR=False <EOL>try :<EOL><INDENT>return method(*args,**kwargs)<EOL><DEDENT>finally :<EOL><INDENT>populators.PROCESS_CURDIR=original <EOL><DEDENT> <DEDENT>return decorated <EOL><DEDENT><EOF><BOF>import cv2 <EOL>import numpy as np <EOL>from cam import MyCam <EOL>from time import time <EOL>def draw_oriented_polylines(img,pts_in,is_closed,color_start,thickness=,color_end=(,,)):<EOL><INDENT>img_out=img <EOL>pts=pts_in.reshape(-,)<EOL>if len(img.shape)==or img.shape []==:<EOL><INDENT>img_out=cv2.cvtColor(img_out,cv2.COLOR_GRAY2BGR)<EOL><DEDENT>cs,ce=color_start,color_end <EOL>n=len(pts)<EOL>for idx,pt in enumerate(pts):<EOL><INDENT>if idx==n and not is_closed :break <EOL>next_pt=pts [(idx +)%n ]<EOL>color=((cs []*(n -idx)+ce []*idx)/n,(cs []*(n -idx)+ce []*idx)/n,(cs []*(n -idx)+ce []*idx)/n)<EOL>cv2.line(img_out,tuple(pt),tuple(next_pt),color,thickness)<EOL><DEDENT> <DEDENT>def find_polygons(gray_image_in,edge_num,tolerance=,area_threshold=,convex_only=True,edge_threshold=,orientation=):<EOL><INDENT> '<STR_LIT>'<EOL>img=gray_image_in.copy()<EOL>lo,hi=,<EOL>edge=cv2.Canny(img,lo,hi)<EOL>thresh1,dst=cv2.threshold(edge,edge_threshold,,cv2.THRESH_BINARY)<EOL>ctr,hry=cv2.findContours(dst,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)<EOL>if hry is None :return []<EOL>hry=hry []<EOL>polygons=[]<EOL>for cnt in ctr :<EOL><INDENT>cnt=cnt.reshape(-,)<EOL>epsilon=tolerance **((*cv2.contourArea(cnt))**)<EOL>tmp=cv2.approxPolyDP(cnt,epsilon,True)<EOL>if len(tmp)!=edge_num :continue <EOL>if convex_only and not cv2.isContourConvex(tmp):continue <EOL>if cv2.contourArea(tmp)<area_threshold :continue <EOL>cross_product=np.cross(tmp []-tmp [],tmp []-tmp [])[]<EOL>if cross_product *orientation >:<EOL><INDENT>tmp=np.flipud(tmp)<EOL><DEDENT>tmp=tmp.reshape(-,)<EOL>distance_from_origin=map(lambda pt :pt []**+pt []**,tmp)<EOL>val,idx=min((val,idx)for(idx,val)in enumerate(distance_from_origin))<EOL>if idx >:<EOL><INDENT>up,down=np.vsplit(tmp,[idx ])<EOL>tmp=np.vstack((down,up))<EOL><DEDENT>polygons.append(tmp)<EOL><DEDENT>return polygons <EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>cam=MyCam()<EOL>while True :<EOL><INDENT>img=cam.read()<EOL>polygons=find_polygons(img,)<EOL>for ctr in polygons :<EOL><INDENT>draw_oriented_polylines(img,ctr,,(,,),,(,,))<EOL><DEDENT>cv2.imshow('<STR_LIT>',img)<EOL>k=cv2.waitKey()<EOL>if k==:<EOL><INDENT>break <DEDENT> <DEDENT> <DEDENT><EOF><BOF>import math <EOL>from collections import defaultdict <EOL>class Vector(object):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,x,y):<EOL><INDENT> '<STR_LIT>'<EOL>self.x=x <EOL>self.y=y <EOL><DEDENT>def get_length(self):<EOL><INDENT> '<STR_LIT>'<EOL>return math.sqrt(self.get_length_squared())<EOL><DEDENT>def get_length_squared(self):<EOL><INDENT> '<STR_LIT>'<EOL>return self.x *self.x +self.y *self.y ;<EOL><DEDENT>def get_slope(self):<EOL><INDENT> '<STR_LIT>'<EOL>if self.x==:return float('inf')<EOL>return float(self.y)/self.x <EOL><DEDENT>def normalize(self):<EOL><INDENT> '<STR_LIT>'<EOL>return self /self.get_length()<EOL><DEDENT>def clamp(self):<EOL><INDENT> '<STR_LIT>'<EOL>if self.get_length()>:<EOL><INDENT>return self.normalize()<EOL><DEDENT>else :<EOL><INDENT>return self <EOL><DEDENT> <DEDENT>def clone(self):<EOL><INDENT> '<STR_LIT>'<EOL>return Vector(self.x,self.y)<EOL><DEDENT>def normal(self):<EOL><INDENT> '<STR_LIT>'<EOL>return Vector(-self.y,self.x)<EOL><DEDENT>def as_tuple(self):<EOL><INDENT> '<STR_LIT>'<EOL>return(self.x,self.y)<EOL><DEDENT>def __add__(self,b):<EOL><INDENT>return Vector(self.x +b.x,self.y +b.y)<EOL><DEDENT>def __sub__(self,b):<EOL><INDENT>return Vector(self.x -b.x,self.y -b.y)<EOL><DEDENT>def __mul__(self,val):<EOL><INDENT>if isinstance(val,Vector):<EOL><INDENT>return self.x *val.x +self.y *val.y <EOL><DEDENT>else :<EOL><INDENT>return Vector(self.x *val,self.y *val)<EOL><DEDENT> <DEDENT>def __div__(self,val):<EOL><INDENT>return Vector(self.x /val,self.y /val)<EOL><DEDENT>def __repr__(self):<EOL><INDENT>return '<STR_LIT>'%(self.x,self.y)<EOL><DEDENT>def __eq__(self,other):<EOL><INDENT>if not isinstance(other,Vector):return False <EOL>d=self -other <EOL>return abs(d.x)<EPSILON and abs(d.y)<EPSILON <EOL><DEDENT>def __ne__(self,other):<EOL><INDENT>return not self.__eq__(other)<EOL><DEDENT>def __hash__(self):<EOL><INDENT>return hash("%.4f %.4f"%(self.x,self.y))<EOL><DEDENT>def __getitem__(self,key):<EOL><INDENT>if key==:return self.x <EOL>elif key==:return self.y <EOL>else :raise KeyError('<STR_LIT>'%key)<EOL><DEDENT>def __setitem__(self,key,value):<EOL><INDENT>if key==:self.x=value <EOL>elif key==:self.y=value <EOL>else :raise KeyError('<STR_LIT>'%key)<EOL><DEDENT>length=property(get_length,None,None)<EOL>length_squared=property(get_length_squared,None,None)<EOL>slope=property(get_slope,None,None)<EOL><DEDENT>VECTOR_NULL=Vector(,)<EOL>VECTOR_X=Vector(,)<EOL>VECTOR_Y=Vector(,)<EOL>EPSILON=<EOF><BOF>'<STR_LIT>'<EOF><BOF>'<STR_LIT>'<EOL>import sys <EOL>import cv2.cv as cv <EOL>from optparse import OptionParser <EOL>min_size=(,)<EOL>image_scale=<EOL>haar_scale=<EOL>min_neighbors=<EOL>haar_flags=<EOL>def detect_and_draw(img,cascade):<EOL><INDENT>gray=cv.CreateImage((img.width,img.height),,)<EOL>small_img=cv.CreateImage((cv.Round(img.width /image_scale),<EOL>cv.Round(img.height /image_scale)),,)<EOL>cv.CvtColor(img,gray,cv.CV_BGR2GRAY)<EOL>cv.Resize(gray,small_img,cv.CV_INTER_LINEAR)<EOL>cv.EqualizeHist(small_img,small_img)<EOL>if(cascade):<EOL><INDENT>t=cv.GetTickCount()<EOL>faces=cv.HaarDetectObjects(small_img,cascade,cv.CreateMemStorage(),<EOL>haar_scale,min_neighbors,haar_flags,min_size)<EOL>t=cv.GetTickCount()-t <EOL>print '<STR_LIT>'%(t /(cv.GetTickFrequency()*))<EOL>if faces :<EOL><INDENT>for((x,y,w,h),n)in faces :<EOL><INDENT>pt1=(int(x *image_scale),int(y *image_scale))<EOL>pt2=(int((x +w)*image_scale),int((y +h)*image_scale))<EOL>cv.Rectangle(img,pt1,pt2,cv.RGB(,,),,,)<EOL><DEDENT> <DEDENT> <DEDENT>cv.ShowImage("result",img)<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>parser=OptionParser(usage='<STR_LIT>')<EOL>parser.add_option("-c","--cascade",action="store",dest="cascade",type="str",help='<STR_LIT>',default='<STR_LIT>')(options,args)=parser.parse_args()<EOL>cascade=cv.Load(options.cascade)<EOL>if len(args)!=:<EOL><INDENT>parser.print_help()<EOL>sys.exit()<EOL><DEDENT>input_name=args []<EOL>if input_name.isdigit():<EOL><INDENT>capture=cv.CreateCameraCapture(int(input_name))<EOL><DEDENT>else :<EOL><INDENT>capture=None <EOL><DEDENT>cv.NamedWindow("result",)<EOL>if capture :<EOL><INDENT>frame_copy=None <EOL>while True :<EOL><INDENT>frame=cv.QueryFrame(capture)<EOL>if not frame :<EOL><INDENT>cv.WaitKey()<EOL>break <EOL><DEDENT>if not frame_copy :<EOL><INDENT>frame_copy=cv.CreateImage((frame.width,frame.height),<EOL>cv.IPL_DEPTH_8U,frame.nChannels)<EOL><DEDENT>if frame.origin==cv.IPL_ORIGIN_TL :<EOL><INDENT>cv.Copy(frame,frame_copy)<EOL><DEDENT>else :<EOL><INDENT>cv.Flip(frame,frame_copy,)<EOL><DEDENT>detect_and_draw(frame_copy,cascade)<EOL>if cv.WaitKey()>=:<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT>else :<EOL><INDENT>image=cv.LoadImage(input_name,)<EOL>detect_and_draw(image,cascade)<EOL>cv.WaitKey()<EOL><DEDENT>cv.DestroyWindow("result")<EOL><DEDENT><EOF><BOF>from zerotest.forwarder import Forwarder <EOL>request=None <EOL>response=None <EOL>def test_callback():<EOL><INDENT>def callback(req,res):<EOL><INDENT>global request <EOL>global response <EOL>request=req <EOL>response=res <EOL><DEDENT>forwarder=Forwarder('<STR_LIT>')<EOL>forwarder.on_forward_complete(callback)<EOL>fake_request=object()<EOL>fake_response=object()<EOL>forwarder.trigger_on_forward_complete(fake_request,fake_response)<EOL>assert request==fake_request <EOL>assert response==fake_response <EOL><DEDENT><EOF><BOF>import cv2.cv as cv <EOL>def is_rect_nonzero(r):<EOL><INDENT>(_,_,w,h)=r <EOL>return(w >)and(h >)<EOL><DEDENT>class CamShiftDemo :<EOL><INDENT>def __init__(self):<EOL><INDENT>self.capture=cv.CaptureFromCAM()<EOL>cv.NamedWindow("CamShiftDemo",)<EOL>cv.NamedWindow("Histogram",)<EOL>cv.SetMouseCallback("CamShiftDemo",self.on_mouse)<EOL>self.drag_start=None <EOL>self.track_window=None <EOL>print("Keys:\n"<EOL>'<STR_LIT>'<EOL>'<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT>def hue_histogram_as_image(self,hist):<EOL><INDENT> '<STR_LIT>'<EOL>histimg_hsv=cv.CreateImage((,),,)<EOL>mybins=cv.CloneMatND(hist.bins)<EOL>cv.Log(mybins,mybins)(_,hi,_,_)=cv.MinMaxLoc(mybins)<EOL>cv.ConvertScale(mybins,mybins,/hi)<EOL>w,h=cv.GetSize(histimg_hsv)<EOL>hdims=cv.GetDims(mybins)[]<EOL>for x in range(w):<EOL><INDENT>xh=(*x)/(w -)<EOL>val=int(mybins [int(hdims *x /w)]*h /)<EOL>cv.Rectangle(histimg_hsv,(x,),(x,h -val),(xh,,),-)<EOL>cv.Rectangle(histimg_hsv,(x,h -val),(x,h),(xh,,),-)<EOL><DEDENT>histimg=cv.CreateImage((,),,)<EOL>cv.CvtColor(histimg_hsv,histimg,cv.CV_HSV2BGR)<EOL>return histimg <EOL><DEDENT>def on_mouse(self,event,x,y,flags,param):<EOL><INDENT>if event==cv.CV_EVENT_LBUTTONDOWN :<EOL><INDENT>self.drag_start=(x,y)<EOL><DEDENT>if event==cv.CV_EVENT_LBUTTONUP :<EOL><INDENT>self.drag_start=None <EOL>self.track_window=self.selection <EOL><DEDENT>if self.drag_start :<EOL><INDENT>xmin=min(x,self.drag_start [])<EOL>ymin=min(y,self.drag_start [])<EOL>xmax=max(x,self.drag_start [])<EOL>ymax=max(y,self.drag_start [])<EOL>self.selection=(xmin,ymin,xmax -xmin,ymax -ymin)<EOL><DEDENT> <DEDENT>def run(self):<EOL><INDENT>hist=cv.CreateHist([],cv.CV_HIST_ARRAY,[(,)],)<EOL>backproject_mode=False <EOL>while True :<EOL><INDENT>frame=cv.QueryFrame(self.capture)<EOL>hsv=cv.CreateImage(cv.GetSize(frame),,)<EOL>cv.CvtColor(frame,hsv,cv.CV_BGR2HSV)<EOL>self.hue=cv.CreateImage(cv.GetSize(frame),,)<EOL>cv.Split(hsv,self.hue,None,None,None)<EOL>backproject=cv.CreateImage(cv.GetSize(frame),,)<EOL>cv.CalcArrBackProject([self.hue ],backproject,hist)<EOL>if self.track_window and is_rect_nonzero(self.track_window):<EOL><INDENT>crit=(cv.CV_TERMCRIT_EPS |cv.CV_TERMCRIT_ITER,,)(iters,(area,value,rect),track_box)=cv.CamShift(backproject,self.track_window,crit)<EOL>self.track_window=rect <EOL><DEDENT>if self.drag_start and is_rect_nonzero(self.selection):<EOL><INDENT>sub=cv.GetSubRect(frame,self.selection)<EOL>save=cv.CloneMat(sub)<EOL>cv.ConvertScale(frame,frame,)<EOL>cv.Copy(save,sub)<EOL>x,y,w,h=self.selection <EOL>cv.Rectangle(frame,(x,y),(x +w,y +h),(,,))<EOL>sel=cv.GetSubRect(self.hue,self.selection)<EOL>cv.CalcArrHist([sel ],hist,)(_,max_val,_,_)=cv.GetMinMaxHistValue(hist)<EOL>if max_val !=:<EOL><INDENT>cv.ConvertScale(hist.bins,hist.bins,/max_val)<EOL><DEDENT> <DEDENT>elif self.track_window and is_rect_nonzero(self.track_window):<EOL><INDENT>cv.EllipseBox(frame,track_box,cv.CV_RGB(,,),,cv.CV_AA,)<EOL><DEDENT>if not backproject_mode :<EOL><INDENT>cv.ShowImage("CamShiftDemo",frame)<EOL><DEDENT>else :<EOL><INDENT>cv.ShowImage("CamShiftDemo",backproject)<EOL><DEDENT>cv.ShowImage("Histogram",self.hue_histogram_as_image(hist))<EOL>c=cv.WaitKey()%<EOL>if c==:<EOL><INDENT>break <EOL><DEDENT>elif c==ord("b"):<EOL><INDENT>backproject_mode=not backproject_mode <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>if __name__=="__main__":<EOL><INDENT>demo=CamShiftDemo()<EOL>demo.run()<EOL>cv.DestroyAllWindows()<EOL><DEDENT><EOF><BOF>import logging <EOL>import threading <EOL>from zerotest.record.formatter import Formatter <EOL>from zerotest.utils.queue_helper import Queue,Empty <EOL>LOG=logging.getLogger(__name__)<EOL>class HTTPRecorder(object):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,filepath):<EOL><INDENT> '<STR_LIT>'<EOL>self.filepath=filepath <EOL>self._running=False <EOL>self._closing=False <EOL>self._service_thread=None <EOL>self._queue=Queue()<EOL>self._formatter=Formatter()<EOL><DEDENT>def start_service(self):<EOL><INDENT> '<STR_LIT>'<EOL>self._service_thread=threading.Thread(target=self._loop_work)<EOL>self._running=True <EOL>LOG.info('<STR_LIT>'.format(self.filepath))<EOL>self._service_thread.start()<EOL><DEDENT>def _loop_work(self):<EOL><INDENT>import codecs <EOL>with codecs.open(self.filepath,'a+','utf-8')as record_file :<EOL><INDENT>while True :<EOL><INDENT>task=self._queue.get()<EOL>LOG.debug("receive task %s",task)<EOL>if task is None :<EOL><INDENT>record_file.close()<EOL>return <EOL><DEDENT>self._formatter.write_record(record_file,task [],task [])<EOL>record_file.flush()<EOL>LOG.debug("writen task %s",task)<EOL><DEDENT> <DEDENT> <DEDENT>def record_http(self,request,response):<EOL><INDENT> '<STR_LIT>'<EOL>if not self._closing :<EOL><INDENT>LOG.debug('<STR_LIT>',request,response)<EOL>self._queue.put((request,response))<EOL><DEDENT> <DEDENT>def close(self):<EOL><INDENT> '<STR_LIT>'<EOL>if self._running :<EOL><INDENT>LOG.debug("closing...")<EOL>self._closing=True <EOL>self._queue.put(None)<EOL>LOG.debug('<STR_LIT>')<EOL>self._service_thread.join()<EOL><DEDENT>else :<EOL><INDENT>raise RuntimeError('<STR_LIT>')<EOL><DEDENT>LOG.info('<STR_LIT>'.format(self.filepath))<EOL><DEDENT>def shutdown(self):<EOL><INDENT> '<STR_LIT>'<EOL>LOG.debug("shutdown...")<EOL>self._closing=True <EOL>try :<EOL><INDENT>while True :<EOL><INDENT>self._queue.get_nowait()<EOL><DEDENT> <DEDENT>except Empty :<EOL><INDENT>pass <EOL><DEDENT>self.close()<EOL><DEDENT> <DEDENT><EOF><BOF>import re <EOL>INVALID_METHOD_R=re.compile(r'[^a-zA-Z0-9_]')<EOL>MULTI_UNDERSCORE_R=re.compile(r'[_]+')<EOL>def get_name_from_request(request):<EOL><INDENT>return '{}_{}'.format(<EOL>request.method.lower(),<EOL>_path_to_func_name(request.path))<EOL><DEDENT>def _path_to_func_name(path):<EOL><INDENT> '<STR_LIT>'<EOL>if path=='/':<EOL><INDENT>return 'root'<EOL><DEDENT>return MULTI_UNDERSCORE_R.sub(<EOL>'_',<EOL>INVALID_METHOD_R.sub(<EOL>'_',<EOL>path )).strip('_')<EOL><DEDENT>def dict_to_param_style_code(d):<EOL><INDENT>return ', '.join('{0}={1}'.format(k,repr(v))for k,v in d.items())<EOL><DEDENT><EOF><BOF>import hashlib <EOL>import hmac <EOL>import json <EOL>from django.contrib.auth import get_user_model <EOL>from django.contrib.auth.models import AnonymousUser <EOL>from django.core.urlresolvers import reverse <EOL>from django.http import HttpRequest,HttpResponse <EOL>from django.test import TestCase,override_settings <EOL>from buildservice.models import Repository <EOL>from buildservice.utils import decorators <EOL>from buildservice.utils.testing import create_user_token <EOL>def view(request):<EOL><INDENT>return HttpResponse(str(request))<EOL><DEDENT>view_token=decorators.oauth_token_required(view)<EOL>view_signature=decorators.signature_required(view)<EOL>view_anonymous=decorators.anonymous_user_required(view)<EOL>view_json=decorators.require_json(view)<EOL>view_api_key=decorators.require_api_key(view)<EOL>@override_settings(GITHUB_HOOK_SECRET='ssssecret',BUILDSERVICE_API_KEY='Key')<EOL>class DecoratorsTestCase(TestCase):<EOL><INDENT>def setUp(self):<EOL><INDENT>self.user=get_user_model().objects.create_user(username='vvv',password='ttt')<EOL><DEDENT>def test_oauth_token_required_anonymous(self):<EOL><INDENT>req=HttpRequest()<EOL>req.user=AnonymousUser()<EOL>resp=view_token(req)<EOL>self.assertEqual(resp.status_code,)<EOL>self.assertEqual(resp.url,reverse('oauth_login'))<EOL><DEDENT>def test_oauth_token_required_no_token(self):<EOL><INDENT>req=HttpRequest()<EOL>req.user=self.user <EOL>resp=view_token(req)<EOL>self.assertEqual(resp.status_code,)<EOL>self.assertEqual(resp.url,reverse('oauth_login'))<EOL><DEDENT>def test_oauth_token_required_ok(self):<EOL><INDENT>req=HttpRequest()<EOL>req.user=self.user <EOL>repo=Repository.objects.create(name='some/repo')<EOL>repo.users.add(self.user)<EOL>create_user_token(self.user,repo)<EOL>resp=view_token(req)<EOL>self.assertEqual(resp.status_code,)<EOL><DEDENT>def test_signature_required_missing(self):<EOL><INDENT>req=HttpRequest()<EOL>req._body='hello'<EOL>resp=view_signature(req)<EOL>self.assertEqual(resp.status_code,)<EOL><DEDENT>def test_signature_required_wrong(self):<EOL><INDENT>req=HttpRequest()<EOL>req._body='hello'<EOL>req.META ['<STR_LIT>']='ihowqepqwhe'<EOL>resp=view_signature(req)<EOL>self.assertEqual(resp.status_code,)<EOL><DEDENT>def test_signature_required_ok(self):<EOL><INDENT>signature="sha1=%s"%hmac.new('ssssecret','hello body',hashlib.sha1).hexdigest()<EOL>req=HttpRequest()<EOL>req._body='hello body'<EOL>req.META ['<STR_LIT>']=signature <EOL>resp=view_signature(req)<EOL>self.assertEqual(resp.status_code,)<EOL><DEDENT>def test_anonymous_user_required_authenticated(self):<EOL><INDENT>req=HttpRequest()<EOL>req.user=self.user <EOL>resp=view_anonymous(req)<EOL>self.assertEqual(resp.status_code,)<EOL>self.assertEqual(resp.url,'/')<EOL><DEDENT>def test_anonymous_user_required_ok(self):<EOL><INDENT>req=HttpRequest()<EOL>req.user=AnonymousUser()<EOL>resp=view_anonymous(req)<EOL>self.assertEqual(resp.status_code,)<EOL><DEDENT>def test_require_json_no_json(self):<EOL><INDENT>req=HttpRequest()<EOL>req._body='yo'<EOL>resp=view_json(req)<EOL>self.assertEqual(resp.status_code,)<EOL>self.assertEqual(json.loads(resp.content),{'error':'<STR_LIT>'})<EOL><DEDENT>def test_require_json_strange_body(self):<EOL><INDENT>req=HttpRequest()<EOL>req._body={'youhou'}<EOL>resp=view_json(req)<EOL>self.assertEqual(resp.status_code,)<EOL>self.assertEqual(json.loads(resp.content),{'error':'<STR_LIT>'})<EOL><DEDENT>def test_require_json_empty(self):<EOL><INDENT>req=HttpRequest()<EOL>req._body=''<EOL>resp=view_json(req)<EOL>self.assertEqual(resp.status_code,)<EOL>self.assertEqual(req.json,{})<EOL><DEDENT>def test_require_json_ok(self):<EOL><INDENT>req=HttpRequest()<EOL>req._body='<STR_LIT>'<EOL>resp=view_json(req)<EOL>self.assertEqual(resp.status_code,)<EOL>self.assertEqual(req.json,{"key":"value"})<EOL><DEDENT>def test_require_api_key_missing(self):<EOL><INDENT>req=HttpRequest()<EOL>resp=view_api_key(req)<EOL>self.assertEqual(resp.status_code,)<EOL><DEDENT>def test_require_api_key_wrong(self):<EOL><INDENT>req=HttpRequest()<EOL>req.GET ['api_key']='oula'<EOL>resp=view_api_key(req)<EOL>self.assertEqual(resp.status_code,)<EOL><DEDENT>def test_require_api_key_ok(self):<EOL><INDENT>req=HttpRequest()<EOL>req.GET ['api_key']='Key'<EOL>resp=view_api_key(req)<EOL>self.assertEqual(resp.status_code,)<EOL><DEDENT> <DEDENT><EOF><BOF>import os <EOL>import sys <EOL>from robot.errors import DataError <EOL>from robot.running import TestLibrary,UserLibrary <EOL>from robot.parsing import disable_curdir_processing <EOL>from robot import utils <EOL>from.model import LibraryDoc,KeywordDoc <EOL>class LibraryDocBuilder(object):<EOL><INDENT>_argument_separator='::'<EOL>def build(self,library):<EOL><INDENT>name,args=self._split_library_name_and_args(library)<EOL>lib=TestLibrary(name,args)<EOL>libdoc=LibraryDoc(name=lib.name,<EOL>doc=self._get_doc(lib),<EOL>version=lib.version,<EOL>scope=lib.scope,<EOL>named_args=lib.supports_named_arguments,<EOL>doc_format=lib.doc_format)<EOL>libdoc.inits=self._get_initializers(lib)<EOL>libdoc.keywords=KeywordDocBuilder().build_keywords(lib)<EOL>return libdoc <EOL><DEDENT>def _split_library_name_and_args(self,library):<EOL><INDENT>args=library.split(self._argument_separator)<EOL>name=args.pop()<EOL>return self._normalize_library_path(name),args <EOL><DEDENT>def _normalize_library_path(self,library):<EOL><INDENT>path=library.replace('/',os.sep)<EOL>if os.path.exists(path):<EOL><INDENT>return os.path.abspath(path)<EOL><DEDENT>return library <EOL><DEDENT>def _get_doc(self,lib):<EOL><INDENT>return lib.doc or '<STR_LIT>'%lib.name <EOL><DEDENT>def _get_initializers(self,lib):<EOL><INDENT>if lib.init.arguments.maxargs :<EOL><INDENT>return [KeywordDocBuilder().build_keyword(lib.init)]<EOL><DEDENT>return []<EOL><DEDENT> <DEDENT>class ResourceDocBuilder(object):<EOL><INDENT>def build(self,path):<EOL><INDENT>res=self._import_resource(path)<EOL>libdoc=LibraryDoc(name=res.name,doc=self._get_doc(res),<EOL>type='resource',named_args=True)<EOL>libdoc.keywords=KeywordDocBuilder().build_keywords(res)<EOL>return libdoc <EOL><DEDENT>@disable_curdir_processing <EOL>def _import_resource(self,path):<EOL><INDENT>return UserLibrary(self._find_resource_file(path))<EOL><DEDENT>def _find_resource_file(self,path):<EOL><INDENT>if os.path.isfile(path):<EOL><INDENT>return path <EOL><DEDENT>for dire in [item for item in sys.path if os.path.isdir(item)]:<EOL><INDENT>if os.path.isfile(os.path.join(dire,path)):<EOL><INDENT>return os.path.join(dire,path)<EOL><DEDENT> <DEDENT>raise DataError('<STR_LIT>'%path)<EOL><DEDENT>def _get_doc(self,res):<EOL><INDENT>doc=res.doc or '<STR_LIT>'%res.name <EOL>return utils.unescape(doc)<EOL><DEDENT> <DEDENT>class KeywordDocBuilder(object):<EOL><INDENT>def build_keywords(self,lib):<EOL><INDENT>return [self.build_keyword(kw)for kw in lib.handlers.values()]<EOL><DEDENT>def build_keyword(self,kw):<EOL><INDENT>return KeywordDoc(name=kw.name,args=self._get_args(kw),doc=kw.doc)<EOL><DEDENT>def _get_args(self,kw):<EOL><INDENT>required,defaults=self._parse_args(kw)<EOL>args=required +['%s=%s'%item for item in defaults ]<EOL>varargs=self._normalize_arg(kw.arguments.varargs,kw.type)<EOL>if varargs :<EOL><INDENT>args.append('*%s'%varargs)<EOL><DEDENT>return args <EOL><DEDENT>def _parse_args(self,kw):<EOL><INDENT>args=[self._normalize_arg(arg,kw.type)for arg in kw.arguments.names ]<EOL>default_count=len(kw.arguments.defaults)<EOL>if not default_count :<EOL><INDENT>return args,[]<EOL><DEDENT>required=args [:-default_count ]<EOL>defaults=zip(args [-default_count :],kw.arguments.defaults)<EOL>return required,defaults <EOL><DEDENT>def _normalize_arg(self,arg,kw_type):<EOL><INDENT>if arg and kw_type=='user':<EOL><INDENT>arg=arg [:-]<EOL><DEDENT>return arg <EOL><DEDENT> <DEDENT><EOF><BOF>USAGE='<STR_LIT>'<EOL>import sys <EOL>import os <EOL>from os.path import abspath,dirname <EOL>import codecs <EOL>import time <EOL>if 'robot'not in sys.modules and __name__=='__main__':<EOL><INDENT>import pythonpathsetter <EOL><DEDENT>from robot import utils <EOL>from robot.running import TestSuite,Keyword <EOL>from robot.conf import RobotSettings <EOL>from robot.parsing import disable_curdir_processing <EOL>from robot.htmldata import HtmlFileWriter,ModelWriter,JsonWriter,TESTDOC <EOL>class TestDoc(utils.Application):<EOL><INDENT>def __init__(self):<EOL><INDENT>utils.Application.__init__(self,USAGE,arg_limits=(,))<EOL><DEDENT>def main(self,args,title=None,**options):<EOL><INDENT>datasources=args [:-]<EOL>outfile=abspath(args [-])<EOL>suite=TestSuiteFactory(datasources,**options)<EOL>self._write_test_doc(suite,outfile,title)<EOL>self.console(outfile)<EOL><DEDENT>def _write_test_doc(self,suite,outfile,title):<EOL><INDENT>output=codecs.open(outfile,'w','UTF-8')<EOL>model_writer=TestdocModelWriter(output,suite,title)<EOL>HtmlFileWriter(output,model_writer).write(TESTDOC)<EOL>output.close()<EOL><DEDENT> <DEDENT>@disable_curdir_processing <EOL>def TestSuiteFactory(datasources,**options):<EOL><INDENT>if isinstance(datasources,basestring):<EOL><INDENT>datasources=[datasources ]<EOL><DEDENT>return TestSuite(datasources,RobotSettings(options))<EOL><DEDENT>class TestdocModelWriter(ModelWriter):<EOL><INDENT>def __init__(self,output,suite,title=None):<EOL><INDENT>self._output=output <EOL>self._output_path=getattr(output,'name',None)<EOL>self._suite=suite <EOL>self._title=title.replace('_',' ')if title else suite.name <EOL><DEDENT>def write(self,line):<EOL><INDENT>self._output.write('<STR_LIT>'+os.linesep)<EOL>self.write_data()<EOL>self._output.write('</script>'+os.linesep)<EOL><DEDENT>def write_data(self):<EOL><INDENT>generated_time=time.localtime()<EOL>model={<EOL>'suite':JsonConverter(self._output_path).convert(self._suite),<EOL>'title':self._title,<EOL>'generated':utils.format_time(generated_time,gmtsep=' '),<EOL>'generatedMillis':long(time.mktime(generated_time)*)<EOL>}<EOL>JsonWriter(self._output).write_json('testdoc= ',model)<EOL><DEDENT> <DEDENT>class JsonConverter(object):<EOL><INDENT>def __init__(self,output_path=None):<EOL><INDENT>self._output_path=output_path <EOL><DEDENT>def convert(self,suite):<EOL><INDENT>return self._convert_suite(suite)<EOL><DEDENT>def _convert_suite(self,suite):<EOL><INDENT>return {<EOL>'source':suite.source or '',<EOL>'relativeSource':self._get_relative_source(suite.source),<EOL>'id':suite.id,<EOL>'name':suite.name,<EOL>'fullName':suite.longname,<EOL>'doc':self._html(suite.doc),<EOL>'metadata':[(n,self._html(v))for n,v in suite.metadata.items()],<EOL>'numberOfTests':suite.get_test_count(),<EOL>'suites':self._convert_suites(suite),<EOL>'tests':self._convert_tests(suite),<EOL>'keywords':list(self._convert_keywords(suite))<EOL>}<EOL><DEDENT>def _get_relative_source(self,source):<EOL><INDENT>if not source or not self._output_path :<EOL><INDENT>return ''<EOL><DEDENT>return utils.get_link_path(source,dirname(self._output_path))<EOL><DEDENT>def _html(self,item):<EOL><INDENT>return utils.html_format(utils.unescape(item))<EOL><DEDENT>def _convert_suites(self,suite):<EOL><INDENT>return [self._convert_suite(s)for s in suite.suites ]<EOL><DEDENT>def _convert_tests(self,suite):<EOL><INDENT>return [self._convert_test(t)for t in suite.tests ]<EOL><DEDENT>def _convert_test(self,test):<EOL><INDENT>return {<EOL>'name':test.name,<EOL>'fullName':test.longname,<EOL>'id':test.id,<EOL>'doc':self._html(test.doc),<EOL>'tags':utils.normalize_tags(test.tags),<EOL>'timeout':self._get_timeout(test.timeout),<EOL>'keywords':list(self._convert_keywords(test))<EOL>}<EOL><DEDENT>def _convert_keywords(self,item):<EOL><INDENT>if item.setup.name :<EOL><INDENT>yield self._convert_keyword(item.setup,type='SETUP')<EOL><DEDENT>for kw in getattr(item,'keywords',[]):<EOL><INDENT>yield self._convert_keyword(kw)<EOL><DEDENT>if item.teardown.name :<EOL><INDENT>yield self._convert_keyword(item.teardown,type='TEARDOWN')<EOL><DEDENT> <DEDENT>def _convert_keyword(self,kw,type=None):<EOL><INDENT>return {<EOL>'name':kw._get_name(kw.name)if isinstance(kw,Keyword)else kw.name,<EOL>'arguments':', '.join(kw.args),<EOL>'type':type or {'kw':'KEYWORD','for':'FOR'}[kw.type ]<EOL>}<EOL><DEDENT>def _get_timeout(self,timeout):<EOL><INDENT>try :<EOL><INDENT>tout=utils.secs_to_timestr(utils.timestr_to_secs(timeout.string))<EOL><DEDENT>except ValueError :<EOL><INDENT>tout=timeout.string <EOL><DEDENT>if timeout.message :<EOL><INDENT>tout +=' :: '+timeout.message <EOL><DEDENT>return tout <EOL><DEDENT> <DEDENT>def testdoc_cli(args):<EOL><INDENT> '<STR_LIT>'<EOL>TestDoc().execute_cli(args)<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>testdoc_cli(sys.argv [:])<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>def format_param(s=''):<EOL><INDENT> '<STR_LIT>'<EOL>return ':%s'%s if s else '?'<EOL><DEDENT>def stringify_bool(b):<EOL><INDENT> '<STR_LIT>'<EOL>return '1'if b else '0'<EOL><DEDENT>import mosql.util <EOL>def patch():<EOL><INDENT> '<STR_LIT>'<EOL>mosql.util.format_param=format_param <EOL>mosql.util.stringify_bool=stringify_bool <EOL><DEDENT>patch()<EOL>if __name__=='__main__':<EOL><INDENT>import doctest <EOL>doctest.testmod()<EOL><DEDENT><EOF><BOF>from..blog.models import Category <EOL>from..blog.forms import TagForm <EOL>from.tag import TagAPI <EOL>class CategoryAPI(TagAPI):<EOL><INDENT>MODEL=Category <EOL><DEDENT><EOF><BOF>from robot.common.statistics import Statistics <EOL>from.listeners import Listeners <EOL>from.logger import LOGGER <EOL>from.loggerhelper import AbstractLogger <EOL>from.debugfile import DebugFile <EOL>from.xmllogger import XmlLogger <EOL>class Output(AbstractLogger):<EOL><INDENT>def __init__(self,settings):<EOL><INDENT>AbstractLogger.__init__(self)<EOL>self._xmllogger=XmlLogger(settings ['Output'],settings ['LogLevel'])<EOL>self._register_loggers(settings ['Listeners'],settings ['DebugFile'])<EOL>self._settings=settings <EOL><DEDENT>def _register_loggers(self,listeners,debugfile):<EOL><INDENT>LOGGER.register_context_changing_logger(self._xmllogger)<EOL>for logger in Listeners(listeners),DebugFile(debugfile):<EOL><INDENT>if logger :LOGGER.register_logger(logger)<EOL><DEDENT>LOGGER.disable_message_cache()<EOL><DEDENT>def close(self,suite):<EOL><INDENT>stats=Statistics(suite,self._settings ['SuiteStatLevel'],<EOL>self._settings ['TagStatInclude'],<EOL>self._settings ['TagStatExclude'],<EOL>self._settings ['TagStatCombine'],<EOL>self._settings ['TagDoc'],<EOL>self._settings ['TagStatLink'])<EOL>stats.serialize(self._xmllogger)<EOL>self._xmllogger.close()<EOL>LOGGER.unregister_logger(self._xmllogger)<EOL>LOGGER.output_file('Output',self._settings ['Output'])<EOL><DEDENT>def start_suite(self,suite):<EOL><INDENT>LOGGER.start_suite(suite)<EOL><DEDENT>def end_suite(self,suite):<EOL><INDENT>LOGGER.end_suite(suite)<EOL><DEDENT>def start_test(self,test):<EOL><INDENT>LOGGER.start_test(test)<EOL><DEDENT>def end_test(self,test):<EOL><INDENT>LOGGER.end_test(test)<EOL><DEDENT>def start_keyword(self,kw):<EOL><INDENT>LOGGER.start_keyword(kw)<EOL><DEDENT>def end_keyword(self,kw):<EOL><INDENT>LOGGER.end_keyword(kw)<EOL><DEDENT>def message(self,msg):<EOL><INDENT>LOGGER.log_message(msg)<EOL><DEDENT>def set_log_level(self,level):<EOL><INDENT>from.pyloggingconf import set_level <EOL>set_level(level)<EOL>return self._xmllogger.set_log_level(level)<EOL><DEDENT> <DEDENT><EOF><BOF>from __future__ import unicode_literals <EOL>from django.conf import settings <EOL>from django.db import migrations,models <EOL>import django.db.models.deletion <EOL>class Migration(migrations.Migration):<EOL><INDENT>initial=True <EOL>dependencies=[<EOL>migrations.swappable_dependency(settings.AUTH_USER_MODEL),<EOL>]<EOL>operations=[<EOL>migrations.CreateModel(<EOL>name='OAuthToken',<EOL>fields=[('id',models.AutoField(auto_created=True,primary_key=True,serialize=False,verbose_name='ID')),('created_at',models.DateTimeField(auto_now_add=True)),('updated_at',models.DateTimeField(auto_now=True)),('user',models.OneToOneField(on_delete=django.db.models.deletion.CASCADE,to=settings.AUTH_USER_MODEL)),<EOL>],),<EOL>migrations.CreateModel(<EOL>name='Webhook',<EOL>fields=[('id',models.AutoField(auto_created=True,primary_key=True,serialize=False,verbose_name='ID')),('repository',models.CharField(max_length=)),('active',models.BooleanField(default=True)),('created_at',models.DateTimeField(auto_now_add=True)),('updated_at',models.DateTimeField(auto_now=True)),('user',models.ForeignKey(on_delete=django.db.models.deletion.CASCADE,to=settings.AUTH_USER_MODEL)),<EOL>],),<EOL>]<EOL><DEDENT><EOF><BOF>class Setting(object):<EOL><INDENT>def __init__(self,setting_name,parent=None,comment=None,linenumber=None):<EOL><INDENT>self.setting_name=setting_name <EOL>self.parent=parent <EOL>self._set_initial_value()<EOL>self._set_comment(comment)<EOL>self.linenumber=linenumber <EOL><DEDENT>def _set_initial_value(self):<EOL><INDENT>self.value=[]<EOL><DEDENT>def _set_comment(self,comment):<EOL><INDENT>self.comment=Comment(comment)<EOL><DEDENT>def reset(self):<EOL><INDENT>self.__init__(self.setting_name,self.parent)<EOL><DEDENT>@property <EOL>def source(self):<EOL><INDENT>return self.parent.source if self.parent is not None else None <EOL><DEDENT>@property <EOL>def directory(self):<EOL><INDENT>return self.parent.directory if self.parent is not None else None <EOL><DEDENT>def populate(self,value,comment=None,linenumber=None):<EOL><INDENT> '<STR_LIT>'<EOL>self.linenumber=linenumber <EOL>self._populate(value)<EOL>self._set_comment(comment)<EOL><DEDENT>def _populate(self,value):<EOL><INDENT>self.value=value <EOL><DEDENT>def is_set(self):<EOL><INDENT>return bool(self.value)<EOL><DEDENT>def is_for_loop(self):<EOL><INDENT>return False <EOL><DEDENT>def report_invalid_syntax(self,message,level='ERROR'):<EOL><INDENT>self.parent.report_invalid_syntax(message,level)<EOL><DEDENT>def _string_value(self,value):<EOL><INDENT>return value if isinstance(value,basestring)else ' '.join(value)<EOL><DEDENT>def _concat_string_with_value(self,string,value):<EOL><INDENT>if string :<EOL><INDENT>return string +' '+self._string_value(value)<EOL><DEDENT>return self._string_value(value)<EOL><DEDENT>def as_list(self):<EOL><INDENT>return self._data_as_list()+self.comment.as_list()<EOL><DEDENT>def _data_as_list(self):<EOL><INDENT>ret=[self.setting_name ]<EOL>if self.value :<EOL><INDENT>ret.extend(self.value)<EOL><DEDENT>return ret <EOL><DEDENT>def __nonzero__(self):<EOL><INDENT>return self.is_set()<EOL><DEDENT> <DEDENT>class StringValueJoiner(object):<EOL><INDENT>def __init__(self,separator):<EOL><INDENT>self._separator=separator <EOL><DEDENT>def join_string_with_value(self,string,value):<EOL><INDENT>if string :<EOL><INDENT>return string +self._separator +self.string_value(value)<EOL><DEDENT>return self.string_value(value)<EOL><DEDENT>def string_value(self,value):<EOL><INDENT>if isinstance(value,basestring):<EOL><INDENT>return value <EOL><DEDENT>return self._separator.join(value)<EOL><DEDENT> <DEDENT>class Documentation(Setting):<EOL><INDENT>def _set_initial_value(self):<EOL><INDENT>self.value=''<EOL><DEDENT>def _populate(self,value):<EOL><INDENT>self.value=self._concat_string_with_value(self.value,value)<EOL><DEDENT>def _string_value(self,value):<EOL><INDENT>return value if isinstance(value,basestring)else ''.join(value)<EOL><DEDENT>def _data_as_list(self):<EOL><INDENT>return [self.setting_name,self.value ]<EOL><DEDENT> <DEDENT>class Template(Setting):<EOL><INDENT>def _set_initial_value(self):<EOL><INDENT>self.value=None <EOL><DEDENT>def _populate(self,value):<EOL><INDENT>self.value=self._concat_string_with_value(self.value,value)<EOL><DEDENT>def is_set(self):<EOL><INDENT>return self.value is not None <EOL><DEDENT>def _data_as_list(self):<EOL><INDENT>ret=[self.setting_name ]<EOL>if self.value :<EOL><INDENT>ret.append(self.value)<EOL><DEDENT>return ret <EOL><DEDENT> <DEDENT>class Fixture(Setting):<EOL><INDENT>def _set_initial_value(self):<EOL><INDENT>self.name=None <EOL>self.args=[]<EOL><DEDENT>def _populate(self,value):<EOL><INDENT>if not self.name :<EOL><INDENT>self.name=value []if value else ''<EOL>value=value [:]<EOL><DEDENT>self.args.extend(value)<EOL><DEDENT>def is_set(self):<EOL><INDENT>return self.name is not None <EOL><DEDENT>def _data_as_list(self):<EOL><INDENT>ret=[self.setting_name ]<EOL>if self.name or self.args :<EOL><INDENT>ret.append(self.name or '')<EOL><DEDENT>if self.args :<EOL><INDENT>ret.extend(self.args)<EOL><DEDENT>return ret <EOL><DEDENT> <DEDENT>class Timeout(Setting):<EOL><INDENT>def _set_initial_value(self):<EOL><INDENT>self.value=None <EOL>self.message=''<EOL><DEDENT>def _populate(self,value):<EOL><INDENT>if not self.value :<EOL><INDENT>self.value=value []if value else ''<EOL>value=value [:]<EOL><DEDENT>self.message=self._concat_string_with_value(self.message,value)<EOL><DEDENT>def is_set(self):<EOL><INDENT>return self.value is not None <EOL><DEDENT>def _data_as_list(self):<EOL><INDENT>ret=[self.setting_name ]<EOL>if self.value or self.message :<EOL><INDENT>ret.append(self.value or '')<EOL><DEDENT>if self.message :<EOL><INDENT>ret.append(self.message)<EOL><DEDENT>return ret <EOL><DEDENT> <DEDENT>class Tags(Setting):<EOL><INDENT>def _set_initial_value(self):<EOL><INDENT>self.value=None <EOL><DEDENT>def _populate(self,value):<EOL><INDENT>self.value=(self.value or [])+value <EOL><DEDENT>def is_set(self):<EOL><INDENT>return self.value is not None <EOL><DEDENT>def __add__(self,other):<EOL><INDENT>if not isinstance(other,Tags):<EOL><INDENT>raise TypeError('<STR_LIT>')<EOL><DEDENT>tags=Tags('Tags')<EOL>tags.value=(self.value or [])+(other.value or [])<EOL>return tags <EOL><DEDENT> <DEDENT>class Arguments(Setting):<EOL><INDENT>pass <EOL><DEDENT>class Return(Setting):<EOL><INDENT>pass <EOL><DEDENT>class Metadata(Setting):<EOL><INDENT>setting_name='Metadata'<EOL>def __init__(self,parent,name,value,comment=None,joined=False,linenumber=None):<EOL><INDENT>self.parent=parent <EOL>self.name=name <EOL>joiner=StringValueJoiner(''if joined else ' ')<EOL>self.value=joiner.join_string_with_value('',value)<EOL>self._set_comment(comment)<EOL>self.linenumber=linenumber <EOL><DEDENT>def reset(self):<EOL><INDENT>pass <EOL><DEDENT>def is_set(self):<EOL><INDENT>return True <EOL><DEDENT>def _data_as_list(self):<EOL><INDENT>return [self.setting_name,self.name,self.value ]<EOL><DEDENT> <DEDENT>class _Import(Setting):<EOL><INDENT>def __init__(self,parent,name,args=None,alias=None,comment=None):<EOL><INDENT>self.parent=parent <EOL>self.name=name <EOL>self.args=args or []<EOL>self.alias=alias <EOL>self._set_comment(comment)<EOL><DEDENT>def reset(self):<EOL><INDENT>pass <EOL><DEDENT>@property <EOL>def type(self):<EOL><INDENT>return type(self).__name__ <EOL><DEDENT>def is_set(self):<EOL><INDENT>return True <EOL><DEDENT>def _data_as_list(self):<EOL><INDENT>return [self.type,self.name ]+self.args <EOL><DEDENT> <DEDENT>class Library(_Import):<EOL><INDENT>def __init__(self,parent,name,args=None,alias=None,comment=None):<EOL><INDENT>if args and not alias :<EOL><INDENT>args,alias=self._split_alias(args)<EOL><DEDENT>_Import.__init__(self,parent,name,args,alias,comment)<EOL><DEDENT>def _split_alias(self,args):<EOL><INDENT>if len(args)>=and isinstance(args [-],basestring)and args [-].upper()=='WITH NAME':<EOL><INDENT>return args [:-],args [-]<EOL><DEDENT>return args,None <EOL><DEDENT>def _data_as_list(self):<EOL><INDENT>alias=['WITH NAME',self.alias ]if self.alias else []<EOL>return ['Library',self.name ]+self.args +alias <EOL><DEDENT> <DEDENT>class Resource(_Import):<EOL><INDENT>def __init__(self,parent,name,invalid_args=None,comment=None):<EOL><INDENT>if invalid_args :<EOL><INDENT>name +=' '+' '.join(invalid_args)<EOL><DEDENT>_Import.__init__(self,parent,name,comment=comment)<EOL><DEDENT> <DEDENT>class Variables(_Import):<EOL><INDENT>def __init__(self,parent,name,args=None,comment=None):<EOL><INDENT>_Import.__init__(self,parent,name,args,comment=comment)<EOL><DEDENT> <DEDENT>class Comment(object):<EOL><INDENT>def __init__(self,comment_data):<EOL><INDENT>if isinstance(comment_data,basestring):<EOL><INDENT>comment_data=[comment_data ]if comment_data else []<EOL><DEDENT>self._comment=comment_data or []<EOL><DEDENT>def __len__(self):<EOL><INDENT>return len(self._comment)<EOL><DEDENT>def as_list(self):<EOL><INDENT>if self._has_comment():<EOL><INDENT>self._comment []='# '+self._comment []<EOL><DEDENT>return self._comment <EOL><DEDENT>def _has_comment(self):<EOL><INDENT>return self._comment and self._comment []and self._comment [][]!='#'<EOL><DEDENT> <DEDENT>class _DataList(object):<EOL><INDENT>def __init__(self,parent):<EOL><INDENT>self._parent=parent <EOL>self.data=[]<EOL><DEDENT>def add(self,meta):<EOL><INDENT>self._add(meta)<EOL><DEDENT>def _add(self,meta):<EOL><INDENT>self.data.append(meta)<EOL><DEDENT>def _parse_name_and_value(self,value):<EOL><INDENT>name=value []if value else ''<EOL>return name,value [:]<EOL><DEDENT>def __getitem__(self,index):<EOL><INDENT>return self.data [index ]<EOL><DEDENT>def __setitem__(self,index,item):<EOL><INDENT>self.data [index ]=item <EOL><DEDENT>def __len__(self):<EOL><INDENT>return len(self.data)<EOL><DEDENT> <DEDENT>class ImportList(_DataList):<EOL><INDENT>def populate_library(self,data,comment,linenumber=None):<EOL><INDENT>self._populate(Library,data,comment)<EOL><DEDENT>def populate_resource(self,data,comment,linenumber=None):<EOL><INDENT>self._populate(Resource,data,comment)<EOL><DEDENT>def populate_variables(self,data,comment,linenumber=None):<EOL><INDENT>self._populate(Variables,data,comment)<EOL><DEDENT>def _populate(self,item_class,data,comment):<EOL><INDENT>name,value=self._parse_name_and_value(data)<EOL>self._add(item_class(self._parent,name,value,comment=comment))<EOL><DEDENT> <DEDENT>class MetadataList(_DataList):<EOL><INDENT>def populate(self,name,value,comment,linenumber=None):<EOL><INDENT>self._add(Metadata(self._parent,name,value,comment,joined=True,linenumber=linenumber))<DEDENT> <DEDENT><EOF><BOF>import examples <EOL>from optparse import OptionParser <EOL>if __name__=="__main__":<EOL><INDENT>op=OptionParser()<EOL>op.add_option("-e","--example",dest="example",help='<STR_LIT>',metavar="EXAMPLE")(opt,args)=op.parse_args()<EOL>if opt.example :<EOL><INDENT>er=examples.ExampleRunner()<EOL>er.example=er.example_from_string(opt.example)<EOL>er.main_loop()<EOL><DEDENT>else :<EOL><INDENT>print('<STR_LIT>')<EOL>for example in examples.Example.__subclasses__():<EOL><INDENT>mod=example.__module__.replace("examples.","")<EOL>print("{0}.{1}\t- {2}".format(mod,example.__name__,example.__doc__.split("\n")[]))<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>from pyspark import SparkConf,SparkContext <EOL>from pyspark.sql import SQLContext,Row <EOL>from pyspark.sql.types import *<EOL>def parsePoint(l):<EOL><INDENT>return [float(x)for x in l.split(';')]<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>conf=SparkConf().setAppName("SparkSQL")<EOL>sc=SparkContext(conf=conf)<EOL>sqlCtx=SQLContext(sc)<EOL>red_wines=sc.textFile('<STR_LIT>')<EOL>red_wines_data=red_wines.zipWithIndex().filter(lambda s :s []>).map(lambda s :s [])<EOL>schemaString='<STR_LIT>'<EOL>fields=[StructField(field_name,StringType(),True)for field_name in schemaString.split()]<EOL>schema=StructType(fields)<EOL>red_wines_df=sqlCtx.createDataFrame(red_wines_data.map(parsePoint),schema)<EOL>print('<STR_LIT>')<EOL>red_wines_df.show()<EOL>print('<STR_LIT>')<EOL>red_wines_df.select("fixed_acidity").show()<EOL>print('<STR_LIT>')<EOL>red_wines_df.groupBy("free_sulfur").count().orderBy("free_sulfur").show()<EOL>red_wines_df.registerTempTable("wine_table")<EOL>print('<STR_LIT>')<EOL>sqlCtx.sql('<STR_LIT>').show()<DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>ply_header='<STR_LIT>'<EOL>def write_ply(fn,verts,colors):<EOL><INDENT>verts=verts.reshape(-,)<EOL>colors=colors.reshape(-,)<EOL>verts=np.hstack([verts,colors ])<EOL>with open(fn,'w')as f :<EOL><INDENT>f.write(ply_header %dict(vert_num=len(verts)))<EOL>np.savetxt(f,verts,'<STR_LIT>')<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>print '<STR_LIT>'<EOL>imgL=cv2.pyrDown(cv2.imread('<STR_LIT>'))<EOL>imgR=cv2.pyrDown(cv2.imread('<STR_LIT>'))<EOL>window_size=<EOL>min_disp=<EOL>num_disp=-min_disp <EOL>stereo=cv2.StereoSGBM(minDisparity=min_disp,<EOL>numDisparities=num_disp,<EOL>SADWindowSize=window_size,<EOL>uniquenessRatio=,<EOL>speckleWindowSize=,<EOL>speckleRange=,<EOL>disp12MaxDiff=,<EOL>P1=**window_size **,<EOL>P2=**window_size **,<EOL>fullDP=False )<EOL>print '<STR_LIT>'<EOL>disp=stereo.compute(imgL,imgR).astype(np.float32)/<EOL>print '<STR_LIT>',<EOL>h,w=imgL.shape [:]<EOL>f=*w <EOL>Q=np.float32([[,,,-*w ],<EOL>[,-,,*h ],<EOL>[,,,-f ],<EOL>[,,,]])<EOL>points=cv2.reprojectImageTo3D(disp,Q)<EOL>colors=cv2.cvtColor(imgL,cv2.COLOR_BGR2RGB)<EOL>mask=disp >disp.min()<EOL>out_points=points [mask ]<EOL>out_colors=colors [mask ]<EOL>out_fn='out.ply'<EOL>write_ply('out.ply',out_points,out_colors)<EOL>print '%s saved'%'out.ply'<EOL>cv2.imshow('left',imgL)<EOL>cv2.imshow('disparity',(disp -min_disp)/num_disp)<EOL>cv2.waitKey()<EOL>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import video <EOL>if __name__=='__main__':<EOL><INDENT>import sys <EOL>try :video_src=sys.argv []<EOL>except :video_src=<EOL>cam=video.create_capture(video_src)<EOL>mser=cv2.MSER()<EOL>while True :<EOL><INDENT>ret,img=cam.read()<EOL>gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)<EOL>vis=img.copy()<EOL>regions=mser.detect(gray,None)<EOL>hulls=[cv2.convexHull(p.reshape(-,,))for p in regions ]<EOL>cv2.polylines(vis,hulls,,(,,))<EOL>cv2.imshow('img',vis)<EOL>if &cv2.waitKey()==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>from common import nothing <EOL>def blur_edge(img,d=):<EOL><INDENT>h,w=img.shape [:]<EOL>img_pad=cv2.copyMakeBorder(img,d,d,d,d,cv2.BORDER_WRAP)<EOL>img_blur=cv2.GaussianBlur(img_pad,(*d +,*d +),-)[d :-d,d :-d ]<EOL>y,x=np.indices((h,w))<EOL>dist=np.dstack([x,w -x -,y,h -y -]).min(-)<EOL>w=np.minimum(np.float32(dist)/d,)<EOL>return img *w +img_blur *(-w)<EOL><DEDENT>def motion_kernel(angle,d,sz=):<EOL><INDENT>kern=np.ones((,d),np.float32)<EOL>c,s=np.cos(angle),np.sin(angle)<EOL>A=np.float32([[c,-s,],[s,c,]])<EOL>sz2=sz //<EOL>A [:,]=(sz2,sz2)-np.dot(A [:,:],((d -)*,))<EOL>kern=cv2.warpAffine(kern,A,(sz,sz),flags=cv2.INTER_CUBIC)<EOL>return kern <EOL><DEDENT>def defocus_kernel(d,sz=):<EOL><INDENT>kern=np.zeros((sz,sz),np.uint8)<EOL>cv2.circle(kern,(sz,sz),d,,-,cv2.LINE_AA,shift=)<EOL>kern=np.float32(kern)/<EOL>return kern <EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>import sys,getopt <EOL>opts,args=getopt.getopt(sys.argv [:],'',['circle','angle=','d=','snr='])<EOL>opts=dict(opts)<EOL>try :<EOL><INDENT>fn=args []<EOL><DEDENT>except :<EOL><INDENT>fn='<STR_LIT>'<EOL><DEDENT>win='deconvolution'<EOL>img=cv2.imread(fn,)<EOL>if img is None :<EOL><INDENT>print '<STR_LIT>',fn1 <EOL>sys.exit()<EOL><DEDENT>img=np.float32(img)/<EOL>cv2.imshow('input',img)<EOL>img=blur_edge(img)<EOL>IMG=cv2.dft(img,flags=cv2.DFT_COMPLEX_OUTPUT)<EOL>defocus='--circle'in opts <EOL>def update(_):<EOL><INDENT>ang=np.deg2rad(cv2.getTrackbarPos('angle',win))<EOL>d=cv2.getTrackbarPos('d',win)<EOL>noise=**(-*cv2.getTrackbarPos('SNR(db)',win))<EOL>if defocus :<EOL><INDENT>psf=defocus_kernel(d)<EOL><DEDENT>else :<EOL><INDENT>psf=motion_kernel(ang,d)<EOL><DEDENT>cv2.imshow('psf',psf)<EOL>psf /=psf.sum()<EOL>psf_pad=np.zeros_like(img)<EOL>kh,kw=psf.shape <EOL>psf_pad [:kh,:kw ]=psf <EOL>PSF=cv2.dft(psf_pad,flags=cv2.DFT_COMPLEX_OUTPUT,nonzeroRows=kh)<EOL>PSF2=(PSF **).sum(-)<EOL>iPSF=PSF /(PSF2 +noise)[...,np.newaxis ]<EOL>RES=cv2.mulSpectrums(IMG,iPSF,)<EOL>res=cv2.idft(RES,flags=cv2.DFT_SCALE |cv2.DFT_REAL_OUTPUT)<EOL>res=np.roll(res,-kh //,)<EOL>res=np.roll(res,-kw //,)<EOL>cv2.imshow(win,res)<EOL><DEDENT>cv2.namedWindow(win)<EOL>cv2.namedWindow('psf',)<EOL>cv2.createTrackbar('angle',win,int(opts.get('--angle',)),,update)<EOL>cv2.createTrackbar('d',win,int(opts.get('--d',)),,update)<EOL>cv2.createTrackbar('SNR(db)',win,int(opts.get('--snr',)),,update)<EOL>update(None)<EOL>while True :<EOL><INDENT>ch=cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT>if ch==ord(' '):<EOL><INDENT>defocus=not defocus <EOL>update(None)<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>import psycopg2 <EOL>from mosql.util import star <EOL>from mosql.query import insert <EOL>from mosql.db import Database,one_to_dict <EOL>dave={<EOL>'person_id':'dave',<EOL>'name':'Dave',<EOL>}<EOL>db=Database(psycopg2,host='127.0.0.1')<EOL>with db as cur :<EOL><INDENT>cur.execute(insert('person',dave,returning=star))<EOL>print one_to_dict(cur)<EOL>print <EOL>assert,'Rollback!'<EOL><DEDENT><EOF><BOF>from robot.errors import DataError <EOL>class BaseLibrary :<EOL><INDENT>def get_handler(self,name):<EOL><INDENT>try :<EOL><INDENT>return self.handlers [name ]<EOL><DEDENT>except KeyError :<EOL><INDENT>raise DataError('<STR_LIT>'%name)<EOL><DEDENT> <DEDENT>def has_handler(self,name):<EOL><INDENT>return self.handlers.has_key(name)<EOL><DEDENT>def __len__(self):<EOL><INDENT>return len(self.handlers)<EOL><DEDENT> <DEDENT><EOF><BOF>import itertools <EOL>class RowSplitter(object):<EOL><INDENT>_comment_mark='#'<EOL>_empty_cell_escape='${EMPTY}'<EOL>_line_continuation='...'<EOL>def __init__(self,cols=):<EOL><INDENT>self._cols=cols <EOL><DEDENT>def split(self,row,indented_table=False):<EOL><INDENT>if not row :<EOL><INDENT>return [[]]<EOL><DEDENT>return self._split_to_rows(row,indented_table)<EOL><DEDENT>def _split_to_rows(self,data,indented_table):<EOL><INDENT>indent=len(list(itertools.takewhile(lambda x :x=='',data)))<EOL>if indented_table :<EOL><INDENT>indent=max(indent,)<EOL><DEDENT>rows=[]<EOL>while data :<EOL><INDENT>current,data=self._split(data)<EOL>rows.append(self._escape_last_empty_cell(current))<EOL>if data and indent +<self._cols :<EOL><INDENT>data=self._indent(data,indent)<EOL><DEDENT> <DEDENT>return rows <EOL><DEDENT>def _split(self,data):<EOL><INDENT>row,rest=data [:self._cols ],data [self._cols :]<EOL>self._in_comment=any(c for c in row if c.startswith(self._comment_mark))<EOL>rest=self._add_line_continuation(rest)<EOL>return row,rest <EOL><DEDENT>def _escape_last_empty_cell(self,row):<EOL><INDENT>if not row [-].strip():<EOL><INDENT>row [-]=self._empty_cell_escape <EOL><DEDENT>return row <EOL><DEDENT>def _add_line_continuation(self,data):<EOL><INDENT>if data :<EOL><INDENT>if self._in_comment :<EOL><INDENT>data []=self._comment_mark +data []<EOL><DEDENT>data=[self._line_continuation ]+data <EOL><DEDENT>return data <EOL><DEDENT>def _indent(self,row,indent):<EOL><INDENT>return ['']*indent +row <EOL><DEDENT> <DEDENT><EOF><BOF>from setuptools import find_packages,setup <EOL>setup(<EOL>name='<STR_LIT>',<EOL>version="",<EOL>description='<STR_LIT>',<EOL>author="Chad Birch",<EOL>author_email='<STR_LIT>',<EOL>platforms=["any"],<EOL>license="MIT",<EOL>url='<STR_LIT>',<EOL>packages=find_packages(),<EOL>install_requires=[i.strip()for i in open('<STR_LIT>').readlines()],)<EOF><BOF>from __future__ import print_function <EOL>_DEFAULT_LINE_NOTIFY_FORMAT='{:=^120}'<EOL>def print_line_notify(msg):<EOL><INDENT>print(_DEFAULT_LINE_NOTIFY_FORMAT.format(" {} ".format(msg)))<EOL><DEDENT><EOF><BOF>from robot.errors import DataError <EOL>from robot import utils <EOL>from.model import LibraryDoc,KeywordDoc <EOL>class JavaDocBuilder(object):<EOL><INDENT>def build(self,path):<EOL><INDENT>doc=ClassDoc(path)<EOL>libdoc=LibraryDoc(name=doc.qualifiedName(),<EOL>doc=self._get_doc(doc),<EOL>version=self._get_version(doc),<EOL>scope=self._get_scope(doc),<EOL>doc_format=self._get_doc_format(doc))<EOL>libdoc.keywords=self._keywords(doc)<EOL>libdoc.inits=self._intializers(doc)<EOL>return libdoc <EOL><DEDENT>def _get_doc(self,doc):<EOL><INDENT>text=doc.getRawCommentText()<EOL>return '\n'.join(line.strip()for line in text.splitlines())<EOL><DEDENT>def _get_version(self,doc):<EOL><INDENT>return self._get_attr(doc,'VERSION')<EOL><DEDENT>def _get_scope(self,doc):<EOL><INDENT>return self._get_attr(doc,'SCOPE',default='TESTCASE',upper=True)<EOL><DEDENT>def _get_doc_format(self,doc):<EOL><INDENT>return self._get_attr(doc,'DOC_FORMAT',upper=True)<EOL><DEDENT>def _get_attr(self,doc,name,default='',upper=False):<EOL><INDENT>name='ROBOT_LIBRARY_'+name <EOL>for field in doc.fields():<EOL><INDENT>if field.name()==name and field.isPublic():<EOL><INDENT>value=field.constantValue()<EOL>if upper :<EOL><INDENT>value=utils.normalize(value,ignore='_').upper()<EOL><DEDENT>return value <EOL><DEDENT> <DEDENT>return default <EOL><DEDENT>def _keywords(self,doc):<EOL><INDENT>return [self._keyword_doc(m)for m in doc.methods()]<EOL><DEDENT>def _keyword_doc(self,method):<EOL><INDENT>return KeywordDoc(<EOL>name=utils.printable_name(method.name(),code_style=True),<EOL>args=list(self._yield_keyword_arguments(method)),<EOL>doc=self._get_doc(method))<EOL><DEDENT>def _yield_keyword_arguments(self,method):<EOL><INDENT>for param in method.parameters():<EOL><INDENT>name=param.name()<EOL>if param.type().dimension()=='[]':<EOL><INDENT>name='*'+name <EOL><DEDENT>yield name <EOL><DEDENT> <DEDENT>def _intializers(self,doc):<EOL><INDENT>inits=[self._keyword_doc(init)for init in doc.constructors()]<EOL>if len(inits)==and not inits [].args :<EOL><INDENT>return []<EOL><DEDENT>return inits <EOL><DEDENT> <DEDENT>def ClassDoc(path):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>from com.sun.tools.javadoc import JavadocTool,Messager,ModifierFilter <EOL>from com.sun.tools.javac.util import List,Context <EOL>from com.sun.tools.javac.code.Flags import PUBLIC <EOL><DEDENT>except ImportError :<EOL><INDENT>raise DataError('<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT>context=Context()<EOL>Messager.preRegister(context,'libdoc')<EOL>jdoctool=JavadocTool.make0(context)<EOL>filter=ModifierFilter(PUBLIC)<EOL>java_names=List.of(path)<EOL>root=jdoctool.getRootDocImpl('en','utf-8',filter,java_names,<EOL>List.nil(),False,List.nil(),<EOL>List.nil(),False,False,True)<EOL>return root.classes()[]<EOL><DEDENT><EOF><BOF>import os <EOL>import sys <EOL>import cv2 <EOL>import numpy as np <EOL>def normalize(X,low,high,dtype=None):<EOL><INDENT> '<STR_LIT>'<EOL>X=np.asarray(X)<EOL>minX,maxX=np.min(X),np.max(X)<EOL>X=X -float(minX)<EOL>X=X /float((maxX -minX))<EOL>X=X *(high -low)<EOL>X=X +low <EOL>if dtype is None :<EOL><INDENT>return np.asarray(X)<EOL><DEDENT>return np.asarray(X,dtype=dtype)<EOL><DEDENT>def read_images(path,sz=None):<EOL><INDENT> '<STR_LIT>'<EOL>c=<EOL>X,y=[],[]<EOL>for dirname,dirnames,filenames in os.walk(path):<EOL><INDENT>for subdirname in dirnames :<EOL><INDENT>subject_path=os.path.join(dirname,subdirname)<EOL>for filename in os.listdir(subject_path):<EOL><INDENT>try :<EOL><INDENT>im=cv2.imread(os.path.join(subject_path,filename),cv2.IMREAD_GRAYSCALE)<EOL>if(sz is not None):<EOL><INDENT>im=cv2.resize(im,sz)<EOL><DEDENT>X.append(np.asarray(im,dtype=np.uint8))<EOL>y.append(c)<EOL><DEDENT>except IOError,(errno,strerror):<EOL><INDENT>print '<STR_LIT>'.format(errno,strerror)<EOL><DEDENT>except :<EOL><INDENT>print '<STR_LIT>',sys.exc_info()[]<EOL>raise <EOL><DEDENT> <DEDENT>c=c +<EOL><DEDENT> <DEDENT>return [X,y ]<EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>out_dir=None <EOL>if len(sys.argv)<:<EOL><INDENT>print '<STR_LIT>'<EOL>sys.exit()<EOL><DEDENT>[X,y ]=read_images(sys.argv [])<EOL>y=np.asarray(y,dtype=np.int32)<EOL>if len(sys.argv)==:<EOL><INDENT>out_dir=sys.argv []<EOL><DEDENT>model=cv2.createEigenFaceRecognizer()<EOL>model.train(np.asarray(X),np.asarray(y))<EOL>[p_label,p_confidence ]=model.predict(np.asarray(X []))<EOL>print '<STR_LIT>'%(p_label,p_confidence)<EOL>print model.getParams()<EOL>mean=model.getMat("mean")<EOL>eigenvectors=model.getMat("eigenvectors")<EOL>mean_norm=normalize(mean,,,dtype=np.uint8)<EOL>mean_resized=mean_norm.reshape(X [].shape)<EOL>if out_dir is None :<EOL><INDENT>cv2.imshow("mean",mean_resized)<EOL><DEDENT>else :<EOL><INDENT>cv2.imwrite("%s/mean.png"%(out_dir),mean_resized)<EOL><DEDENT>for i in xrange(min(len(X),)):<EOL><INDENT>eigenvector_i=eigenvectors [:,i ].reshape(X [].shape)<EOL>eigenvector_i_norm=normalize(eigenvector_i,,,dtype=np.uint8)<EOL>if out_dir is None :<EOL><INDENT>cv2.imshow("%s/eigenface_%d"%(out_dir,i),eigenvector_i_norm)<EOL><DEDENT>else :<EOL><INDENT>cv2.imwrite('<STR_LIT>'%(out_dir,i),eigenvector_i_norm)<EOL><DEDENT> <DEDENT>if out_dir is None :<EOL><INDENT>cv2.waitKey()<EOL><DEDENT> <DEDENT><EOF><BOF>import unittest <EOL>from flask import url_for <EOL>from yapper import create_app,db <EOL>from yapper.blueprints.user.models import Role,User <EOL>from yapper.blueprints.blog.models import Post <EOL>class LoginTestCase(unittest.TestCase):<EOL><INDENT>def setUp(self):<EOL><INDENT>self.app=create_app('test')<EOL>self.app.config ['CSRF_ENABLED']=False <EOL>self.client=self.app.test_client()<EOL>self.app_context=self.app.app_context()<EOL>self.app_context.push()<EOL>db.create_all()<EOL>Role.insert_roles()<EOL>role=Role.query.filter_by(name='user').first()<EOL>user=User(<EOL>name='Test User',<EOL>email='test@mail.com',<EOL>password='testpass',<EOL>status=True,<EOL>role=role )<EOL>db.session.add(user)<EOL>db.session.commit()<EOL><DEDENT>def tearDown(self):<EOL><INDENT>db.session.remove()<EOL>db.drop_all()<EOL>self.app_context.pop()<EOL><DEDENT>def login(self,e,p):<EOL><INDENT>return self.client.post(url_for('user.login'),data=dict(<EOL>email=e,<EOL>password=p ),follow_redirects=True)<EOL><DEDENT>def logout(self):<EOL><INDENT>return self.client.get(url_for('user.logout'),follow_redirects=True)<EOL><DEDENT>def test_empty_db(self):<EOL><INDENT>p=Post.query.all()<EOL>assert len(p)is <EOL><DEDENT>def test_can_login(self):<EOL><INDENT>rv=self.login('test@mail.com','testpass')<EOL>assert 'Test User'in rv.data <EOL>rv=self.logout()<EOL>assert '<STR_LIT>'in rv.data <EOL>rv=self.login('test@gmail.com','po')<EOL>assert '<STR_LIT>'in rv.data <EOL><DEDENT>def test_add_post(self):<EOL><INDENT>self.login('test@mail.com','testpass')<EOL>rv=self.client.post(url_for('blog.add'),data=dict(<EOL>title='Title',<EOL>description='Desc',<EOL>body='## hello there'),follow_redirects=True)<EOL>assert '<STR_LIT>'in rv.data <EOL>rv=self.client.get(<EOL>url_for(<EOL>'<STR_LIT>',<EOL>slug='<STR_LIT>'))<EOL>assert rv.status_code==<EOL><DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>from collections import namedtuple <EOL>import video <EOL>import common <EOL>FLANN_INDEX_KDTREE=<EOL>FLANN_INDEX_LSH=<EOL>flann_params=dict(algorithm=FLANN_INDEX_LSH,<EOL>table_number=,<EOL>key_size=,<EOL>multi_probe_level=)<EOL>MIN_MATCH_COUNT=<EOL>'<STR_LIT>'<EOL>PlanarTarget=namedtuple('PlaneTarget','<STR_LIT>')<EOL>'<STR_LIT>'<EOL>TrackedTarget=namedtuple('TrackedTarget','<STR_LIT>')<EOL>class PlaneTracker :<EOL><INDENT>def __init__(self):<EOL><INDENT>self.detector=cv2.ORB(nfeatures=)<EOL>self.matcher=cv2.FlannBasedMatcher(flann_params,{})<EOL>self.targets=[]<EOL><DEDENT>def add_target(self,image,rect,data=None):<EOL><INDENT> '<STR_LIT>'<EOL>x0,y0,x1,y1=rect <EOL>raw_points,raw_descrs=self.detect_features(image)<EOL>points,descs=[],[]<EOL>for kp,desc in zip(raw_points,raw_descrs):<EOL><INDENT>x,y=kp.pt <EOL>if x0 <=x <=x1 and y0 <=y <=y1 :<EOL><INDENT>points.append(kp)<EOL>descs.append(desc)<EOL><DEDENT> <DEDENT>descs=np.uint8(descs)<EOL>self.matcher.add([descs ])<EOL>target=PlanarTarget(image=image,rect=rect,keypoints=points,descrs=descs,data=None)<EOL>self.targets.append(target)<EOL><DEDENT>def clear(self):<EOL><INDENT> '<STR_LIT>'<EOL>self.targets=[]<EOL>self.matcher.clear()<EOL><DEDENT>def track(self,frame):<EOL><INDENT> '<STR_LIT>'<EOL>self.frame_points,self.frame_descrs=self.detect_features(frame)<EOL>if len(self.frame_points)<MIN_MATCH_COUNT :<EOL><INDENT>return []<EOL><DEDENT>matches=self.matcher.knnMatch(self.frame_descrs,k=)<EOL>matches=[m []for m in matches if len(m)==and m [].distance <m [].distance *]<EOL>if len(matches)<MIN_MATCH_COUNT :<EOL><INDENT>return []<EOL><DEDENT>matches_by_id=[[]for _ in xrange(len(self.targets))]<EOL>for m in matches :<EOL><INDENT>matches_by_id [m.imgIdx ].append(m)<EOL><DEDENT>tracked=[]<EOL>for imgIdx,matches in enumerate(matches_by_id):<EOL><INDENT>if len(matches)<MIN_MATCH_COUNT :<EOL><INDENT>continue <EOL><DEDENT>target=self.targets [imgIdx ]<EOL>p0=[target.keypoints [m.trainIdx ].pt for m in matches ]<EOL>p1=[self.frame_points [m.queryIdx ].pt for m in matches ]<EOL>p0,p1=np.float32((p0,p1))<EOL>H,status=cv2.findHomography(p0,p1,cv2.RANSAC,)<EOL>status=status.ravel()!=<EOL>if status.sum()<MIN_MATCH_COUNT :<EOL><INDENT>continue <EOL><DEDENT>p0,p1=p0 [status ],p1 [status ]<EOL>x0,y0,x1,y1=target.rect <EOL>quad=np.float32([[x0,y0 ],[x1,y0 ],[x1,y1 ],[x0,y1 ]])<EOL>quad=cv2.perspectiveTransform(quad.reshape(,-,),H).reshape(-,)<EOL>track=TrackedTarget(target=target,p0=p0,p1=p1,H=H,quad=quad)<EOL>tracked.append(track)<EOL><DEDENT>tracked.sort(key=lambda t :len(t.p0),reverse=True)<EOL>return tracked <EOL><DEDENT>def detect_features(self,frame):<EOL><INDENT> '<STR_LIT>'<EOL>keypoints,descrs=self.detector.detectAndCompute(frame,None)<EOL>if descrs is None :<EOL><INDENT>descrs=[]<EOL><DEDENT>return keypoints,descrs <EOL><DEDENT> <DEDENT>class App :<EOL><INDENT>def __init__(self,src):<EOL><INDENT>self.cap=video.create_capture(src)<EOL>self.frame=None <EOL>self.paused=False <EOL>self.tracker=PlaneTracker()<EOL>cv2.namedWindow('plane')<EOL>self.rect_sel=common.RectSelector('plane',self.on_rect)<EOL><DEDENT>def on_rect(self,rect):<EOL><INDENT>self.tracker.add_target(self.frame,rect)<EOL><DEDENT>def run(self):<EOL><INDENT>while True :<EOL><INDENT>playing=not self.paused and not self.rect_sel.dragging <EOL>if playing or self.frame is None :<EOL><INDENT>ret,frame=self.cap.read()<EOL>if not ret :<EOL><INDENT>break <EOL><DEDENT>self.frame=frame.copy()<EOL><DEDENT>vis=self.frame.copy()<EOL>if playing :<EOL><INDENT>tracked=self.tracker.track(self.frame)<EOL>for tr in tracked :<EOL><INDENT>cv2.polylines(vis,[np.int32(tr.quad)],True,(,,),)<EOL>for(x,y)in np.int32(tr.p1):<EOL><INDENT>cv2.circle(vis,(x,y),,(,,))<EOL><DEDENT> <DEDENT> <DEDENT>self.rect_sel.draw(vis)<EOL>cv2.imshow('plane',vis)<EOL>ch=cv2.waitKey()<EOL>if ch==ord(' '):<EOL><INDENT>self.paused=not self.paused <EOL><DEDENT>if ch==ord('c'):<EOL><INDENT>self.tracker.clear()<EOL><DEDENT>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>import sys <EOL>try :video_src=sys.argv []<EOL>except :video_src=<EOL>App(video_src).run()<EOL><DEDENT><EOF><BOF>import urllib2 <EOL>import cv2.cv as cv <EOL>import sys <EOL>if __name__=="__main__":<EOL><INDENT>laplace=None <EOL>colorlaplace=None <EOL>planes=[None,None,None ]<EOL>capture=None <EOL>if len(sys.argv)==:<EOL><INDENT>capture=cv.CreateCameraCapture()<EOL><DEDENT>elif len(sys.argv)==and sys.argv [].isdigit():<EOL><INDENT>capture=cv.CreateCameraCapture(int(sys.argv []))<EOL><DEDENT>elif len(sys.argv)==:<EOL><INDENT>capture=cv.CreateFileCapture(sys.argv [])<EOL><DEDENT>if not capture :<EOL><INDENT>print '<STR_LIT>'<EOL>sys.exit(-)<EOL><DEDENT>cv.NamedWindow("Laplacian",)<EOL>while True :<EOL><INDENT>frame=cv.QueryFrame(capture)<EOL>if frame :<EOL><INDENT>if not laplace :<EOL><INDENT>planes=[cv.CreateImage((frame.width,frame.height),,)for i in range()]<EOL>laplace=cv.CreateImage((frame.width,frame.height),cv.IPL_DEPTH_16S,)<EOL>colorlaplace=cv.CreateImage((frame.width,frame.height),,)<EOL><DEDENT>cv.Split(frame,planes [],planes [],planes [],None)<EOL>for plane in planes :<EOL><INDENT>cv.Laplace(plane,laplace,)<EOL>cv.ConvertScaleAbs(laplace,plane,,)<EOL><DEDENT>cv.Merge(planes [],planes [],planes [],None,colorlaplace)<EOL>cv.ShowImage("Laplacian",colorlaplace)<EOL><DEDENT>if cv.WaitKey()!=-:<EOL><INDENT>break <EOL><DEDENT> <DEDENT>cv.DestroyWindow("Laplacian")<EOL><DEDENT><EOF><BOF>from.import core <EOL>core.start()<EOF><BOF>'<STR_LIT>'<EOL>from common import splitfn <EOL>import sys <EOL>import webbrowser <EOL>import Tkinter as tk <EOL>from glob import glob <EOL>from subprocess import Popen <EOL>from ScrolledText import ScrolledText <EOL>exclude_list=['demo','common']<EOL>class LinkManager :<EOL><INDENT>def __init__(self,text,url_callback=None):<EOL><INDENT>self.text=text <EOL>self.text.tag_config("link",foreground="blue",underline=)<EOL>self.text.tag_bind("link","<Enter>",self._enter)<EOL>self.text.tag_bind("link","<Leave>",self._leave)<EOL>self.text.tag_bind("link","<Button-1>",self._click)<EOL>self.url_callback=url_callback <EOL>self.reset()<EOL><DEDENT>def reset(self):<EOL><INDENT>self.links={}<EOL><DEDENT>def add(self,action):<EOL><INDENT>tag="link-%d"%len(self.links)<EOL>self.links [tag ]=action <EOL>return "link",tag <EOL><DEDENT>def _enter(self,event):<EOL><INDENT>self.text.config(cursor="hand2")<EOL><DEDENT>def _leave(self,event):<EOL><INDENT>self.text.config(cursor="")<EOL><DEDENT>def _click(self,event):<EOL><INDENT>for tag in self.text.tag_names(tk.CURRENT):<EOL><INDENT>if tag.startswith("link-"):<EOL><INDENT>proc=self.links [tag ]<EOL>if callable(proc):<EOL><INDENT>proc()<EOL><DEDENT>else :<EOL><INDENT>if self.url_callback :<EOL><INDENT>self.url_callback(proc)<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>class App :<EOL><INDENT>def __init__(self):<EOL><INDENT>root=tk.Tk()<EOL>root.title('OpenCV Demo')<EOL>self.win=win=tk.PanedWindow(root,orient=tk.HORIZONTAL,sashrelief=tk.RAISED,sashwidth=)<EOL>self.win.pack(fill=tk.BOTH,expand=)<EOL>left=tk.Frame(win)<EOL>right=tk.Frame(win)<EOL>win.add(left)<EOL>win.add(right)<EOL>scrollbar=tk.Scrollbar(left,orient=tk.VERTICAL)<EOL>self.demos_lb=demos_lb=tk.Listbox(left,yscrollcommand=scrollbar.set)<EOL>scrollbar.config(command=demos_lb.yview)<EOL>scrollbar.pack(side=tk.RIGHT,fill=tk.Y)<EOL>demos_lb.pack(side=tk.LEFT,fill=tk.BOTH,expand=)<EOL>self.samples={}<EOL>for fn in glob('*.py'):<EOL><INDENT>name=splitfn(fn)[]<EOL>if fn []!='_'and name not in exclude_list :<EOL><INDENT>demos_lb.insert(tk.END,name)<EOL>self.samples [name ]=fn <EOL><DEDENT> <DEDENT>demos_lb.bind('<STR_LIT>',self.on_demo_select)<EOL>self.cmd_entry=cmd_entry=tk.Entry(right)<EOL>cmd_entry.bind('<Return>',self.on_run)<EOL>run_btn=tk.Button(right,command=self.on_run,text='Run',width=)<EOL>self.text=text=ScrolledText(right,font=('arial',,'normal'),width=,wrap='word')<EOL>self.linker=linker=LinkManager(text,self.on_link)<EOL>self.text.tag_config("header1",font=('arial',,'bold'))<EOL>self.text.tag_config("header2",font=('arial',,'bold'))<EOL>text.config(state='disabled')<EOL>text.pack(fill='both',expand=,side=tk.BOTTOM)<EOL>cmd_entry.pack(fill='x',side='left',expand=)<EOL>run_btn.pack()<EOL><DEDENT>def on_link(self,url):<EOL><INDENT>print url <EOL>webbrowser.open(url)<EOL><DEDENT>def on_demo_select(self,evt):<EOL><INDENT>name=self.demos_lb.get(self.demos_lb.curselection()[])<EOL>fn=self.samples [name ]<EOL>loc={}<EOL>execfile(fn,loc)<EOL>descr=loc.get('__doc__','no-description')<EOL>self.linker.reset()<EOL>self.text.config(state='normal')<EOL>self.text.delete(,tk.END)<EOL>self.format_text(descr)<EOL>self.text.config(state='disabled')<EOL>self.cmd_entry.delete(,tk.END)<EOL>self.cmd_entry.insert(,fn)<EOL><DEDENT>def format_text(self,s):<EOL><INDENT>text=self.text <EOL>lines=s.splitlines()<EOL>for i,s in enumerate(lines):<EOL><INDENT>s=s.rstrip()<EOL>if i==and not s :<EOL><INDENT>continue <EOL><DEDENT>if s and s=='='*len(s):<EOL><INDENT>text.tag_add('header1','end-2l','end-1l')<EOL><DEDENT>elif s and s=='-'*len(s):<EOL><INDENT>text.tag_add('header2','end-2l','end-1l')<EOL><DEDENT>else :<EOL><INDENT>text.insert('end',s +'\n')<EOL><DEDENT> <DEDENT>def add_link(start,end,url):<EOL><INDENT>for tag in self.linker.add(url):<EOL><INDENT>text.tag_add(tag,start,end)<EOL><DEDENT> <DEDENT>self.match_text(r'http://\S+',add_link)<EOL><DEDENT>def match_text(self,pattern,tag_proc,regexp=True):<EOL><INDENT>text=self.text <EOL>text.mark_set('matchPos','1.0')<EOL>count=tk.IntVar()<EOL>while True :<EOL><INDENT>match_index=text.search(pattern,'matchPos',count=count,regexp=regexp,stopindex='end')<EOL>if not match_index :<EOL><INDENT>break <EOL><DEDENT>end_index=text.index("%s+%sc"%(match_index,count.get()))<EOL>text.mark_set('matchPos',end_index)<EOL>if callable(tag_proc):<EOL><INDENT>tag_proc(match_index,end_index,text.get(match_index,end_index))<EOL><DEDENT>else :<EOL><INDENT>text.tag_add(tag_proc,match_index,end_index)<EOL><DEDENT> <DEDENT> <DEDENT>def on_run(self,*args):<EOL><INDENT>cmd=self.cmd_entry.get()<EOL>print 'running:',cmd <EOL>Popen(sys.executable +' '+cmd,shell=True)<EOL><DEDENT>def run(self):<EOL><INDENT>tk.mainloop()<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>App().run()<EOL><DEDENT><EOF><BOF>import numpy as np <EOL>import cv2 <EOL>from time import clock <EOL>import sys <EOL>import video <EOL>if __name__=='__main__':<EOL><INDENT>hsv_map=np.zeros((,,),np.uint8)<EOL>h,s=np.indices(hsv_map.shape [:])<EOL>hsv_map [:,:,]=h <EOL>hsv_map [:,:,]=s <EOL>hsv_map [:,:,]=<EOL>hsv_map=cv2.cvtColor(hsv_map,cv2.COLOR_HSV2BGR)<EOL>cv2.imshow('hsv_map',hsv_map)<EOL>cv2.namedWindow('hist',)<EOL>hist_scale=<EOL>def set_scale(val):<EOL><INDENT>global hist_scale <EOL>hist_scale=val <EOL><DEDENT>cv2.createTrackbar('scale','hist',hist_scale,,set_scale)<EOL>try :fn=sys.argv []<EOL>except :fn=<EOL>cam=video.create_capture(fn,fallback='<STR_LIT>')<EOL>while True :<EOL><INDENT>flag,frame=cam.read()<EOL>cv2.imshow('camera',frame)<EOL>small=cv2.pyrDown(frame)<EOL>hsv=cv2.cvtColor(small,cv2.COLOR_BGR2HSV)<EOL>dark=hsv [...,]<<EOL>hsv [dark ]=<EOL>h=cv2.calcHist([hsv ],[,],None,[,],[,,,])<EOL>h=np.clip(h **hist_scale,,)<EOL>vis=hsv_map *h [:,:,np.newaxis ]/<EOL>cv2.imshow('hist',vis)<EOL>ch=&cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import cv2 <EOL>import numpy as np <EOL>import sys <EOL>import math <EOL>try :<EOL><INDENT>fn=sys.argv []<EOL><DEDENT>except :<EOL><INDENT>fn='<STR_LIT>'<EOL><DEDENT>print __doc__ <EOL>src=cv2.imread(fn)<EOL>dst=cv2.Canny(src,,)<EOL>cdst=cv2.cvtColor(dst,cv2.COLOR_GRAY2BGR)<EOL>lines=cv2.HoughLinesP(dst,,math.pi /,,np.array([]),,)<EOL>a,b,c=lines.shape <EOL>for i in range(b):<EOL><INDENT>cv2.line(cdst,(lines [][i ][],lines [][i ][]),(lines [][i ][],lines [][i ][]),(,,),,cv2.LINE_AA)<EOL><DEDENT>cv2.imshow("source",src)<EOL>cv2.imshow("detected lines",cdst)<EOL>cv2.waitKey()<EOF><BOF>from robot.utils import NormalizedDict <EOL>class Metadata(NormalizedDict):<EOL><INDENT>def __init__(self,initial=None):<EOL><INDENT>NormalizedDict.__init__(self,initial,ignore=['_'])<EOL><DEDENT>def __unicode__(self):<EOL><INDENT>return u'{%s}'%', '.join('%s: %s'%(k,self [k ])for k in self)<EOL><DEDENT>def __str__(self):<EOL><INDENT>return unicode(self).encode('ASCII','replace')<EOL><DEDENT> <DEDENT><EOF>