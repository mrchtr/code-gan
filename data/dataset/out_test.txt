<BOF>import os <EOL>import sys <EOL>import time <EOL>import glob <EOL>import fnmatch <EOL>import shutil <EOL>import subprocess <EOL>try :<EOL><INDENT>from robot.version import get_version <EOL>from robot.api import logger <EOL>from robot.utils import(ConnectionCache,seq2str,timestr_to_secs,<EOL>secs_to_timestr,plural_or_not,get_time,abspath,<EOL>secs_to_timestamp,parse_time,unic,decode_output,<EOL>get_env_var,set_env_var,del_env_var,get_env_vars,<EOL>decode_from_system)<EOL>__version__=get_version()<EOL>PROCESSES=ConnectionCache('<STR_LIT>')<EOL>del ConnectionCache,get_version <EOL><DEDENT>except ImportError :<EOL><INDENT>from os.path import abspath <EOL>from os import(getenv as get_env_var,putenv as set_env_var,<EOL>unsetenv as del_env_var,environ)<EOL>__version__='<unknown>'<EOL>get_env_vars=environ.copy <EOL>logger=None <EOL>seq2str=lambda items :', '.join("'%s'"%item for item in items)<EOL>timestr_to_secs=int <EOL>plural_or_not=lambda count :''if count==else 's'<EOL>secs_to_timestr=lambda secs :'%d second%s'%(secs,plural_or_not(secs))<EOL>unic=unicode <EOL>decode_output=decode_from_system=lambda string :string <EOL>class _NotImplemented :<EOL><INDENT>def __getattr__(self,name):<EOL><INDENT>raise NotImplementedError('<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT> <DEDENT>get_time=secs_to_timestamp=parse_time=PROCESSES=_NotImplemented()<EOL><DEDENT>class OperatingSystem :<EOL><INDENT> '<STR_LIT>'<EOL>ROBOT_LIBRARY_SCOPE='GLOBAL'<EOL>ROBOT_LIBRARY_VERSION=__version__ <EOL>def run(self,command):<EOL><INDENT> '<STR_LIT>'<EOL>return self._run(command)[]<EOL><DEDENT>def run_and_return_rc(self,command):<EOL><INDENT> '<STR_LIT>'<EOL>return self._run(command)[]<EOL><DEDENT>def run_and_return_rc_and_output(self,command):<EOL><INDENT> '<STR_LIT>'<EOL>return self._run(command)<EOL><DEDENT>def _run(self,command):<EOL><INDENT>process=_Process(command)<EOL>self._info('<STR_LIT>'%process)<EOL>stdout=process.read()<EOL>rc=process.close()<EOL>return rc,stdout <EOL><DEDENT>def start_process(self,command,stdin=None,alias=None):<EOL><INDENT> '<STR_LIT>'<EOL>process=_Process2(command,stdin)<EOL>self._info('<STR_LIT>'%process)<EOL>return PROCESSES.register(process,alias)<EOL><DEDENT>def switch_process(self,index_or_alias):<EOL><INDENT> '<STR_LIT>'<EOL>PROCESSES.switch(index_or_alias)<EOL><DEDENT>def read_process_output(self):<EOL><INDENT> '<STR_LIT>'<EOL>output=PROCESSES.current.read()<EOL>PROCESSES.current.close()<EOL>return output <EOL><DEDENT>def stop_process(self):<EOL><INDENT> '<STR_LIT>'<EOL>PROCESSES.current.close()<EOL><DEDENT>def stop_all_processes(self):<EOL><INDENT> '<STR_LIT>'<EOL>PROCESSES.close_all()<EOL><DEDENT>def get_file(self,path,encoding='UTF-8'):<EOL><INDENT> '<STR_LIT>'<EOL>content=self.get_binary_file(path)<EOL>return unicode(content,encoding).replace('\r\n','\n')<EOL><DEDENT>def get_binary_file(self,path):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>self._link('<STR_LIT>',path)<EOL>f=open(path,'rb')<EOL>try :<EOL><INDENT>return f.read()<EOL><DEDENT>finally :<EOL><INDENT>f.close()<EOL><DEDENT> <DEDENT>def grep_file(self,path,pattern,encoding='UTF-8'):<EOL><INDENT> '<STR_LIT>'<EOL>pattern='*%s*'%pattern <EOL>orig=self.get_file(path,encoding).splitlines()<EOL>lines=[line for line in orig if fnmatch.fnmatchcase(line,pattern)]<EOL>self._info('<STR_LIT>'%(len(lines),len(orig)))<EOL>return '\n'.join(lines)<EOL><DEDENT>def log_file(self,path,encoding='UTF-8'):<EOL><INDENT> '<STR_LIT>'<EOL>content=self.get_file(path,encoding)<EOL>self._info(content)<EOL>return content <EOL><DEDENT>def should_exist(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>if not glob.glob(path):<EOL><INDENT>self._fail(msg,'<STR_LIT>'%path)<EOL><DEDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>def should_not_exist(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>matches=glob.glob(path)<EOL>if not matches :<EOL><INDENT>self._link('<STR_LIT>',path)<EOL>return <EOL><DEDENT>if not msg :<EOL><INDENT>if self._is_pattern_path(path):<EOL><INDENT>matches.sort()<EOL>msg='<STR_LIT>'%(path,seq2str(matches))<EOL><DEDENT>else :<EOL><INDENT>msg='<STR_LIT>'%path <EOL><DEDENT> <DEDENT>raise AssertionError(msg)<EOL><DEDENT>def file_should_exist(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>matches=[p for p in glob.glob(path)if os.path.isfile(p)]<EOL>if not matches :<EOL><INDENT>self._fail(msg,'<STR_LIT>'%path)<EOL><DEDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>def file_should_not_exist(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>matches=[p for p in glob.glob(path)if os.path.isfile(p)]<EOL>if not matches :<EOL><INDENT>self._link('<STR_LIT>',path)<EOL>return <EOL><DEDENT>if not msg :<EOL><INDENT>if self._is_pattern_path(path):<EOL><INDENT>matches.sort()<EOL>name=len(matches)==and 'file'or 'files'<EOL>msg='<STR_LIT>'%(path,name,seq2str(matches))<EOL><DEDENT>else :<EOL><INDENT>msg='<STR_LIT>'%path <EOL><DEDENT> <DEDENT>raise AssertionError(msg)<EOL><DEDENT>def directory_should_exist(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>matches=[p for p in glob.glob(path)if os.path.isdir(p)]<EOL>if not matches :<EOL><INDENT>self._fail(msg,'<STR_LIT>'%path)<EOL><DEDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>def directory_should_not_exist(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>matches=[p for p in glob.glob(path)if os.path.isdir(p)]<EOL>if not matches :<EOL><INDENT>self._link('<STR_LIT>',path)<EOL>return <EOL><DEDENT>if not msg :<EOL><INDENT>if self._is_pattern_path(path):<EOL><INDENT>matches.sort()<EOL>name=len(matches)==and 'directory'or 'directories'<EOL>msg='<STR_LIT>'%(path,name,seq2str(matches))<EOL><DEDENT>else :<EOL><INDENT>msg='<STR_LIT>'%path <EOL><DEDENT> <DEDENT>raise AssertionError(msg)<EOL><DEDENT>def _is_pattern_path(self,path):<EOL><INDENT>return '*'in path or '?'in path or('['in path and ']'in path)<EOL><DEDENT>def wait_until_removed(self,path,timeout='1 minute'):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>timeout=timestr_to_secs(timeout)<EOL>maxtime=time.time()+timeout <EOL>while glob.glob(path):<EOL><INDENT>time.sleep()<EOL>if timeout >=and time.time()>maxtime :<EOL><INDENT>raise AssertionError('<STR_LIT>'<EOL>%(path,secs_to_timestr(timeout)))<EOL><DEDENT> <DEDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>def wait_until_created(self,path,timeout='1 minute'):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>timeout=timestr_to_secs(timeout)<EOL>maxtime=time.time()+timeout <EOL>while not glob.glob(path):<EOL><INDENT>time.sleep()<EOL>if timeout >=and time.time()>maxtime :<EOL><INDENT>raise AssertionError('<STR_LIT>'<EOL>%(path,secs_to_timestr(timeout)))<EOL><DEDENT> <DEDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>def directory_should_be_empty(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>items=self._list_dir(path)<EOL>if items :<EOL><INDENT>if not msg :<EOL><INDENT>msg='<STR_LIT>'%(path,seq2str(items,lastsep=', '))<EOL><DEDENT>raise AssertionError(msg)<EOL><DEDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>def directory_should_not_be_empty(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>count=len(self._list_dir(path))<EOL>if count==:<EOL><INDENT>self._fail(msg,'<STR_LIT>'%path)<EOL><DEDENT>plural=plural_or_not(count)<EOL>self._link('<STR_LIT>'%(count,plural),<EOL>path)<EOL><DEDENT>def file_should_be_empty(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>if not os.path.isfile(path):<EOL><INDENT>raise AssertionError('<STR_LIT>'%path)<EOL><DEDENT>size=os.stat(path).st_size <EOL>if size >:<EOL><INDENT>self._fail(msg,'<STR_LIT>'%(path,size))<EOL><DEDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>def file_should_not_be_empty(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>if not os.path.isfile(path):<EOL><INDENT>raise AssertionError('<STR_LIT>'%path)<EOL><DEDENT>size=os.stat(path).st_size <EOL>if size==:<EOL><INDENT>self._fail(msg,'<STR_LIT>'%path)<EOL><DEDENT>self._link('<STR_LIT>'%size,path)<EOL><DEDENT>def create_file(self,path,content='',encoding='UTF-8'):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._write_to_file(path,content,encoding,'w')<EOL>self._link('<STR_LIT>',path)<EOL><DEDENT>def append_to_file(self,path,content,encoding='UTF-8'):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._write_to_file(path,content,encoding,'a')<EOL>self._link('<STR_LIT>',path)<EOL><DEDENT>def _write_to_file(self,path,content,encoding,mode):<EOL><INDENT>path=self._absnorm(path)<EOL>parent=os.path.dirname(path)<EOL>if not os.path.exists(parent):<EOL><INDENT>os.makedirs(parent)<EOL><DEDENT>f=open(path,mode +'b')<EOL>try :<EOL><INDENT>f.write(content.encode(encoding))<EOL><DEDENT>finally :<EOL><INDENT>f.close()<EOL><DEDENT>return path <EOL><DEDENT>def remove_file(self,path):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>matches=glob.glob(path)<EOL>if not matches :<EOL><INDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>for match in matches :<EOL><INDENT>if not os.path.isfile(match):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%match)<EOL><DEDENT>os.remove(match)<EOL>self._link('<STR_LIT>',match)<EOL><DEDENT> <DEDENT>def remove_files(self,*paths):<EOL><INDENT> '<STR_LIT>'<EOL>for path in paths :<EOL><INDENT>self.remove_file(path)<EOL><DEDENT> <DEDENT>def empty_directory(self,path):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>items=[os.path.join(path,item)for item in self._list_dir(path)]<EOL>for item in items :<EOL><INDENT>if os.path.isdir(item):<EOL><INDENT>shutil.rmtree(item)<EOL><DEDENT>else :<EOL><INDENT>os.remove(item)<EOL><DEDENT> <DEDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>def create_directory(self,path):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>if os.path.isdir(path):<EOL><INDENT>self._link('<STR_LIT>',path)<EOL>return <EOL><DEDENT>if os.path.exists(path):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%path)<EOL><DEDENT>os.makedirs(path)<EOL>self._link('<STR_LIT>',path)<EOL><DEDENT>def remove_directory(self,path,recursive=False):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>if not os.path.exists(path):<EOL><INDENT>self._link('<STR_LIT>',path)<EOL>return <EOL><DEDENT>if os.path.isfile(path):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%path)<EOL><DEDENT>if recursive :<EOL><INDENT>shutil.rmtree(path)<EOL><DEDENT>else :<EOL><INDENT>msg='<STR_LIT>'%path <EOL>self.directory_should_be_empty(path,msg)<EOL>os.rmdir(path)<EOL><DEDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>def copy_file(self,source,destination):<EOL><INDENT> '<STR_LIT>'<EOL>source,destination=self._copy_file(source,destination)<EOL>self._link('<STR_LIT>',source,destination)<EOL><DEDENT>def move_file(self,source,destination):<EOL><INDENT> '<STR_LIT>'<EOL>source,destination=self._copy_file(source,destination)<EOL>os.remove(source)<EOL>self._link('<STR_LIT>',source,destination)<EOL><DEDENT>def _copy_file(self,source,dest):<EOL><INDENT>source=self._absnorm(source)<EOL>dest=dest.replace('/',os.sep)<EOL>dest_is_dir=dest.endswith(os.sep)<EOL>dest=self._absnorm(dest)<EOL>if not os.path.exists(source):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%source)<EOL><DEDENT>if not os.path.isfile(source):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%source)<EOL><DEDENT>if not os.path.exists(dest):<EOL><INDENT>if dest_is_dir :<EOL><INDENT>parent=dest <EOL><DEDENT>else :<EOL><INDENT>parent=os.path.dirname(dest)<EOL><DEDENT>if not os.path.exists(parent):<EOL><INDENT>os.makedirs(parent)<EOL><DEDENT> <DEDENT>shutil.copy(source,dest)<EOL>return source,dest <EOL><DEDENT>def copy_directory(self,source,destination):<EOL><INDENT> '<STR_LIT>'<EOL>source,destination=self._copy_dir(source,destination)<EOL>self._link('<STR_LIT>',source,destination)<EOL><DEDENT>def move_directory(self,source,destination):<EOL><INDENT> '<STR_LIT>'<EOL>source,destination=self._copy_dir(source,destination)<EOL>shutil.rmtree(source)<EOL>self._link('<STR_LIT>',source,destination)<EOL><DEDENT>def _copy_dir(self,source,dest):<EOL><INDENT>source=self._absnorm(source)<EOL>dest=self._absnorm(dest)<EOL>if not os.path.exists(source):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%source)<EOL><DEDENT>if not os.path.isdir(source):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%source)<EOL><DEDENT>if os.path.exists(dest)and not os.path.isdir(dest):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%dest)<EOL><DEDENT>if os.path.exists(dest):<EOL><INDENT>base=os.path.basename(source)<EOL>dest=os.path.join(dest,base)<EOL><DEDENT>else :<EOL><INDENT>parent=os.path.dirname(dest)<EOL>if not os.path.exists(parent):<EOL><INDENT>os.makedirs(parent)<EOL><DEDENT> <DEDENT>shutil.copytree(source,dest)<EOL>return source,dest <EOL><DEDENT>def get_environment_variable(self,name,default=None):<EOL><INDENT> '<STR_LIT>'<EOL>value=get_env_var(name,default)<EOL>if value is None :<EOL><INDENT>raise RuntimeError('<STR_LIT>'%name)<EOL><DEDENT>return value <EOL><DEDENT>def set_environment_variable(self,name,value):<EOL><INDENT> '<STR_LIT>'<EOL>set_env_var(name,value)<EOL>self._info('<STR_LIT>'%(name,value))<EOL><DEDENT>def remove_environment_variable(self,*names):<EOL><INDENT> '<STR_LIT>'<EOL>for name in names :<EOL><INDENT>value=del_env_var(name)<EOL>if value :<EOL><INDENT>self._info('<STR_LIT>'%name)<EOL><DEDENT>else :<EOL><INDENT>self._info('<STR_LIT>'%name)<EOL><DEDENT> <DEDENT> <DEDENT>def environment_variable_should_be_set(self,name,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>value=get_env_var(name)<EOL>if not value :<EOL><INDENT>self._fail(msg,'<STR_LIT>'%name)<EOL><DEDENT>self._info('<STR_LIT>'%(name,value))<EOL><DEDENT>def environment_variable_should_not_be_set(self,name,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>value=get_env_var(name)<EOL>if value :<EOL><INDENT>self._fail(msg,'<STR_LIT>'%(name,value))<EOL><DEDENT>self._info('<STR_LIT>'%name)<EOL><DEDENT>def get_environment_variables(self):<EOL><INDENT> '<STR_LIT>'<EOL>return get_env_vars()<EOL><DEDENT>def log_environment_variables(self,level='INFO'):<EOL><INDENT> '<STR_LIT>'<EOL>vars=get_env_vars()<EOL>for name,value in sorted(vars.items(),key=lambda item :item [].lower()):<EOL><INDENT>self._log('%s= %s'%(name,value),level)<EOL><DEDENT>return vars <EOL><DEDENT>def join_path(self,base,*parts):<EOL><INDENT> '<STR_LIT>'<EOL>base=base.replace('/',os.sep)<EOL>parts=[p.replace('/',os.sep)for p in parts ]<EOL>return self.normalize_path(os.path.join(base,*parts))<EOL><DEDENT>def join_paths(self,base,*paths):<EOL><INDENT> '<STR_LIT>'<EOL>return [self.join_path(base,path)for path in paths ]<EOL><DEDENT>def normalize_path(self,path):<EOL><INDENT> '<STR_LIT>'<EOL>return os.path.normpath(path.replace('/',os.sep))or '.'<EOL><DEDENT>def split_path(self,path):<EOL><INDENT> '<STR_LIT>'<EOL>return os.path.split(self.normalize_path(path))<EOL><DEDENT>def split_extension(self,path):<EOL><INDENT> '<STR_LIT>'<EOL>path=self.normalize_path(path)<EOL>basename=os.path.basename(path)<EOL>if basename.startswith('.'*basename.count('.')):<EOL><INDENT>return path,''<EOL><DEDENT>if path.endswith('.'):<EOL><INDENT>path2=path.rstrip('.')<EOL>trailing_dots='.'*(len(path)-len(path2))<EOL>path=path2 <EOL><DEDENT>else :<EOL><INDENT>trailing_dots=''<EOL><DEDENT>basepath,ext=os.path.splitext(path)<EOL>if ext.startswith('.'):<EOL><INDENT>ext=ext [:]<EOL><DEDENT>if ext :<EOL><INDENT>ext +=trailing_dots <EOL><DEDENT>else :<EOL><INDENT>basepath +=trailing_dots <EOL><DEDENT>return basepath,ext <EOL><DEDENT>def get_modified_time(self,path,format='timestamp'):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>if not os.path.exists(path):<EOL><INDENT>raise RuntimeError('<STR_LIT>'<EOL>'<STR_LIT>'%path)<EOL><DEDENT>mtime=get_time(format,os.stat(path).st_mtime)<EOL>self._link('<STR_LIT>'%mtime,path)<EOL>return mtime <EOL><DEDENT>def set_modified_time(self,path,mtime):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>try :<EOL><INDENT>if not os.path.exists(path):<EOL><INDENT>raise ValueError('<STR_LIT>')<EOL><DEDENT>if not os.path.isfile(path):<EOL><INDENT>raise ValueError('<STR_LIT>')<EOL><DEDENT>mtime=parse_time(mtime)<EOL><DEDENT>except ValueError,err :<EOL><INDENT>raise RuntimeError('<STR_LIT>'<EOL>%(path,unicode(err)))<EOL><DEDENT>os.utime(path,(mtime,mtime))<EOL>time.sleep()<EOL>tstamp=secs_to_timestamp(mtime,('-',' ',':'))<EOL>self._link('<STR_LIT>'%tstamp,path)<EOL><DEDENT>def get_file_size(self,path):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>if not os.path.isfile(path):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%path)<EOL><DEDENT>size=os.stat(path).st_size <EOL>plural=plural_or_not(size)<EOL>self._link('<STR_LIT>'%(size,plural),path)<EOL>return size <EOL><DEDENT>def list_directory(self,path,pattern=None,absolute=False):<EOL><INDENT> '<STR_LIT>'<EOL>items=self._list_dir(path,pattern,absolute)<EOL>self._info('%d item%s:\n%s'%(len(items),plural_or_not(items),'\n'.join(items)))<EOL>return items <EOL><DEDENT>def list_files_in_directory(self,path,pattern=None,absolute=False):<EOL><INDENT> '<STR_LIT>'<EOL>files=self._list_files_in_dir(path,pattern,absolute)<EOL>self._info('%d file%s:\n%s'%(len(files),plural_or_not(files),'\n'.join(files)))<EOL>return files <EOL><DEDENT>def list_directories_in_directory(self,path,pattern=None,absolute=False):<EOL><INDENT> '<STR_LIT>'<EOL>dirs=self._list_dirs_in_dir(path,pattern,absolute)<EOL>self._info('<STR_LIT>'%(len(dirs),'y'if len(dirs)==else 'ies','\n'.join(dirs)))<EOL>return dirs <EOL><DEDENT>def count_items_in_directory(self,path,pattern=None):<EOL><INDENT> '<STR_LIT>'<EOL>count=len(self._list_dir(path,pattern))<EOL>self._info("%s item%s."%(count,plural_or_not(count)))<EOL>return count <EOL><DEDENT>def count_files_in_directory(self,path,pattern=None):<EOL><INDENT> '<STR_LIT>'<EOL>count=len(self._list_files_in_dir(path,pattern))<EOL>self._info("%s file%s."%(count,plural_or_not(count)))<EOL>return count <EOL><DEDENT>def count_directories_in_directory(self,path,pattern=None):<EOL><INDENT> '<STR_LIT>'<EOL>count=len(self._list_dirs_in_dir(path,pattern))<EOL>self._info("%s director%s."%(count,'y'if count==else 'ies'))<EOL>return count <EOL><DEDENT>def _list_dir(self,path,pattern=None,absolute=False):<EOL><INDENT>path=self._absnorm(path)<EOL>self._link('<STR_LIT>',path)<EOL>if not os.path.isdir(path):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%path)<EOL><DEDENT>items=sorted(unic(item)for item in os.listdir(path))<EOL>if pattern :<EOL><INDENT>items=[i for i in items if fnmatch.fnmatchcase(i,pattern)]<EOL><DEDENT>if absolute :<EOL><INDENT>path=os.path.normpath(path)<EOL>items=[os.path.join(path,item)for item in items ]<EOL><DEDENT>return items <EOL><DEDENT>def _list_files_in_dir(self,path,pattern=None,absolute=False):<EOL><INDENT>return [item for item in self._list_dir(path,pattern,absolute)<EOL>if os.path.isfile(os.path.join(path,item))]<EOL><DEDENT>def _list_dirs_in_dir(self,path,pattern=None,absolute=False):<EOL><INDENT>return [item for item in self._list_dir(path,pattern,absolute)<EOL>if os.path.isdir(os.path.join(path,item))]<EOL><DEDENT>def touch(self,path):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>if os.path.isdir(path):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%path)<EOL><DEDENT>if not os.path.exists(os.path.dirname(path)):<EOL><INDENT>raise RuntimeError('<STR_LIT>'<EOL>"does not exist"%path)<EOL><DEDENT>if os.path.exists(path):<EOL><INDENT>mtime=round(time.time())<EOL>os.utime(path,(mtime,mtime))<EOL>self._link('<STR_LIT>',path)<EOL><DEDENT>else :<EOL><INDENT>open(path,'w').close()<EOL>self._link('<STR_LIT>',path)<EOL><DEDENT> <DEDENT>def _absnorm(self,path):<EOL><INDENT>try :<EOL><INDENT>return abspath(path.replace('/',os.sep))<EOL><DEDENT>except ValueError :<EOL><INDENT>return os.path.normpath(path.replace('/',os.sep))<EOL><DEDENT> <DEDENT>def _fail(self,error,default):<EOL><INDENT>raise AssertionError(error or default)<EOL><DEDENT>def _info(self,msg):<EOL><INDENT>self._log(msg,'INFO')<EOL><DEDENT>def _link(self,msg,*paths):<EOL><INDENT>paths=tuple('<STR_LIT>'%(p,p)for p in paths)<EOL>self._log(msg %paths,'HTML')<EOL><DEDENT>def _warn(self,msg):<EOL><INDENT>self._log(msg,'WARN')<EOL><DEDENT>def _log(self,msg,level):<EOL><INDENT>if logger :<EOL><INDENT>logger.write(msg,level)<EOL><DEDENT>else :<EOL><INDENT>print '*%s* %s'%(level,msg)<EOL><DEDENT> <DEDENT> <DEDENT>class _Process :<EOL><INDENT>def __init__(self,command):<EOL><INDENT>self._command=self._process_command(command)<EOL>self._process=os.popen(self._command)<EOL><DEDENT>def __str__(self):<EOL><INDENT>return self._command <EOL><DEDENT>def read(self):<EOL><INDENT>return self._process_output(self._process.read())<EOL><DEDENT>def close(self):<EOL><INDENT>try :<EOL><INDENT>rc=self._process.close()<EOL><DEDENT>except IOError :<EOL><INDENT>return <EOL><DEDENT>if rc is None :<EOL><INDENT>return <EOL><DEDENT>if os.sep=='\\'or sys.platform.startswith('java'):<EOL><INDENT>return rc %<EOL><DEDENT>return rc >><EOL><DEDENT>def _process_command(self,command):<EOL><INDENT>if '>'not in command :<EOL><INDENT>if command.endswith('&'):<EOL><INDENT>command=command [:-]+' 2>&1 &'<EOL><DEDENT>else :<EOL><INDENT>command +=' 2>&1'<EOL><DEDENT> <DEDENT>return self._encode_to_file_system(command)<EOL><DEDENT>def _encode_to_file_system(self,string):<EOL><INDENT>enc=sys.getfilesystemencoding()<EOL>return string.encode(enc)if enc else string <EOL><DEDENT>def _process_output(self,stdout):<EOL><INDENT>stdout=stdout.replace('\r\n','\n')<EOL>if stdout.endswith('\n'):<EOL><INDENT>stdout=stdout [:-]<EOL><DEDENT>return decode_output(stdout)<EOL><DEDENT> <DEDENT>class _Process2(_Process):<EOL><INDENT>def __init__(self,command,input_):<EOL><INDENT>self._command=self._process_command(command)<EOL>p=subprocess.Popen(self._command,shell=True,stdin=subprocess.PIPE,<EOL>stdout=subprocess.PIPE,stderr=subprocess.STDOUT,<EOL>close_fds=os.sep=='/')<EOL>stdin,self.stdout=p.stdin,p.stdout <EOL>if input_ :<EOL><INDENT>stdin.write(input_)<EOL><DEDENT>stdin.close()<EOL>self.closed=False <EOL><DEDENT>def read(self):<EOL><INDENT>if self.closed :<EOL><INDENT>raise RuntimeError('<STR_LIT>')<EOL><DEDENT>return self._process_output(self.stdout.read())<EOL><DEDENT>def close(self):<EOL><INDENT>if not self.closed :<EOL><INDENT>self.stdout.close()<EOL>self.closed=True <EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>from multiprocessing.pool import ThreadPool <EOL>from collections import deque <EOL>from common import clock,draw_str,StatValue <EOL>import video <EOL>class DummyTask :<EOL><INDENT>def __init__(self,data):<EOL><INDENT>self.data=data <EOL><DEDENT>def ready(self):<EOL><INDENT>return True <EOL><DEDENT>def get(self):<EOL><INDENT>return self.data <EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>import sys <EOL>print __doc__ <EOL>try :fn=sys.argv []<EOL>except :fn=<EOL>cap=video.create_capture(fn)<EOL>def process_frame(frame,t0):<EOL><INDENT>frame=cv2.medianBlur(frame,)<EOL>frame=cv2.medianBlur(frame,)<EOL>return frame,t0 <EOL><DEDENT>threadn=cv2.getNumberOfCPUs()<EOL>pool=ThreadPool(processes=threadn)<EOL>pending=deque()<EOL>threaded_mode=True <EOL>latency=StatValue()<EOL>frame_interval=StatValue()<EOL>last_frame_time=clock()<EOL>while True :<EOL><INDENT>while len(pending)>and pending [].ready():<EOL><INDENT>res,t0=pending.popleft().get()<EOL>latency.update(clock()-t0)<EOL>draw_str(res,(,),'<STR_LIT>'+str(threaded_mode))<EOL>draw_str(res,(,),'<STR_LIT>'%(latency.value *))<EOL>draw_str(res,(,),'<STR_LIT>'%(frame_interval.value *))<EOL>cv2.imshow('threaded video',res)<EOL><DEDENT>if len(pending)<threadn :<EOL><INDENT>ret,frame=cap.read()<EOL>t=clock()<EOL>frame_interval.update(t -last_frame_time)<EOL>last_frame_time=t <EOL>if threaded_mode :<EOL><INDENT>task=pool.apply_async(process_frame,(frame.copy(),t))<EOL><DEDENT>else :<EOL><INDENT>task=DummyTask(process_frame(frame,t))<EOL><DEDENT>pending.append(task)<EOL><DEDENT>ch=&cv2.waitKey()<EOL>if ch==ord(' '):<EOL><INDENT>threaded_mode=not threaded_mode <EOL><DEDENT>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT>cv2.destroyAllWindows()<EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>from common import Sketcher <EOL>class App :<EOL><INDENT>def __init__(self,fn):<EOL><INDENT>self.img=cv2.imread(fn)<EOL>if self.img is None :<EOL><INDENT>raise Exception('<STR_LIT>'%fn)<EOL><DEDENT>h,w=self.img.shape [:]<EOL>self.markers=np.zeros((h,w),np.int32)<EOL>self.markers_vis=self.img.copy()<EOL>self.cur_marker=<EOL>self.colors=np.int32(list(np.ndindex(,,)))*<EOL>self.auto_update=True <EOL>self.sketch=Sketcher('img',[self.markers_vis,self.markers ],self.get_colors)<EOL><DEDENT>def get_colors(self):<EOL><INDENT>return map(int,self.colors [self.cur_marker ]),self.cur_marker <EOL><DEDENT>def watershed(self):<EOL><INDENT>m=self.markers.copy()<EOL>cv2.watershed(self.img,m)<EOL>overlay=self.colors [np.maximum(m,)]<EOL>vis=cv2.addWeighted(self.img,,overlay,,,dtype=cv2.CV_8UC3)<EOL>cv2.imshow('watershed',vis)<EOL><DEDENT>def run(self):<EOL><INDENT>while True :<EOL><INDENT>ch=&cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT>if ch >=ord('1')and ch <=ord('7'):<EOL><INDENT>self.cur_marker=ch -ord('0')<EOL>print 'marker: ',self.cur_marker <EOL><DEDENT>if ch==ord(' ')or(self.sketch.dirty and self.auto_update):<EOL><INDENT>self.watershed()<EOL>self.sketch.dirty=False <EOL><DEDENT>if ch in [ord('a'),ord('A')]:<EOL><INDENT>self.auto_update=not self.auto_update <EOL>print 'auto_update if',['off','on'][self.auto_update ]<EOL><DEDENT>if ch in [ord('r'),ord('R')]:<EOL><INDENT>self.markers [:]=<EOL>self.markers_vis [:]=self.img <EOL>self.sketch.show()<EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>import sys <EOL>try :<EOL><INDENT>fn=sys.argv []<EOL><DEDENT>except :<EOL><INDENT>fn='<STR_LIT>'<EOL><DEDENT>print __doc__ <EOL>App(fn).run()<EOL><DEDENT><EOF><BOF>import pygame <EOL>from pygame.locals import *<EOL>from py2d.Math import *<EOL>from examples import Example <EOL>class Draw(Example):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,runner):<EOL><INDENT>self.runner=runner <EOL>self.title="Simple Drawing"<EOL>self.poly=Polygon()<EOL><DEDENT>def update(self,time_elapsed):<EOL><INDENT>if self.runner.keys [K_BACKSPACE ]and self.poly.points :<EOL><INDENT>del(self.poly.points [len(self.poly.points)-])<EOL>self.runner.keys [K_BACKSPACE ]=False <EOL><DEDENT> <DEDENT>def render(self):<EOL><INDENT>if len(self.poly)>:<EOL><INDENT>pygame.draw.lines(self.runner.screen,,True,self.poly.as_tuple_list())<EOL><DEDENT>elif self.poly.points :<EOL><INDENT>pygame.draw.circle(self.runner.screen,,self.poly.points [].as_tuple(),)<EOL><DEDENT> <DEDENT>def mouse_down(self,pos,button):<EOL><INDENT>if button==:<EOL><INDENT>self.poly.add_point(Vector(pos [],pos []))<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import cv2 <EOL>import numpy as np <EOL>import sys <EOL>def data_matrix_demo(cap):<EOL><INDENT>window_name='<STR_LIT>'<EOL>frame_number=<EOL>need_to_save=False <EOL>while :<EOL><INDENT>ret,frame=cap.read()<EOL>if not ret :<EOL><INDENT>break <EOL><DEDENT>gray=cv2.cvtColor(frame,cv2.COLOR_RGB2GRAY)<EOL>codes,corners,dmtx=cv2.findDataMatrix(gray)<EOL>cv2.drawDataMatrixCodes(frame,codes,corners)<EOL>cv2.imshow(window_name,frame)<EOL>key=cv2.waitKey()<EOL>c=chr(key &)<EOL>if c in ['q','Q',chr()]:<EOL><INDENT>break <EOL><DEDENT>if c==' ':<EOL><INDENT>need_to_save=True <EOL><DEDENT>if need_to_save and codes :<EOL><INDENT>filename=('<STR_LIT>'%frame_number)<EOL>cv2.imwrite(filename,frame)<EOL>print "Saved frame to "+filename <EOL>need_to_save=False <EOL><DEDENT>frame_number +=<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>if len(sys.argv)==:<EOL><INDENT>cap=cv2.VideoCapture()<EOL><DEDENT>else :<EOL><INDENT>cap=cv2.VideoCapture(sys.argv [])<EOL>if not cap.isOpened():<EOL><INDENT>cap=cv2.VideoCapture(int(sys.argv []))<EOL><DEDENT> <DEDENT>if not cap.isOpened():<EOL><INDENT>print '<STR_LIT>'<EOL>sys.exit(-)<EOL><DEDENT>data_matrix_demo(cap)<EOL><DEDENT><EOF><BOF>from setuptools import setup <EOL>'<STR_LIT>'<EOL>import sys <EOL>from distutils.core import setup <EOL>from codecs import open <EOL>from os import path <EOL>here=path.abspath(path.dirname(__file__))<EOL>with open(path.join(here,'README.md'),encoding='utf-8')as f :<EOL><INDENT>long_description=f.read()<EOL><DEDENT>setup(<EOL>name='webb',<EOL>version='0.9.2.5',<EOL>description='<STR_LIT>',<EOL>author='Hardik Vasa',<EOL>maintainer='Hardik Vasa',<EOL>author_email='<STR_LIT>',<EOL>long_description=long_description,<EOL>license='<STR_LIT>',<EOL>url='<STR_LIT>',<EOL>keywords='<STR_LIT>',<EOL>classifiers=[<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>],<EOL>zip_safe=False,<EOL>packages=['webb'],)<EOF><BOF>class CommentCache(object):<EOL><INDENT>def __init__(self):<EOL><INDENT>self._comments=[]<EOL><DEDENT>def add(self,comment):<EOL><INDENT>self._comments.append(comment)<EOL><DEDENT>def consume_with(self,function):<EOL><INDENT>map(function,self._comments)<EOL>self.__init__()<EOL><DEDENT> <DEDENT>class Comments(object):<EOL><INDENT>def __init__(self):<EOL><INDENT>self._comments=[]<EOL><DEDENT>def add(self,row):<EOL><INDENT>if row.comments :<EOL><INDENT>self._comments.extend(c.strip()for c in row.comments if c.strip())<EOL><DEDENT> <DEDENT>@property <EOL>def value(self):<EOL><INDENT>return self._comments <EOL><DEDENT> <DEDENT><EOF><BOF>from django.contrib.auth import get_user_model <EOL>from django.core.urlresolvers import reverse <EOL>from django.test import TestCase,override_settings <EOL>from mock import patch <EOL>from buildservice.errors import MissingToken,InvalidStatus <EOL>from buildservice.models import Build,Repository <EOL>from buildservice.utils.testing import create_user_token <EOL>@override_settings(BUILDSERVICE_BASE_URL='<STR_LIT>')<EOL>class BuildTestCase(TestCase):<EOL><INDENT>def setUp(self):<EOL><INDENT>self.user=get_user_model().objects.create_user('user',password='pwd')<EOL>self.repo=Repository.objects.create(name='john-doe/repo')<EOL>self.repo.users.add(self.user)<EOL>self.build=Build.objects.create(<EOL>repository=self.repo,<EOL>pusher_name='john-doe',<EOL>branch='master',<EOL>sha='<STR_LIT>',<EOL>number=)<EOL><DEDENT>def test_pusher_profile_url(self):<EOL><INDENT>self.assertEqual(self.build.pusher_profile_url,'<STR_LIT>')<EOL><DEDENT>def test_url(self):<EOL><INDENT>build_detail=reverse('build_detail',args=[self.repo.name,self.build.number ])<EOL>self.assertEqual(self.build.url,'<STR_LIT>'%build_detail)<EOL><DEDENT>def test_is_success_yes(self):<EOL><INDENT>self.build.status='success'<EOL>self.assertTrue(self.build.is_success)<EOL><DEDENT>def test_is_success_no(self):<EOL><INDENT>self.assertFalse(self.build.is_success)<EOL><DEDENT>def test_is_pending_yes(self):<EOL><INDENT>self.assertTrue(self.build.is_pending)<EOL><DEDENT>def test_is_pending_no(self):<EOL><INDENT>self.build.status='errored'<EOL>self.assertFalse(self.build.is_pending)<EOL><DEDENT>def test_short_sha(self):<EOL><INDENT>self.assertEqual(self.build.short_sha,'1234567')<EOL><DEDENT>def test_update_status_no_token(self):<EOL><INDENT>self.assertRaises(MissingToken,self.build.update_status,'something')<EOL><DEDENT>def test_update_status_bad_status(self):<EOL><INDENT>create_user_token(self.user,self.repo)<EOL>self.assertRaises(InvalidStatus,self.build.update_status,'something')<EOL>self.build.refresh_from_db()<EOL>self.assertEqual(self.build.status,'pending')<EOL><DEDENT>@patch('<STR_LIT>')<EOL>def test_update_status_ok(self,create_status):<EOL><INDENT>token=create_user_token(self.user,self.repo)<EOL>self.build.update_status('success')<EOL>self.build.refresh_from_db()<EOL>self.assertEqual(self.build.status,'success')<EOL>create_status.assert_called_with(<EOL>token.value,'john-doe/repo',self.build.sha,<EOL>state='success',target_url=self.build.url )<EOL><DEDENT> <DEDENT><EOF><BOF>def climebox_usage():<EOL><INDENT>clime.Program().printusage()<EOL><DEDENT>def climebox_dirname(file_name):<EOL><INDENT>print(os.path.dirname(file_name))<EOL><DEDENT>def climebox_false():<EOL><INDENT>exit()<EOL><DEDENT>def climebox_pwd():<EOL><INDENT>print(os.getcwd())<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>import clime <EOL>import sys,os <EOL>import inspect <EOL>execname=os.path.basename(sys.argv [])<EOL>if execname=='climebox'or execname=='climebox.py':<EOL><INDENT>clime.Program(defcmdname='climebox_usage').main()<EOL>exit()<EOL><DEDENT>import __main__ <EOL>for cmdname in clime.Program().cmdfs.keys():<EOL><INDENT>attr=getattr(__main__,cmdname)<EOL>cmdname='climebox_'+execname <EOL>if cmdname==attr.func_name :<EOL><INDENT>clime.Program(defcmdname=cmdname,progname=execname).main()<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import sys <EOL>BLUE=[,,]<EOL>RED=[,,]<EOL>GREEN=[,,]<EOL>BLACK=[,,]<EOL>WHITE=[,,]<EOL>DRAW_BG={'color':BLACK,'val':}<EOL>DRAW_FG={'color':WHITE,'val':}<EOL>DRAW_PR_FG={'color':GREEN,'val':}<EOL>DRAW_PR_BG={'color':RED,'val':}<EOL>rect=(,,,)<EOL>drawing=False <EOL>rectangle=False <EOL>rect_over=False <EOL>rect_or_mask=<EOL>value=DRAW_FG <EOL>thickness=<EOL>def onmouse(event,x,y,flags,param):<EOL><INDENT>global img,img2,drawing,value,mask,rectangle,rect,rect_or_mask,ix,iy,rect_over <EOL>if event==cv2.EVENT_RBUTTONDOWN :<EOL><INDENT>rectangle=True <EOL>ix,iy=x,y <EOL><DEDENT>elif event==cv2.EVENT_MOUSEMOVE :<EOL><INDENT>if rectangle==True :<EOL><INDENT>img=img2.copy()<EOL>cv2.rectangle(img,(ix,iy),(x,y),BLUE,)<EOL>rect=(ix,iy,abs(ix -x),abs(iy -y))<EOL>rect_or_mask=<EOL><DEDENT> <DEDENT>elif event==cv2.EVENT_RBUTTONUP :<EOL><INDENT>rectangle=False <EOL>rect_over=True <EOL>cv2.rectangle(img,(ix,iy),(x,y),BLUE,)<EOL>rect=(ix,iy,abs(ix -x),abs(iy -y))<EOL>rect_or_mask=<EOL>print '<STR_LIT>'<EOL><DEDENT>if event==cv2.EVENT_LBUTTONDOWN :<EOL><INDENT>if rect_over==False :<EOL><INDENT>print '<STR_LIT>'<EOL><DEDENT>else :<EOL><INDENT>drawing=True <EOL>cv2.circle(img,(x,y),thickness,value ['color'],-)<EOL>cv2.circle(mask,(x,y),thickness,value ['val'],-)<EOL><DEDENT> <DEDENT>elif event==cv2.EVENT_MOUSEMOVE :<EOL><INDENT>if drawing==True :<EOL><INDENT>cv2.circle(img,(x,y),thickness,value ['color'],-)<EOL>cv2.circle(mask,(x,y),thickness,value ['val'],-)<EOL><DEDENT> <DEDENT>elif event==cv2.EVENT_LBUTTONUP :<EOL><INDENT>if drawing==True :<EOL><INDENT>drawing=False <EOL>cv2.circle(img,(x,y),thickness,value ['color'],-)<EOL>cv2.circle(mask,(x,y),thickness,value ['val'],-)<EOL><DEDENT> <DEDENT> <DEDENT>print __doc__ <EOL>if len(sys.argv)==:<EOL><INDENT>filename=sys.argv []<EOL><DEDENT>else :<EOL><INDENT>print '<STR_LIT>'<EOL>print '<STR_LIT>'<EOL>filename='../cpp/lena.jpg'<EOL><DEDENT>img=cv2.imread(filename)<EOL>img2=img.copy()<EOL>mask=np.zeros(img.shape [:],dtype=np.uint8)<EOL>output=np.zeros(img.shape,np.uint8)<EOL>cv2.namedWindow('output')<EOL>cv2.namedWindow('input')<EOL>cv2.setMouseCallback('input',onmouse)<EOL>cv2.moveWindow('input',img.shape []+,)<EOL>print '<STR_LIT>'<EOL>print '<STR_LIT>'<EOL>while():<EOL><INDENT>cv2.imshow('output',output)<EOL>cv2.imshow('input',img)<EOL>k=&cv2.waitKey()<EOL>if k==:<EOL><INDENT>break <EOL><DEDENT>elif k==ord('0'):<EOL><INDENT>print '<STR_LIT>'<EOL>value=DRAW_BG <EOL><DEDENT>elif k==ord('1'):<EOL><INDENT>print '<STR_LIT>'<EOL>value=DRAW_FG <EOL><DEDENT>elif k==ord('2'):<EOL><INDENT>value=DRAW_PR_BG <EOL><DEDENT>elif k==ord('3'):<EOL><INDENT>value=DRAW_PR_FG <EOL><DEDENT>elif k==ord('s'):<EOL><INDENT>bar=np.zeros((img.shape [],,),np.uint8)<EOL>res=np.hstack((img2,bar,img,bar,output))<EOL>cv2.imwrite('<STR_LIT>',res)<EOL>print '<STR_LIT>'<EOL><DEDENT>elif k==ord('r'):<EOL><INDENT>print "resetting \n"<EOL>rect=(,,,)<EOL>drawing=False <EOL>rectangle=False <EOL>rect_or_mask=<EOL>rect_over=False <EOL>value=DRAW_FG <EOL>img=img2.copy()<EOL>mask=np.zeros(img.shape [:],dtype=np.uint8)<EOL>output=np.zeros(img.shape,np.uint8)<EOL><DEDENT>elif k==ord('n'):<EOL><INDENT>print '<STR_LIT>'<EOL>if(rect_or_mask==):<EOL><INDENT>bgdmodel=np.zeros((,),np.float64)<EOL>fgdmodel=np.zeros((,),np.float64)<EOL>cv2.grabCut(img2,mask,rect,bgdmodel,fgdmodel,,cv2.GC_INIT_WITH_RECT)<EOL>rect_or_mask=<EOL><DEDENT>elif rect_or_mask==:<EOL><INDENT>bgdmodel=np.zeros((,),np.float64)<EOL>fgdmodel=np.zeros((,),np.float64)<EOL>cv2.grabCut(img2,mask,rect,bgdmodel,fgdmodel,,cv2.GC_INIT_WITH_MASK)<EOL><DEDENT> <DEDENT>mask2=np.where((mask==)+(mask==),,).astype('uint8')<EOL>output=cv2.bitwise_and(img2,img2,mask=mask2)<EOL><DEDENT>cv2.destroyAllWindows()<EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import video <EOL>from common import anorm2,draw_str <EOL>from time import clock <EOL>lk_params=dict(winSize=(,),<EOL>maxLevel=,<EOL>criteria=(cv2.TERM_CRITERIA_EPS |cv2.TERM_CRITERIA_COUNT,,))<EOL>feature_params=dict(maxCorners=,<EOL>qualityLevel=,<EOL>minDistance=,<EOL>blockSize=)<EOL>class App :<EOL><INDENT>def __init__(self,video_src):<EOL><INDENT>self.track_len=<EOL>self.detect_interval=<EOL>self.tracks=[]<EOL>self.cam=video.create_capture(video_src)<EOL>self.frame_idx=<EOL><DEDENT>def run(self):<EOL><INDENT>while True :<EOL><INDENT>ret,frame=self.cam.read()<EOL>frame_gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)<EOL>vis=frame.copy()<EOL>if len(self.tracks)>:<EOL><INDENT>img0,img1=self.prev_gray,frame_gray <EOL>p0=np.float32([tr [-]for tr in self.tracks ]).reshape(-,,)<EOL>p1,st,err=cv2.calcOpticalFlowPyrLK(img0,img1,p0,None,**lk_params)<EOL>p0r,st,err=cv2.calcOpticalFlowPyrLK(img1,img0,p1,None,**lk_params)<EOL>d=abs(p0 -p0r).reshape(-,).max(-)<EOL>good=d <<EOL>new_tracks=[]<EOL>for tr,(x,y),good_flag in zip(self.tracks,p1.reshape(-,),good):<EOL><INDENT>if not good_flag :<EOL><INDENT>continue <EOL><DEDENT>tr.append((x,y))<EOL>if len(tr)>self.track_len :<EOL><INDENT>del tr []<EOL><DEDENT>new_tracks.append(tr)<EOL>cv2.circle(vis,(x,y),,(,,),-)<EOL><DEDENT>self.tracks=new_tracks <EOL>cv2.polylines(vis,[np.int32(tr)for tr in self.tracks ],False,(,,))<EOL>draw_str(vis,(,),'track count: %d'%len(self.tracks))<EOL><DEDENT>if self.frame_idx %self.detect_interval==:<EOL><INDENT>mask=np.zeros_like(frame_gray)<EOL>mask [:]=<EOL>for x,y in [np.int32(tr [-])for tr in self.tracks ]:<EOL><INDENT>cv2.circle(mask,(x,y),,,-)<EOL><DEDENT>p=cv2.goodFeaturesToTrack(frame_gray,mask=mask,**feature_params)<EOL>if p is not None :<EOL><INDENT>for x,y in np.float32(p).reshape(-,):<EOL><INDENT>self.tracks.append([(x,y)])<EOL><DEDENT> <DEDENT> <DEDENT>self.frame_idx +=<EOL>self.prev_gray=frame_gray <EOL>cv2.imshow('lk_track',vis)<EOL>ch=&cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>def main():<EOL><INDENT>import sys <EOL>try :<EOL><INDENT>video_src=sys.argv []<EOL><DEDENT>except :<EOL><INDENT>video_src=<EOL><DEDENT>print __doc__ <EOL>App(video_src).run()<EOL>cv2.destroyAllWindows()<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>main()<EOL><DEDENT><EOF><BOF>import cv2 <EOL>import numpy as np <EOL>from screen_finder.screen_finder import ScreenFinder <EOL>from cam import OpenCV_Cam <EOL>def draw_burning(canvas,location):<EOL><INDENT>cv2.circle(canvas,(lx,ly),,(,,,))<EOL>return canvas <EOL><DEDENT>def find_laser_loc(img,threshold):<EOL><INDENT>red_part=img [:,:,]<EOL>max_pos=red_part.argmax()<EOL>ly,lx=np.unravel_index(max_pos,red_part.shape)<EOL>if red_part [ly,lx ]<threshold :<EOL><INDENT>return None <EOL><DEDENT>return np.array([lx,ly ])<EOL><DEDENT>def find_threshold(cam):<EOL><INDENT>img=cam.read()<EOL>hx,hy=find_laser_loc(img,)<EOL>threshold=img [hy,hx,]+<EOL>print '<STR_LIT>',threshold <EOL>return threshold <EOL><DEDENT>background=cv2.imread('wood.png')<EOL>cv2.imshow('Burn this page!',background)<EOL>sf=ScreenFinder()<EOL>sf.set_screen_img(background)<EOL>cam=OpenCV_Cam()<EOL>cam.size=,<EOL>img=cam.read()<EOL>sf.find_screen_img(img)<EOL>sf.find_screen_loop(cam,False)<EOL>bs=background.shape <EOL>canvas=np.full((bs [],bs [],),,dtype=np.uint8)<EOL>thresh=find_threshold(cam)<EOL>show_top_view,show_cam_view=False,False <EOL>while True :<EOL><INDENT>img=cam.read()<EOL>if show_cam_view :<EOL><INDENT>cv2.imshow('Cam view',img)<EOL><DEDENT>if show_top_view :<EOL><INDENT>top_view=sf.screen_top_view(img)<EOL>cv2.imshow('Top view',top_view)<EOL><DEDENT>cam_laser=find_laser_loc(img,thresh)<EOL>if cam_laser is not None :<EOL><INDENT>lx,ly=tuple(sf.reverse_transform(cam_laser).reshape(-))<EOL>background=draw_burning(background,(lx,ly))<EOL><DEDENT>cv2.imshow('Burn this page!',background)<EOL>k=cv2.waitKey()<EOL>if k==ord('a'):<EOL><INDENT>sf.find_screen_loop(cam,False)<EOL>thresh=find_threshold(cam)<EOL><DEDENT>elif k==ord('s'):<EOL><INDENT>background=cv2.imread('wood.png')<EOL><DEDENT>elif k==ord('d'):<EOL><INDENT>show_top_view=not show_top_view <EOL>if show_top_view is False :<EOL><INDENT>cv2.destroyWindow('Top view')<EOL><DEDENT> <DEDENT>elif k==ord('f'):<EOL><INDENT>show_cam_view=not show_cam_view <EOL>if show_cam_view is False :<EOL><INDENT>cv2.destroyWindow('Cam view')<EOL><DEDENT> <DEDENT>elif k==:<EOL><INDENT>break <DEDENT> <DEDENT><EOF><BOF>from collections import defaultdict <EOL>from pprint import pprint <EOL>def print_report(target_dict,key=None):<EOL><INDENT>len_pairs=len(target_dict)<EOL>print '<STR_LIT>'.format(len_pairs)<EOL>print <EOL>lenio_count_map=defaultdict(int)<EOL>for k,v in target_dict.iteritems():<EOL><INDENT>lenio_count_map [(len(k),len(v))]+=<EOL><DEDENT>total_count=sum(lenio_count_map.itervalues())<EOL>print '<STR_LIT>'<EOL>print <EOL>cum_pct=<EOL>for lenio,count in sorted(lenio_count_map.iteritems(),key=key):<EOL><INDENT>pct=*count /total_count <EOL>cum_pct +=pct <EOL>print '<STR_LIT>'.format(lenio,count,pct,cum_pct)<EOL><DEDENT>print <EOL>print 'Total  : {:>6,}'.format(total_count)<EOL>print '<STR_LIT>'.format(*total_count /len(lenio_count_map))<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>from time import time <EOL>start=time()<EOL>import zipcodetw <EOL>end=time()<EOL>print '<STR_LIT>'.format(end -start)<EOL>print <EOL>print '<STR_LIT>'<EOL>print <EOL>print_report(zipcodetw._dir.tokens_rzpairs_map)<EOL>print <EOL>print <EOL>print '<STR_LIT>'<EOL>print <EOL>print_report(zipcodetw._dir.tokens_gzipcode_map,key=lambda p :(p [][],-p [][]))<EOL><DEDENT><EOF><BOF>import logging <EOL>from robot.api import logger <EOL>from robot import utils <EOL>LEVELS={'TRACE':logging.NOTSET,<EOL>'DEBUG':logging.DEBUG,<EOL>'INFO':logging.INFO,<EOL>'WARN':logging.WARNING }<EOL>def initialize(level):<EOL><INDENT>logging.raiseExceptions=False <EOL>logging.getLogger().addHandler(RobotHandler())<EOL>set_level(level)<EOL><DEDENT>def set_level(level):<EOL><INDENT>try :<EOL><INDENT>level=LEVELS [level.upper()]<EOL><DEDENT>except KeyError :<EOL><INDENT>return <EOL><DEDENT>logging.getLogger().setLevel(level)<EOL><DEDENT>class RobotHandler(logging.Handler):<EOL><INDENT>def emit(self,record):<EOL><INDENT>message,error=self._get_message(record)<EOL>method=self._get_logger_method(record.levelno)<EOL>method(message)<EOL>if error :<EOL><INDENT>logger.debug(error)<EOL><DEDENT> <DEDENT>def _get_message(self,record):<EOL><INDENT>try :<EOL><INDENT>return record.getMessage(),None <EOL><DEDENT>except :<EOL><INDENT>message='<STR_LIT>'%utils.unic(record.msg)<EOL>error='\n'.join(utils.get_error_details())<EOL>return message,error <EOL><DEDENT> <DEDENT>def _get_logger_method(self,level):<EOL><INDENT>if level >=logging.WARNING :<EOL><INDENT>return logger.warn <EOL><DEDENT>if level >=logging.INFO :<EOL><INDENT>return logger.info <EOL><DEDENT>if level >=logging.DEBUG :<EOL><INDENT>return logger.debug <EOL><DEDENT>return logger.trace <EOL><DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from functools import wraps <EOL>import hashlib <EOL>import hmac <EOL>import json <EOL>from django.conf import settings <EOL>from django.http import HttpResponse,JsonResponse <EOL>from django.shortcuts import redirect <EOL>from buildservice.models import OAuthToken <EOL>def oauth_token_required(func):<EOL><INDENT> '<STR_LIT>'<EOL>@wraps(func)<EOL>def inner(request,*args,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>_=request.user.oauth_token <EOL><DEDENT>except(AttributeError,OAuthToken.DoesNotExist):<EOL><INDENT>return redirect('oauth_login')<EOL><DEDENT>return func(request,*args,**kwargs)<EOL><DEDENT>return inner <EOL><DEDENT>def signature_required(func):<EOL><INDENT> '<STR_LIT>'<EOL>@wraps(func)<EOL>def inner(request,*args,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>signature="sha1=%s"%hmac.new(<EOL>settings.GITHUB_HOOK_SECRET.encode('utf-8'),<EOL>request.body,<EOL>hashlib.sha1 ).hexdigest()<EOL>if signature !=request.META.get('<STR_LIT>'):<EOL><INDENT>return HttpResponse(status=,content='<STR_LIT>')<EOL><DEDENT>return func(request,*args,**kwargs)<EOL><DEDENT>return inner <EOL><DEDENT>def anonymous_user_required(func):<EOL><INDENT> '<STR_LIT>'<EOL>@wraps(func)<EOL>def inner(request,*args,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>if request.user.is_authenticated():<EOL><INDENT>return redirect('home')<EOL><DEDENT>return func(request,*args,**kwargs)<EOL><DEDENT>return inner <EOL><DEDENT>def require_json(func):<EOL><INDENT> '<STR_LIT>'<EOL>@wraps(func)<EOL>def wrapped(request,*args,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>request.json=json.loads(request.body or '{}')<EOL><DEDENT>except(ValueError,TypeError):<EOL><INDENT>return JsonResponse(data={'error':'<STR_LIT>'},status=)<EOL><DEDENT>return func(request,*args,**kwargs)<EOL><DEDENT>return wrapped <EOL><DEDENT>def require_api_key(func):<EOL><INDENT> '<STR_LIT>'<EOL>@wraps(func)<EOL>def wrapped(request,*args,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>if request.GET.get('api_key')!=settings.BUILDSERVICE_API_KEY :<EOL><INDENT>return HttpResponse(status=,content='<STR_LIT>')<EOL><DEDENT>return func(request,*args,**kwargs)<EOL><DEDENT>return wrapped <EOL><DEDENT><EOF><BOF>import sys <EOL>sys.path.append("core")<EOL>import os <EOL>import model <EOL>import editor <EOL>import ntpath <EOL>global shadowList <EOL>global createConfig <EOL>createConfig={}<EOL>global context <EOL>def createModule(newContext,newCreateConfig):<EOL><INDENT>global context <EOL>global createConfig <EOL>global shadowList <EOL>context=newContext <EOL>createConfig=newCreateConfig <EOL>if createConfig ["type"]=="script":<EOL><INDENT>packages=context.getScriptPackages()<EOL><DEDENT>elif createConfig ["type"]=="text":<EOL><INDENT>packages=context.getTextPackages()<EOL><DEDENT>context.window.show_quick_panel(packages,onPackageSelected,)<EOL>shadowList=packages <EOL><DEDENT>def onPackageSelected(selectionIndex):<EOL><INDENT>global createConfig <EOL>global shadowList <EOL>moduleSuggestiong=shadowList [selectionIndex ]<EOL>if selectionIndex==-:<EOL><INDENT>return <EOL><DEDENT>if selectionIndex==:<EOL><INDENT>moduleSuggestiong=""<EOL><DEDENT>if createConfig ["type"]=="script":<EOL><INDENT>packagePath=context.getBaseDir()+context.settings ["script_folder"]+"/"+moduleSuggestiong <EOL>if os.path.exists(packagePath)==True :<EOL><INDENT>createConfig ["packageBase"]=context.settings ["script_folder"]<EOL><DEDENT> <DEDENT>elif createConfig ["type"]=="text":<EOL><INDENT>packagePath=context.getBaseDir()+context.settings ["text_folder"]+"/"+moduleSuggestiong <EOL>if os.path.exists(packagePath)==True :<EOL><INDENT>createConfig ["packageBase"]=context.settings ["text_folder"]<EOL><DEDENT> <DEDENT>context.window.show_input_panel('<STR_LIT>',moduleSuggestiong +createConfig ["name"],onNameDone,onNameChange,onNamceCancle)<EOL><DEDENT>def onNameDone(inputString):<EOL><INDENT>global createConfig <EOL>global context <EOL>global shadowList <EOL>moduleFile=context.getBaseDir()+createConfig ["packageBase"]+"/"+inputString <EOL>createConfig ["moduleFile"]=moduleFile <EOL>print moduleFile <EOL>name=moduleFile [moduleFile.rfind("/"):]<EOL>if not "."in name :<EOL><INDENT>if createConfig ["type"]=="script":<EOL><INDENT>ext=".js"<EOL>name +=ext <EOL><DEDENT>elif createConfig ["type"]=="text":<EOL><INDENT>ext=".html"<EOL>name +=ext <EOL><DEDENT> <DEDENT>else :<EOL><INDENT>ext=name [name.rfind("."):]<EOL><DEDENT>moduleDir=moduleFile [:moduleFile.rfind("/")]<EOL>moduleFile=moduleDir +name <EOL>createConfig ["moduleFile"]=moduleFile <EOL>if os.path.exists(moduleDir)==False :<EOL><INDENT>os.makedirs(moduleDir)<EOL><DEDENT>if len(context.settings ['<STR_LIT>'])>:<EOL><INDENT>snippetsDir=context.getBaseDir()+context.settings ['<STR_LIT>']<EOL>snippets=[]<EOL>shadowList=[]<EOL>snippets.append("Blank")<EOL>shadowList.append("")<EOL>for file in os.listdir(snippetsDir):<EOL><INDENT>dirfile=os.path.join(snippetsDir,file)<EOL>if os.path.isfile(dirfile):<EOL><INDENT>print "TEST.="+str(ntpath.basename(file)[:]),str(ntpath.basename(file)[:])is "."<EOL>if "DS_Store"not in ntpath.basename(file):<EOL><INDENT>snippets.append(ntpath.basename(file))<EOL>shadowList.append(dirfile)<EOL><DEDENT> <DEDENT> <DEDENT>context.window.show_quick_panel(snippets,onSnippetSelected,)<EOL><DEDENT>else :<EOL><INDENT>finish("")<EOL><DEDENT> <DEDENT>def onSnippetSelected(selectionIndex):<EOL><INDENT>global shadowList <EOL>if selectionIndex==:<EOL><INDENT>finish("")<EOL><DEDENT>else :<EOL><INDENT>moduleName=createConfig ["moduleFile"][createConfig ["moduleFile"].rfind("/")+:createConfig ["moduleFile"].rfind(".")]<EOL>f=open(shadowList [selectionIndex ],"r")<EOL>data=f.read()<EOL>snippet=data <EOL>snippet=snippet.replace("$MODULE_NAME",moduleName)<EOL>f.close()<EOL>finish(snippet)<EOL><DEDENT> <DEDENT>def finish(snippet):<EOL><INDENT>global createConfig <EOL>global context <EOL>fileContent=""<EOL>if createConfig ["type"]=="script":<EOL><INDENT>fileContent='<STR_LIT>'<EOL>if len(context.settings ["auto_add"])>:<EOL><INDENT>for module in context.settings ["auto_add"]:<EOL><INDENT>addEdit=editor.ModuleEdit(fileContent,context)<EOL>addEdit.addModule(context.getModuleByImportString(module),module)<EOL>fileContent=addEdit.render()+"\n"+snippet +"\n});"<EOL><DEDENT> <DEDENT> <DEDENT>file=open(createConfig ["moduleFile"],'w+')<EOL>file.write(fileContent)<EOL>file.close()<EOL>if createConfig ["type"]=="script":<EOL><INDENT>temp=(createConfig ["moduleFile"]).split(context.getBaseDir()+createConfig ["packageBase"]+"/")[];<EOL>importString=temp [:temp.rfind(".")]<EOL><DEDENT>elif createConfig ["type"]=="text":<EOL><INDENT>temp=(createConfig ["moduleFile"]).split(context.getBaseDir()+createConfig ["packageBase"]+"/")[];<EOL>importString="text!"+context.settings ["texts_name"]+"/"+temp <EOL><DEDENT>createConfig ["callback"](importString,createConfig)<EOL><DEDENT>def onNameChange(input):<EOL><INDENT>pass <EOL><DEDENT>def onNamceCancle(input):<EOL><INDENT>pass <EOL><DEDENT><EOF><BOF>from zerotest.cli import CLI <EOL>class AttributeDict(object):<EOL><INDENT>def __init__(self,**kwargs):<EOL><INDENT>self.__dict__=kwargs <EOL><DEDENT> <DEDENT>def test_verify_parse_result():<EOL><INDENT>cli=CLI()<EOL>cli._parse_result=AttributeDict(url='invalid.url')<EOL>assert not cli.verify_parse_result()<EOL>cli._parse_result=AttributeDict(url='<STR_LIT>')<EOL>assert cli.verify_parse_result()<EOL>cli._parse_result=AttributeDict(endpoint='invalid.url')<EOL>assert not cli.verify_parse_result()<EOL>cli._parse_result=AttributeDict(endpoint='<STR_LIT>')<EOL>assert cli.verify_parse_result()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>from multiprocessing.pool import ThreadPool <EOL>from digits import *<EOL>try :<EOL><INDENT>import cloud <EOL>have_cloud=True <EOL><DEDENT>except ImportError :<EOL><INDENT>have_cloud=False <EOL><DEDENT>def cross_validate(model_class,params,samples,labels,kfold=,pool=None):<EOL><INDENT>n=len(samples)<EOL>folds=np.array_split(np.arange(n),kfold)<EOL>def f(i):<EOL><INDENT>model=model_class(**params)<EOL>test_idx=folds [i ]<EOL>train_idx=list(folds)<EOL>train_idx.pop(i)<EOL>train_idx=np.hstack(train_idx)<EOL>train_samples,train_labels=samples [train_idx ],labels [train_idx ]<EOL>test_samples,test_labels=samples [test_idx ],labels [test_idx ]<EOL>model.train(train_samples,train_labels)<EOL>resp=model.predict(test_samples)<EOL>score=(resp !=test_labels).mean()<EOL>print ".",<EOL>return score <EOL><DEDENT>if pool is None :<EOL><INDENT>scores=map(f,xrange(kfold))<EOL><DEDENT>else :<EOL><INDENT>scores=pool.map(f,xrange(kfold))<EOL><DEDENT>return np.mean(scores)<EOL><DEDENT>class App(object):<EOL><INDENT>def __init__(self,usecloud=False,cloud_env=''):<EOL><INDENT>if usecloud and not have_cloud :<EOL><INDENT>print '<STR_LIT>'<EOL>usecloud=False <EOL><DEDENT>self.usecloud=usecloud <EOL>self.cloud_env=cloud_env <EOL>if self.usecloud :<EOL><INDENT>print '<STR_LIT>'<EOL>cloud.files.put(DIGITS_FN)<EOL>self.preprocess_job=cloud.call(self.preprocess,_env=self.cloud_env)<EOL><DEDENT>else :<EOL><INDENT>self._samples,self._labels=self.preprocess()<EOL><DEDENT> <DEDENT>def preprocess(self):<EOL><INDENT>if self.usecloud :<EOL><INDENT>cloud.files.get(DIGITS_FN)<EOL><DEDENT>digits,labels=load_digits(DIGITS_FN)<EOL>shuffle=np.random.permutation(len(digits))<EOL>digits,labels=digits [shuffle ],labels [shuffle ]<EOL>digits2=map(deskew,digits)<EOL>samples=preprocess_hog(digits2)<EOL>return samples,labels <EOL><DEDENT>def get_dataset(self):<EOL><INDENT>if self.usecloud :<EOL><INDENT>return cloud.result(self.preprocess_job)<EOL><DEDENT>else :<EOL><INDENT>return self._samples,self._labels <EOL><DEDENT> <DEDENT>def run_jobs(self,f,jobs):<EOL><INDENT>if self.usecloud :<EOL><INDENT>jids=cloud.map(f,jobs,_env=self.cloud_env,_profile=True,_depends_on=self.preprocess_job)<EOL>ires=cloud.iresult(jids)<EOL><DEDENT>else :<EOL><INDENT>pool=ThreadPool(processes=cv2.getNumberOfCPUs())<EOL>ires=pool.imap_unordered(f,jobs)<EOL><DEDENT>return ires <EOL><DEDENT>def adjust_SVM(self):<EOL><INDENT>Cs=np.logspace(,,,base=)<EOL>gammas=np.logspace(-,,,base=)<EOL>scores=np.zeros((len(Cs),len(gammas)))<EOL>scores [:]=np.nan <EOL>print '<STR_LIT>'<EOL>def f(job):<EOL><INDENT>i,j=job <EOL>samples,labels=self.get_dataset()<EOL>params=dict(C=Cs [i ],gamma=gammas [j ])<EOL>score=cross_validate(SVM,params,samples,labels)<EOL>return i,j,score <EOL><DEDENT>ires=self.run_jobs(f,np.ndindex(*scores.shape))<EOL>for count,(i,j,score)in enumerate(ires):<EOL><INDENT>scores [i,j ]=score <EOL>print '<STR_LIT>'%(count +,scores.size,np.nanmin(scores)*,score *)<EOL><DEDENT>print scores <EOL>print '<STR_LIT>'<EOL>np.savez('svm_scores.npz',scores=scores,Cs=Cs,gammas=gammas)<EOL>i,j=np.unravel_index(scores.argmin(),scores.shape)<EOL>best_params=dict(C=Cs [i ],gamma=gammas [j ])<EOL>print 'best params:',best_params <EOL>print '<STR_LIT>'%(scores.min()*)<EOL>return best_params <EOL><DEDENT>def adjust_KNearest(self):<EOL><INDENT>print '<STR_LIT>'<EOL>def f(k):<EOL><INDENT>samples,labels=self.get_dataset()<EOL>err=cross_validate(KNearest,dict(k=k),samples,labels)<EOL>return k,err <EOL><DEDENT>best_err,best_k=np.inf,-<EOL>for k,err in self.run_jobs(f,xrange(,)):<EOL><INDENT>if err <best_err :<EOL><INDENT>best_err,best_k=err,k <EOL><DEDENT>print '<STR_LIT>'%(k,err *)<EOL><DEDENT>best_params=dict(k=best_k)<EOL>print 'best params:',best_params,'err: %.2f'%(best_err *)<EOL>return best_params <EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>import getopt <EOL>import sys <EOL>print __doc__ <EOL>args,_=getopt.getopt(sys.argv [:],'',['model=','cloud','env='])<EOL>args=dict(args)<EOL>args.setdefault('--model','svm')<EOL>args.setdefault('--env','')<EOL>if args ['--model']not in ['svm','knearest']:<EOL><INDENT>print '<STR_LIT>'%args ['--model']<EOL>sys.exit()<EOL><DEDENT>t=clock()<EOL>app=App(usecloud='--cloud'in args,cloud_env=args ['--env'])<EOL>if args ['--model']=='knearest':<EOL><INDENT>app.adjust_KNearest()<EOL><DEDENT>else :<EOL><INDENT>app.adjust_SVM()<EOL><DEDENT>print 'work time: %f s'%(clock()-t)<EOL><DEDENT><EOF><BOF>from robot import model,utils <EOL>from.message import Message <EOL>class Keyword(model.Keyword):<EOL><INDENT>__slots__=['status','starttime','endtime']<EOL>message_class=Message <EOL>def __init__(self,name='',doc='',args=None,type='kw',timeout='',<EOL>status='FAIL',starttime=None,endtime=None):<EOL><INDENT> '<STR_LIT>'<EOL>model.Keyword.__init__(self,name,doc,args,type,timeout)<EOL>self.status=status <EOL>self.starttime=starttime <EOL>self.endtime=endtime <EOL><DEDENT>@property <EOL>def elapsedtime(self):<EOL><INDENT>return utils.get_elapsed_time(self.starttime,self.endtime)<EOL><DEDENT>@property <EOL>def passed(self):<EOL><INDENT>return self.status=='PASS'<EOL><DEDENT> <DEDENT><EOF><BOF>import cv2 <EOL>import numpy as np <EOL>from cam import OpenCV_Cam <EOL>if __name__=='__main__':<EOL><INDENT>cam=OpenCV_Cam()<EOL>w,h=cam.size <EOL>cam.set('EXPOSURE',)<EOL>dst=np.full((h,w,),,dtype=np.uint8)<EOL>exp_list=range(-,-,-)<EOL>ratio=/len(exp_list)<EOL>for e in exp_list :<EOL><INDENT>cam.set('EXPOSURE',e)<EOL>img=None <EOL>while img is None :<EOL><INDENT>img=cam.read()<EOL><DEDENT>dst=cv2.addWeighted(dst,,img,ratio,)<EOL>cv2.imshow(str(e),img)<EOL>cv2.imshow('dst'+str(e),dst)<EOL>cv2.waitKey()<EOL><DEDENT>cv2.imshow('mix',dst)<EOL>k=cv2.waitKey()<DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import cv2 <EOL>import numpy as np <EOL>import sys <EOL>print __doc__ <EOL>try :<EOL><INDENT>fn=sys.argv []<EOL><DEDENT>except :<EOL><INDENT>fn='<STR_LIT>'<EOL><DEDENT>src=cv2.imread(fn,)<EOL>img=cv2.cvtColor(src,cv2.COLOR_BGR2GRAY)<EOL>img=cv2.medianBlur(img,)<EOL>cimg=src.copy()<EOL>circles=cv2.HoughCircles(img,cv2.HOUGH_GRADIENT,,,np.array([]),,,,)<EOL>a,b,c=circles.shape <EOL>for i in range(b):<EOL><INDENT>cv2.circle(cimg,(circles [][i ][],circles [][i ][]),circles [][i ][],(,,),,cv2.LINE_AA)<EOL>cv2.circle(cimg,(circles [][i ][],circles [][i ][]),,(,,),,cv2.LINE_AA)<EOL><DEDENT>cv2.imshow("source",src)<EOL>cv2.imshow('<STR_LIT>',cimg)<EOL>cv2.waitKey()<EOF><BOF>import numpy as np <EOL>import cv2 <EOL>from webcam_gui import webcam_gui <EOL>def edge_filter(frame_in):<EOL><INDENT>frame_gray=cv2.cvtColor(frame_in,cv2.COLOR_BGR2GRAY)<EOL>frame_blur=cv2.blur(frame_gray,(,))<EOL>frame_out=cv2.Canny(frame_blur,,)<EOL>return frame_out <EOL><DEDENT>def threshold(frame_in,min):<EOL><INDENT>frame_blur=cv2.blur(frame_in,(,))<EOL>thresh1,thresh=cv2.threshold(frame_blur,min,,cv2.THRESH_BINARY)<EOL>frame_out=thresh <EOL>return frame_out <EOL><DEDENT>def adap_threshold(frame_in):<EOL><INDENT>frame_blur=cv2.blur(frame_in,(,))<EOL>thresh=cv2.adaptiveThreshold(frame_blur,,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,,)<EOL>frame_out=thresh <EOL>return frame_out <EOL><DEDENT>def canny_filter(frame_in):<EOL><INDENT>frame_blur=cv2.blur(frame_in,(,))<EOL>canny=cv2.Canny(frame_blur,,)<EOL>frame_out=canny <EOL>return frame_out <EOL><DEDENT>def gray_filter(frame_in):<EOL><INDENT>frame_out=cv2.cvtColor(frame_in,cv2.COLOR_BGR2GRAY)<EOL>return frame_out <EOL><DEDENT>def angle_cos(p0,p1,p2):<EOL><INDENT>d1,d2=(p0 -p1).astype('float'),(p2 -p1).astype('float')<EOL>return abs(np.dot(d1,d2)/np.sqrt(np.dot(d1,d1)*np.dot(d2,d2)))<EOL><DEDENT>def equal(p0,p1,p2,tolerance):<EOL><INDENT>d1,d2=(p0 -p1).astype('float'),(p2 -p1).astype('float')<EOL>l1=np.sqrt(d1 []**+d1 []**)<EOL>l2=np.sqrt(d2 []**+d2 []**)<EOL>if l1 <=l2 *(+tolerance)and l1 >=l2 *(-tolerance):<EOL><INDENT>return True <EOL><DEDENT>else :<EOL><INDENT>return False <EOL><DEDENT> <DEDENT>def find_square(frame_in):<EOL><INDENT>frame_out=frame_in.copy()<EOL>frame_gray=cv2.cvtColor(frame_in,cv2.COLOR_BGR2GRAY)<EOL>thresh=adap_threshold(frame_gray)<EOL>frame_blur=cv2.blur(thresh,(,))<EOL>contours,hry=cv2.findContours(frame_blur,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)<EOL>squares=[]<EOL>for cnt in contours :<EOL><INDENT>cnt_len=cv2.arcLength(cnt,True)<EOL>cnt=cv2.approxPolyDP(cnt,*cnt_len,True)<EOL>if cv2.contourArea(cnt)>and len(cnt)==and cv2.isContourConvex(cnt):<EOL><INDENT>cnt=cnt.reshape(-,)<EOL>max_cos=np.max([angle_cos(cnt [i ],cnt [(i +)%],cnt [(i +)%])for i in xrange()])<EOL>if max_cos <and equal(cnt [],cnt [],cnt [],):<EOL><INDENT>squares.append(cnt)<EOL><DEDENT> <DEDENT> <DEDENT>cv2.drawContours(frame_out,squares,-,(,,),)<EOL>return frame_out <EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>webcam_gui(find_square)<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import os <EOL>import yapper as application <EOL>env=os.getenv('FLASK_CONFIG')<EOL>if env is None or env not in ["test","prod"]:<EOL><INDENT>env="dev"<EOL><DEDENT>app=application.create_app(env)<EOL>if __name__=="__main__":<EOL><INDENT>app.run(host="0.0.0.0",port=,debug=True)<EOL><DEDENT><EOF><BOF>from robot.utils import setter <EOL>from.itemlist import ItemList <EOL>from.keyword import Keyword,Keywords <EOL>from.modelobject import ModelObject <EOL>from.tags import Tags <EOL>class TestCase(ModelObject):<EOL><INDENT>__slots__=['parent','name','doc','timeout']<EOL>keyword_class=Keyword <EOL>def __init__(self,name='',doc='',tags=None,timeout=''):<EOL><INDENT>self.parent=None <EOL>self.name=name <EOL>self.doc=doc <EOL>self.tags=tags <EOL>self.timeout=timeout <EOL>self.keywords=[]<EOL><DEDENT>@setter <EOL>def tags(self,tags):<EOL><INDENT>return Tags(tags)<EOL><DEDENT>@setter <EOL>def keywords(self,keywords):<EOL><INDENT>return Keywords(self.keyword_class,self,keywords)<EOL><DEDENT>@property <EOL>def id(self):<EOL><INDENT>if not self.parent :<EOL><INDENT>return 't1'<EOL><DEDENT>return '%s-t%d'%(self.parent.id,self.parent.tests.index(self)+)<EOL><DEDENT>@property <EOL>def longname(self):<EOL><INDENT>if not self.parent :<EOL><INDENT>return self.name <EOL><DEDENT>return '%s.%s'%(self.parent.longname,self.name)<EOL><DEDENT>@property <EOL>def critical(self):<EOL><INDENT>if not self.parent :<EOL><INDENT>return True <EOL><DEDENT>return self.parent.criticality.test_is_critical(self)<EOL><DEDENT>def visit(self,visitor):<EOL><INDENT>visitor.visit_test(self)<EOL><DEDENT> <DEDENT>class TestCases(ItemList):<EOL><INDENT>__slots__=[]<EOL>def __init__(self,test_class=TestCase,parent=None,tests=None):<EOL><INDENT>ItemList.__init__(self,test_class,{'parent':parent },tests)<EOL><DEDENT> <DEDENT><EOF><BOF>from pyspark import SparkConf,SparkContext <EOL>from pyspark.mllib.clustering import LDA,LDAModel <EOL>from pyspark.mllib.linalg import Vectors <EOL>import numpy as np <EOL>def vectorizer(sentence,vocab):<EOL><INDENT> '<STR_LIT>'<EOL>vocabulary=vocab.value <EOL>vec=np.zeros(len(vocabulary))<EOL>for word in sentence.split(" "):<EOL><INDENT>if word in vocabulary :<EOL><INDENT>vec [vocabulary.index(word)]+=<EOL><DEDENT> <DEDENT>return Vectors.dense(vec)<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>conf=SparkConf().setAppName("LDA")<EOL>sc=SparkContext(conf=conf)<EOL>tolstoy=sc.textFile('<STR_LIT>')<EOL>sentences=tolstoy.filter(lambda s :len(s)>)<EOL>word_counts=sentences.flatMap(lambda s :s.split(" ")).map(lambda w :(w.lower(),)).reduceByKey(lambda a,b :a +b)<EOL>top_words=word_counts.takeOrdered(,key=lambda(w,c):-c)<EOL>vocabulary=[str(k)for(k,v)in top_words ]<EOL>br_vocabulary=sc.broadcast(vocabulary)<EOL>dense_vectors=sentences.map(lambda s :vectorizer(s,br_vocabulary))<EOL>corpus=dense_vectors.zipWithIndex().map(lambda(v,i):[i,v ])<EOL>lda_model=LDA.train(corpus,k=,maxIterations=)<EOL>print('<STR_LIT>'+str(lda_model.vocabSize())+" words):")<EOL>topics=lda_model.topicsMatrix()<EOL>for topic in range(topics.shape []):<EOL><INDENT>print("Topic "+str(topic)+":")<EOL>topic_word_counts=sorted(zip(vocabulary,lda_model.topicsMatrix()[:,topic ]),key=lambda(w,c):-c)<EOL>top_words=[w for(w,c)in topic_word_counts [:]]<EOL>print top_words <DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import cv2 <EOL>from time import clock <EOL>class OpenCV_Cam(object):<EOL><INDENT>def __init__(self,src=None):<EOL><INDENT>self.start_cam(src)<EOL>self.__fcount,self.__frate,self.__start=,,clock()<EOL><DEDENT>@staticmethod <EOL>def cam_count():<EOL><INDENT>cam_idx=<EOL>cap=cv2.VideoCapture(cam_idx)<EOL>while cap.read()[]:<EOL><INDENT>cam_idx +=<EOL>cap=cv2.VideoCapture(cam_idx)<EOL><DEDENT>return cam_idx <EOL><DEDENT>def start_cam(self,src=None):<EOL><INDENT>if src is not None :<EOL><INDENT>self.cam=VideoCapture(src)<EOL>if not self.cam.isOpened():<EOL><INDENT>raise ValueError('Cannot open '+src +'as VideoCapture')<EOL><DEDENT>return <EOL><DEDENT>idx=<EOL>cam1,cam2=cv2.VideoCapture(),cv2.VideoCapture()<EOL>while(cam2.read()[]):<EOL><INDENT>cam1.release()<EOL>cam1=cam2 <EOL>idx +=<EOL>cam2=cv2.VideoCapture(idx)<EOL><DEDENT>self.cam=cam1 <EOL>if not self.cam.isOpened():<EOL><INDENT>raise Error('<STR_LIT>')<EOL><DEDENT> <DEDENT>@property <EOL>def size(self):<EOL><INDENT>w=self.cam.get(cv2.cv.CV_CAP_PROP_FRAME_WIDTH)<EOL>h=self.cam.get(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT)<EOL>return(int(w),int(h))<EOL><DEDENT>@size.setter <EOL>def size(self,shape):<EOL><INDENT>self.cam.set(cv2.cv.CV_CAP_PROP_FRAME_WIDTH,shape [])<EOL>self.cam.set(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT,shape [])<EOL><DEDENT>def read(self):<EOL><INDENT>self.__fcount +=<EOL>self.__frame=self.cam.read()[]<EOL>if self.__fcount==:<EOL><INDENT>end=clock()<EOL>self.__frate=/(end -self.__start)<EOL>self.__start=clock()<EOL>self.__fcount=<EOL><DEDENT>return self.__frame <EOL><DEDENT>@property <EOL>def frame_rate(self):<EOL><INDENT>return self.__frate <EOL><DEDENT>@property <EOL>def info(self):<EOL><INDENT>vars=[x [:]for x in dir(cv2.cv)if 'CV_CAP_PROP'in x ]<EOL>ret={}<EOL>for p in vars :<EOL><INDENT>cmd='ret[\''+p +'<STR_LIT>'+p +')'<EOL>exec cmd <EOL><DEDENT>return ret <EOL><DEDENT>def set(self,property,value):<EOL><INDENT>cmd='<STR_LIT>'+property +', '+str(value)+')'<EOL>print cmd <EOL>exec cmd <EOL><DEDENT>def cam_loop(self,func=lambda x :x,params=()):<EOL><INDENT>while True :<EOL><INDENT>input=self.read()<EOL>output=func(input,*params)<EOL>window_name=func.__name__ <EOL>if window_name=='<lambda>':window_name='camera image'<EOL>cv2.imshow(window_name,output)<EOL>k=cv2.waitKey()<EOL>if k==:<EOL><INDENT>break <EOL><DEDENT>elif k==ord('p'):<EOL><INDENT>info=self.info <EOL>for i in info :<EOL><INDENT>print i,'=',info [i ]<EOL><DEDENT> <DEDENT>elif k==ord('s'):<EOL><INDENT>p=raw_input('type property:')<EOL>if('<STR_LIT>'+p)not in dir(cv2.cv):<EOL><INDENT>print p,'<STR_LIT>'<EOL>print '<STR_LIT>',[x [:]for x in dir(cv2.cv)if 'CV_CAP_PROP'in x ]<EOL><DEDENT>else :<EOL><INDENT>v=raw_input('type value:')<EOL>self.set(p,v)<EOL><DEDENT> <DEDENT>elif k==ord('f'):<EOL><INDENT>print self.frame_rate <EOL><DEDENT> <DEDENT> <DEDENT>def __enter__(self):<EOL><INDENT>return self <EOL><DEDENT>def __exit__(self,exc_type,exc_value,traceback):<EOL><INDENT>self.cam.release()<EOL><DEDENT>def release(self):<EOL><INDENT>self.cam.release()<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>cam=OpenCV_Cam()<EOL>cam.size=(,)<EOL>info=cam.info <EOL>for i in info :<EOL><INDENT>print i,'=',info [i ]<EOL><DEDENT>cam.cam_loop()<EOL><DEDENT><EOF><BOF>import unittest <EOL>from yapper import create_app,db <EOL>from yapper.blueprints.user.models import User,Role <EOL>class TestUserAddToDb(unittest.TestCase):<EOL><INDENT>def setUp(self):<EOL><INDENT>self.app=create_app('test')<EOL>self.app_context=self.app.app_context()<EOL>self.app_context.push()<EOL>db.create_all()<EOL><DEDENT>def tearDown(self):<EOL><INDENT>db.session.remove()<EOL>db.drop_all()<EOL>self.app_context.pop()<EOL><DEDENT>def test_role_gets_id(self):<EOL><INDENT>role=Role(name='admin')<EOL>self.assertTrue(role.id is None)<EOL>db.session.add(role)<EOL>db.session.commit()<EOL>self.assertFalse(role.id is None)<EOL><DEDENT>def test_user_gets_role_and_id(self):<EOL><INDENT>role=Role(name='administrator')<EOL>self.assertTrue(role.id is None)<EOL>user=User(email='b2@gmail.com',password='1234',role=role)<EOL>self.assertTrue(user.id is None)<EOL>db.session.add(user)<EOL>db.session.commit()<EOL>self.assertFalse(role.id is None)<EOL>self.assertFalse(user.id is None)<EOL>self.assertTrue(user.role_id==role.id)<EOL>self.assertTrue(user.is_admin())<EOL><DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import cv2 <EOL>from time import clock <EOL>class OpenCV_Cam(object):<EOL><INDENT>def __init__(self,src=None):<EOL><INDENT>self.start_cam(src)<EOL>self.__fcount,self.__frate,self.__start=,,clock()<EOL><DEDENT>@staticmethod <EOL>def cam_count():<EOL><INDENT>cam_idx=<EOL>cap=cv2.VideoCapture(cam_idx)<EOL>while cap.read()[]:<EOL><INDENT>cam_idx +=<EOL>cap=cv2.VideoCapture(cam_idx)<EOL><DEDENT>return cam_idx <EOL><DEDENT>def start_cam(self,src=None):<EOL><INDENT>if src is not None :<EOL><INDENT>self.cam=cv2.VideoCapture(src)<EOL>if not self.cam.isOpened():<EOL><INDENT>raise ValueError('Cannot open '+src +'as VideoCapture')<EOL><DEDENT>return <EOL><DEDENT>idx=<EOL>cam1,cam2=cv2.VideoCapture(),cv2.VideoCapture()<EOL>while(cam2.read()[]):<EOL><INDENT>cam1.release()<EOL>cam1=cam2 <EOL>idx +=<EOL>cam2=cv2.VideoCapture(idx)<EOL><DEDENT>self.cam=cam1 <EOL>if not self.cam.isOpened():<EOL><INDENT>raise Error('<STR_LIT>')<EOL><DEDENT> <DEDENT>@property <EOL>def size(self):<EOL><INDENT>w=self.cam.get(cv2.cv.CV_CAP_PROP_FRAME_WIDTH)<EOL>h=self.cam.get(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT)<EOL>return(int(w),int(h))<EOL><DEDENT>@size.setter <EOL>def size(self,shape):<EOL><INDENT>self.cam.set(cv2.cv.CV_CAP_PROP_FRAME_WIDTH,shape [])<EOL>self.cam.set(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT,shape [])<EOL><DEDENT>def read(self):<EOL><INDENT>self.__fcount +=<EOL>self.__frame=self.cam.read()[]<EOL>if self.__fcount==:<EOL><INDENT>end=clock()<EOL>self.__frate=/(end -self.__start)<EOL>self.__start=clock()<EOL>self.__fcount=<EOL><DEDENT>return self.__frame <EOL><DEDENT>@property <EOL>def frame_rate(self):<EOL><INDENT>return self.__frate <EOL><DEDENT>@property <EOL>def info(self):<EOL><INDENT>vars=[x [:]for x in dir(cv2.cv)if 'CV_CAP_PROP'in x ]<EOL>ret={}<EOL>for p in vars :<EOL><INDENT>cmd='ret[\''+p +'<STR_LIT>'+p +')'<EOL>exec cmd <EOL><DEDENT>return ret <EOL><DEDENT>def set(self,property,value):<EOL><INDENT>cmd='<STR_LIT>'+property +', '+str(value)+')'<EOL>print cmd <EOL>exec cmd <EOL><DEDENT>def cam_loop(self,func=lambda x :x,params=()):<EOL><INDENT>while True :<EOL><INDENT>input=self.read()<EOL>output=func(input,*params)<EOL>window_name=func.__name__ <EOL>if window_name=='<lambda>':window_name='camera image'<EOL>cv2.imshow(window_name,output)<EOL>k=cv2.waitKey()<EOL>if k==:<EOL><INDENT>break <EOL><DEDENT>elif k==ord('p'):<EOL><INDENT>info=self.info <EOL>for i in info :<EOL><INDENT>print i,'=',info [i ]<EOL><DEDENT> <DEDENT>elif k==ord('s'):<EOL><INDENT>p=raw_input('type property:')<EOL>if('<STR_LIT>'+p)not in dir(cv2.cv):<EOL><INDENT>print p,'<STR_LIT>'<EOL>print '<STR_LIT>',[x [:]for x in dir(cv2.cv)if 'CV_CAP_PROP'in x ]<EOL><DEDENT>else :<EOL><INDENT>v=raw_input('type value:')<EOL>self.set(p,v)<EOL><DEDENT> <DEDENT>elif k==ord('f'):<EOL><INDENT>print self.frame_rate <EOL><DEDENT> <DEDENT> <DEDENT>def __enter__(self):<EOL><INDENT>return self <EOL><DEDENT>def __exit__(self,exc_type,exc_value,traceback):<EOL><INDENT>self.cam.release()<EOL><DEDENT>def release(self):<EOL><INDENT>self.cam.release()<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>cam=OpenCV_Cam()<EOL>cam.size=(,)<EOL>info=cam.info <EOL>for i in info :<EOL><INDENT>print i,'=',info [i ]<EOL><DEDENT>cam.cam_loop()<EOL><DEDENT><EOF><BOF>from robot import utils <EOL>from robot.common import BaseTestSuite,BaseTestCase <EOL>from robot.parsing import TestData <EOL>from robot.errors import ExecutionFailed,DataError <EOL>from robot.variables import GLOBAL_VARIABLES <EOL>from robot.output import LOGGER <EOL>from.fixture import(Setup,Teardown,SuiteSetupListener,SuiteTearDownListener,<EOL>TestSetupListener,TestTeardownListener)<EOL>from.keywords import Keywords <EOL>from.namespace import Namespace <EOL>from.runerrors import SuiteRunErrors,TestRunErrors <EOL>from.userkeyword import UserLibrary <EOL>from.context import EXECUTION_CONTEXTS <EOL>from.defaultvalues import DefaultValues <EOL>def TestSuite(datasources,settings):<EOL><INDENT> '<STR_LIT>'<EOL>if isinstance(datasources,basestring):<EOL><INDENT>datasources=[datasources ]<EOL><DEDENT>datasources=[utils.abspath(path)for path in datasources ]<EOL>suite=_get_suite(datasources,settings ['SuiteNames'],settings ['WarnOnSkipped'])<EOL>suite.set_options(settings)<EOL>_check_suite_contains_tests(suite,settings ['RunEmptySuite'])<EOL>return suite <EOL><DEDENT>def _get_suite(datasources,include_suites,warn_on_skipped):<EOL><INDENT>if not datasources :<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>if len(datasources)>:<EOL><INDENT>return _get_multisource_suite(datasources,include_suites,warn_on_skipped)<EOL><DEDENT>return RunnableTestSuite(_parse_suite(datasources [],include_suites,warn_on_skipped))<EOL><DEDENT>def _parse_suite(path,include_suites,warn_on_skipped):<EOL><INDENT>try :<EOL><INDENT>return TestData(source=path,include_suites=include_suites,warn_on_skipped=warn_on_skipped)<EOL><DEDENT>except DataError,err :<EOL><INDENT>raise DataError('<STR_LIT>'%(path,unicode(err)))<EOL><DEDENT> <DEDENT>def _get_multisource_suite(datasources,include_suites,warn_on_skipped):<EOL><INDENT>suitedatas=[]<EOL>for datasource in datasources :<EOL><INDENT>try :<EOL><INDENT>suitedatas.append(_parse_suite(datasource,include_suites,warn_on_skipped))<EOL><DEDENT>except DataError,err :<EOL><INDENT>LOGGER.warn(err)<EOL><DEDENT> <DEDENT>suite=RunnableMultiTestSuite(suitedatas)<EOL>if suite.get_test_count()==:<EOL><INDENT>raise DataError('<STR_LIT>'<EOL>%utils.seq2str(datasources))<EOL><DEDENT>return suite <EOL><DEDENT>def _check_suite_contains_tests(suite,run_empty_suites=False):<EOL><INDENT>suite.filter_empty_suites()<EOL>if not suite.get_test_count()and not run_empty_suites :<EOL><INDENT>raise DataError('<STR_LIT>'%(suite.source))<EOL><DEDENT> <DEDENT>class RunnableTestSuite(BaseTestSuite):<EOL><INDENT>def __init__(self,data,parent=None,defaults=None):<EOL><INDENT>BaseTestSuite.__init__(self,data.name,data.source,parent)<EOL>self.variables=GLOBAL_VARIABLES.copy()<EOL>self.variables.set_from_variable_table(data.variable_table)<EOL>self.source=data.source <EOL>self.doc=data.setting_table.doc.value <EOL>self.metadata=self._get_metadata(data.setting_table.metadata)<EOL>self.imports=data.imports <EOL>self.user_keywords=UserLibrary(data.keywords)<EOL>self.setup=Setup(data.setting_table.suite_setup.name,<EOL>data.setting_table.suite_setup.args)<EOL>self.teardown=Teardown(data.setting_table.suite_teardown.name,<EOL>data.setting_table.suite_teardown.args)<EOL>defaults=DefaultValues(data.setting_table,defaults)<EOL>for suite in data.children :<EOL><INDENT>RunnableTestSuite(suite,parent=self,defaults=defaults)<EOL><DEDENT>for test in data.testcase_table :<EOL><INDENT>RunnableTestCase(test,parent=self,defaults=defaults)<EOL><DEDENT>self._run_mode_exit_on_failure=False <EOL>self._run_mode_dry_run=False <EOL>self._run_mode_skip_teardowns_on_exit=False <EOL><DEDENT>def filter_empty_suites(self):<EOL><INDENT>for suite in self.suites [:]:<EOL><INDENT>suite.filter_empty_suites()<EOL>if suite.get_test_count()==:<EOL><INDENT>self.suites.remove(suite)<EOL>LOGGER.info('<STR_LIT>'<EOL>'<STR_LIT>'%(suite.source))<EOL><DEDENT> <DEDENT> <DEDENT>def _get_metadata(self,metadata):<EOL><INDENT>meta=utils.NormalizedDict()<EOL>for item in metadata :<EOL><INDENT>meta [item.name ]=item.value <EOL><DEDENT>return meta <EOL><DEDENT>def run(self,output,parent=None,errors=None):<EOL><INDENT>context=self._start_run(output,parent,errors)<EOL>self._run_setup(context)<EOL>self._run_sub_suites(context)<EOL>self._run_tests(context)<EOL>self._report_status(context)<EOL>self._run_teardown(context)<EOL>self._end_run(context)<EOL><DEDENT>def _start_run(self,output,parent,errors):<EOL><INDENT>if not errors :<EOL><INDENT>errors=SuiteRunErrors(self._run_mode_exit_on_failure,self._run_mode_skip_teardowns_on_exit)<EOL><DEDENT>self.run_errors=errors <EOL>self.run_errors.start_suite()<EOL>self.status='RUNNING'<EOL>self.starttime=utils.get_timestamp()<EOL>parent_vars=parent.context.get_current_vars()if parent else None <EOL>ns=Namespace(self,parent_vars)<EOL>self.context=EXECUTION_CONTEXTS.start_suite(ns,output,self._run_mode_dry_run)<EOL>if not errors.exit :<EOL><INDENT>ns.handle_imports()<EOL><DEDENT>self._set_variable_dependent_metadata(self.context)<EOL>output.start_suite(self)<EOL>return self.context <EOL><DEDENT>def _set_variable_dependent_metadata(self,context):<EOL><INDENT>errors=[]<EOL>self.doc=context.replace_vars_from_setting('Documentation',self.doc,<EOL>errors)<EOL>self.setup.replace_variables(context.get_current_vars(),errors)<EOL>self.teardown.replace_variables(context.get_current_vars(),errors)<EOL>for name,value in self.metadata.items():<EOL><INDENT>self.metadata [name ]=context.replace_vars_from_setting(name,value,<EOL>errors)<EOL><DEDENT>if errors :<EOL><INDENT>self.run_errors.suite_init_err('<STR_LIT>'<EOL>%'\n'.join(errors))<EOL><DEDENT> <DEDENT>def _run_setup(self,context):<EOL><INDENT>if self.run_errors.is_suite_setup_allowed():<EOL><INDENT>self.setup.run(context,SuiteSetupListener(self))<EOL>self.run_errors.setup_executed()<EOL><DEDENT> <DEDENT>def _run_teardown(self,context):<EOL><INDENT>if self.run_errors.is_suite_teardown_allowed():<EOL><INDENT>self.teardown.run(context,SuiteTearDownListener(self))<EOL><DEDENT> <DEDENT>def _run_sub_suites(self,context):<EOL><INDENT>for suite in self.suites :<EOL><INDENT>suite.run(context.output,self,self.run_errors)<EOL><DEDENT> <DEDENT>def _run_tests(self,context):<EOL><INDENT>executed_tests=[]<EOL>for test in self.tests :<EOL><INDENT>normname=utils.normalize(test.name)<EOL>if normname in executed_tests :<EOL><INDENT>LOGGER.warn('<STR_LIT>'<EOL>"test suite '%s'"%(test.name,self.longname))<EOL><DEDENT>executed_tests.append(normname)<EOL>test.run(context,self.run_errors)<EOL>context.set_prev_test_variables(test)<EOL><DEDENT> <DEDENT>def _report_status(self,context):<EOL><INDENT>self.set_status()<EOL>self.message=self.run_errors.suite_error()<EOL>context.report_suite_status(self.status,self.get_full_message())<EOL><DEDENT>def _end_run(self,context):<EOL><INDENT>self.endtime=utils.get_timestamp()<EOL>self.elapsedtime=utils.get_elapsed_time(self.starttime,self.endtime)<EOL>context.copy_prev_test_vars_to_global()<EOL>context.end_suite(self)<EOL>self.run_errors.end_suite()<EOL><DEDENT> <DEDENT>class RunnableMultiTestSuite(RunnableTestSuite):<EOL><INDENT>def __init__(self,suitedatas):<EOL><INDENT>BaseTestSuite.__init__(self,name='')<EOL>self.variables=GLOBAL_VARIABLES.copy()<EOL>self.doc=''<EOL>self.imports=[]<EOL>self.setup=Setup(None,None)<EOL>self.teardown=Teardown(None,None)<EOL>for suite in suitedatas :<EOL><INDENT>RunnableTestSuite(suite,parent=self)<EOL><DEDENT>self._run_mode_exit_on_failure=False <EOL>self._run_mode_dry_run=False <EOL>self._run_mode_skip_teardowns_on_exit=False <EOL><DEDENT> <DEDENT>class RunnableTestCase(BaseTestCase):<EOL><INDENT>def __init__(self,tc_data,parent,defaults):<EOL><INDENT>BaseTestCase.__init__(self,tc_data.name,parent)<EOL>self.doc=tc_data.doc.value <EOL>self.setup=defaults.get_setup(tc_data.setup)<EOL>self.teardown=defaults.get_teardown(tc_data.teardown)<EOL>self.tags=defaults.get_tags(tc_data.tags)<EOL>self.timeout=defaults.get_timeout(tc_data.timeout)<EOL>self.template=defaults.get_template(tc_data.template)<EOL>self.keywords=Keywords(tc_data.steps,self.template)<EOL><DEDENT>def run(self,context,suite_errors):<EOL><INDENT>self._suite_errors=suite_errors <EOL>self._start_run(context)<EOL>if self.run_errors.is_allowed_to_run():<EOL><INDENT>self._run(context)<EOL><DEDENT>else :<EOL><INDENT>self._not_allowed_to_run()<EOL><DEDENT>self._end_run(context)<EOL><DEDENT>def _start_run(self,context):<EOL><INDENT>self.run_errors=TestRunErrors(self._suite_errors)<EOL>self.status='RUNNING'<EOL>self.starttime=utils.get_timestamp()<EOL>self.run_errors.init_err(self._init_test(context))<EOL>context.start_test(self)<EOL><DEDENT>def _init_test(self,context):<EOL><INDENT>errors=[]<EOL>self.doc=context.replace_vars_from_setting('Documentation',self.doc,<EOL>errors)<EOL>self.setup.replace_variables(context.get_current_vars(),errors)<EOL>self.teardown.replace_variables(context.get_current_vars(),errors)<EOL>tags=context.replace_vars_from_setting('Tags',self.tags,errors)<EOL>self.tags=utils.normalize_tags(tags)<EOL>self.timeout.replace_variables(context.get_current_vars())<EOL>if errors :<EOL><INDENT>return '<STR_LIT>'%'\n'.join(errors)<EOL><DEDENT>if not self.name :<EOL><INDENT>return '<STR_LIT>'<EOL><DEDENT>if not self.keywords :<EOL><INDENT>return '<STR_LIT>'<EOL><DEDENT>return None <EOL><DEDENT>def _run(self,context):<EOL><INDENT>self.timeout.start()<EOL>self._run_setup(context)<EOL>if not self.run_errors.setup_failed():<EOL><INDENT>try :<EOL><INDENT>self.keywords.run(context)<EOL><DEDENT>except ExecutionFailed,err :<EOL><INDENT>self.run_errors.kw_err(unicode(err))<EOL>self.keyword_failed(err)<EOL><DEDENT> <DEDENT>context.set_test_status_before_teardown(*self._report_status())<EOL>self._run_teardown(context)<EOL>self._report_status_after_teardown()<EOL><DEDENT>def keyword_failed(self,err):<EOL><INDENT>self.timeout.set_keyword_timeout(err.timeout)<EOL>self._suite_errors.test_failed(exit=err.exit,critical=self.critical)<EOL><DEDENT>def _run_setup(self,context):<EOL><INDENT>self.setup.run(context,TestSetupListener(self))<EOL><DEDENT>def _report_status(self):<EOL><INDENT>message=self.run_errors.get_message()<EOL>if message :<EOL><INDENT>self.status='FAIL'<EOL>self.message=message <EOL><DEDENT>else :<EOL><INDENT>self.status='PASS'<EOL><DEDENT>return self.message,self.status <EOL><DEDENT>def _run_teardown(self,context):<EOL><INDENT>if self._suite_errors.is_test_teardown_allowed():<EOL><INDENT>self.teardown.run(context,TestTeardownListener(self))<EOL><DEDENT> <DEDENT>def _report_status_after_teardown(self):<EOL><INDENT>if self.run_errors.teardown_failed():<EOL><INDENT>self.status='FAIL'<EOL>self.message=self.run_errors.get_teardown_message(self.message)<EOL><DEDENT>if self.status=='PASS'and self.timeout.timed_out():<EOL><INDENT>self.status='FAIL'<EOL>self.message=self.timeout.get_message()<EOL><DEDENT>if self.status=='FAIL':<EOL><INDENT>self._suite_errors.test_failed(critical=self.critical)<EOL><DEDENT> <DEDENT>def _not_allowed_to_run(self):<EOL><INDENT>self.status='FAIL'<EOL>self.message=self.run_errors.parent_or_init_error()<EOL><DEDENT>def _end_run(self,context):<EOL><INDENT>self.endtime=utils.get_timestamp()<EOL>self.elapsedtime=utils.get_elapsed_time(self.starttime,self.endtime)<EOL>context.end_test(self)<EOL><DEDENT> <DEDENT><EOF><BOF>import telnetlib <EOL>import time <EOL>import re <EOL>import inspect <EOL>from robot.version import get_version <EOL>from robot import utils <EOL>class Telnet :<EOL><INDENT> '<STR_LIT>'<EOL>ROBOT_LIBRARY_SCOPE='TEST_SUITE'<EOL>ROBOT_LIBRARY_VERSION=get_version()<EOL>def __init__(self,timeout=,newline='CRLF',prompt=None,prompt_is_regexp=False):<EOL><INDENT> '<STR_LIT>'<EOL>self._timeout=timeout==''and or timeout <EOL>self._newline=newline==''and 'CRLF'or newline <EOL>self._prompt=(prompt,prompt_is_regexp)<EOL>self._cache=utils.ConnectionCache()<EOL>self._conn=None <EOL>self._conn_kws=self._lib_kws=None <EOL><DEDENT>def get_keyword_names(self):<EOL><INDENT>return self._get_library_keywords()+self._get_connection_keywords()<EOL><DEDENT>def _get_library_keywords(self):<EOL><INDENT>if self._lib_kws is None :<EOL><INDENT>self._lib_kws=[name for name in dir(self)<EOL>if not name.startswith('_')and name !='<STR_LIT>'<EOL>and inspect.ismethod(getattr(self,name))]<EOL><DEDENT>return self._lib_kws <EOL><DEDENT>def _get_connection_keywords(self):<EOL><INDENT>if self._conn_kws is None :<EOL><INDENT>conn=self._get_connection()<EOL>excluded=[name for name in dir(telnetlib.Telnet())<EOL>if name not in ['write','read','read_until']]<EOL>self._conn_kws=[name for name in dir(conn)<EOL>if not name.startswith('_')and name not in excluded <EOL>and inspect.ismethod(getattr(conn,name))]<EOL><DEDENT>return self._conn_kws <EOL><DEDENT>def __getattr__(self,name):<EOL><INDENT>if name not in self._get_connection_keywords():<EOL><INDENT>raise AttributeError(name)<EOL><DEDENT>conn=self._conn is None and self._get_connection()or self._conn <EOL>return getattr(conn,name)<EOL><DEDENT>def open_connection(self,host,alias=None,port=,timeout=None,<EOL>newline=None,prompt=None,prompt_is_regexp=False):<EOL><INDENT> '<STR_LIT>'<EOL>if timeout is None or timeout=='':<EOL><INDENT>timeout=self._timeout <EOL><DEDENT>if newline is None :<EOL><INDENT>newline=self._newline <EOL><DEDENT>if prompt is None :<EOL><INDENT>prompt,prompt_is_regexp=self._prompt <EOL><DEDENT>print '<STR_LIT>'%(host,port,self._prompt)<EOL>self._conn=self._get_connection(host,port,timeout,newline,<EOL>prompt,prompt_is_regexp)<EOL>return self._cache.register(self._conn,alias)<EOL><DEDENT>def _get_connection(self,*args):<EOL><INDENT> '<STR_LIT>'<EOL>return TelnetConnection(*args)<EOL><DEDENT>def switch_connection(self,index_or_alias):<EOL><INDENT> '<STR_LIT>'<EOL>old_index=self._cache.current_index <EOL>self._conn=self._cache.switch(index_or_alias)<EOL>return old_index <EOL><DEDENT>def close_all_connections(self):<EOL><INDENT> '<STR_LIT>'<EOL>self._conn=self._cache.close_all()<EOL><DEDENT> <DEDENT>class TelnetConnection(telnetlib.Telnet):<EOL><INDENT>def __init__(self,host=None,port=,timeout=,newline='CRLF',<EOL>prompt=None,prompt_is_regexp=False):<EOL><INDENT>port=port==''and or int(port)<EOL>telnetlib.Telnet.__init__(self,host,port)<EOL>self.set_timeout(timeout)<EOL>self.set_newline(newline)<EOL>self.set_prompt(prompt,prompt_is_regexp)<EOL>self._default_log_level='INFO'<EOL>self.set_option_negotiation_callback(self._negotiate_echo_on)<EOL><DEDENT>def set_timeout(self,timeout):<EOL><INDENT> '<STR_LIT>'<EOL>old=getattr(self,'_timeout',)<EOL>self._timeout=utils.timestr_to_secs(timeout)<EOL>return utils.secs_to_timestr(old)<EOL><DEDENT>def set_newline(self,newline):<EOL><INDENT> '<STR_LIT>'<EOL>old=getattr(self,'_newline','CRLF')<EOL>self._newline=newline.upper().replace('LF','\n').replace('CR','\r')<EOL>return old <EOL><DEDENT>def close_connection(self,loglevel=None):<EOL><INDENT> '<STR_LIT>'<EOL>telnetlib.Telnet.close(self)<EOL>ret=self.read_all().decode('ASCII','ignore')<EOL>self._log(ret,loglevel)<EOL>return ret <EOL><DEDENT>def login(self,username,password,login_prompt='login: ',<EOL>password_prompt='Password: '):<EOL><INDENT> '<STR_LIT>'<EOL>ret=self.read_until(login_prompt,'TRACE').decode('ASCII','ignore')<EOL>self.write_bare(username +self._newline)<EOL>ret +=username +'\n'<EOL>ret +=self.read_until(password_prompt,'TRACE').decode('ASCII','ignore')<EOL>self.write_bare(password +self._newline)<EOL>ret +='*'*len(password)+'\n'<EOL>if self._prompt_is_set():<EOL><INDENT>try :<EOL><INDENT>ret +=self.read_until_prompt('TRACE')<EOL><DEDENT>except AssertionError :<EOL><INDENT>self._verify_login(ret)<EOL>raise <EOL><DEDENT> <DEDENT>else :<EOL><INDENT>ret +=self._verify_login(ret)<EOL><DEDENT>self._log(ret)<EOL>return ret <EOL><DEDENT>def _verify_login(self,ret):<EOL><INDENT>time.sleep()<EOL>while True :<EOL><INDENT>try :<EOL><INDENT>ret +=self.read_until('\n','TRACE').decode('ASCII','ignore')<EOL><DEDENT>except AssertionError :<EOL><INDENT>return ret <EOL><DEDENT>else :<EOL><INDENT>if 'Login incorrect'in ret :<EOL><INDENT>self._log(ret)<EOL>raise AssertionError("Login incorrect")<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>def write(self,text,loglevel=None):<EOL><INDENT> '<STR_LIT>'<EOL>if self._newline in text :<EOL><INDENT>raise RuntimeError('<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT>text +=self._newline <EOL>self.write_bare(text)<EOL>return self.read_until(self._newline,loglevel)<EOL><DEDENT>def write_bare(self,text):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>text=str(text)<EOL><DEDENT>except UnicodeError :<EOL><INDENT>raise ValueError('<STR_LIT>'<EOL>'Got: %s'%text)<EOL><DEDENT>telnetlib.Telnet.write(self,text)<EOL><DEDENT>def write_until_expected_output(self,text,expected,timeout,<EOL>retry_interval,loglevel=None):<EOL><INDENT> '<STR_LIT>'<EOL>timeout=utils.timestr_to_secs(timeout)<EOL>retry_interval=utils.timestr_to_secs(retry_interval)<EOL>starttime=time.time()<EOL>while time.time()-starttime <timeout :<EOL><INDENT>self.write_bare(text)<EOL>self.read_until(text,loglevel)<EOL>ret=telnetlib.Telnet.read_until(self,expected,<EOL>retry_interval).decode('ASCII','ignore')<EOL>self._log(ret,loglevel)<EOL>if ret.endswith(expected):<EOL><INDENT>return ret <EOL><DEDENT> <DEDENT>raise AssertionError('<STR_LIT>'<EOL>%(expected,utils.secs_to_timestr(timeout)))<EOL><DEDENT>def read(self,loglevel=None):<EOL><INDENT> '<STR_LIT>'<EOL>ret=self.read_very_eager().decode('ASCII','ignore')<EOL>self._log(ret,loglevel)<EOL>return ret <EOL><DEDENT>def read_until(self,expected,loglevel=None):<EOL><INDENT> '<STR_LIT>'<EOL>ret=telnetlib.Telnet.read_until(self,expected,<EOL>self._timeout).decode('ASCII','ignore')<EOL>self._log(ret,loglevel)<EOL>if not ret.endswith(expected):<EOL><INDENT>raise AssertionError('<STR_LIT>'<EOL>%(expected,utils.secs_to_timestr(self._timeout)))<EOL><DEDENT>return ret <EOL><DEDENT>def read_until_regexp(self,*expected):<EOL><INDENT> '<STR_LIT>'<EOL>expected=list(expected)<EOL>if self._is_valid_log_level(expected [-]):<EOL><INDENT>loglevel=expected [-]<EOL>expected=expected [:-]<EOL><DEDENT>else :<EOL><INDENT>loglevel='INFO'<EOL><DEDENT>try :<EOL><INDENT>index,_,ret=self.expect(expected,self._timeout)<EOL><DEDENT>except TypeError :<EOL><INDENT>index,ret=-,''<EOL><DEDENT>ret=ret.decode('ASCII','ignore')<EOL>self._log(ret,loglevel)<EOL>if index==-:<EOL><INDENT>expected=[exp if isinstance(exp,basestring)else exp.pattern <EOL>for exp in expected ]<EOL>raise AssertionError('<STR_LIT>'<EOL>%(utils.seq2str(expected,lastsep=' or '),<EOL>utils.secs_to_timestr(self._timeout)))<EOL><DEDENT>return ret <EOL><DEDENT>def read_until_prompt(self,loglevel=None):<EOL><INDENT> '<STR_LIT>'<EOL>if not self._prompt_is_set():<EOL><INDENT>raise RuntimeError('<STR_LIT>')<EOL><DEDENT>prompt,regexp=self._prompt <EOL>if regexp :<EOL><INDENT>return self.read_until_regexp(prompt,loglevel)<EOL><DEDENT>return self.read_until(prompt,loglevel)<EOL><DEDENT>def execute_command(self,command,loglevel=None):<EOL><INDENT> '<STR_LIT>'<EOL>self.write(command,loglevel)<EOL>return self.read_until_prompt(loglevel)<EOL><DEDENT>def set_prompt(self,prompt,prompt_is_regexp=False):<EOL><INDENT> '<STR_LIT>'<EOL>old=hasattr(self,'_prompt')and self._prompt or(None,False)<EOL>if prompt_is_regexp :<EOL><INDENT>self._prompt=(re.compile(prompt),True)<EOL><DEDENT>else :<EOL><INDENT>self._prompt=(prompt,False)<EOL><DEDENT>if old []:<EOL><INDENT>return old [].pattern,True <EOL><DEDENT>return old <EOL><DEDENT>def _prompt_is_set(self):<EOL><INDENT>return self._prompt []is not None <EOL><DEDENT>def set_default_log_level(self,level):<EOL><INDENT> '<STR_LIT>'<EOL>self._is_valid_log_level(level,raise_if_invalid=True)<EOL>old=self._default_log_level <EOL>self._default_log_level=level.upper()<EOL>return old <EOL><DEDENT>def _log(self,msg,level=None):<EOL><INDENT>self._is_valid_log_level(level,raise_if_invalid=True)<EOL>msg=msg.strip()<EOL>if level is None :<EOL><INDENT>level=self._default_log_level <EOL><DEDENT>if msg !='':<EOL><INDENT>print '*%s* %s'%(level.upper(),msg)<EOL><DEDENT> <DEDENT>def _is_valid_log_level(self,level,raise_if_invalid=False):<EOL><INDENT>if level is None :<EOL><INDENT>return True <EOL><DEDENT>if isinstance(level,basestring)and level.upper()in ['TRACE','DEBUG','INFO','WARN']:<EOL><INDENT>return True <EOL><DEDENT>if not raise_if_invalid :<EOL><INDENT>return False <EOL><DEDENT>raise AssertionError('<STR_LIT>'%level)<EOL><DEDENT>def _negotiate_echo_on(self,sock,cmd,opt):<EOL><INDENT>if opt==telnetlib.ECHO and cmd in(telnetlib.WILL,telnetlib.WONT):<EOL><INDENT>self.sock.sendall(telnetlib.IAC +telnetlib.DO +opt)<EOL><DEDENT>elif opt !=telnetlib.NOOPT :<EOL><INDENT>if cmd in(telnetlib.DO,telnetlib.DONT):<EOL><INDENT>self.sock.sendall(telnetlib.IAC +telnetlib.WONT +opt)<EOL><DEDENT>elif cmd in(telnetlib.WILL,telnetlib.WONT):<EOL><INDENT>self.sock.sendall(telnetlib.IAC +telnetlib.DONT +opt)<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT><EOF><BOF>import psycopg2 <EOL>from pprint import pprint <EOL>from mosql.query import select,left_join <EOL>from mosql.db import Database,all_to_dicts <EOL>db=Database(psycopg2,host='127.0.0.1')<EOL>with db as cur :<EOL><INDENT>cur.execute(select(<EOL>'person',<EOL>{'person_id':'mosky'},<EOL>joins=left_join('detail',using='person_id'),<EOL>))<EOL>pprint(all_to_dicts(cur))<EOL><DEDENT><EOF><BOF>import cv2.cv as cv <EOL>class PyrSegmentation :<EOL><INDENT>def __init__(self,img0):<EOL><INDENT>self.thresh1=<EOL>self.thresh2=<EOL>self.level=<EOL>self.storage=cv.CreateMemStorage()<EOL>cv.NamedWindow("Source",)<EOL>cv.ShowImage("Source",img0)<EOL>cv.NamedWindow("Segmentation",)<EOL>cv.CreateTrackbar("Thresh1","Segmentation",self.thresh1,,self.set_thresh1)<EOL>cv.CreateTrackbar("Thresh2","Segmentation",self.thresh2,,self.set_thresh2)<EOL>self.image0=cv.CloneImage(img0)<EOL>self.image1=cv.CloneImage(img0)<EOL>cv.ShowImage("Segmentation",self.image1)<EOL><DEDENT>def set_thresh1(self,val):<EOL><INDENT>self.thresh1=val <EOL>self.on_segment()<EOL><DEDENT>def set_thresh2(self,val):<EOL><INDENT>self.thresh2=val <EOL>self.on_segment()<EOL><DEDENT>def on_segment(self):<EOL><INDENT>comp=cv.PyrSegmentation(self.image0,self.image1,self.storage,self.level,self.thresh1 +,self.thresh2 +)<EOL>cv.ShowImage("Segmentation",self.image1)<EOL><DEDENT>def run(self):<EOL><INDENT>self.on_segment()<EOL>cv.WaitKey()<EOL><DEDENT> <DEDENT>if __name__=="__main__":<EOL><INDENT>img0=cv.LoadImage("../c/fruits.jpg",)<EOL>PyrSegmentation(img0).run()<EOL>cv.DestroyAllWindows()<EOL><DEDENT><EOF><BOF>from functools import wraps <EOL>from flask import request,abort <EOL>def has_access_token(tkn):<EOL><INDENT> '<STR_LIT>'<EOL>def decorator(f):<EOL><INDENT>@wraps(f)<EOL>def decorated_function(*args,**kwargs):<EOL><INDENT>token=request.headers.get('Access-Token','')<EOL>if token !=tkn :<EOL><INDENT>abort()<EOL><DEDENT>return f(*args,**kwargs)<EOL><DEDENT>return decorated_function <EOL><DEDENT>return decorator <EOL><DEDENT><EOF><BOF>import logging <EOL>from zerotest.common import DEBUG <EOL>if not DEBUG :<EOL><INDENT>logging.getLogger("werkzeug").setLevel(logging.ERROR)<EOL>logging.getLogger('<STR_LIT>').setLevel(logging.ERROR)<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>from common import anorm,getsize <EOL>FLANN_INDEX_KDTREE=<EOL>FLANN_INDEX_LSH=<EOL>def init_feature(name):<EOL><INDENT>chunks=name.split('-')<EOL>if chunks []=='sift':<EOL><INDENT>detector=cv2.SIFT()<EOL>norm=cv2.NORM_L2 <EOL><DEDENT>elif chunks []=='surf':<EOL><INDENT>detector=cv2.SURF()<EOL>norm=cv2.NORM_L2 <EOL><DEDENT>elif chunks []=='orb':<EOL><INDENT>detector=cv2.ORB()<EOL>norm=cv2.NORM_HAMMING <EOL><DEDENT>else :<EOL><INDENT>return None,None <EOL><DEDENT>if 'flann'in chunks :<EOL><INDENT>if norm==cv2.NORM_L2 :<EOL><INDENT>flann_params=dict(algorithm=FLANN_INDEX_KDTREE,trees=)<EOL><DEDENT>else :<EOL><INDENT>flann_params=dict(algorithm=FLANN_INDEX_LSH,<EOL>table_number=,<EOL>key_size=,<EOL>multi_probe_level=)<EOL><DEDENT>matcher=cv2.FlannBasedMatcher(flann_params,{})<EOL><DEDENT>else :<EOL><INDENT>matcher=cv2.BFMatcher(norm)<EOL><DEDENT>return detector,matcher <EOL><DEDENT>def filter_matches(kp1,kp2,matches,ratio=):<EOL><INDENT>mkp1,mkp2=[],[]<EOL>for m in matches :<EOL><INDENT>if len(m)==and m [].distance <m [].distance *ratio :<EOL><INDENT>m=m []<EOL>mkp1.append(kp1 [m.queryIdx ])<EOL>mkp2.append(kp2 [m.trainIdx ])<EOL><DEDENT> <DEDENT>p1=np.float32([kp.pt for kp in mkp1 ])<EOL>p2=np.float32([kp.pt for kp in mkp2 ])<EOL>kp_pairs=zip(mkp1,mkp2)<EOL>return p1,p2,kp_pairs <EOL><DEDENT>def explore_match(win,img1,img2,kp_pairs,status=None,H=None):<EOL><INDENT>h1,w1=img1.shape [:]<EOL>h2,w2=img2.shape [:]<EOL>vis=np.zeros((max(h1,h2),w1 +w2),np.uint8)<EOL>vis [:h1,:w1 ]=img1 <EOL>vis [:h2,w1 :w1 +w2 ]=img2 <EOL>vis=cv2.cvtColor(vis,cv2.COLOR_GRAY2BGR)<EOL>if H is not None :<EOL><INDENT>corners=np.float32([[,],[w1,],[w1,h1 ],[,h1 ]])<EOL>corners=np.int32(cv2.perspectiveTransform(corners.reshape(,-,),H).reshape(-,)+(w1,))<EOL>cv2.polylines(vis,[corners ],True,(,,))<EOL><DEDENT>if status is None :<EOL><INDENT>status=np.ones(len(kp_pairs),np.bool_)<EOL><DEDENT>p1=np.int32([kpp [].pt for kpp in kp_pairs ])<EOL>p2=np.int32([kpp [].pt for kpp in kp_pairs ])+(w1,)<EOL>green=(,,)<EOL>red=(,,)<EOL>white=(,,)<EOL>kp_color=(,,)<EOL>for(x1,y1),(x2,y2),inlier in zip(p1,p2,status):<EOL><INDENT>if inlier :<EOL><INDENT>col=green <EOL>cv2.circle(vis,(x1,y1),,col,-)<EOL>cv2.circle(vis,(x2,y2),,col,-)<EOL><DEDENT>else :<EOL><INDENT>col=red <EOL>r=<EOL>thickness=<EOL>cv2.line(vis,(x1 -r,y1 -r),(x1 +r,y1 +r),col,thickness)<EOL>cv2.line(vis,(x1 -r,y1 +r),(x1 +r,y1 -r),col,thickness)<EOL>cv2.line(vis,(x2 -r,y2 -r),(x2 +r,y2 +r),col,thickness)<EOL>cv2.line(vis,(x2 -r,y2 +r),(x2 +r,y2 -r),col,thickness)<EOL><DEDENT> <DEDENT>vis0=vis.copy()<EOL>for(x1,y1),(x2,y2),inlier in zip(p1,p2,status):<EOL><INDENT>if inlier :<EOL><INDENT>cv2.line(vis,(x1,y1),(x2,y2),green)<EOL><DEDENT> <DEDENT>cv2.imshow(win,vis)<EOL>def onmouse(event,x,y,flags,param):<EOL><INDENT>cur_vis=vis <EOL>if flags &cv2.EVENT_FLAG_LBUTTON :<EOL><INDENT>cur_vis=vis0.copy()<EOL>r=<EOL>m=(anorm(p1 -(x,y))<r)|(anorm(p2 -(x,y))<r)<EOL>idxs=np.where(m)[]<EOL>kp1s,kp2s=[],[]<EOL>for i in idxs :<EOL><INDENT>(x1,y1),(x2,y2)=p1 [i ],p2 [i ]<EOL>col=(red,green)[status [i ]]<EOL>cv2.line(cur_vis,(x1,y1),(x2,y2),col)<EOL>kp1,kp2=kp_pairs [i ]<EOL>kp1s.append(kp1)<EOL>kp2s.append(kp2)<EOL><DEDENT>cur_vis=cv2.drawKeypoints(cur_vis,kp1s,flags=,color=kp_color)<EOL>cur_vis [:,w1 :]=cv2.drawKeypoints(cur_vis [:,w1 :],kp2s,flags=,color=kp_color)<EOL><DEDENT>cv2.imshow(win,cur_vis)<EOL><DEDENT>cv2.setMouseCallback(win,onmouse)<EOL>return vis <EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>import sys,getopt <EOL>opts,args=getopt.getopt(sys.argv [:],'',['feature='])<EOL>opts=dict(opts)<EOL>feature_name=opts.get('--feature','sift')<EOL>try :fn1,fn2=args <EOL>except :<EOL><INDENT>fn1='../c/box.png'<EOL>fn2='<STR_LIT>'<EOL><DEDENT>img1=cv2.imread(fn1,)<EOL>img2=cv2.imread(fn2,)<EOL>detector,matcher=init_feature(feature_name)<EOL>if detector !=None :<EOL><INDENT>print 'using',feature_name <EOL><DEDENT>else :<EOL><INDENT>print '<STR_LIT>',feature_name <EOL>sys.exit()<EOL><DEDENT>kp1,desc1=detector.detectAndCompute(img1,None)<EOL>kp2,desc2=detector.detectAndCompute(img2,None)<EOL>print '<STR_LIT>'%(len(kp1),len(kp2))<EOL>def match_and_draw(win):<EOL><INDENT>print 'matching...'<EOL>raw_matches=matcher.knnMatch(desc1,trainDescriptors=desc2,k=)<EOL>p1,p2,kp_pairs=filter_matches(kp1,kp2,raw_matches)<EOL>if len(p1)>=:<EOL><INDENT>H,status=cv2.findHomography(p1,p2,cv2.RANSAC,)<EOL>print '<STR_LIT>'%(np.sum(status),len(status))<EOL><DEDENT>else :<EOL><INDENT>H,status=None,None <EOL>print '<STR_LIT>'%len(p1)<EOL><DEDENT>vis=explore_match(win,img1,img2,kp_pairs,status,H)<EOL><DEDENT>match_and_draw('find_obj')<EOL>cv2.waitKey()<EOL>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import sys <EOL>import types <EOL>PY2=sys.version_info []==<EOL>PY3=sys.version_info []==<EOL>if PY3 :<EOL><INDENT>string_types=str,<EOL>integer_types=int,<EOL>class_types=type,<EOL>text_type=str <EOL>binary_type=bytes <EOL><DEDENT>else :<EOL><INDENT>string_types=basestring,<EOL>integer_types=(int,long)<EOL>class_types=(type,types.ClassType)<EOL>text_type=unicode <EOL>binary_type=str <EOL><DEDENT>try :<EOL><INDENT>from itertools import izip <EOL><DEDENT>except ImportError :<EOL><INDENT>izip=zip <EOL><DEDENT><EOF><BOF>from __future__ import unicode_literals <EOL>from django.db import migrations,models <EOL>import django.db.models.deletion <EOL>class Migration(migrations.Migration):<EOL><INDENT>dependencies=[('buildservice','<STR_LIT>'),<EOL>]<EOL>operations=[<EOL>migrations.CreateModel(<EOL>name='Repository',<EOL>fields=[('id',models.AutoField(auto_created=True,primary_key=True,serialize=False,verbose_name='ID')),('name',models.CharField(max_length=)),('created_at',models.DateTimeField(auto_now_add=True)),<EOL>],),<EOL>migrations.AlterField(<EOL>model_name='build',<EOL>name='repository',<EOL>field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE,to='<STR_LIT>'),),<EOL>migrations.AlterField(<EOL>model_name='webhook',<EOL>name='repository',<EOL>field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE,to='<STR_LIT>'),),<EOL>]<EOL><DEDENT><EOF><BOF>from robot.errors import DataError <EOL>class XmlElementHandler(object):<EOL><INDENT>def __init__(self,execution_result,root_handler=None):<EOL><INDENT>self._stack=[(execution_result,root_handler or RootHandler())]<EOL><DEDENT>def start(self,elem):<EOL><INDENT>result,handler=self._stack [-]<EOL>self._stack.append(handler.handle_child(elem,result))<EOL><DEDENT>def end(self,elem):<EOL><INDENT>result,handler=self._stack.pop()<EOL>handler.end(elem,result)<EOL><DEDENT> <DEDENT>class _Handler(object):<EOL><INDENT>def __init__(self):<EOL><INDENT>self._child_map=dict((c.tag,c)for c in self._children())<EOL><DEDENT>def _children(self):<EOL><INDENT>return []<EOL><DEDENT>def handle_child(self,elem,result):<EOL><INDENT>try :<EOL><INDENT>handler=self._child_map [elem.tag ]<EOL><DEDENT>except KeyError :<EOL><INDENT>raise DataError('<STR_LIT>'%elem.tag)<EOL><DEDENT>return handler.start(elem,result),handler <EOL><DEDENT>def start(self,elem,result):<EOL><INDENT>return result <EOL><DEDENT>def end(self,elem,result):<EOL><INDENT>pass <EOL><DEDENT>def _timestamp(self,elem,attr_name):<EOL><INDENT>timestamp=elem.get(attr_name)<EOL>return timestamp if timestamp !='N/A'else None <EOL><DEDENT> <DEDENT>class RootHandler(_Handler):<EOL><INDENT>def _children(self):<EOL><INDENT>return [RobotHandler()]<EOL><DEDENT> <DEDENT>class RobotHandler(_Handler):<EOL><INDENT>tag='robot'<EOL>def start(self,elem,result):<EOL><INDENT>result.generator=elem.get('generator','unknown').split()[].upper()<EOL>return result <EOL><DEDENT>def _children(self):<EOL><INDENT>return [RootSuiteHandler(),StatisticsHandler(),ErrorsHandler()]<EOL><DEDENT> <DEDENT>class SuiteHandler(_Handler):<EOL><INDENT>tag='suite'<EOL>def start(self,elem,result):<EOL><INDENT>return result.suites.create(name=elem.get('name'),<EOL>source=elem.get('source',''))<EOL><DEDENT>def _children(self):<EOL><INDENT>return [DocHandler(),MetadataHandler(),SuiteStatusHandler(),<EOL>KeywordHandler(),TestCaseHandler(),self ]<EOL><DEDENT> <DEDENT>class RootSuiteHandler(SuiteHandler):<EOL><INDENT>def start(self,elem,result):<EOL><INDENT>result.suite.name=elem.get('name')<EOL>result.suite.source=elem.get('source','')<EOL>return result.suite <EOL><DEDENT>def _children(self):<EOL><INDENT>return SuiteHandler._children(self)[:-]+[SuiteHandler()]<EOL><DEDENT> <DEDENT>class TestCaseHandler(_Handler):<EOL><INDENT>tag='test'<EOL>def start(self,elem,result):<EOL><INDENT>return result.tests.create(name=elem.get('name'),<EOL>timeout=elem.get('timeout',''))<EOL><DEDENT>def _children(self):<EOL><INDENT>return [DocHandler(),TagsHandler(),TestStatusHandler(),KeywordHandler()]<EOL><DEDENT> <DEDENT>class KeywordHandler(_Handler):<EOL><INDENT>tag='kw'<EOL>def start(self,elem,result):<EOL><INDENT>return result.keywords.create(name=elem.get('name'),<EOL>timeout=elem.get('timeout'),<EOL>type=elem.get('type'))<EOL><DEDENT>def _children(self):<EOL><INDENT>return [DocHandler(),ArgumentsHandler(),KeywordStatusHandler(),<EOL>MessageHandler(),self ]<EOL><DEDENT> <DEDENT>class MessageHandler(_Handler):<EOL><INDENT>tag='msg'<EOL>def end(self,elem,result):<EOL><INDENT>result.messages.create(elem.text or '',<EOL>elem.get('level'),<EOL>elem.get('html','no')=='yes',<EOL>self._timestamp(elem,'timestamp'))<EOL><DEDENT> <DEDENT>class _StatusHandler(_Handler):<EOL><INDENT>tag='status'<EOL>def _set_status(self,elem,result):<EOL><INDENT>result.status=elem.get('status','FAIL')<EOL><DEDENT>def _set_message(self,elem,result):<EOL><INDENT>result.message=elem.text or ''<EOL><DEDENT>def _set_times(self,elem,result):<EOL><INDENT>result.starttime=self._timestamp(elem,'starttime')<EOL>result.endtime=self._timestamp(elem,'endtime')<EOL><DEDENT> <DEDENT>class KeywordStatusHandler(_StatusHandler):<EOL><INDENT>def end(self,elem,result):<EOL><INDENT>self._set_status(elem,result)<EOL>self._set_times(elem,result)<EOL><DEDENT> <DEDENT>class SuiteStatusHandler(_StatusHandler):<EOL><INDENT>def end(self,elem,result):<EOL><INDENT>self._set_message(elem,result)<EOL>self._set_times(elem,result)<EOL><DEDENT> <DEDENT>class TestStatusHandler(_StatusHandler):<EOL><INDENT>def end(self,elem,result):<EOL><INDENT>self._set_status(elem,result)<EOL>self._set_message(elem,result)<EOL>self._set_times(elem,result)<EOL><DEDENT> <DEDENT>class DocHandler(_Handler):<EOL><INDENT>tag='doc'<EOL>def end(self,elem,result):<EOL><INDENT>result.doc=elem.text or ''<EOL><DEDENT> <DEDENT>class MetadataHandler(_Handler):<EOL><INDENT>tag='metadata'<EOL>def _children(self):<EOL><INDENT>return [MetadataItemHandler()]<EOL><DEDENT> <DEDENT>class MetadataItemHandler(_Handler):<EOL><INDENT>tag='item'<EOL>def end(self,elem,result):<EOL><INDENT>result.metadata [elem.get('name')]=elem.text or ''<EOL><DEDENT> <DEDENT>class TagsHandler(_Handler):<EOL><INDENT>tag='tags'<EOL>def _children(self):<EOL><INDENT>return [TagHandler()]<EOL><DEDENT> <DEDENT>class TagHandler(_Handler):<EOL><INDENT>tag='tag'<EOL>def end(self,elem,result):<EOL><INDENT>result.tags.add(elem.text or '')<EOL><DEDENT> <DEDENT>class ArgumentsHandler(_Handler):<EOL><INDENT>tag='arguments'<EOL>def _children(self):<EOL><INDENT>return [ArgumentHandler()]<EOL><DEDENT> <DEDENT>class ArgumentHandler(_Handler):<EOL><INDENT>tag='arg'<EOL>def end(self,elem,result):<EOL><INDENT>result.args.append(elem.text or '')<EOL><DEDENT> <DEDENT>class ErrorsHandler(_Handler):<EOL><INDENT>tag='errors'<EOL>def start(self,elem,result):<EOL><INDENT>return result.errors <EOL><DEDENT>def _children(self):<EOL><INDENT>return [MessageHandler()]<EOL><DEDENT> <DEDENT>class StatisticsHandler(_Handler):<EOL><INDENT>tag='statistics'<EOL>def handle_child(self,elem,result):<EOL><INDENT>return result,self <EOL><DEDENT> <DEDENT><EOF><BOF>import os <EOL>import re <EOL>from robot.errors import DataError <EOL>from robot.htmldata import HtmlFileWriter,ModelWriter,JsonWriter,LIBDOC <EOL>from robot import utils <EOL>class LibdocHtmlWriter(object):<EOL><INDENT>def write(self,libdoc,output):<EOL><INDENT>model_writer=LibdocModelWriter(output,libdoc)<EOL>HtmlFileWriter(output,model_writer).write(LIBDOC)<EOL><DEDENT> <DEDENT>class LibdocModelWriter(ModelWriter):<EOL><INDENT>def __init__(self,output,libdoc):<EOL><INDENT>self._output=output <EOL>self._libdoc=libdoc <EOL><DEDENT>def write(self,line):<EOL><INDENT>self._output.write('<STR_LIT>'+os.linesep)<EOL>self.write_data()<EOL>self._output.write('</script>'+os.linesep)<EOL><DEDENT>def write_data(self):<EOL><INDENT>formatter=DocFormatter(self._libdoc.keywords,self._libdoc.doc,<EOL>self._libdoc.doc_format)<EOL>libdoc=JsonConverter(formatter).convert(self._libdoc)<EOL>JsonWriter(self._output).write_json('libdoc= ',libdoc)<EOL><DEDENT> <DEDENT>class JsonConverter(object):<EOL><INDENT>def __init__(self,doc_formatter):<EOL><INDENT>self._doc_formatter=doc_formatter <EOL><DEDENT>def convert(self,libdoc):<EOL><INDENT>return {<EOL>'name':libdoc.name,<EOL>'doc':self._doc_formatter.html(libdoc.doc,intro=True),<EOL>'version':libdoc.version,<EOL>'named_args':libdoc.named_args,<EOL>'scope':libdoc.scope,<EOL>'generated':utils.get_timestamp(daysep='-',millissep=None),<EOL>'inits':self._get_keywords(libdoc.inits),<EOL>'keywords':self._get_keywords(libdoc.keywords)<EOL>}<EOL><DEDENT>def _get_keywords(self,keywords):<EOL><INDENT>return [self._convert_keyword(kw)for kw in keywords ]<EOL><DEDENT>def _convert_keyword(self,kw):<EOL><INDENT>return {<EOL>'name':kw.name,<EOL>'args':', '.join(kw.args),<EOL>'doc':self._doc_formatter.html(kw.doc),<EOL>'shortdoc':kw.shortdoc <EOL>}<EOL><DEDENT> <DEDENT>class DocFormatter(object):<EOL><INDENT>_header_regexp=re.compile(r'<h2>(.+?)</h2>')<EOL>_name_regexp=re.compile('`(.+?)`')<EOL>def __init__(self,keywords,introduction,doc_format='ROBOT'):<EOL><INDENT>self._doc_to_html=DocToHtml(doc_format)<EOL>self._targets=self._get_targets(keywords,introduction,<EOL>doc_format=='ROBOT')<EOL><DEDENT>def _get_targets(self,keywords,introduction,robot_format):<EOL><INDENT>targets=utils.NormalizedDict({<EOL>'introduction':'introduction',<EOL>'<STR_LIT>':'introduction',<EOL>'importing':'importing',<EOL>'<STR_LIT>':'importing',<EOL>'shortcuts':'shortcuts',<EOL>'keywords':'keywords'<EOL>})<EOL>for kw in keywords :<EOL><INDENT>targets [kw.name ]=kw.name <EOL><DEDENT>if robot_format :<EOL><INDENT>for header in self._yield_header_targets(introduction):<EOL><INDENT>targets [header ]=header <EOL><DEDENT> <DEDENT>return targets <EOL><DEDENT>def _yield_header_targets(self,introduction):<EOL><INDENT>for line in introduction.splitlines():<EOL><INDENT>line=line.strip()<EOL>if line.startswith('= ')and line.endswith('='):<EOL><INDENT>yield line [:-].strip()<EOL><DEDENT> <DEDENT> <DEDENT>def html(self,doc,intro=False):<EOL><INDENT>doc=self._doc_to_html(doc)<EOL>if intro :<EOL><INDENT>doc=self._header_regexp.sub('<STR_LIT>',doc)<EOL><DEDENT>return self._name_regexp.sub(self._link_keywords,doc)<EOL><DEDENT>def _link_keywords(self,match):<EOL><INDENT>name=match.group()<EOL>if name in self._targets :<EOL><INDENT>return '<STR_LIT>'%(self._targets [name ],name)<EOL><DEDENT>return '<STR_LIT>'%name <EOL><DEDENT> <DEDENT>class DocToHtml(object):<EOL><INDENT>def __init__(self,format):<EOL><INDENT>self._formatter=self._get_formatter(format)<EOL><DEDENT>def _get_formatter(self,format):<EOL><INDENT>try :<EOL><INDENT>return {'ROBOT':utils.html_format,<EOL>'TEXT':self._format_text,<EOL>'HTML':self._format_html,<EOL>'REST':self._format_rest }[format ]<EOL><DEDENT>except KeyError :<EOL><INDENT>raise DataError('<STR_LIT>'%format)<EOL><DEDENT> <DEDENT>def _format_text(self,doc):<EOL><INDENT>return '<STR_LIT>'%utils.html_escape(doc)<EOL><DEDENT>def _format_html(self,doc):<EOL><INDENT>return '<STR_LIT>'%doc <EOL><DEDENT>def _format_rest(self,doc):<EOL><INDENT>try :<EOL><INDENT>from docutils.core import publish_parts <EOL><DEDENT>except ImportError :<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>parts=publish_parts(doc,writer_name='html')<EOL>return self._format_html(parts ['html_body'])<EOL><DEDENT>def __call__(self,doc):<EOL><INDENT>return self._formatter(doc)<EOL><DEDENT> <DEDENT><EOF><BOF>import numpy as np <EOL>import cv2 <EOL>def draw_match(img1,kp1,<EOL>img2,kp2,<EOL>matches,<EOL>output=None,<EOL>matchColor=(,,),<EOL>matchesMask=None,<EOL>*args,**kargs):<EOL><INDENT>h1=img1.shape []<EOL>w1=img1.shape []<EOL>h2=img2.shape []<EOL>w2=img2.shape []<EOL>w=w1 +w2 <EOL>h=max(h1,h2)<EOL>outimg=np.full((h,w,),,np.uint8)<EOL>img1_=img1.copy()<EOL>img2_=img2.copy()<EOL>if len(img1.shape)==or img1.shape []==:<EOL><INDENT>img1_=cv2.cvtColor(img1_,cv2.COLOR_GRAY2BGR)<EOL><DEDENT>if len(img2.shape)==or img2.shape []==:<EOL><INDENT>img2_=cv2.cvtColor(img2_,cv2.COLOR_GRAY2BGR)<EOL><DEDENT>outimg [:h1,:w1,:]=img1_ <EOL>outimg [:h2,w1 :w1 +w2,:]=img2_ <EOL>for i,m in enumerate(matches):<EOL><INDENT>if matchesMask is not None and matchesMask [i ]==:continue <EOL>i1,i2=m.queryIdx,m.trainIdx <EOL>pt1,pt2=kp1 [i1 ].pt,kp2 [i2 ].pt <EOL>pt1=(int(pt1 []),int(pt1 []))<EOL>pt2=(int(w1 +pt2 []),int(pt2 []))<EOL>cv2.line(outimg,pt1,pt2,matchColor)<EOL><DEDENT>if output is not None :<EOL><INDENT>output=outimg.copy()<EOL><DEDENT>return outimg <EOL><DEDENT>def test_feature_matching_realtime(detetor=cv2.ORB()):<EOL><INDENT>from cam import MyCam <EOL>'<STR_LIT>'<EOL>MIN_MATCH_COUNT=<EOL>cam=MyCam()<EOL>cam.size=(,)<EOL>img1=img1=cv2.imread('box.png',)<EOL>cv2.imshow('source',img1)<EOL>while True :<EOL><INDENT>img2=cv2.flip(cv2.cvtColor(cam.read(),cv2.COLOR_BGR2GRAY),)<EOL>k=cv2.waitKey()<EOL>if k==ord('s'):<EOL><INDENT>img1=img2.copy()<EOL>cv2.imwrite('campic.png',img1)<EOL><DEDENT>elif k==:<EOL><INDENT>break <EOL><DEDENT>if k is not None :<EOL><INDENT>cv2.destroyWindow('preview')<EOL>kp1,des1=detetor.detectAndCompute(img1,None)<EOL><DEDENT>kp2,des2=detetor.detectAndCompute(img2,None)<EOL>if des2 is None :<EOL><INDENT>img3=img3=draw_match(img1,kp1,img2,kp2,[])<EOL>continue <EOL><DEDENT>des1=des1.astype(np.uint8,copy=False)<EOL>des2=des2.astype(np.uint8,copy=False)<EOL>bf=cv2.BFMatcher(cv2.NORM_HAMMING)<EOL>matches=bf.knnMatch(des1,des2,k=)<EOL>good=[]<EOL>try :<EOL><INDENT>for m,n in matches :<EOL><INDENT>if m.distance <*n.distance :<EOL><INDENT>good.append(m)<EOL><DEDENT> <DEDENT> <DEDENT>except ValueError :<EOL><INDENT>good=[]<EOL><DEDENT>if len(good)>MIN_MATCH_COUNT :<EOL><INDENT>src_pts=np.float32([kp1 [m.queryIdx ].pt for m in good ]).reshape(-,,)<EOL>dst_pts=np.float32([kp2 [m.trainIdx ].pt for m in good ]).reshape(-,,)<EOL>M,mask=cv2.findHomography(src_pts,dst_pts,cv2.RANSAC,)<EOL>matchesMask=mask.ravel().tolist()<EOL>h,w=img1.shape <EOL>pts=np.float32([[,],[,h -],[w -,h -],[w -,]]).reshape(-,,)<EOL>dst=cv2.perspectiveTransform(pts,M)<EOL>cv2.polylines(img2,[np.int32(dst)],True,(,,),)<EOL><DEDENT>else :<EOL><INDENT>matchesMask=None <EOL>good=[]<EOL><DEDENT>img3=draw_match(img1,kp1,img2,kp2,good,matchesMask=matchesMask)<EOL>cv2.imshow('matches',img3)<EOL><DEDENT>print '<STR_LIT>'<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>test_feature_matching_realtime()<DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from robot.parsing import TestCaseFile,TestDataDirectory,ResourceFile,TestData <EOL>from robot.result import ExecutionResult <EOL>from robot.running import TestSuite <EOF><BOF>import re <EOL>from functools import partial <EOL>from itertools import cycle <EOL>class LinkFormatter(object):<EOL><INDENT>_image_exts=('.jpg','.jpeg','.png','.gif','.bmp')<EOL>_link=re.compile('\[(.+?\|.*?)\]')<EOL>_url=re.compile('<STR_LIT>',re.VERBOSE |re.MULTILINE)<EOL>def format_url(self,text):<EOL><INDENT>return self._format_url(text,format_as_image=False)<EOL><DEDENT>def _format_url(self,text,format_as_image=True):<EOL><INDENT>if '://'not in text :<EOL><INDENT>return text <EOL><DEDENT>return self._url.sub(partial(self._replace_url,format_as_image),text)<EOL><DEDENT>def _replace_url(self,format_as_image,match):<EOL><INDENT>pre=match.group()<EOL>url=match.group()<EOL>if format_as_image and self._is_image(url):<EOL><INDENT>return pre +self._get_image(url)<EOL><DEDENT>return pre +self._get_link(url)<EOL><DEDENT>def _get_image(self,src,title=None):<EOL><INDENT>return '<STR_LIT>'%(self._quot(src),self._quot(title or src))<EOL><DEDENT>def _get_link(self,href,content=None):<EOL><INDENT>return '<STR_LIT>'%(self._quot(href),content or href)<EOL><DEDENT>def _quot(self,attr):<EOL><INDENT>return attr if '"'not in attr else attr.replace('"','&quot;')<EOL><DEDENT>def format_link(self,text):<EOL><INDENT>tokens=self._link.split(text)<EOL>formatters=cycle((self._format_url,self._format_link))<EOL>return ''.join(f(t)for f,t in zip(formatters,tokens))<EOL><DEDENT>def _format_link(self,text):<EOL><INDENT>link,content=[t.strip()for t in text.split('|',)]<EOL>if self._is_image(content):<EOL><INDENT>content=self._get_image(content,link)<EOL><DEDENT>elif self._is_image(link):<EOL><INDENT>return self._get_image(link,content)<EOL><DEDENT>return self._get_link(link,content)<EOL><DEDENT>def _is_image(self,text):<EOL><INDENT>return text.lower().endswith(self._image_exts)<EOL><DEDENT> <DEDENT>class LineFormatter(object):<EOL><INDENT>handles=lambda self,line :True <EOL>newline='\n'<EOL>_bold=re.compile('<STR_LIT>',re.VERBOSE)<EOL>_italic=re.compile('<STR_LIT>',re.VERBOSE)<EOL>def __init__(self):<EOL><INDENT>self._format_link=LinkFormatter().format_link <EOL><DEDENT>def format(self,line):<EOL><INDENT>return self._format_link(self._format_italic(self._format_bold(line)))<EOL><DEDENT>def _format_bold(self,line):<EOL><INDENT>return self._bold.sub('\\1<b>\\3</b>',line)if '*'in line else line <EOL><DEDENT>def _format_italic(self,line):<EOL><INDENT>return self._italic.sub('\\1<i>\\3</i>',line)if '_'in line else line <EOL><DEDENT> <DEDENT>class HtmlFormatter(object):<EOL><INDENT>def __init__(self):<EOL><INDENT>self._results=[]<EOL>self._formatters=[TableFormatter(),<EOL>PreformattedFormatter(),<EOL>ListFormatter(),<EOL>HeaderFormatter(),<EOL>RulerFormatter()]<EOL>self._formatters.append(ParagraphFormatter(self._formatters [:]))<EOL>self._current=None <EOL><DEDENT>def format(self,text):<EOL><INDENT>for line in text.splitlines():<EOL><INDENT>self._process_line(line)<EOL><DEDENT>self._end_current()<EOL>return '\n'.join(self._results)<EOL><DEDENT>def _process_line(self,line):<EOL><INDENT>if not line.strip():<EOL><INDENT>self._end_current()<EOL><DEDENT>elif self._current and self._current.handles(line):<EOL><INDENT>self._current.add(line)<EOL><DEDENT>else :<EOL><INDENT>self._end_current()<EOL>self._current=self._find_formatter(line)<EOL>self._current.add(line)<EOL><DEDENT> <DEDENT>def _end_current(self):<EOL><INDENT>if self._current :<EOL><INDENT>self._results.append(self._current.end())<EOL>self._current=None <EOL><DEDENT> <DEDENT>def _find_formatter(self,line):<EOL><INDENT>for formatter in self._formatters :<EOL><INDENT>if formatter.handles(line):<EOL><INDENT>return formatter <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>class _Formatter(object):<EOL><INDENT>_strip_lines=True <EOL>def __init__(self):<EOL><INDENT>self._lines=[]<EOL><DEDENT>def handles(self,line):<EOL><INDENT>return self._handles(line.strip()if self._strip_lines else line)<EOL><DEDENT>def _handles(self,line):<EOL><INDENT>raise NotImplementedError <EOL><DEDENT>def add(self,line):<EOL><INDENT>self._lines.append(line.strip()if self._strip_lines else line)<EOL><DEDENT>def end(self):<EOL><INDENT>result=self.format(self._lines)<EOL>self._lines=[]<EOL>return result <EOL><DEDENT>def format(self,lines):<EOL><INDENT>raise NotImplementedError <EOL><DEDENT> <DEDENT>class _SingleLineFormatter(_Formatter):<EOL><INDENT>def _handles(self,line):<EOL><INDENT>return not self._lines and self._match(line)<EOL><DEDENT>def _match(self,line):<EOL><INDENT>raise NotImplementedError <EOL><DEDENT>def format(self,lines):<EOL><INDENT>return self.format_line(lines [])<EOL><DEDENT>def format_line(self,line):<EOL><INDENT>raise NotImplementedError <EOL><DEDENT> <DEDENT>class RulerFormatter(_SingleLineFormatter):<EOL><INDENT>_match=re.compile('^-{3,}$').match <EOL>def format_line(self,line):<EOL><INDENT>return '<hr>'<EOL><DEDENT> <DEDENT>class HeaderFormatter(_SingleLineFormatter):<EOL><INDENT>_match=re.compile('<STR_LIT>').match <EOL>def format_line(self,line):<EOL><INDENT>level,text=self._match(line).groups()<EOL>level=len(level)+<EOL>return '<h%d>%s</h%d>'%(level,text,level)<EOL><DEDENT> <DEDENT>class ParagraphFormatter(_Formatter):<EOL><INDENT>_format_line=LineFormatter().format <EOL>def __init__(self,other_formatters):<EOL><INDENT>_Formatter.__init__(self)<EOL>self._other_formatters=other_formatters <EOL><DEDENT>def _handles(self,line):<EOL><INDENT>return not any(other.handles(line)<EOL>for other in self._other_formatters)<EOL><DEDENT>def format(self,lines):<EOL><INDENT>return '<p>%s</p>'%self._format_line(' '.join(lines))<EOL><DEDENT> <DEDENT>class TableFormatter(_Formatter):<EOL><INDENT>_table_line=re.compile('^\|(.* |)\|$')<EOL>_line_splitter=re.compile(' \|(?=)')<EOL>_format_cell=LineFormatter().format <EOL>def _handles(self,line):<EOL><INDENT>return self._table_line.match(line)is not None <EOL><DEDENT>def format(self,lines):<EOL><INDENT>return self._format_table([self._split_to_cells(l)for l in lines ])<EOL><DEDENT>def _split_to_cells(self,line):<EOL><INDENT>return [cell.strip()for cell in self._line_splitter.split(line [:-])]<EOL><DEDENT>def _format_table(self,rows):<EOL><INDENT>maxlen=max(len(row)for row in rows)<EOL>table=['<STR_LIT>']<EOL>for row in rows :<EOL><INDENT>row +=['']*(maxlen -len(row))<EOL>table.append('<tr>')<EOL>table.extend('<td>%s</td>'%self._format_cell(c)for c in row)<EOL>table.append('</tr>')<EOL><DEDENT>table.append('</table>')<EOL>return '\n'.join(table)<EOL><DEDENT> <DEDENT>class PreformattedFormatter(_Formatter):<EOL><INDENT>_format_line=LineFormatter().format <EOL>def _handles(self,line):<EOL><INDENT>return line.startswith('| ')or line=='|'<EOL><DEDENT>def format(self,lines):<EOL><INDENT>lines=[self._format_line(line [:])for line in lines ]<EOL>return '\n'.join(['<pre>']+lines +['</pre>'])<EOL><DEDENT> <DEDENT>class ListFormatter(_Formatter):<EOL><INDENT>_strip_lines=False <EOL>_format_item=LineFormatter().format <EOL>def _handles(self,line):<EOL><INDENT>return line.strip().startswith('- ')or line.startswith(' ')and self._lines <EOL><DEDENT>def format(self,lines):<EOL><INDENT>items=['<li>%s</li>'%self._format_item(line)<EOL>for line in self._combine_lines(lines)]<EOL>return '\n'.join(['<ul>']+items +['</ul>'])<EOL><DEDENT>def _combine_lines(self,lines):<EOL><INDENT>current=[]<EOL>for line in lines :<EOL><INDENT>line=line.strip()<EOL>if not line.startswith('- '):<EOL><INDENT>current.append(line)<EOL>continue <EOL><DEDENT>if current :<EOL><INDENT>yield ' '.join(current)<EOL><DEDENT>current=[line [:].strip()]<EOL><DEDENT>yield ' '.join(current)<EOL><DEDENT> <DEDENT><EOF><BOF>from flask_wtf import Form <EOL>from wtforms.fields import StringField,TextAreaField,SubmitField <EOL>from wtforms.validators import DataRequired,Length <EOL>class PostForm(Form):<EOL><INDENT>title=StringField(<EOL>u'Post Title',<EOL>validators=[<EOL>DataRequired(message=u'Empty title'),<EOL>Length(max=,message='<STR_LIT>')<EOL>])<EOL>description=TextAreaField(<EOL>u'Description',<EOL>validators=[<EOL>DataRequired(message='<STR_LIT>'),<EOL>Length(max=,message='<STR_LIT>')<EOL>])<EOL>body=TextAreaField(<EOL>u'Content',<EOL>validators=[DataRequired(message=u'Empty Post')])<EOL>submit=SubmitField(u'Add Post')<EOL><DEDENT>class TagForm(Form):<EOL><INDENT> '<STR_LIT>'<EOL>name=StringField(<EOL>'<STR_LIT>',<EOL>validators=[<EOL>DataRequired(message=u'Empty name'),<EOL>Length(max=,message='<STR_LIT>')<EOL>])<EOL><DEDENT><EOF><BOF>from collections import OrderedDict <EOL>from zerotest.request import Request <EOL>from zerotest.utils.generator_helper import(<EOL>get_name_from_request,<EOL>dict_to_param_style_code )<EOL>INVALID_CHARS=(<EOL>'*',<EOL>'-',<EOL>'#',<EOL>'/',<EOL>'.')<EOL>def test_get_name_from_request():<EOL><INDENT>req=Request(path='/',method='GET')<EOL>assert get_name_from_request(req)=='get_root'<EOL>req=Request(path='/the/world',method='PUT')<EOL>assert get_name_from_request(req)=='put_the_world'<EOL>for invalid_char in INVALID_CHARS :<EOL><INDENT>assert(<EOL>get_name_from_request(<EOL>Request(<EOL>path='<STR_LIT>'.format(invalid_char),<EOL>method='GET'))=='<STR_LIT>')<EOL><DEDENT> <DEDENT>def test_dict_to_param_style_code():<EOL><INDENT>test_dict=OrderedDict()<EOL>test_dict ['param_a']='A'<EOL>test_dict ['test_c']='C'<EOL>assert dict_to_param_style_code(test_dict)=='<STR_LIT>'<EOL><DEDENT><EOF><BOF>import cv2 <EOL>import numpy as np <EOL>from cam import OpenCV_Cam <EOL>from time import time <EOL>def draw_oriented_polylines(img,pts_in,is_closed,color_start,thickness=,color_end=(,,)):<EOL><INDENT>img_out=img <EOL>pts=pts_in.reshape(-,)<EOL>if len(img.shape)==or img.shape []==:<EOL><INDENT>img_out=cv2.cvtColor(img_out,cv2.COLOR_GRAY2BGR)<EOL><DEDENT>cs,ce=color_start,color_end <EOL>n=len(pts)<EOL>for idx,pt in enumerate(pts):<EOL><INDENT>if idx==n and not is_closed :break <EOL>next_pt=pts [(idx +)%n ]<EOL>color=((cs []*(n -idx)+ce []*idx)/n,(cs []*(n -idx)+ce []*idx)/n,(cs []*(n -idx)+ce []*idx)/n)<EOL>cv2.line(img_out,tuple(pt),tuple(next_pt),color,thickness)<EOL><DEDENT> <DEDENT>def find_polygons(gray_image_in,edge_num,tolerance=,area_threshold=,convex_only=True,edge_threshold=,orientation=):<EOL><INDENT> '<STR_LIT>'<EOL>img=gray_image_in.copy()<EOL>lo,hi=,<EOL>edge=cv2.Canny(img,lo,hi)<EOL>thresh1,dst=cv2.threshold(edge,edge_threshold,,cv2.THRESH_BINARY)<EOL>ctr,hry=cv2.findContours(dst,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)<EOL>if hry is None :return []<EOL>hry=hry []<EOL>polygons=[]<EOL>for cnt in ctr :<EOL><INDENT>cnt=cnt.reshape(-,)<EOL>epsilon=tolerance **((*cv2.contourArea(cnt))**)<EOL>tmp=cv2.approxPolyDP(cnt,epsilon,True)<EOL>if len(tmp)!=edge_num :continue <EOL>if convex_only and not cv2.isContourConvex(tmp):continue <EOL>if cv2.contourArea(tmp)<area_threshold :continue <EOL>cross_product=np.cross(tmp []-tmp [],tmp []-tmp [])[]<EOL>if cross_product *orientation >:<EOL><INDENT>tmp=np.flipud(tmp)<EOL><DEDENT>tmp=tmp.reshape(-,)<EOL>distance_from_origin=map(lambda pt :pt []**+pt []**,tmp)<EOL>val,idx=min((val,idx)for(idx,val)in enumerate(distance_from_origin))<EOL>if idx >:<EOL><INDENT>up,down=np.vsplit(tmp,[idx ])<EOL>tmp=np.vstack((down,up))<EOL><DEDENT>polygons.append(tmp)<EOL><DEDENT>return polygons <EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>cam=OpenCV_Cam()<EOL>while True :<EOL><INDENT>img=cam.read()<EOL>polygons=find_polygons(img,)<EOL>for ctr in polygons :<EOL><INDENT>draw_oriented_polylines(img,ctr,,(,,),,(,,))<EOL><DEDENT>cv2.imshow('<STR_LIT>',img)<EOL>k=cv2.waitKey()<EOL>if k==:<EOL><INDENT>break <DEDENT> <DEDENT> <DEDENT><EOF><BOF>import slugify <EOL>from flask import url_for <EOL>from vomitter import LOGGER as L <EOL>from yapper import db <EOL>from yapper.lib.models import BaseModel <EOL>from yapper.lib.cache import cache <EOL>from yapper.lib.decorators import profile <EOL>from yapper.utilities.md import create_post_from_md <EOL>TYPE_POST=<EOL>TYPE_PAGE=<EOL>tags_posts=db.Table(<EOL>'tags_posts',<EOL>db.Column('id',db.Integer,primary_key=True),<EOL>db.Column('tag_id',db.Integer,db.ForeignKey('tags.id')),<EOL>db.Column('post_id',db.Integer,db.ForeignKey('posts.id')))<EOL>categories_posts=db.Table(<EOL>'<STR_LIT>',<EOL>db.Column('id',db.Integer,primary_key=True),<EOL>db.Column('category_id',db.Integer,db.ForeignKey('categories.id')),<EOL>db.Column('post_id',db.Integer,db.ForeignKey('posts.id')))<EOL>class Tag(BaseModel):<EOL><INDENT>__tablename__='tags'<EOL>id=db.Column(db.Integer(),primary_key=True)<EOL>name=db.Column(db.String(),unique=True,index=True)<EOL>def __repr__(self):<EOL><INDENT>return '<Tag %s>'%self.name <EOL><DEDENT>def to_json(self):<EOL><INDENT>json_data={<EOL>'id':self.id,<EOL>'name':self.name,<EOL>'created_at':str(self.created_at)}<EOL>return json_data <EOL><DEDENT> <DEDENT>class Category(BaseModel):<EOL><INDENT>__tablename__='categories'<EOL>id=db.Column(db.Integer(),primary_key=True)<EOL>name=db.Column(db.String(),unique=True,index=True)<EOL>def __repr__(self):<EOL><INDENT>return '<Category %s>'%self.name <EOL><DEDENT>def to_json(self):<EOL><INDENT>json_data={<EOL>'id':self.id,<EOL>'name':self.name,<EOL>'created_at':str(self.created_at)}<EOL>return json_data <EOL><DEDENT> <DEDENT>class Post(BaseModel):<EOL><INDENT>__tablename__='posts'<EOL>author_id=db.Column(db.Integer,db.ForeignKey('users.id'))<EOL>title=db.Column(db.String())<EOL>slug=db.Column(db.String(),unique=True)<EOL>description=db.Column(db.Text,default='')<EOL>body=db.Column(db.Text,default='')<EOL>status=db.Column(db.Boolean,default=True)<EOL>body_html=db.Column(db.Text,default='')<EOL>tags=db.relationship(<EOL>'Tag',secondary=tags_posts,<EOL>backref=db.backref('posts',lazy='dynamic'))<EOL>categories=db.relationship(<EOL>'Category',secondary=categories_posts,<EOL>backref=db.backref('posts',lazy='dynamic'))<EOL>def to_json(self):<EOL><INDENT>json_data={<EOL>'id':self.id,<EOL>'title':self.title,<EOL>'slug':self.slug,<EOL>'description':self.description,<EOL>'created_at':str(self.created_at),<EOL>'modified_at':str(self.modified_at),<EOL>'author':self.author.to_json(),<EOL>'permalink':url_for('<STR_LIT>',<EOL>slug=self.slug,_external=True)<EOL>}<EOL>return json_data <EOL><DEDENT>@classmethod <EOL>@profile <EOL>def get_by_slug(cls,slug):<EOL><INDENT>L.d('<STR_LIT>')<EOL>obj=cache.get(cls.key(slug))<EOL>if obj :<EOL><INDENT>L.d('<STR_LIT>'%cls.key(slug))<EOL>return obj <EOL><DEDENT>L.d('<STR_LIT>'%cls.key(slug))<EOL>obj=cls.query.filter_by(slug=slug).first()<EOL>if obj :<EOL><INDENT>L.d('<STR_LIT>'%cls.key(slug))<EOL>cache.set(cls.key(slug),obj)<EOL><DEDENT>else :<EOL><INDENT>L.d('<STR_LIT>')<EOL><DEDENT>return obj <EOL><DEDENT>@property <EOL>def content(self):<EOL><INDENT>return self.body <EOL><DEDENT>@content.setter <EOL>def content(self,body):<EOL><INDENT>self.body=body <EOL>self.body_html=create_post_from_md(body)<EOL><DEDENT>@property <EOL>def html(self):<EOL><INDENT>return self.body_html <EOL><DEDENT>@staticmethod <EOL>def on_change_body(target,value,oldvalue,initiator):<EOL><INDENT>target.body_html=create_post_from_md(value)<EOL><DEDENT>@staticmethod <EOL>def generate_fake(count=):<EOL><INDENT>from random import seed <EOL>import forgery_py <EOL>seed()<EOL>for i in range(count):<EOL><INDENT>author_id=<EOL>title=forgery_py.lorem_ipsum.sentence()<EOL>p=Post(<EOL>content=forgery_py.lorem_ipsum.paragraphs(),<EOL>title=title,<EOL>slug=slugify.slugify(title),<EOL>description=forgery_py.lorem_ipsum.sentence(),<EOL>author_id=author_id )<EOL>db.session.add(p)<EOL><DEDENT>db.session.commit()<EOL><DEDENT> <DEDENT>db.event.listen(Post.body,'set',Post.on_change_body)<EOF><BOF>USAGE='<STR_LIT>'<EOL>import os <EOL>import sys <EOL>from StringIO import StringIO <EOL>if 'robot'not in sys.modules and __name__=='__main__':<EOL><INDENT>import pythonpathsetter <EOL><DEDENT>from robot.errors import DataError <EOL>from robot.parsing import(ResourceFile,TestDataDirectory,TestCaseFile,<EOL>disable_curdir_processing)<EOL>from robot.utils import Application <EOL>class Tidy(object):<EOL><INDENT>def __init__(self,**options):<EOL><INDENT>self._options=options <EOL><DEDENT>def file(self,path,output=None):<EOL><INDENT>data=self._create_datafile(path)<EOL>outfile=open(output,'w')if output else StringIO()<EOL>try :<EOL><INDENT>self._save_file(data,outfile)<EOL>if not output :<EOL><INDENT>return outfile.getvalue().replace('\r\n','\n').decode('UTF-8')<EOL><DEDENT> <DEDENT>finally :<EOL><INDENT>outfile.close()<EOL><DEDENT> <DEDENT>def directory(self,path):<EOL><INDENT>self._save_directory(TestDataDirectory(source=path).populate())<EOL><DEDENT>def inplace(self,path):<EOL><INDENT>self._save_file(self._create_datafile(path))<EOL><DEDENT>def _save_file(self,data,output=None):<EOL><INDENT>source=data.initfile if self._is_directory(data)else data.source <EOL>if source and not output :<EOL><INDENT>os.remove(source)<EOL><DEDENT>data.save(output=output,**self._options)<EOL><DEDENT>def _save_directory(self,data):<EOL><INDENT>if not self._is_directory(data):<EOL><INDENT>self._save_file(data)<EOL>return <EOL><DEDENT>if data.initfile :<EOL><INDENT>self._save_file(data)<EOL><DEDENT>for child in data.children :<EOL><INDENT>self._save_directory(child)<EOL><DEDENT> <DEDENT>def _is_directory(self,data):<EOL><INDENT>return hasattr(data,'initfile')<EOL><DEDENT>@disable_curdir_processing <EOL>def _create_datafile(self,source):<EOL><INDENT>if self._is_init_file(source):<EOL><INDENT>dir_=os.path.dirname(source)<EOL>return TestDataDirectory(source=dir_).populate(recurse=False)<EOL><DEDENT>try :<EOL><INDENT>return TestCaseFile(source=source).populate()<EOL><DEDENT>except DataError :<EOL><INDENT>try :<EOL><INDENT>return ResourceFile(source=source).populate()<EOL><DEDENT>except DataError :<EOL><INDENT>raise DataError('<STR_LIT>'%source)<EOL><DEDENT> <DEDENT> <DEDENT>def _is_init_file(self,source):<EOL><INDENT>return os.path.splitext(os.path.basename(source))[]=='__init__'<EOL><DEDENT> <DEDENT>class TidyCommandLine(Application):<EOL><INDENT>def __init__(self):<EOL><INDENT>Application.__init__(self,USAGE,arg_limits=(,))<EOL><DEDENT>def main(self,arguments,recursive=False,inplace=False,format='txt',<EOL>usepipes=False,spacecount=):<EOL><INDENT>tidy=Tidy(format=format,pipe_separated=usepipes,<EOL>txt_separating_spaces=spacecount)<EOL>if recursive :<EOL><INDENT>tidy.directory(arguments [])<EOL><DEDENT>elif inplace :<EOL><INDENT>for source in arguments :<EOL><INDENT>tidy.inplace(source)<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>output=tidy.file(*arguments)<EOL>self.console(output)<EOL><DEDENT> <DEDENT>def validate(self,opts,args):<EOL><INDENT>self._validate_mode_and_arguments(args,**opts)<EOL>opts ['format']=self._validate_format(args,**opts)<EOL>if not opts ['spacecount']:<EOL><INDENT>opts.pop('spacecount')<EOL><DEDENT>else :<EOL><INDENT>opts ['spacecount']=self._validate_spacecount(opts ['spacecount'])<EOL><DEDENT>return opts,args <EOL><DEDENT>def _validate_mode_and_arguments(self,args,inplace,recursive,**others):<EOL><INDENT>if inplace and recursive :<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>if recursive and(len(args)>or not os.path.isdir(args [])):<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>if not(inplace or recursive)and len(args)>:<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT> <DEDENT>def _validate_format(self,args,format,inplace,recursive,**others):<EOL><INDENT>if not format :<EOL><INDENT>if inplace or recursive or len(args)<:<EOL><INDENT>return None <EOL><DEDENT>format=os.path.splitext(args [])[][:]<EOL><DEDENT>format=format.upper()<EOL>if format not in ['TXT','TSV','HTML']:<EOL><INDENT>raise DataError('<STR_LIT>'%format)<EOL><DEDENT>return format <EOL><DEDENT>def _validate_spacecount(self,spacecount):<EOL><INDENT>try :<EOL><INDENT>spacecount=int(spacecount)<EOL>if spacecount <:<EOL><INDENT>raise ValueError <EOL><DEDENT> <DEDENT>except ValueError :<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>return spacecount <EOL><DEDENT> <DEDENT>def tidy_cli(args):<EOL><INDENT> '<STR_LIT>'<EOL>TidyCommandLine().execute_cli(args)<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>tidy_cli(sys.argv [:])<EOL><DEDENT><EOF><BOF>from robot.utils import setter <EOL>from itemlist import ItemList <EOL>from message import Message,Messages <EOL>from modelobject import ModelObject <EOL>class Keyword(ModelObject):<EOL><INDENT>__slots__=['parent','name','doc','args','type','timeout']<EOL>KEYWORD_TYPE='kw'<EOL>SETUP_TYPE='setup'<EOL>TEARDOWN_TYPE='teardown'<EOL>FOR_LOOP_TYPE='for'<EOL>FOR_ITEM_TYPE='foritem'<EOL>message_class=Message <EOL>def __init__(self,name='',doc='',args=None,type='kw',timeout=''):<EOL><INDENT>self.parent=None <EOL>self.name=name <EOL>self.doc=doc <EOL>self.args=args or []<EOL>self.type=type <EOL>self.timeout=timeout <EOL>self.messages=[]<EOL>self.keywords=[]<EOL><DEDENT>@setter <EOL>def keywords(self,keywords):<EOL><INDENT>return Keywords(self.__class__,self,keywords)<EOL><DEDENT>@setter <EOL>def messages(self,messages):<EOL><INDENT>return Messages(self.message_class,self,messages)<EOL><DEDENT>@property <EOL>def id(self):<EOL><INDENT>if not self.parent :<EOL><INDENT>return 'k1'<EOL><DEDENT>return '%s-k%d'%(self.parent.id,self.parent.keywords.index(self)+)<EOL><DEDENT>def visit(self,visitor):<EOL><INDENT>visitor.visit_keyword(self)<EOL><DEDENT> <DEDENT>class Keywords(ItemList):<EOL><INDENT>__slots__=[]<EOL>def __init__(self,keyword_class=Keyword,parent=None,keywords=None):<EOL><INDENT>ItemList.__init__(self,keyword_class,{'parent':parent },keywords)<EOL><DEDENT>@property <EOL>def setup(self):<EOL><INDENT>return self []if(self and self [].type=='setup')else None <EOL><DEDENT>@property <EOL>def teardown(self):<EOL><INDENT>return self [-]if(self and self [-].type=='teardown')else None <EOL><DEDENT>@property <EOL>def all(self):<EOL><INDENT>return self <EOL><DEDENT>@property <EOL>def normal(self):<EOL><INDENT>for kw in self :<EOL><INDENT>if kw.type not in('setup','teardown'):<EOL><INDENT>yield kw <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>__author__='<STR_LIT>'<EOL>from google.appengine.ext import db <EOL>from oauth2client.appengine import CredentialsProperty <EOL>class Credentials(db.Model):<EOL><INDENT> '<STR_LIT>'<EOL>credentials=CredentialsProperty()<EOL><DEDENT><EOF><BOF>__title__='jsongit'<EOL>__author__='John Krauss'<EOL>__license__='BSD'<EOL>__copyright__='<STR_LIT>'<EOL>from.api import init <EOL>from.utils import signature,global_config <EOL>from.exceptions import(<EOL>NotJsonError,InvalidKeyError,DifferentRepoError,NoGlobalSettingError,<EOL>StagedDataError)<EOL>from.constants import GIT_SORT_NONE,GIT_SORT_TOPOLOGICAL,GIT_SORT_TIME,GIT_SORT_REVERSE <EOF><BOF>import sys <EOL>VERSION='2.7.5'<EOL>RELEASE='final'<EOL>TIMESTAMP='20121024-155048'<EOL>def get_version(sep=' '):<EOL><INDENT>if RELEASE=='final':<EOL><INDENT>return VERSION <EOL><DEDENT>return VERSION +sep +RELEASE <EOL><DEDENT>def get_full_version(who=''):<EOL><INDENT>sys_version=sys.version.split()[]<EOL>version='<STR_LIT>'%(who,get_version(),_get_interpreter(),sys_version,sys.platform)<EOL>return version.strip()<EOL><DEDENT>def _get_interpreter():<EOL><INDENT>if sys.platform.startswith('java'):<EOL><INDENT>return 'Jython'<EOL><DEDENT>if sys.platform=='cli':<EOL><INDENT>return 'IronPython'<EOL><DEDENT>if 'PyPy'in sys.version :<EOL><INDENT>return 'PyPy'<EOL><DEDENT>return 'Python'<EOL><DEDENT><EOF><BOF>from __future__ import unicode_literals <EOL>from __future__ import print_function <EOL>import logging <EOL>import sys <EOL>from zerotest.fuzzy_matcher import FuzzyMatcher <EOL>LOG=logging.getLogger(__name__)<EOL>_SERIALIZABLE_CONTENT_TYPE={'<STR_LIT>':'json'}<EOL>class ResponseMatcher(object):<EOL><INDENT>def __init__(self,fuzzy_match=False,fuzzy_match_options=None,ignore_headers=None,ignore_all_headers=False,<EOL>ignore_fields=None):<EOL><INDENT> '<STR_LIT>'<EOL>ignore_headers=ignore_headers or []<EOL>self._fuzzy_match=fuzzy_match <EOL>self._fuzzy_match_options=fuzzy_match_options or {}<EOL>self._ignore_headers=set(map(lambda h :h.upper(),ignore_headers))<EOL>self._ignore_all_headers=ignore_all_headers <EOL>self._ignore_fields=ignore_fields <EOL><DEDENT>def _compare_status(self,r1,r2):<EOL><INDENT>assert r1.status==r2.status <EOL><DEDENT>def __remove_ignore_headers(self,headers):<EOL><INDENT>return {k.upper():headers [k ]for k in headers if <EOL>k.upper()not in self._ignore_headers }<EOL><DEDENT>def _compare_headers(self,expect,real):<EOL><INDENT>if not self._ignore_all_headers :<EOL><INDENT>expect_headers=self.__remove_ignore_headers(expect.headers)<EOL>real_headers=self.__remove_ignore_headers(real.headers)<EOL>assert expect_headers==real_headers <EOL><DEDENT> <DEDENT>def __delete_ignore_fields(self,content):<EOL><INDENT>from zerotest.utils.data_helper import delete_path_from_dict <EOL>for field_path in self._ignore_fields or():<EOL><INDENT>if field_path in content :<EOL><INDENT>content.pop(field_path,None)<EOL><DEDENT>else :<EOL><INDENT>delete_path_from_dict(content,field_path)<EOL><DEDENT> <DEDENT> <DEDENT>def _handle_content_type_json(self,content):<EOL><INDENT>import json <EOL>try :<EOL><INDENT>content=json.loads(content)<EOL><DEDENT>except :<EOL><INDENT>LOG.error('<STR_LIT>')<EOL>raise <EOL><DEDENT>self.__delete_ignore_fields(content)<EOL>return content <EOL><DEDENT>def _prepare_body_data(self,r1,r2):<EOL><INDENT>r1_content_type=r1.get_header('Content-Type')<EOL>r2_content_type=r2.get_header('Content-Type')<EOL>assert r1_content_type==r2_content_type <EOL>r1_content=r1.body <EOL>r2_content=r2.body <EOL>content_type=None <EOL>if r1_content_type :<EOL><INDENT>values=r1_content_type.split(';')<EOL>for v in values :<EOL><INDENT>content_type=_SERIALIZABLE_CONTENT_TYPE.get(v.lower())<EOL>if content_type :<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT>if content_type :<EOL><INDENT>handler=getattr(self,'<STR_LIT>'.format(content_type))<EOL>if handler :<EOL><INDENT>r1_content=handler(r1_content)<EOL>r2_content=handler(r2_content)<EOL><DEDENT> <DEDENT>return r1_content,r2_content <EOL><DEDENT>def _compare_body(self,r1,r2):<EOL><INDENT>r1_content,r2_content=self._prepare_body_data(r1,r2)<EOL>is_formatted=all([isinstance(c,dict)for c in(r1_content,r2_content)])<EOL>if self._fuzzy_match and is_formatted :<EOL><INDENT>fuzzy_matcher=FuzzyMatcher(**self._fuzzy_match_options)<EOL>fuzzy_matcher.set_items(r1_content,r2_content)<EOL>try :<EOL><INDENT>fuzzy_matcher.compare()<EOL><DEDENT>except AssertionError :<EOL><INDENT>print('expect : {}'.format(r1_content),file=sys.stderr)<EOL>print('actual : {}'.format(r2_content),file=sys.stderr)<EOL>raise <EOL><DEDENT> <DEDENT>else :<EOL><INDENT>assert r1_content==r2_content <EOL><DEDENT> <DEDENT>def match_responses(self,expect,real):<EOL><INDENT> '<STR_LIT>'<EOL>for attr in('status','headers','body'):<EOL><INDENT>compare_func='_compare_{}'.format(attr)<EOL>getattr(self,compare_func)(expect,real)<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>from robot.utils import setter <EOL>from.tags import TagPatterns <EOL>from.namepatterns import SuiteNamePatterns,TestNamePatterns <EOL>from.visitor import SuiteVisitor <EOL>class Filter(SuiteVisitor):<EOL><INDENT>def __init__(self,include_suites=None,include_tests=None,<EOL>include_tags=None,exclude_tags=None):<EOL><INDENT>self.include_suites=include_suites <EOL>self.include_tests=include_tests <EOL>self.include_tags=include_tags <EOL>self.exclude_tags=exclude_tags <EOL><DEDENT>@setter <EOL>def include_suites(self,suites):<EOL><INDENT>return SuiteNamePatterns(suites)if not isinstance(suites,SuiteNamePatterns)else suites <EOL><DEDENT>@setter <EOL>def include_tests(self,tests):<EOL><INDENT>return TestNamePatterns(tests)if not isinstance(tests,TestNamePatterns)else tests <EOL><DEDENT>@setter <EOL>def include_tags(self,tags):<EOL><INDENT>return TagPatterns(tags)if not isinstance(tags,TagPatterns)else tags <EOL><DEDENT>@setter <EOL>def exclude_tags(self,tags):<EOL><INDENT>return TagPatterns(tags)if not isinstance(tags,TagPatterns)else tags <EOL><DEDENT>def start_suite(self,suite):<EOL><INDENT>if not self :<EOL><INDENT>return False <EOL><DEDENT>if hasattr(suite,'starttime'):<EOL><INDENT>suite.starttime=suite.endtime=None <EOL><DEDENT>if self.include_suites :<EOL><INDENT>return self._filter_by_suite_name(suite)<EOL><DEDENT>if self.include_tests :<EOL><INDENT>suite.tests=self._filter(suite,self._included_by_test_name)<EOL><DEDENT>if self.include_tags :<EOL><INDENT>suite.tests=self._filter(suite,self._included_by_tags)<EOL><DEDENT>if self.exclude_tags :<EOL><INDENT>suite.tests=self._filter(suite,self._not_excluded_by_tags)<EOL><DEDENT>return bool(suite.suites)<EOL><DEDENT>def _filter_by_suite_name(self,suite):<EOL><INDENT>if self.include_suites.match(suite.name,suite.longname):<EOL><INDENT>suite.visit(Filter(include_suites=[],<EOL>include_tests=self.include_tests,<EOL>include_tags=self.include_tags,<EOL>exclude_tags=self.exclude_tags))<EOL>return False <EOL><DEDENT>suite.tests=[]<EOL>return True <EOL><DEDENT>def _filter(self,suite,filter):<EOL><INDENT>return [t for t in suite.tests if filter(t)]<EOL><DEDENT>def _included_by_test_name(self,test):<EOL><INDENT>return self.include_tests.match(test.name,test.longname)<EOL><DEDENT>def _included_by_tags(self,test):<EOL><INDENT>return self.include_tags.match(test.tags)<EOL><DEDENT>def _not_excluded_by_tags(self,test):<EOL><INDENT>return not self.exclude_tags.match(test.tags)<EOL><DEDENT>def end_suite(self,suite):<EOL><INDENT>suite.suites=[s for s in suite.suites if s.test_count ]<EOL><DEDENT>def visit_test(self,test):<EOL><INDENT>pass <EOL><DEDENT>def visit_keyword(self,keyword):<EOL><INDENT>pass <EOL><DEDENT>def __nonzero__(self):<EOL><INDENT>return bool(self.include_suites or self.include_tests or <EOL>self.include_tags or self.exclude_tags)<EOL><DEDENT> <DEDENT><EOF><BOF>from distutils.core import setup <EOL>from postbox import __version__ <EOL>setup(<EOL>name='postbox',<EOL>description='<STR_LIT>',<EOL>long_description=open('README.rst').read(),<EOL>version=__version__,<EOL>author='Mosky',<EOL>author_email='<STR_LIT>',<EOL>url='<STR_LIT>',<EOL>py_modules=['postbox'],<EOL>license='MIT',<EOL>classifiers=[<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>])<EOF><BOF>from django.conf import settings <EOL>from django.contrib.auth import get_user_model <EOL>from django.core.urlresolvers import reverse <EOL>from django.test import TestCase,Client,override_settings <EOL>from mock import patch <EOL>from buildservice.models import OAuthToken,Repository <EOL>@override_settings(GITHUB_CLIENT_SECRET='the_secret')<EOL>class OAuthViewsTestCase(TestCase):<EOL><INDENT>login_url=reverse('oauth_login')<EOL>callback_url=reverse('oauth_callback')<EOL>def setUp(self):<EOL><INDENT>self.client=Client()<EOL>self.user=get_user_model().objects.create_user('user',password='pwd')<EOL><DEDENT>def test_get_login_anonymous(self):<EOL><INDENT>resp=self.client.get(self.login_url)<EOL>self.assertEqual(resp.status_code,)<EOL>self.assertEqual(resp.url,reverse('auth_login')+'?next='+self.login_url)<EOL><DEDENT>@patch(<EOL>'<STR_LIT>',<EOL>return_value=('<STR_LIT>','the_state'))<EOL>def test_get_login_ok(self,authorization_url):<EOL><INDENT>self.assertTrue(self.client.login(username='user',password='pwd'))<EOL>resp=self.client.get(self.login_url)<EOL>self.assertEqual(resp.status_code,)<EOL>authorization_url.assert_called_with(settings.GITHUB_AUTHORIZATION_BASE_URL)<EOL>self.assertEqual(resp.url,'<STR_LIT>')<EOL>self.assertEqual(resp.wsgi_request.session ['oauth_state'],'the_state')<EOL><DEDENT>def test_callback_anonymous(self):<EOL><INDENT>resp=self.client.get(self.callback_url)<EOL>self.assertEqual(resp.status_code,)<EOL>self.assertEqual(resp.url,reverse('auth_login')+'?next='+self.callback_url)<EOL><DEDENT>def test_callback_token_missing_oauth_state(self):<EOL><INDENT>self.assertTrue(self.client.login(username='user',password='pwd'))<EOL>resp=self.client.get(self.callback_url)<EOL>self.assertEqual(resp.status_code,)<EOL>self.assertEqual(resp.content,'<STR_LIT>')<EOL><DEDENT>@patch('<STR_LIT>',return_value='token')<EOL>def test_callback_token_malformatted(self,fetch_token):<EOL><INDENT>self.assertTrue(self.client.login(username='user',password='pwd'))<EOL>session=self.client.session <EOL>session ['oauth_state']='the_state'<EOL>session.save()<EOL>resp=self.client.get(self.callback_url)<EOL>fetch_token.assert_called_with(<EOL>settings.GITHUB_TOKEN_URL,<EOL>client_secret='the_secret',<EOL>authorization_response=resp.wsgi_request.build_absolute_uri())<EOL>self.assertEqual(resp.status_code,)<EOL>self.assertEqual(resp.content,'<STR_LIT>')<EOL><DEDENT>@patch('<STR_LIT>',return_value={})<EOL>def test_callback_token_malformatted_bis(self,fetch_token):<EOL><INDENT>self.assertTrue(self.client.login(username='user',password='pwd'))<EOL>session=self.client.session <EOL>session ['oauth_state']='the_state'<EOL>session.save()<EOL>resp=self.client.get(self.callback_url)<EOL>fetch_token.assert_called_with(<EOL>settings.GITHUB_TOKEN_URL,<EOL>client_secret='the_secret',<EOL>authorization_response=resp.wsgi_request.build_absolute_uri())<EOL>self.assertEqual(resp.status_code,)<EOL>self.assertEqual(resp.content,'<STR_LIT>')<EOL><DEDENT>@patch.object(Repository,'<STR_LIT>')<EOL>@patch('<STR_LIT>',return_value={'access_token':'abc'})<EOL>def test_callback_ok(self,fetch_token,add_repos):<EOL><INDENT>self.assertTrue(self.client.login(username='user',password='pwd'))<EOL>session=self.client.session <EOL>session ['oauth_state']='the_state'<EOL>session.save()<EOL>resp=self.client.get(self.callback_url)<EOL>fetch_token.assert_called_with(<EOL>settings.GITHUB_TOKEN_URL,<EOL>client_secret='the_secret',<EOL>authorization_response=resp.wsgi_request.build_absolute_uri())<EOL>add_repos.assert_called_with(self.user)<EOL>self.assertEqual(resp.status_code,)<EOL>self.assertEqual(resp.url,'/')<EOL>token=OAuthToken.objects.get(user=self.user)<EOL>self.assertEqual(token.value,'abc')<EOL><DEDENT> <DEDENT><EOF><BOF>try :<EOL><INDENT>from Queue import Queue,Empty <EOL><DEDENT>except ImportError :<EOL><INDENT>from queue import Queue,Empty <EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>__author__=['<STR_LIT>',<EOL>'<STR_LIT>',<EOL>]<EOL>__all__=[<EOL>'positional',<EOL>]<EOL>import gflags <EOL>import inspect <EOL>import logging <EOL>import types <EOL>import urllib <EOL>import urlparse <EOL>try :<EOL><INDENT>from urlparse import parse_qsl <EOL><DEDENT>except ImportError :<EOL><INDENT>from cgi import parse_qsl <EOL><DEDENT>logger=logging.getLogger(__name__)<EOL>FLAGS=gflags.FLAGS <EOL>gflags.DEFINE_enum('<STR_LIT>','WARNING',<EOL>['EXCEPTION','WARNING','IGNORE'],<EOL>'<STR_LIT>')<EOL>def positional(max_positional_args):<EOL><INDENT> '<STR_LIT>'<EOL>def positional_decorator(wrapped):<EOL><INDENT>def positional_wrapper(*args,**kwargs):<EOL><INDENT>if len(args)>max_positional_args :<EOL><INDENT>plural_s=''<EOL>if max_positional_args !=:<EOL><INDENT>plural_s='s'<EOL><DEDENT>message='<STR_LIT>'%(<EOL>wrapped.__name__,max_positional_args,plural_s,len(args))<EOL>if FLAGS.positional_parameters_enforcement=='EXCEPTION':<EOL><INDENT>raise TypeError(message)<EOL><DEDENT>elif FLAGS.positional_parameters_enforcement=='WARNING':<EOL><INDENT>logger.warning(message)<EOL><DEDENT>else :<EOL><INDENT>pass <EOL><DEDENT> <DEDENT>return wrapped(*args,**kwargs)<EOL><DEDENT>return positional_wrapper <EOL><DEDENT>if isinstance(max_positional_args,(int,long)):<EOL><INDENT>return positional_decorator <EOL><DEDENT>else :<EOL><INDENT>args,_,_,defaults=inspect.getargspec(max_positional_args)<EOL>return positional(len(args)-len(defaults))(max_positional_args)<EOL><DEDENT> <DEDENT>def scopes_to_string(scopes):<EOL><INDENT> '<STR_LIT>'<EOL>if isinstance(scopes,types.StringTypes):<EOL><INDENT>return scopes <EOL><DEDENT>else :<EOL><INDENT>return ' '.join(scopes)<EOL><DEDENT> <DEDENT>def dict_to_tuple_key(dictionary):<EOL><INDENT> '<STR_LIT>'<EOL>return tuple(sorted(dictionary.items()))<EOL><DEDENT>def _add_query_parameter(url,name,value):<EOL><INDENT> '<STR_LIT>'<EOL>if value is None :<EOL><INDENT>return url <EOL><DEDENT>else :<EOL><INDENT>parsed=list(urlparse.urlparse(url))<EOL>q=dict(parse_qsl(parsed []))<EOL>q [name ]=value <EOL>parsed []=urllib.urlencode(q)<EOL>return urlparse.urlunparse(parsed)<EOL><DEDENT> <DEDENT><EOF><BOF>from __future__ import print_function <EOL>__all__=['start','customize','CMD_SUFFIX','Program','Command']<EOL>import sys <EOL>import inspect <EOL>import re <EOL>from os.path import basename <EOL>from collections import defaultdict <EOL>from.util import json,autotype,getargspec <EOL>Empty=type('Empty',(object,),{<EOL>'__nonzero__':lambda self :False,<EOL>'__repr__':lambda self :'Empty',<EOL>})()<EOL>class Command(object):<EOL><INDENT> '<STR_LIT>'<EOL>arg_desc_re=re.compile(r'^\s*-')<EOL>'<STR_LIT>'<EOL>arg_re=re.compile('<STR_LIT>')<EOL>'<STR_LIT>'<EOL>arg_type_map={<EOL>'n':int,'num':int,'number':int,<EOL>'i':int,'int':int,'integer':int,<EOL>'s':str,'str':str,'string':str,<EOL>'f':float,'float':float,<EOL>'json':json,<EOL>None :autotype <EOL>}<EOL>'<STR_LIT>'<EOL>def __init__(self,func,name=None):<EOL><INDENT>self.name=name <EOL>self.func=func <EOL>arg_names,vararg_name,keyarg_name,arg_defaults=getargspec(func)<EOL>self.arg_names=arg_names <EOL>self.vararg_name=vararg_name <EOL>self.keyarg_name=keyarg_name <EOL>self.arg_defaults=arg_defaults or tuple()<EOL>self.no_defult_args_len=len(self.arg_names)-len(self.arg_defaults)<EOL>self.arg_name_set=set(arg_names)<EOL>self.arg_default_map=dict(zip(<EOL>*map(reversed,(self.arg_names,self.arg_defaults))))<EOL>self.arg_meta_map={}<EOL>self.alias_arg_map={}<EOL>doc=inspect.getdoc(func)<EOL>if not doc :return <EOL>for line in doc.splitlines():<EOL><INDENT>if not self.arg_desc_re.match(line):continue <EOL>arg_part,_,desc_part=line.strip().partition('  ')<EOL>aliases_set=set()<EOL>for m in self.arg_re.finditer(arg_part):<EOL><INDENT>key,meta=m.group('key','meta')<EOL>key=key.replace('-','_')<EOL>self.arg_meta_map [key ]=meta <EOL>aliases_set.add(key)<EOL><DEDENT>arg_name_set=self.arg_name_set &aliases_set <EOL>if not arg_name_set :continue <EOL>aliases_set -=arg_name_set <EOL>arg_name=arg_name_set.pop()<EOL>for alias in aliases_set :<EOL><INDENT>self.alias_arg_map [alias ]=arg_name <EOL><DEDENT> <DEDENT> <DEDENT>def dealias(self,alias):<EOL><INDENT> '<STR_LIT>'<EOL>return self.alias_arg_map.get(alias,alias)<EOL><DEDENT>def cast(self,arg_name,val):<EOL><INDENT> '<STR_LIT>'<EOL>meta=self.arg_meta_map.get(arg_name)<EOL>if meta is not None :<EOL><INDENT>meta=meta.strip('<>').lower()<EOL><DEDENT>type=self.arg_type_map [meta ]<EOL>return type(val)<EOL><DEDENT>def parse(self,raw_args=None):<EOL><INDENT> '<STR_LIT>'<EOL>if raw_args is None :<EOL><INDENT>raw_args=sys.argv [:]<EOL><DEDENT>elif isinstance(raw_args,str):<EOL><INDENT>raw_args=raw_args.split()<EOL><DEDENT>pargs=[]<EOL>kargs=defaultdict(list)<EOL>while raw_args :<EOL><INDENT>arg_name=None <EOL>val=Empty <EOL>if raw_args [].startswith('-')and len(raw_args [])>=:<EOL><INDENT>before_eq_str,eq_str,val=raw_args.pop().partition('=')<EOL>if not eq_str :<EOL><INDENT>val=Empty <EOL><DEDENT>if before_eq_str.startswith('--'):<EOL><INDENT>arg_name=self.dealias(before_eq_str [:].replace('-','_'))<EOL><DEDENT>else :<EOL><INDENT>sep=<EOL>for c in before_eq_str [:]:<EOL><INDENT>if c in self.arg_name_set or c in self.alias_arg_map :<EOL><INDENT>sep +=<EOL><DEDENT>else :<EOL><INDENT>break <EOL><DEDENT> <DEDENT>for c in before_eq_str [:sep -]:<EOL><INDENT>arg_name=self.dealias(c)<EOL>kargs [arg_name ].append(Empty)<EOL><DEDENT>arg_name=self.dealias(before_eq_str [sep -])<EOL>if val is Empty :<EOL><INDENT>val=before_eq_str [sep :]or Empty <EOL><DEDENT> <DEDENT>if(<EOL>val is Empty and <EOL>not isinstance(self.arg_default_map.get(arg_name),bool)and <EOL>raw_args and not raw_args [].startswith('-')):<EOL><INDENT>val=raw_args.pop()<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>val=raw_args.pop()<EOL><DEDENT>if arg_name :<EOL><INDENT>kargs [arg_name ].append(val)<EOL><DEDENT>else :<EOL><INDENT>pargs.append(val)<EOL><DEDENT> <DEDENT>kargs=dict(kargs)<EOL>for arg_name,collected_vals in kargs.items():<EOL><INDENT>default=self.arg_default_map.get(arg_name)<EOL>if isinstance(default,bool):<EOL><INDENT>kargs [arg_name ]=not default <EOL><DEDENT>elif all(val is Empty for val in collected_vals):<EOL><INDENT>if isinstance(default,int):<EOL><INDENT>kargs [arg_name ]=len(collected_vals)<EOL><DEDENT>else :<EOL><INDENT>kargs [arg_name ]=None <EOL><DEDENT> <DEDENT>else :<EOL><INDENT>val=next(val for val in reversed(collected_vals)if val is not Empty)<EOL>if not self.keyarg_name or arg_name in self.arg_meta_map :<EOL><INDENT>kargs [arg_name ]=self.cast(arg_name,val)<EOL><DEDENT>else :<EOL><INDENT>kargs [arg_name ]=self.cast(self.keyarg_name,val)<EOL><DEDENT> <DEDENT> <DEDENT>for arg_name,default in self.arg_default_map.items():<EOL><INDENT>if arg_name not in kargs :<EOL><INDENT>kargs [arg_name ]=default <EOL><DEDENT> <DEDENT>isbuiltin=inspect.isbuiltin(self.func)<EOL>for pos,name in enumerate(self.arg_names):<EOL><INDENT>if name in kargs and(pos <len(pargs)or isbuiltin):<EOL><INDENT>pargs.insert(pos,kargs.pop(name))<EOL><DEDENT> <DEDENT>for i,parg in enumerate(pargs):<EOL><INDENT>if i <self.no_defult_args_len :<EOL><INDENT>pargs [i ]=self.cast(self.arg_names [i ],parg)<EOL><DEDENT>elif self.vararg_name :<EOL><INDENT>pargs [i ]=self.cast(self.vararg_name,parg)<EOL><DEDENT> <DEDENT>return(pargs,kargs)<EOL><DEDENT>scan=parse <EOL>'<STR_LIT>'<EOL>def execute(self,raw_args=None):<EOL><INDENT> '<STR_LIT>'<EOL>pargs,kargs=self.parse(raw_args)<EOL>return self.func(*pargs,**kargs)<EOL><DEDENT>def build_usage(self,without_name=False):<EOL><INDENT> '<STR_LIT>'<EOL>alias_arg_rmap={}<EOL>for alias,arg_name in self.alias_arg_map.items():<EOL><INDENT>aliases=alias_arg_rmap.setdefault(arg_name,[])<EOL>aliases.append(alias)<EOL><DEDENT>usage=[]<EOL>if self.arg_defaults :<EOL><INDENT>for arg_name in self.arg_names [-len(self.arg_defaults):]:<EOL><INDENT>pieces=[]<EOL>for name in alias_arg_rmap.get(arg_name,[])+[arg_name ]:<EOL><INDENT>is_long_opt=len(name)><EOL>pieces.append('%s%s'%('-'*(+is_long_opt),name.replace('_','-')))<EOL>meta=self.arg_meta_map.get(name)<EOL>if meta is None :<EOL><INDENT>default=self.arg_default_map [self.dealias(name)]<EOL>if isinstance(default,bool):<EOL><INDENT>continue <EOL><DEDENT>elif default is None :<EOL><INDENT>meta='<value>'<EOL><DEDENT>else :<EOL><INDENT>meta='{!r}'.format(default)<EOL><DEDENT> <DEDENT>if is_long_opt :<EOL><INDENT>pieces [-]+='='+meta <EOL><DEDENT>else :<EOL><INDENT>pieces [-]+=' '+meta <EOL><DEDENT> <DEDENT>usage.append('[%s]'%' | '.join(pieces))<EOL><DEDENT> <DEDENT>if self.keyarg_name :<EOL><INDENT>usage.append('<STR_LIT>')<EOL><DEDENT>usage.extend('<%s>'%name.replace('_','-')for name in self.arg_names [:-len(self.arg_defaults)or None ])<EOL>if self.vararg_name :<EOL><INDENT>usage.append('[<%s>...]'%self.vararg_name.replace('_','-'))<EOL><DEDENT>if without_name :<EOL><INDENT>return '%s'%' '.join(usage)<EOL><DEDENT>else :<EOL><INDENT>return '%s %s'%((self.name or self.func.__name__).replace('_','-'),' '.join(usage))<EOL><DEDENT> <DEDENT>get_usage=build_usage <EOL>'<STR_LIT>'<EOL><DEDENT>CMD_SUFFIX=re.compile('<STR_LIT>')<EOL>'<STR_LIT>'<EOL>class Program(object):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,obj=None,default=None,white_list=None,white_pattern=None,black_list=None,ignore_help=False,ignore_return=False,name=None,doc=None,debug=False):<EOL><INDENT>obj=obj or sys.modules ['__main__']<EOL>self.obj=obj <EOL>if hasattr(obj,'items'):<EOL><INDENT>obj_items=obj.items()<EOL><DEDENT>else :<EOL><INDENT>obj_items=inspect.getmembers(obj)<EOL><DEDENT>if not white_list and hasattr(obj,'__all__'):<EOL><INDENT>white_list=obj.__all__ <EOL><DEDENT>tests=(inspect.isbuiltin,inspect.isfunction,inspect.ismethod)<EOL>self.command_funcs={}<EOL>for obj_name,obj in obj_items :<EOL><INDENT>if obj_name.startswith('_'):continue <EOL>if not any(test(obj)for test in tests):continue <EOL>if white_list is not None and obj_name not in white_list :continue <EOL>if black_list is not None and obj_name in black_list :continue <EOL>if white_pattern :<EOL><INDENT>match=white_pattern.match(obj_name)<EOL>if not match :continue <EOL>obj_name=match.group('name')<EOL><DEDENT>self.command_funcs [obj_name ]=obj <EOL><DEDENT>self.default=default <EOL>if len(self.command_funcs)==:<EOL><INDENT>self.default=list(self.command_funcs.keys())[]<EOL><DEDENT>self.ignore_help=ignore_help <EOL>self.ignore_return=ignore_return <EOL>self.name=name or basename(sys.argv [])<EOL>self.doc=doc <EOL>self.debug=debug <EOL><DEDENT>def complain(self,msg):<EOL><INDENT> '<STR_LIT>'<EOL>print('%s: %s'%(self.name,msg),file=sys.stdout)<EOL><DEDENT>def main(self,raw_args=None):<EOL><INDENT> '<STR_LIT>'<EOL>if raw_args is None :<EOL><INDENT>raw_args=sys.argv [:]<EOL><DEDENT>elif isinstance(raw_args,str):<EOL><INDENT>raw_args=raw_args.split()<EOL><DEDENT>cmd_name=None <EOL>cmd_func=None <EOL>if len(raw_args)==:<EOL><INDENT>pass <EOL><DEDENT>elif not self.ignore_help and raw_args []in('--help','-h'):<EOL><INDENT>self.print_usage()<EOL>return <EOL><DEDENT>else :<EOL><INDENT>cmd_func=self.command_funcs.get(raw_args [].replace('-','_'))<EOL>if cmd_func is not None :<EOL><INDENT>cmd_name=raw_args.pop().replace('-','_')<EOL><DEDENT> <DEDENT>if cmd_func is None :<EOL><INDENT>if self.default :<EOL><INDENT>cmd_name=cmd_name <EOL>cmd_func=self.command_funcs [self.default ]<EOL><DEDENT>else :<EOL><INDENT>self.print_usage()<EOL>return <EOL><DEDENT> <DEDENT>if not self.ignore_help and '--help'in raw_args :<EOL><INDENT>self.print_usage(cmd_name)<EOL>return <EOL><DEDENT>cmd=Command(cmd_func,cmd_name)<EOL>try :<EOL><INDENT>return_val=cmd.execute(raw_args)<EOL><DEDENT>except BaseException as e :<EOL><INDENT>if self.debug :<EOL><INDENT>raise <EOL><DEDENT>self.complain('<STR_LIT>'.format(<EOL>e.__class__.__name__,<EOL>e ))<EOL>sys.exit()<EOL><DEDENT>if not self.ignore_return and return_val is not None :<EOL><INDENT>if inspect.isgenerator(return_val):<EOL><INDENT>for i in return_val :<EOL><INDENT>print(i)<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>print(return_val)<EOL><DEDENT> <DEDENT> <DEDENT>def print_usage(self,cmd_name=None):<EOL><INDENT> '<STR_LIT>'<EOL>def append_usage(cmd_name,without_name=False):<EOL><INDENT>cmd_func=self.command_funcs [cmd_name ]<EOL>usages.append(Command(cmd_func,cmd_name).build_usage(without_name))<EOL><DEDENT>usages=[]<EOL>if cmd_name is None :<EOL><INDENT>if self.default is not None :<EOL><INDENT>append_usage(self.default,True)<EOL><DEDENT>for name in sorted(self.command_funcs.keys()):<EOL><INDENT>append_usage(name)<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>if self.default==cmd_name :<EOL><INDENT>append_usage(cmd_name,without_name=True)<EOL><DEDENT>append_usage(cmd_name)<EOL><DEDENT>iusages=iter(usages)<EOL>try :<EOL><INDENT>print('usage:',next(iusages))<EOL><DEDENT>except StopIteration :<EOL><INDENT>pass <EOL><DEDENT>else :<EOL><INDENT>for usage in iusages :<EOL><INDENT>print('   or:',usage)<EOL><DEDENT> <DEDENT>if cmd_name is None :<EOL><INDENT>if self.doc :<EOL><INDENT>doc=self.doc <EOL><DEDENT>elif inspect.ismodule(self.obj):<EOL><INDENT>doc=inspect.getdoc(self.obj)<EOL><DEDENT>else :<EOL><INDENT>doc=None <EOL><DEDENT>if not doc :<EOL><INDENT>cmd_name=self.default <EOL><DEDENT> <DEDENT>if cmd_name :<EOL><INDENT>doc=inspect.getdoc(self.command_funcs [cmd_name ])<EOL><DEDENT>if doc :<EOL><INDENT>print()<EOL>print(doc)<EOL>print()<EOL><DEDENT> <DEDENT> <DEDENT>def start(*args,**kargs):<EOL><INDENT> '<STR_LIT>'<EOL>prog=Program(*args,**kargs)<EOL>prog.main()<EOL>return prog <EOL><DEDENT>customize=start <EOL>'<STR_LIT>'<EOL>if __name__=='__main__':<EOL><INDENT>import doctest <EOL>doctest.testmod()<EOL>def read_json(json=None):<EOL><INDENT> '<STR_LIT>'<EOL>return json <EOL><DEDENT>read_json_cmd=Command(read_json)<EOL>print('---')<EOL>print(read_json_cmd.build_usage())<EOL>print(read_json_cmd.execute('[1,2,3]'))<EOL>print(read_json_cmd.execute(['--json','{"x": 1}']))<EOL>print('---')<EOL>prog=Program(white_list=['read_json'],debug=True)<EOL>prog.main()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import video <EOL>from common import draw_str <EOL>lk_params=dict(winSize=(,),<EOL>maxLevel=,<EOL>criteria=(cv2.TERM_CRITERIA_EPS |cv2.TERM_CRITERIA_COUNT,,))<EOL>feature_params=dict(maxCorners=,<EOL>qualityLevel=,<EOL>minDistance=,<EOL>blockSize=)<EOL>def checkedTrace(img0,img1,p0,back_threshold=):<EOL><INDENT>p1,st,err=cv2.calcOpticalFlowPyrLK(img0,img1,p0,None,**lk_params)<EOL>p0r,st,err=cv2.calcOpticalFlowPyrLK(img1,img0,p1,None,**lk_params)<EOL>d=abs(p0 -p0r).reshape(-,).max(-)<EOL>status=d <back_threshold <EOL>return p1,status <EOL><DEDENT>green=(,,)<EOL>red=(,,)<EOL>class App :<EOL><INDENT>def __init__(self,video_src):<EOL><INDENT>self.cam=video.create_capture(video_src)<EOL>self.p0=None <EOL>self.use_ransac=True <EOL><DEDENT>def run(self):<EOL><INDENT>while True :<EOL><INDENT>ret,frame=self.cam.read()<EOL>frame_gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)<EOL>vis=frame.copy()<EOL>if self.p0 is not None :<EOL><INDENT>p2,trace_status=checkedTrace(self.gray1,frame_gray,self.p1)<EOL>self.p1=p2 [trace_status ].copy()<EOL>self.p0=self.p0 [trace_status ].copy()<EOL>self.gray1=frame_gray <EOL>if len(self.p0)<:<EOL><INDENT>self.p0=None <EOL>continue <EOL><DEDENT>H,status=cv2.findHomography(self.p0,self.p1,(,cv2.RANSAC)[self.use_ransac ],)<EOL>h,w=frame.shape [:]<EOL>overlay=cv2.warpPerspective(self.frame0,H,(w,h))<EOL>vis=cv2.addWeighted(vis,,overlay,,)<EOL>for(x0,y0),(x1,y1),good in zip(self.p0 [:,],self.p1 [:,],status [:,]):<EOL><INDENT>if good :<EOL><INDENT>cv2.line(vis,(x0,y0),(x1,y1),(,,))<EOL><DEDENT>cv2.circle(vis,(x1,y1),,(red,green)[good ],-)<EOL><DEDENT>draw_str(vis,(,),'track count: %d'%len(self.p1))<EOL>if self.use_ransac :<EOL><INDENT>draw_str(vis,(,),'RANSAC')<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>p=cv2.goodFeaturesToTrack(frame_gray,**feature_params)<EOL>if p is not None :<EOL><INDENT>for x,y in p [:,]:<EOL><INDENT>cv2.circle(vis,(x,y),,green,-)<EOL><DEDENT>draw_str(vis,(,),'<STR_LIT>'%len(p))<EOL><DEDENT> <DEDENT>cv2.imshow('lk_homography',vis)<EOL>ch=&cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT>if ch==ord(' '):<EOL><INDENT>self.frame0=frame.copy()<EOL>self.p0=cv2.goodFeaturesToTrack(frame_gray,**feature_params)<EOL>if self.p0 is not None :<EOL><INDENT>self.p1=self.p0 <EOL>self.gray0=frame_gray <EOL>self.gray1=frame_gray <EOL><DEDENT> <DEDENT>if ch==ord('r'):<EOL><INDENT>self.use_ransac=not self.use_ransac <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>def main():<EOL><INDENT>import sys <EOL>try :<EOL><INDENT>video_src=sys.argv []<EOL><DEDENT>except :<EOL><INDENT>video_src=<EOL><DEDENT>print __doc__ <EOL>App(video_src).run()<EOL>cv2.destroyAllWindows()<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>main()<EOL><DEDENT><EOF><BOF>import psycopg2 <EOL>from flask import Flask,request,jsonify <EOL>from mosql.query import select,left_join <EOL>from mosql.db import Database <EOL>db=Database(psycopg2,host='127.0.0.1')<EOL>app=Flask(__name__)<EOL>@app.route('/')<EOL>def index():<EOL><INDENT>with db as cur :<EOL><INDENT>cur.execute(select(<EOL>'person',<EOL>request.args or None,<EOL>joins=left_join('detail',using=('person_id',)),))<EOL>return jsonify(data=list(cur))<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>app.run(debug=True)<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>if __name__=='__main__':<EOL><INDENT>import sys <EOL>try :<EOL><INDENT>fn=sys.argv []<EOL><DEDENT>except :<EOL><INDENT>fn='<STR_LIT>'<EOL><DEDENT>print __doc__ <EOL>img=cv2.imread(fn,True)<EOL>if img is None :<EOL><INDENT>print '<STR_LIT>',fn <EOL>sys.exit()<EOL><DEDENT>h,w=img.shape [:]<EOL>mask=np.zeros((h +,w +),np.uint8)<EOL>seed_pt=None <EOL>fixed_range=True <EOL>connectivity=<EOL>def update(dummy=None):<EOL><INDENT>if seed_pt is None :<EOL><INDENT>cv2.imshow('floodfill',img)<EOL>return <EOL><DEDENT>flooded=img.copy()<EOL>mask [:]=<EOL>lo=cv2.getTrackbarPos('lo','floodfill')<EOL>hi=cv2.getTrackbarPos('hi','floodfill')<EOL>flags=connectivity <EOL>if fixed_range :<EOL><INDENT>flags |=cv2.FLOODFILL_FIXED_RANGE <EOL><DEDENT>cv2.floodFill(flooded,mask,seed_pt,(,,),(lo,)*,(hi,)*,flags)<EOL>cv2.circle(flooded,seed_pt,,(,,),-)<EOL>cv2.imshow('floodfill',flooded)<EOL><DEDENT>def onmouse(event,x,y,flags,param):<EOL><INDENT>global seed_pt <EOL>if flags &cv2.EVENT_FLAG_LBUTTON :<EOL><INDENT>seed_pt=x,y <EOL>update()<EOL><DEDENT> <DEDENT>update()<EOL>cv2.setMouseCallback('floodfill',onmouse)<EOL>cv2.createTrackbar('lo','floodfill',,,update)<EOL>cv2.createTrackbar('hi','floodfill',,,update)<EOL>while True :<EOL><INDENT>ch=&cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT>if ch==ord('f'):<EOL><INDENT>fixed_range=not fixed_range <EOL>print 'using %s range'%('floating','fixed')[fixed_range ]<EOL>update()<EOL><DEDENT>if ch==ord('c'):<EOL><INDENT>connectivity=-connectivity <EOL>print 'connectivity=',connectivity <EOL>update()<EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>import sys <EOL>from threading import currentThread <EOL>try :<EOL><INDENT>import signal <EOL><DEDENT>except ImportError :<EOL><INDENT>signal=None <EOL><DEDENT>if sys.platform.startswith('java'):<EOL><INDENT>from java.lang import IllegalArgumentException <EOL><DEDENT>else :<EOL><INDENT>IllegalArgumentException=None <EOL><DEDENT>from robot.errors import ExecutionFailed <EOL>from robot.output import LOGGER <EOL>class _StopSignalMonitor(object):<EOL><INDENT>def __init__(self):<EOL><INDENT>self._signal_count=<EOL>self._running_keyword=False <EOL><DEDENT>def __call__(self,signum,frame):<EOL><INDENT>self._signal_count +=<EOL>LOGGER.info('<STR_LIT>'%signum)<EOL>if self._signal_count >:<EOL><INDENT>sys.__stderr__.write('<STR_LIT>')<EOL>raise SystemExit()<EOL><DEDENT>sys.__stderr__.write('<STR_LIT>')<EOL>if self._running_keyword and not sys.platform.startswith('java'):<EOL><INDENT>self._stop_execution_gracefully()<EOL><DEDENT> <DEDENT>def _stop_execution_gracefully(self):<EOL><INDENT>raise ExecutionFailed('<STR_LIT>',exit=True)<EOL><DEDENT>def start(self):<EOL><INDENT>if signal :<EOL><INDENT>for signum in signal.SIGINT,signal.SIGTERM :<EOL><INDENT>self._register_signal_handler(signum)<EOL><DEDENT> <DEDENT> <DEDENT>def _register_signal_handler(self,signum):<EOL><INDENT>try :<EOL><INDENT>signal.signal(signum,self)<EOL><DEDENT>except(ValueError,IllegalArgumentException),err :<EOL><INDENT>if currentThread().getName()=='MainThread':<EOL><INDENT>self._warn_about_registeration_error(signum,err)<EOL><DEDENT> <DEDENT> <DEDENT>def _warn_about_registeration_error(self,signum,err):<EOL><INDENT>name,ctrlc={signal.SIGINT :('INT','or with Ctrl-C '),<EOL>signal.SIGTERM :('TERM','')}[signum ]<EOL>LOGGER.warn('<STR_LIT>'<EOL>'<STR_LIT>'<EOL>'<STR_LIT>'%(name,ctrlc,err))<EOL><DEDENT>def start_running_keyword(self,in_teardown):<EOL><INDENT>self._running_keyword=True <EOL>if self._signal_count and not in_teardown :<EOL><INDENT>self._stop_execution_gracefully()<EOL><DEDENT> <DEDENT>def stop_running_keyword(self):<EOL><INDENT>self._running_keyword=False <EOL><DEDENT> <DEDENT>STOP_SIGNAL_MONITOR=_StopSignalMonitor()<EOF><BOF>import psycopg2 <EOL>from mosql.util import raw <EOL>from mosql.query import select,left_join <EOL>from mosql.db import Database,group <EOL>db=Database(psycopg2,host='127.0.0.1')<EOL>with db as cur :<EOL><INDENT>cur.execute(select(<EOL>'person',<EOL>joins=left_join('detail',using='person_id'),<EOL>where={'key':'email'},<EOL>group_by='person_id',<EOL>select=('person_id',raw('array_agg(val)')),<EOL>order_by='person_id',))<EOL>print '<STR_LIT>'<EOL>for row in cur :<EOL><INDENT>print row <EOL><DEDENT>print <EOL>cur.execute(select(<EOL>'person',<EOL>joins=left_join('detail',using='person_id'),<EOL>where={'key':'email'},<EOL>select=('person_id','val'),<EOL>order_by='person_id',))<EOL>print '<STR_LIT>'<EOL>for row in group(['person_id'],cur):<EOL><INDENT>print row <EOL><DEDENT> <DEDENT><EOF><BOF>import cv2 <EOL>import numpy as np <EOL>def mix_image(back,fore,(x,y),in_place=False):<EOL><INDENT> '<STR_LIT>'<EOL>x,y=round(x),round(y)<EOL>if in_place :<EOL><INDENT>ret=back <EOL><DEDENT>else :<EOL><INDENT>ret=back.copy()<EOL><DEDENT>fh,fw,fd=fore.shape <EOL>bh,bw,bd=ret.shape <EOL>if fd==:<EOL><INDENT>fore_alpha=lambda fy,h,fx,w :fore [fy :fy +h,fx :fx +w,]/<EOL><DEDENT>else :<EOL><INDENT>fore_alpha=lambda fy,h,fx,w :<EOL><DEDENT>if True in [x +fw <,x >bw,y +fh <,y >bh ]:<EOL><INDENT>return ret <EOL><DEDENT>fx,fy=,<EOL>bx,by=x,y <EOL>w,h=fw,fh <EOL>if bx <:<EOL><INDENT>w=fw +bx <EOL>fx=-bx <EOL>bx=<EOL><DEDENT>if by <:<EOL><INDENT>h=fh +by <EOL>fy=-by <EOL>by=<EOL><DEDENT>if bx +w >bw :<EOL><INDENT>w=bw -bx <EOL><DEDENT>if by +h >bh :<EOL><INDENT>h=bh -by <EOL><DEDENT>for c in range(,):<EOL><INDENT>ret [by :by +h,bx :bx +w,c ]=fore [fy :fy +h,fx :fx +w,c ]*fore_alpha(fy,h,fx,w)+ret [by :by +h,bx :bx +w,c ]*(-fore_alpha(fy,h,fx,w))<EOL><DEDENT>return ret <EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>back=cv2.imread("land.jpg")<EOL>fore=cv2.imread("phppg.png",-)<EOL>sh=fore.shape <EOL>b=np.full_like(fore,,np.uint8)<EOL>bb=mix_image(b,fore,(,))<EOL>cv2.imshow('fore',bb)<EOL>cv2.imshow('back',back)<EOL>from random import random as rdm <EOL>w,h,d=back.shape <EOL>for i in range():<EOL><INDENT>back=mix_image(back,fore,(w **(rdm()-),h **(rdm()-)))<EOL><DEDENT>cv2.imshow('mixed',back)<EOL>cv2.imwrite('mixed.png',back)<EOL>cv2.waitKey()<DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import video <EOL>class App(object):<EOL><INDENT>def __init__(self,video_src):<EOL><INDENT>self.cam=video.create_capture(video_src)<EOL>ret,self.frame=self.cam.read()<EOL>cv2.namedWindow('camshift')<EOL>cv2.setMouseCallback('camshift',self.onmouse)<EOL>self.selection=None <EOL>self.drag_start=None <EOL>self.tracking_state=<EOL>self.show_backproj=False <EOL><DEDENT>def onmouse(self,event,x,y,flags,param):<EOL><INDENT>x,y=np.int16([x,y ])<EOL>if event==cv2.EVENT_LBUTTONDOWN :<EOL><INDENT>self.drag_start=(x,y)<EOL>self.tracking_state=<EOL><DEDENT>if self.drag_start :<EOL><INDENT>if flags &cv2.EVENT_FLAG_LBUTTON :<EOL><INDENT>h,w=self.frame.shape [:]<EOL>xo,yo=self.drag_start <EOL>x0,y0=np.maximum(,np.minimum([xo,yo ],[x,y ]))<EOL>x1,y1=np.minimum([w,h ],np.maximum([xo,yo ],[x,y ]))<EOL>self.selection=None <EOL>if x1 -x0 >and y1 -y0 >:<EOL><INDENT>self.selection=(x0,y0,x1,y1)<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>self.drag_start=None <EOL>if self.selection is not None :<EOL><INDENT>self.tracking_state=<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>def show_hist(self):<EOL><INDENT>bin_count=self.hist.shape []<EOL>bin_w=<EOL>img=np.zeros((,bin_count *bin_w,),np.uint8)<EOL>for i in xrange(bin_count):<EOL><INDENT>h=int(self.hist [i ])<EOL>cv2.rectangle(img,(i *bin_w +,),((i +)*bin_w -,-h),(int(*i /bin_count),,),-)<EOL><DEDENT>img=cv2.cvtColor(img,cv2.COLOR_HSV2BGR)<EOL>cv2.imshow('hist',img)<EOL><DEDENT>def run(self):<EOL><INDENT>while True :<EOL><INDENT>ret,self.frame=self.cam.read()<EOL>vis=self.frame.copy()<EOL>hsv=cv2.cvtColor(self.frame,cv2.COLOR_BGR2HSV)<EOL>mask=cv2.inRange(hsv,np.array((,,)),np.array((,,)))<EOL>if self.selection :<EOL><INDENT>x0,y0,x1,y1=self.selection <EOL>self.track_window=(x0,y0,x1 -x0,y1 -y0)<EOL>hsv_roi=hsv [y0 :y1,x0 :x1 ]<EOL>mask_roi=mask [y0 :y1,x0 :x1 ]<EOL>hist=cv2.calcHist([hsv_roi ],[],mask_roi,[],[,])<EOL>cv2.normalize(hist,hist,,,cv2.NORM_MINMAX);<EOL>self.hist=hist.reshape(-)<EOL>self.show_hist()<EOL>vis_roi=vis [y0 :y1,x0 :x1 ]<EOL>cv2.bitwise_not(vis_roi,vis_roi)<EOL>vis [mask==]=<EOL><DEDENT>if self.tracking_state==:<EOL><INDENT>self.selection=None <EOL>prob=cv2.calcBackProject([hsv ],[],self.hist,[,],)<EOL>prob &=mask <EOL>term_crit=(cv2.TERM_CRITERIA_EPS |cv2.TERM_CRITERIA_COUNT,,)<EOL>track_box,self.track_window=cv2.CamShift(prob,self.track_window,term_crit)<EOL>if self.show_backproj :<EOL><INDENT>vis [:]=prob [...,np.newaxis ]<EOL><DEDENT>try :cv2.ellipse(vis,track_box,(,,),)<EOL>except :print track_box <EOL><DEDENT>cv2.imshow('camshift',vis)<EOL>ch=&cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT>if ch==ord('b'):<EOL><INDENT>self.show_backproj=not self.show_backproj <EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>import sys <EOL>try :video_src=sys.argv []<EOL>except :video_src=<EOL>print __doc__ <EOL>App(video_src).run()<EOL><DEDENT><EOF><BOF>print '<STR_LIT>'<EOL>import cv2.cv as cv <EOL>import random <EOL>_MAX_POINTS=<EOL>if __name__=='__main__':<EOL><INDENT>my_random=random.Random()<EOL>image=cv.CreateImage((,),,)<EOL>cv.NamedWindow('hull',cv.CV_WINDOW_AUTOSIZE)<EOL>while True :<EOL><INDENT>count=my_random.randrange(,_MAX_POINTS)+<EOL>points=[]<EOL>for i in range(count):<EOL><INDENT>points.append((<EOL>my_random.randrange(,image.width /)+image.width /,<EOL>my_random.randrange(,image.width /)+image.width /))<EOL><DEDENT>storage=cv.CreateMemStorage()<EOL>hull=cv.ConvexHull2(points,storage,cv.CV_CLOCKWISE,)<EOL>cv.SetZero(image)<EOL>for i in range(count):<EOL><INDENT>cv.Circle(image,points [i ],,(,,,),<EOL>cv.CV_FILLED,cv.CV_AA,)<EOL><DEDENT>cv.PolyLine(image,[hull ],,cv.RGB(,,),,cv.CV_AA)<EOL>cv.ShowImage('hull',image)<EOL>k=cv.WaitKey()%<EOL>if k==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT>cv.DestroyAllWindows()<EOL><DEDENT><EOF><BOF>import HTMLParser <EOL>from datetime import datetime,timedelta <EOL>import pytz <EOL>import random <EOL>import re <EOL>from database import db <EOL>from models import Account,Settings,TopTodayAccount <EOL>class Simulator(object):<EOL><INDENT>def __init__(self):<EOL><INDENT>self.accounts={account.subreddit :account <EOL>for account in db.query(Account)}<EOL>self.subreddit=Settings ["subreddit"]<EOL>self.mod_account=self.accounts ["all"]<EOL><DEDENT>def pick_account_to_comment(self):<EOL><INDENT>accounts=[a for a in self.accounts.values()if a.can_comment ]<EOL>try :<EOL><INDENT>return next(a for a in accounts if not a.last_commented)<EOL><DEDENT>except StopIteration :<EOL><INDENT>pass <EOL><DEDENT>accounts=sorted(accounts,key=lambda a :a.last_commented)<EOL>num_to_keep=int(len(accounts)*)<EOL>return random.choice(accounts [:num_to_keep ])<EOL><DEDENT>def pick_account_to_submit(self):<EOL><INDENT>try :<EOL><INDENT>top_today_account=next(a for a in self.accounts.values()<EOL>if isinstance(a,TopTodayAccount))<EOL><DEDENT>except StopIteration :<EOL><INDENT>pass <EOL><DEDENT>else :<EOL><INDENT>now=datetime.now(pytz.utc)<EOL>if now -top_today_account.last_submitted >timedelta(hours=):<EOL><INDENT>return top_today_account <EOL><DEDENT> <DEDENT>accounts=[a for a in self.accounts.values()if a.is_able_to_submit ]<EOL>try :<EOL><INDENT>return next(a for a in accounts if not a.last_submitted)<EOL><DEDENT>except StopIteration :<EOL><INDENT>pass <EOL><DEDENT>accounts=sorted(accounts,key=lambda a :a.last_submitted)<EOL>num_to_keep=int(len(accounts)*)<EOL>return random.choice(accounts [:num_to_keep ])<EOL><DEDENT>def make_comment(self):<EOL><INDENT>account=self.pick_account_to_comment()<EOL>account.train_from_comments()<EOL>subreddit=account.session.get_subreddit(self.subreddit)<EOL>for submission in subreddit.get_new(limit=):<EOL><INDENT>if submission.author.name !=Settings ["owner"]:<EOL><INDENT>break <EOL><DEDENT> <DEDENT>account.post_comment_on(submission)<EOL><DEDENT>def make_submission(self):<EOL><INDENT>account=self.pick_account_to_submit()<EOL>account.train_from_submissions()<EOL>account.post_submission(self.subreddit)<EOL><DEDENT>def update_leaderboard(self,limit=):<EOL><INDENT>session=self.mod_account.session <EOL>subreddit=session.get_subreddit(self.subreddit)<EOL>accounts=sorted(<EOL>[a for a in self.accounts.values()if a.can_comment ],<EOL>key=lambda a :a.mean_comment_karma,<EOL>reverse=True,)<EOL>leaderboard_md='<STR_LIT>'<EOL>for rank,account in enumerate(accounts,start=):<EOL><INDENT>leaderboard_md +='<STR_LIT>'.format(<EOL>rank,<EOL>account.name,<EOL>account.mean_comment_karma,)<EOL>if rank >=limit :<EOL><INDENT>break <EOL><DEDENT> <DEDENT>start_delim='<STR_LIT>'<EOL>end_delim='<STR_LIT>'<EOL>current_sidebar=subreddit.get_settings()["description"]<EOL>current_sidebar=HTMLParser.HTMLParser().unescape(current_sidebar)<EOL>replace_pattern=re.compile(<EOL>"{}.*?{}".format(re.escape(start_delim),re.escape(end_delim)),<EOL>re.IGNORECASE |re.DOTALL |re.UNICODE,)<EOL>new_sidebar=re.sub(<EOL>replace_pattern,<EOL>"{}\n\n{}\n\n{}".format(start_delim,leaderboard_md,end_delim),<EOL>current_sidebar,)<EOL>subreddit.update_settings(description=new_sidebar)<EOL>flair_map=[{<EOL>"user":account.name,<EOL>"flair_text":'<STR_LIT>'.format(<EOL>rank,len(accounts),account.mean_comment_karma),<EOL>}for rank,account in enumerate(accounts,start=)]<EOL>subreddit.set_flair_csv(flair_map)<EOL><DEDENT>def print_accounts_table(self):<EOL><INDENT>accounts=sorted(self.accounts.values(),key=lambda a :a.added)<EOL>accounts=[a for a in accounts if not isinstance(a,TopTodayAccount)]<EOL>print '<STR_LIT>'<EOL>print ":--|--:|:--|:--"<EOL>checkmark="&#10003;"<EOL>for account in accounts :<EOL><INDENT>print '<STR_LIT>'.format(<EOL>account.subreddit,<EOL>"/u/"+account.name,<EOL>account.added.strftime("%Y-%m-%d"),<EOL>checkmark if account.can_comment else "",<EOL>checkmark if account.can_submit else "",)<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>import cv2 <EOL>from webcam_gui import webcam_gui <EOL>def imgproc(frame):<EOL><INDENT>gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)<EOL>cv2.imshow('gray',gray)<EOL>blur=cv2.blur(gray,(,))<EOL>edge=cv2.Canny(blur,,)<EOL>edge=cv2.blur(edge,(,))<EOL>cv2.imshow('blured edge',edge)<EOL>thresh1,thresh=cv2.threshold(edge,,,cv2.THRESH_BINARY)<EOL>cv2.imshow('thresh',thresh)<EOL>contours,hry=cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)<EOL>cpframe=frame.copy()<EOL>cv2.drawContours(cpframe,contours,-,(,,),)<EOL>cv2.imshow('cpframe',cpframe)<EOL>contours=[ctr for ctr in contours if cv2.contourArea(ctr)>]<EOL>contours=[cv2.approxPolyDP(ctr,,True)for ctr in contours ]<EOL>contours=[ctr for ctr in contours if cv2.isContourConvex(ctr)]<EOL>cv2.drawContours(frame,contours,-,(,,),)<EOL>return frame <EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>webcam_gui(imgproc,video_src=)<DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import signal <EOL>import tempfile <EOL>import time <EOL>from subprocess import Popen <EOL>import requests <EOL>from tests.mock import pickup_port <EOL>from zerotest.utils.url_helper import urljoin <EOL>class Proxy(object):<EOL><INDENT>def __init__(self):<EOL><INDENT>self.port=None <EOL>self._process=None <EOL>_,self.data_file=tempfile.mkstemp()<EOL><DEDENT>@property <EOL>def url(self):<EOL><INDENT>return '<STR_LIT>'.format(self.port)<EOL><DEDENT>@property <EOL>def running(self):<EOL><INDENT>if not self._process :<EOL><INDENT>return False <EOL><DEDENT>self._process.poll()<EOL>return self._process.returncode is None <EOL><DEDENT>def shutdown(self):<EOL><INDENT>if self.running :<EOL><INDENT>self._process.send_signal(signal.SIGINT)<EOL>self._process.wait()<EOL><DEDENT> <DEDENT>def start_server(self,url):<EOL><INDENT> '<STR_LIT>'<EOL>port=pickup_port()<EOL>self._process=Popen(['python','zerotest/cli.py','server','-p',str(port),'-f',self.data_file,url ])<EOL>self.port=port <EOL>test_count=<EOL>while test_count >:<EOL><INDENT>try :<EOL><INDENT>if self.running :<EOL><INDENT>r=requests.get(urljoin(self.url,'/count'))<EOL>if r.status_code==:<EOL><INDENT>return <EOL><DEDENT> <DEDENT> <DEDENT>except requests.exceptions.ConnectionError :<EOL><INDENT>pass <EOL><DEDENT>print('<STR_LIT>',test_count)<EOL>time.sleep()<EOL>test_count -=<EOL><DEDENT>else :<EOL><INDENT>self.shutdown()<EOL>raise RuntimeError('<STR_LIT>')<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>from __future__ import print_function <EOL>'<STR_LIT>'<EOL>'<STR_LIT>'<EOL>import difflib <EOL>import ConfigParser <EOL>import os <EOL>import random <EOL>import re <EOL>import string <EOL>import sys <EOL>import threading <EOL>import time <EOL>import xml.etree.ElementTree as ET <EOL>from urllib import urlencode <EOL>from urllib2 import build_opener,install_opener,urlopen,ProxyHandler,Request <EOL>from urlparse import urlsplit,urlunsplit,parse_qsl <EOL>from optparse import OptionParser <EOL>from subprocess import Popen,PIPE <EOL>from sys import exit <EOL>NAME="Panoptic"<EOL>VERSION="v0.1"<EOL>URL='<STR_LIT>'<EOL>INVALID_FILENAME="".join(random.sample(string.letters,))<EOL>MAX_HELP_OPTION_LENGTH=<EOL>CASES_FILE="cases.xml"<EOL>USER_AGENTS_FILE="agents.txt"<EOL>HOME_FILES_FILE="home.txt"<EOL>HEURISTIC_RATIO=<EOL>SKIP_RETRIEVE_THRESHOLD=<EOL>BANNER='<STR_LIT>'%(NAME,VERSION,URL)<EOL>ROTATOR_CHARS="|/-\\"<EOL>GIT_REPOSITORY='<STR_LIT>'<EOL>EXAMPLES='<STR_LIT>'<EOL>class PROXY_TYPE :<EOL><INDENT>HTTP="HTTP"<EOL>HTTPS="HTTPS"<EOL>SOCKS4="SOCKS4"<EOL>SOCKS5="SOCKS5"<EOL><DEDENT>class HTTP_HEADER :<EOL><INDENT>COOKIE="Cookie"<EOL>USER_AGENT="User-agent"<EOL>CONTENT_LENGTH="Content-length"<EOL><DEDENT>class AttribDict(dict):<EOL><INDENT>def __getattr__(self,name):<EOL><INDENT>return self.get(name)<EOL><DEDENT>def __setattr__(self,name,value):<EOL><INDENT>return self.__setitem__(name,value)<EOL><DEDENT> <DEDENT>kb=AttribDict()<EOL>args=None <EOL>def print(*args,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>with kb.print_lock :<EOL><INDENT>return __builtins__.print(*args,**kwargs)<EOL><DEDENT> <DEDENT>def get_cases(args):<EOL><INDENT> '<STR_LIT>'<EOL>tree=ET.parse(CASES_FILE)<EOL>root=tree.getroot()<EOL>def _(parent,element):<EOL><INDENT>element.parent=parent <EOL>for key,value in element.attrib.items():<EOL><INDENT>setattr(element,key,value)<EOL><DEDENT>for child in element.getchildren():<EOL><INDENT>_(element,child)<EOL><DEDENT> <DEDENT>_(None,root)<EOL>for attr in("os","software","category"):<EOL><INDENT>if getattr(args,attr):<EOL><INDENT>for element in root.findall(".//%s"%attr):<EOL><INDENT>if element.value.lower()!=getattr(args,attr).lower():<EOL><INDENT>element.parent.remove(element)<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>if args.type :<EOL><INDENT>for _ in(_ for _ in("conf","log","other")if _.lower()!=args.type.lower()):<EOL><INDENT>for element in root.findall(".//%s"%_):<EOL><INDENT>element.parent.remove(element)<EOL><DEDENT> <DEDENT> <DEDENT>def _(element,tag):<EOL><INDENT>while element.parent is not None :<EOL><INDENT>if element.parent.tag==tag :<EOL><INDENT>return element.parent <EOL><DEDENT>else :<EOL><INDENT>element=element.parent <EOL><DEDENT> <DEDENT> <DEDENT>cases=[]<EOL>replacements={}<EOL>if args.url :<EOL><INDENT>replacements ["HOST"]=urlsplit(args.url).netloc <EOL><DEDENT>for element in root.findall(".//file"):<EOL><INDENT>case=AttribDict()<EOL>case.location=element.value <EOL>case.os=_(element,"os").value <EOL>case.category=_(element,"category").value <EOL>case.software=_(element,"software").value <EOL>case.type=_(element,"log")is not None and "log"or _(element,"conf")is not None and "conf"or _(element,"other")is not None and "other"<EOL>for variable in re.findall(r"\{[^}]+\}",case.location):<EOL><INDENT>case.location=case.location.replace(variable,replacements.get(variable.strip("{}"),variable))<EOL><DEDENT>match=re.search(r"\[([^\]]+)\]",case.location)<EOL>if match and kb.through :<EOL><INDENT>original=case.location <EOL>for replacement in kb.versioned_locations [match.group()]:<EOL><INDENT>case=AttribDict(case)<EOL>case.location=original.replace(match.group(),replacement)<EOL>cases.append(case)<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>cases.append(case)<EOL><DEDENT> <DEDENT>return cases <EOL><DEDENT>def load_list(filepath):<EOL><INDENT> '<STR_LIT>'<EOL>items=[]<EOL>cases=[]<EOL>with open(filepath,'r')as f :<EOL><INDENT>items=f.readlines()<EOL><DEDENT>for item in items :<EOL><INDENT>case=AttribDict({'location':item.strip()})<EOL>cases.append(case)<EOL><DEDENT>return cases <EOL><DEDENT>def get_revision():<EOL><INDENT> '<STR_LIT>'<EOL>retval=None <EOL>filepath=None <EOL>_=os.path.dirname(__file__)<EOL>while True :<EOL><INDENT>filepath=os.path.join(_,".git","HEAD")<EOL>if os.path.exists(filepath):<EOL><INDENT>break <EOL><DEDENT>else :<EOL><INDENT>filepath=None <EOL>if _==os.path.dirname(_):<EOL><INDENT>break <EOL><DEDENT>else :<EOL><INDENT>_=os.path.dirname(_)<EOL><DEDENT> <DEDENT> <DEDENT>while True :<EOL><INDENT>if filepath and os.path.isfile(filepath):<EOL><INDENT>with open(filepath,"r")as f :<EOL><INDENT>content=f.read()<EOL>filepath=None <EOL>if content.startswith("ref: "):<EOL><INDENT>filepath=os.path.join(_,".git",content.replace("ref: ","")).strip()<EOL><DEDENT>else :<EOL><INDENT>match=re.match('<STR_LIT>',content)<EOL>retval=match.group()if match else None <EOL>break <EOL><DEDENT> <DEDENT> <DEDENT>else :<EOL><INDENT>break <EOL><DEDENT> <DEDENT>if not retval :<EOL><INDENT>process=Popen('<STR_LIT>',shell=True,stdout=PIPE,stderr=PIPE)<EOL>stdout,_=process.communicate()<EOL>match=re.search('<STR_LIT>',stdout or "")<EOL>retval=match.group()if match else None <EOL><DEDENT>return retval [:]if retval else None <EOL><DEDENT>def check_revision():<EOL><INDENT> '<STR_LIT>'<EOL>global BANNER <EOL>global VERSION <EOL>revision=get_revision()<EOL>if revision :<EOL><INDENT>_=VERSION <EOL>VERSION="%s-%s"%(VERSION,revision)<EOL>BANNER=BANNER.replace(_,VERSION)<EOL><DEDENT> <DEDENT>def update():<EOL><INDENT> '<STR_LIT>'<EOL>print('<STR_LIT>')<EOL>process=Popen('<STR_LIT>'%GIT_REPOSITORY,shell=True,stdout=PIPE,stderr=PIPE)<EOL>stdout,stderr=process.communicate()<EOL>success=not process.returncode <EOL>if success :<EOL><INDENT>updated="Already"not in stdout <EOL>process=Popen('<STR_LIT>',shell=True,stdout=PIPE,stderr=PIPE)<EOL>stdout,_=process.communicate()<EOL>revision=stdout [:]if stdout and re.search('<STR_LIT>',stdout)else "-"<EOL>print('<STR_LIT>'%("Already at"if not updated else "Updated to",revision))<EOL><DEDENT>else :<EOL><INDENT>print('<STR_LIT>'%repr(stderr.strip()))<EOL>print('<STR_LIT>')<EOL><DEDENT> <DEDENT>def ask_question(question,default=None,automatic=False):<EOL><INDENT> '<STR_LIT>'<EOL>question="[?] %s "%question <EOL>if automatic :<EOL><INDENT>answer=default <EOL>print("%s%s"%(question,answer))<EOL><DEDENT>else :<EOL><INDENT>with kb.print_lock :<EOL><INDENT>answer=raw_input(question)<EOL><DEDENT> <DEDENT>print <EOL>return answer <EOL><DEDENT>def prepare_request(payload):<EOL><INDENT> '<STR_LIT>'<EOL>_=re.sub('<STR_LIT>'%args.param,<EOL>r"\1=%s"%(payload or ""),kb.request_params)<EOL>request_args={"url":"%s://%s%s"%(kb.parsed_target_url.scheme or "http",kb.parsed_target_url.netloc,kb.parsed_target_url.path)}<EOL>if args.data :<EOL><INDENT>request_args ["data"]=_ <EOL><DEDENT>else :<EOL><INDENT>request_args ["url"]+="?%s"%_ <EOL><DEDENT>if args.header :<EOL><INDENT>request_args ["header"]=args.header <EOL><DEDENT>if args.cookie :<EOL><INDENT>request_args ["cookie"]=args.cookie <EOL><DEDENT>if args.user_agent :<EOL><INDENT>request_args ["user_agent"]=args.user_agent <EOL><DEDENT>request_args ["verbose"]=args.verbose <EOL>return request_args <EOL><DEDENT>def clean_response(response,filepath):<EOL><INDENT> '<STR_LIT>'<EOL>response=response.replace(filepath,"")<EOL>regex=re.sub(r"[^A-Za-z0-9]",'<STR_LIT>',filepath)<EOL>return re.sub(regex,"",response,re.I)<EOL><DEDENT>def request_file(case,replace_slashes=True):<EOL><INDENT> '<STR_LIT>'<EOL>global ROTATOR_CHARS <EOL>if args.replace_slash and replace_slashes :<EOL><INDENT>case.location=case.location.replace("/",args.replace_slash.replace("\\","\\\\"))<EOL><DEDENT>if kb.restrict_os and kb.restrict_os !=case.os :<EOL><INDENT>if args.verbose :<EOL><INDENT>print('<STR_LIT>'%case.location)<EOL><DEDENT>return None <EOL><DEDENT>if args.prefix and args.prefix [len(args.prefix)-]=="/":<EOL><INDENT>args.prefix=args.prefix [:-]<EOL><DEDENT>_="%s%s%s"%(args.prefix,case.location,args.postfix)<EOL>if args.verbose :<EOL><INDENT>print('<STR_LIT>'%_)<EOL><DEDENT>else :<EOL><INDENT>with kb.print_lock :<EOL><INDENT>sys.stdout.write("\r%s\r"%ROTATOR_CHARS [])<EOL>sys.stdout.flush()<EOL><DEDENT> <DEDENT>ROTATOR_CHARS=ROTATOR_CHARS [:]+ROTATOR_CHARS []<EOL>request_args=prepare_request(_)<EOL>html=get_page(**request_args)<EOL>if not html or args.bad_string and html.find(args.bad_string)!=-:<EOL><INDENT>return None <EOL><DEDENT>matcher=difflib.SequenceMatcher(None,clean_response(html,case.location),clean_response(kb.invalid_response,INVALID_FILENAME))<EOL>if matcher.quick_ratio()<HEURISTIC_RATIO :<EOL><INDENT>with kb.value_lock :<EOL><INDENT>if not kb.found :<EOL><INDENT>print('<STR_LIT>')<EOL>if case.os :<EOL><INDENT>print("[i] OS: %s"%case.os)<EOL>if kb.restrict_os is None :<EOL><INDENT>answer=ask_question('<STR_LIT>'%case.os,default='Y',automatic=args.automatic)<EOL>kb.restrict_os=answer.upper()!='N'and case.os <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>_="/".join(_ for _ in(case.os,case.category,case.type)if _)<EOL>if _ :<EOL><INDENT>_="'%s'(%s)"%(case.location,_)<EOL>_=_.replace("%s/%s/"%(case.os,case.os),"%s/"%case.os)<EOL><DEDENT>else :<EOL><INDENT>_="'%s'"%case.location <EOL><DEDENT>print("[+] Found %s."%_)<EOL>if args.verbose :<EOL><INDENT>kb.files.append(_)<EOL><DEDENT>if args.write_files :<EOL><INDENT>_=os.path.join("output",kb.parsed_target_url.netloc)<EOL>if not os.path.exists(_):<EOL><INDENT>os.makedirs(_)<EOL><DEDENT>with open(os.path.join(_,"%s.txt"%case.location.replace(args.replace_slash if args.replace_slash else "/","_")),"w")as f :<EOL><INDENT>content=html <EOL>with kb.value_lock :<EOL><INDENT>if kb.filter_output is None :<EOL><INDENT>answer=ask_question('<STR_LIT>',default='Y',automatic=args.automatic)<EOL>kb.filter_output=answer.upper()!='N'<EOL><DEDENT> <DEDENT>if kb.get("filter_output"):<EOL><INDENT>matcher=difflib.SequenceMatcher(None,html or "",kb.original_response or "")<EOL>matching_blocks=matcher.get_matching_blocks()<EOL>if matching_blocks :<EOL><INDENT>start=matching_blocks []<EOL>if start []==start []==and start []>:<EOL><INDENT>content=content [start []:]<EOL><DEDENT>if len(matching_blocks)>:<EOL><INDENT>end=matching_blocks [-]<EOL>if end []>and end []+end []==len(html)and end []+end []==len(kb.original_response):<EOL><INDENT>content=content [:-end []]<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>f.write(content)<EOL><DEDENT> <DEDENT>return html <EOL><DEDENT>return None <EOL><DEDENT>def try_cases(cases):<EOL><INDENT> '<STR_LIT>'<EOL>passwd_files=["/etc/passwd",'<STR_LIT>']<EOL>if args.replace_slash :<EOL><INDENT>for i,v in enumerate(passwd_files):<EOL><INDENT>passwd_files [i ]=v.replace("/",args.replace_slash)<EOL><DEDENT> <DEDENT>for case in cases :<EOL><INDENT>html=request_file(case)<EOL>if html is None :<EOL><INDENT>continue <EOL><DEDENT>if not kb.found :<EOL><INDENT>kb.found=True <EOL><DEDENT>if case.location in passwd_files and not args.skip_parsing :<EOL><INDENT>users=re.finditer('<STR_LIT>',html)<EOL>if args.verbose :<EOL><INDENT>print('<STR_LIT>'%case.location)<EOL><DEDENT>for user in users :<EOL><INDENT>if args.verbose :<EOL><INDENT>print('<STR_LIT>'%(user.group("username"),user.group("info")))<EOL><DEDENT>if not kb.home_files :<EOL><INDENT>with open(HOME_FILES_FILE,"r")as f :<EOL><INDENT>kb.home_files=filter(None,(_.strip()for _ in f.readlines()))<EOL><DEDENT> <DEDENT>for _ in kb.home_files :<EOL><INDENT>if user.group("home")=="/":<EOL><INDENT>continue <EOL><DEDENT>request_file(AttribDict({"category":"*NIX User File","type":"conf","os":case.os,"location":"%s/%s"%(user.group("home"),_),"software":"*NIX"}))<EOL><DEDENT> <DEDENT> <DEDENT>if "mysql-bin.index"in case.location and not args.skip_parsing :<EOL><INDENT>binlogs=re.findall('<STR_LIT>',html)<EOL>location=case.location.rfind("/")+<EOL>if args.verbose :<EOL><INDENT>print('<STR_LIT>'%case.location)<EOL><DEDENT>for _ in binlogs :<EOL><INDENT>request_file(AttribDict({"category":"Databases","type":"log","os":case.os,"location":"%s%s"%(case.location [:location ],_),"software":"MySQL"}),False)<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>def parse_args():<EOL><INDENT> '<STR_LIT>'<EOL>OptionParser.format_epilog=lambda self,formatter :self.epilog <EOL>parser=OptionParser(usage='<STR_LIT>',epilog=EXAMPLES)<EOL>parser.add_option("-v","--verbose",action="store_true",dest="verbose",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-u","--url",dest="url",<EOL>help="set target URL")<EOL>parser.add_option("-p","--param",dest="param",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-d","--data",dest="data",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-t","--type",dest="type",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-o","--os",dest="os",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-s","--software",dest="software",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-c","--category",dest="category",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-l","--list",dest="list",metavar="GROUP",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-a","--auto",dest="automatic",action="store_true",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-w","--write-files",dest="write_files",action="store_true",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-x","--skip-parsing",dest="skip_parsing",action="store_true",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--load",dest="list_file",metavar="LISTFILE",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--ignore-proxy",dest="ignore_proxy",action="store_true",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--proxy",dest="proxy",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--user-agent",dest="user_agent",metavar="UA",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--random-agent",dest="random_agent",action="store_true",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--cookie",dest="cookie",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--header",dest="header",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--prefix",dest="prefix",default="",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--postfix",dest="postfix",default="",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--multiplier",dest="multiplier",type="int",default=,<EOL>help='<STR_LIT>')<EOL>parser.add_option("--bad-string",dest="bad_string",metavar="STRING",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--replace-slash",dest="replace_slash",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--threads",dest="threads",type="int",default=,<EOL>help='<STR_LIT>')<EOL>parser.add_option("--through",dest="through",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--update",dest="update",action="store_true",<EOL>help='<STR_LIT>')<EOL>parser.formatter.store_option_strings(parser)<EOL>parser.formatter.store_option_strings=lambda _ :None <EOL>for option,value in parser.formatter.option_strings.items():<EOL><INDENT>value=re.sub('<STR_LIT>',r"\g<1>/\g<3>",value)<EOL>value=value.replace(", ",'/')<EOL>if len(value)>MAX_HELP_OPTION_LENGTH :<EOL><INDENT>value=("%%.%ds.."%(MAX_HELP_OPTION_LENGTH -parser.formatter.indent_increment))%value <EOL><DEDENT>parser.formatter.option_strings [option ]=value <EOL><DEDENT>args=parser.parse_args()[]<EOL>if args.url and not args.url.lower().startswith("http"):<EOL><INDENT>args.url="http://%s"%args.url <EOL><DEDENT>if not any((args.url,args.list,args.update)):<EOL><INDENT>parser.error('<STR_LIT>')<EOL><DEDENT>if args.prefix :<EOL><INDENT>args.prefix=args.prefix *args.multiplier <EOL><DEDENT>return args <EOL><DEDENT>def main():<EOL><INDENT> '<STR_LIT>'<EOL>global args <EOL>kb.files=[]<EOL>kb.found=False <EOL>kb.print_lock=threading.Lock()<EOL>kb.value_lock=threading.Lock()<EOL>kb.versioned_locations={}<EOL>check_revision()<EOL>print(BANNER)<EOL>args=parse_args()<EOL>if args.update :<EOL><INDENT>update()<EOL>exit()<EOL><DEDENT>with open("versions.ini")as f :<EOL><INDENT>section=None <EOL>for line in f.xreadlines():<EOL><INDENT>line=line.strip()<EOL>if re.match(r"\[.+\]",line):<EOL><INDENT>section=line.strip("[]")<EOL><DEDENT>elif line :<EOL><INDENT>if section not in kb.versioned_locations :<EOL><INDENT>kb.versioned_locations [section ]=[]<EOL><DEDENT>kb.versioned_locations [section ].append(line)<EOL><DEDENT> <DEDENT> <DEDENT>cases=get_cases(args)if not args.list_file else load_list(args.list_file)<EOL>if not cases :<EOL><INDENT>print('<STR_LIT>'<EOL>'<STR_LIT>')<EOL>exit()<EOL><DEDENT>if args.list :<EOL><INDENT>args.list=args.list.lower()<EOL>_=("category","software","os")<EOL>if args.list not in _ :<EOL><INDENT>print('<STR_LIT>'%", ".join(_))<EOL>exit()<EOL><DEDENT>print('<STR_LIT>'%args.list)<EOL>try :<EOL><INDENT>for _ in set([_ [args.list ]for _ in cases ]):<EOL><INDENT>print(_ if re.search('<STR_LIT>',_)else '"%s"'%_)<EOL><DEDENT> <DEDENT>except KeyError :<EOL><INDENT>pass <EOL><DEDENT>finally :<EOL><INDENT>exit()<EOL><DEDENT> <DEDENT>if args.ignore_proxy :<EOL><INDENT>_=ProxyHandler({})<EOL>opener=build_opener(_)<EOL>install_opener(opener)<EOL><DEDENT>elif args.proxy :<EOL><INDENT>match=re.search('<STR_LIT>',args.proxy,re.I)<EOL>if match :<EOL><INDENT>if match.group("type").upper()in(PROXY_TYPE.HTTP,PROXY_TYPE.HTTPS):<EOL><INDENT>_=ProxyHandler({match.group("type"):args.proxy })<EOL>opener=build_opener(_)<EOL>install_opener(opener)<EOL><DEDENT>else :<EOL><INDENT>from thirdparty.socks import socks <EOL>if match.group("type").upper()==PROXY_TYPE.SOCKS4 :<EOL><INDENT>socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS4,match.group("address"),int(match.group("port")),True)<EOL><DEDENT>elif match.group("type").upper()==PROXY_TYPE.SOCKS5 :<EOL><INDENT>socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5,match.group("address"),int(match.group("port")),True)<EOL><DEDENT> <DEDENT> <DEDENT>else :<EOL><INDENT>print('<STR_LIT>')<EOL>exit()<EOL><DEDENT> <DEDENT>if args.random_agent :<EOL><INDENT>with open(USER_AGENTS_FILE,'r')as f :<EOL><INDENT>args.user_agent=random.sample(f.readlines(),)[]<EOL><DEDENT> <DEDENT>kb.parsed_target_url=urlsplit(args.url)<EOL>kb.request_params=args.data if args.data else kb.parsed_target_url.query <EOL>if not args.param :<EOL><INDENT>match=re.match('<STR_LIT>',kb.request_params)<EOL>if match :<EOL><INDENT>args.param=match.group("param")<EOL><DEDENT>else :<EOL><INDENT>found=False <EOL>for match in re.finditer('<STR_LIT>',kb.request_params):<EOL><INDENT>found=True <EOL>print('<STR_LIT>'%match.group("param"))<EOL><DEDENT>if found :<EOL><INDENT>print('<STR_LIT>')<EOL><DEDENT>print('<STR_LIT>')<EOL>exit()<EOL><DEDENT> <DEDENT>if args.os :<EOL><INDENT>kb.restrict_os=args.os <EOL><DEDENT>print('<STR_LIT>'%time.strftime("%X"))<EOL>print('<STR_LIT>')<EOL>request_args=prepare_request(None)<EOL>request_args ["url"]=args.url <EOL>if args.data :<EOL><INDENT>request_args ["data"]=args.data <EOL><DEDENT>kb.original_response=get_page(**request_args)<EOL>if not kb.original_response :<EOL><INDENT>print('<STR_LIT>')<EOL>if not args.verbose :<EOL><INDENT>print('<STR_LIT>')<EOL><DEDENT>exit()<EOL><DEDENT>print('<STR_LIT>')<EOL>request_args=prepare_request("%s%s%s"%(args.prefix,INVALID_FILENAME,args.postfix))<EOL>kb.invalid_response=get_page(**request_args)<EOL>print("[i] Done!")<EOL>print('<STR_LIT>')<EOL>if args.threads >:<EOL><INDENT>print('<STR_LIT>'%args.threads)<EOL><DEDENT>threads=[]<EOL>for i in xrange(args.threads):<EOL><INDENT>thread=threading.Thread(target=try_cases,args=([cases [_ ]for _ in xrange(i,len(cases),args.threads)],))<EOL>thread.daemon=True <EOL>thread.start()<EOL>threads.append(thread)<EOL><DEDENT>alive=True <EOL>while alive :<EOL><INDENT>alive=False <EOL>for thread in threads :<EOL><INDENT>if thread.isAlive():<EOL><INDENT>alive=True <EOL>time.sleep()<EOL><DEDENT> <DEDENT> <DEDENT>if not kb.found :<EOL><INDENT>print('<STR_LIT>')<EOL><DEDENT>elif args.verbose :<EOL><INDENT>print('<STR_LIT>')<EOL>for _ in kb.files :<EOL><INDENT>print("[o] %s"%_)<EOL><DEDENT> <DEDENT>print('<STR_LIT>')<EOL>print('<STR_LIT>'%time.strftime("%X"))<EOL><DEDENT>def get_page(**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>url=kwargs.get("url",None)<EOL>post=kwargs.get("data",None)<EOL>header=kwargs.get("header",None)<EOL>cookie=kwargs.get("cookie",None)<EOL>user_agent=kwargs.get("user_agent",None)<EOL>verbose=kwargs.get("verbose",False)<EOL>headers={}<EOL>parsed_url=None <EOL>page=None <EOL>if url is None :<EOL><INDENT>raise Exception('<STR_LIT>')<EOL><DEDENT>try :<EOL><INDENT>parsed_url=urlsplit(url)<EOL><DEDENT>except :<EOL><INDENT>raise Exception('<STR_LIT>'%url)<EOL><DEDENT>if user_agent is None :<EOL><INDENT>user_agent="%s %s"%(NAME,VERSION)<EOL><DEDENT>if post is None :<EOL><INDENT>parsed_url=parsed_url._replace(query=urlencode(parse_qsl(parsed_url.query)))<EOL>url=urlunsplit(parsed_url)<EOL><DEDENT>else :<EOL><INDENT>post=urlencode(parse_qsl(post),"POST")<EOL><DEDENT>try :<EOL><INDENT>headers [HTTP_HEADER.USER_AGENT ]=user_agent <EOL>if cookie :<EOL><INDENT>headers [HTTP_HEADER.COOKIE ]=cookie <EOL><DEDENT>if header :<EOL><INDENT>headers [header.split("=")[]]=header.split("=",)[]<EOL><DEDENT>req=Request(url,post,headers)<EOL>conn=urlopen(req)<EOL>if not args.write_files and kb.original_response and kb.invalid_response :<EOL><INDENT>_=conn.headers.get(HTTP_HEADER.CONTENT_LENGTH,"")<EOL>if _.isdigit():<EOL><INDENT>_=int(_)<EOL>if _ -max(len(kb.original_response),len(kb.invalid_response))>SKIP_RETRIEVE_THRESHOLD :<EOL><INDENT>page="".join(random.choice(string.letters)for i in xrange(_))<EOL><DEDENT> <DEDENT> <DEDENT>if not page :<EOL><INDENT>page=conn.read()<EOL><DEDENT> <DEDENT>except KeyboardInterrupt :<EOL><INDENT>raise <EOL><DEDENT>except Exception,e :<EOL><INDENT>if hasattr(e,"read"):<EOL><INDENT>page=page or e.read()<EOL><DEDENT>if verbose :<EOL><INDENT>if hasattr(e,"msg"):<EOL><INDENT>print('<STR_LIT>'%e.msg)<EOL><DEDENT>if hasattr(e,"reason"):<EOL><INDENT>print('<STR_LIT>'%e.reason)<EOL><DEDENT>if getattr(e,"message"):<EOL><INDENT>print('<STR_LIT>'%e.message)<EOL><DEDENT>if hasattr(e,"code"):<EOL><INDENT>print('<STR_LIT>'%e.code)<EOL><DEDENT>if hasattr(e,"info"):<EOL><INDENT>print('<STR_LIT>'%e.info())<EOL><DEDENT> <DEDENT> <DEDENT>return page <EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>try :<EOL><INDENT>main()<EOL><DEDENT>except KeyboardInterrupt :<EOL><INDENT>print('<STR_LIT>')<EOL><DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from.htmlfilewriter import HtmlFileWriter,ModelWriter <EOL>from.jsonwriter import JsonWriter <EOL>LOG='rebot/log.html'<EOL>REPORT='<STR_LIT>'<EOL>LIBDOC='<STR_LIT>'<EOL>TESTDOC='<STR_LIT>'<EOF><BOF>__version__='0.6'<EOL>from os.path import dirname,join <EOL>from.util import Directory <EOL>_package_root=dirname(__file__)<EOL>_chp_csv_path=join(_package_root,'201412.csv')<EOL>_db_path=join(_package_root,'201412.db')<EOL>_dir=Directory(_db_path)<EOL>find=_dir.find <EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>def angle_cos(p0,p1,p2):<EOL><INDENT>d1,d2=(p0 -p1).astype('float'),(p2 -p1).astype('float')<EOL>return abs(np.dot(d1,d2)/np.sqrt(np.dot(d1,d1)*np.dot(d2,d2)))<EOL><DEDENT>def find_squares(img):<EOL><INDENT>img=cv2.GaussianBlur(img,(,),)<EOL>squares=[]<EOL>for gray in cv2.split(img):<EOL><INDENT>for thrs in xrange(,,):<EOL><INDENT>if thrs==:<EOL><INDENT>bin=cv2.Canny(gray,,,apertureSize=)<EOL>bin=cv2.dilate(bin,None)<EOL><DEDENT>else :<EOL><INDENT>retval,bin=cv2.threshold(gray,thrs,,cv2.THRESH_BINARY)<EOL><DEDENT>contours,hierarchy=cv2.findContours(bin,cv2.RETR_LIST,cv2.CHAIN_APPROX_SIMPLE)<EOL>for cnt in contours :<EOL><INDENT>cnt_len=cv2.arcLength(cnt,True)<EOL>cnt=cv2.approxPolyDP(cnt,*cnt_len,True)<EOL>if len(cnt)==and cv2.contourArea(cnt)>and cv2.isContourConvex(cnt):<EOL><INDENT>cnt=cnt.reshape(-,)<EOL>max_cos=np.max([angle_cos(cnt [i ],cnt [(i +)%],cnt [(i +)%])for i in xrange()])<EOL>if max_cos <:<EOL><INDENT>squares.append(cnt)<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>return squares <EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>from glob import glob <EOL>for fn in glob('../cpp/pic*.png'):<EOL><INDENT>img=cv2.imread(fn)<EOL>squares=find_squares(img)<EOL>cv2.drawContours(img,squares,-,(,,),)<EOL>cv2.imshow('squares',img)<EOL>ch=&cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>import six <EOL>if six.PY2 :<EOL><INDENT>from StringIO import StringIO <EOL><DEDENT>else :<EOL><INDENT>from io import StringIO <EOL><DEDENT>assert StringIO <EOF><BOF>import sys <EOL>import cv2.cv as cv <EOL>import urllib2 <EOL>wndname='<STR_LIT>'<EOL>tbarname="Threshold"<EOL>dist=<EOL>dist8u1=<EOL>dist8u2=<EOL>dist8u=<EOL>dist32s=<EOL>gray=<EOL>edge=<EOL>def on_trackbar(edge_thresh):<EOL><INDENT>cv.Threshold(gray,edge,float(edge_thresh),float(edge_thresh),cv.CV_THRESH_BINARY)<EOL>cv.DistTransform(edge,dist,cv.CV_DIST_L2,cv.CV_DIST_MASK_5)<EOL>cv.ConvertScale(dist,dist,,)<EOL>cv.Pow(dist,dist,)<EOL>cv.ConvertScale(dist,dist32s,,)<EOL>cv.AndS(dist32s,cv.ScalarAll(),dist32s,None)<EOL>cv.ConvertScale(dist32s,dist8u1,,)<EOL>cv.ConvertScale(dist32s,dist32s,-,)<EOL>cv.AddS(dist32s,cv.ScalarAll(),dist32s,None)<EOL>cv.ConvertScale(dist32s,dist8u2,,)<EOL>cv.Merge(dist8u1,dist8u2,dist8u2,None,dist8u)<EOL>cv.ShowImage(wndname,dist8u)<EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>edge_thresh=<EOL>if len(sys.argv)>:<EOL><INDENT>gray=cv.LoadImage(sys.argv [],cv.CV_LOAD_IMAGE_GRAYSCALE)<EOL><DEDENT>else :<EOL><INDENT>url='<STR_LIT>'<EOL>filedata=urllib2.urlopen(url).read()<EOL>imagefiledata=cv.CreateMatHeader(,len(filedata),cv.CV_8UC1)<EOL>cv.SetData(imagefiledata,filedata,len(filedata))<EOL>gray=cv.DecodeImage(imagefiledata,cv.CV_LOAD_IMAGE_GRAYSCALE)<EOL><DEDENT>dist=cv.CreateImage((gray.width,gray.height),cv.IPL_DEPTH_32F,)<EOL>dist8u1=cv.CloneImage(gray)<EOL>dist8u2=cv.CloneImage(gray)<EOL>dist8u=cv.CreateImage((gray.width,gray.height),cv.IPL_DEPTH_8U,)<EOL>dist32s=cv.CreateImage((gray.width,gray.height),cv.IPL_DEPTH_32S,)<EOL>edge=cv.CloneImage(gray)<EOL>cv.NamedWindow(wndname,)<EOL>cv.CreateTrackbar(tbarname,wndname,edge_thresh,,on_trackbar)<EOL>on_trackbar(edge_thresh)<EOL>cv.WaitKey()<EOL>cv.DestroyAllWindows()<EOL><DEDENT><EOF><BOF>import pygame <EOL>from pygame.locals import *<EOL>from py2d.Math import *<EOL>from py2d.SVG import convert_svg <EOL>from examples import Example <EOL>class SVGConverter(Example):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,runner):<EOL><INDENT>self.runner=runner <EOL>self.title='<STR_LIT>'<EOL>self.polys=[]<EOL>for id,polys in convert_svg('<STR_LIT>',bezier_max_divisions=None).iteritems():<EOL><INDENT>self.polys.append(polys)<EOL><DEDENT>self.decomp=[]<EOL>self.poly_colors=[,,,,,]<EOL><DEDENT>def render(self):<EOL><INDENT>t=Transform.unit()<EOL>for j,p in enumerate(self.polys):<EOL><INDENT>for i,h in enumerate(p):<EOL><INDENT>self.draw_poly(t *h,self.poly_colors [j %len(self.poly_colors)],False)<EOL><DEDENT> <DEDENT> <DEDENT>def draw_poly(self,poly,color,fill):<EOL><INDENT>if len(poly)>:<EOL><INDENT>if fill and len(poly)>:<EOL><INDENT>pygame.draw.polygon(self.runner.screen,color,poly.as_tuple_list())<EOL><DEDENT>pygame.draw.lines(self.runner.screen,color,True,poly.as_tuple_list())<EOL><DEDENT>elif poly.points :<EOL><INDENT>pygame.draw.circle(self.runner.screen,color,poly.points [].as_tuple(),)<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from collections import defaultdict <EOL>def group_repositories(repos):<EOL><INDENT> '<STR_LIT>'<EOL>sections=defaultdict(list)<EOL>for repo in repos :<EOL><INDENT>sections [repo.owner.login ].append(repo)<EOL><DEDENT>for key in sections.keys():<EOL><INDENT>if len(sections [key ])<=:<EOL><INDENT>sections ['Other'].extend(sections.pop(key))<EOL><DEDENT> <DEDENT>order=lambda t :'z'*if t []=='Other'else t [].lower()<EOL>return sorted(sections.items(),key=order)<EOL><DEDENT>def get_user_active_repositories(user):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>return user.repositories.filter(webhook__active=True)<EOL><DEDENT>except AttributeError :<EOL><INDENT>return []<EOL><DEDENT> <DEDENT><EOF><BOF>class ParseConfig :<EOL><INDENT>def getFolder(self):<EOL><INDENT>return self.folder <EOL><DEDENT>def setFolder(self,folder):<EOL><INDENT>self.folder=folder <EOL><DEDENT>def getExt(self):<EOL><INDENT>return self.ext <EOL><DEDENT>def setExt(self,ext):<EOL><INDENT>self.ext=ext <EOL><DEDENT>def getType(self):<EOL><INDENT>return self.type <EOL><DEDENT>def setType(self,type):<EOL><INDENT>self.type=type <EOL><DEDENT> <DEDENT><EOF><BOF>import numpy as np <EOL>import cv2 <EOL>from common import splitfn <EOL>import os <EOL>USAGE='<STR_LIT>'<EOL>if __name__=='__main__':<EOL><INDENT>import sys <EOL>import getopt <EOL>from glob import glob <EOL>args,img_mask=getopt.getopt(sys.argv [:],'',['save=','debug=','square_size='])<EOL>args=dict(args)<EOL>try :<EOL><INDENT>img_mask=img_mask []<EOL><DEDENT>except :<EOL><INDENT>img_mask='<STR_LIT>'<EOL><DEDENT>img_names=glob(img_mask)<EOL>debug_dir=args.get('--debug')<EOL>square_size=float(args.get('--square_size',))<EOL>pattern_size=(,)<EOL>pattern_points=np.zeros((np.prod(pattern_size),),np.float32)<EOL>pattern_points [:,:]=np.indices(pattern_size).T.reshape(-,)<EOL>pattern_points *=square_size <EOL>obj_points=[]<EOL>img_points=[]<EOL>h,w=,<EOL>for fn in img_names :<EOL><INDENT>print '<STR_LIT>'%fn,<EOL>img=cv2.imread(fn,)<EOL>if img is None :<EOL><INDENT>print "Failed to load",fn <EOL>continue <EOL><DEDENT>h,w=img.shape [:]<EOL>found,corners=cv2.findChessboardCorners(img,pattern_size)<EOL>if found :<EOL><INDENT>term=(cv2.TERM_CRITERIA_EPS +cv2.TERM_CRITERIA_COUNT,,)<EOL>cv2.cornerSubPix(img,corners,(,),(-,-),term)<EOL><DEDENT>if debug_dir :<EOL><INDENT>vis=cv2.cvtColor(img,cv2.COLOR_GRAY2BGR)<EOL>cv2.drawChessboardCorners(vis,pattern_size,corners,found)<EOL>path,name,ext=splitfn(fn)<EOL>cv2.imwrite('%s/%s_chess.bmp'%(debug_dir,name),vis)<EOL><DEDENT>if not found :<EOL><INDENT>print '<STR_LIT>'<EOL>continue <EOL><DEDENT>img_points.append(corners.reshape(-,))<EOL>obj_points.append(pattern_points)<EOL>print 'ok'<EOL><DEDENT>rms,camera_matrix,dist_coefs,rvecs,tvecs=cv2.calibrateCamera(obj_points,img_points,(w,h),None,None)<EOL>print "RMS:",rms <EOL>print '<STR_LIT>',camera_matrix <EOL>print '<STR_LIT>',dist_coefs.ravel()<EOL>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>import codecs <EOL>class LibdocOutput(object):<EOL><INDENT>def __init__(self,output_path,format):<EOL><INDENT>self._output_path=output_path <EOL>self._format=format.upper()<EOL>self._output_file=None <EOL><DEDENT>def __enter__(self):<EOL><INDENT>if self._format=='HTML':<EOL><INDENT>self._output_file=codecs.open(self._output_path,'w','UTF-8')<EOL>return self._output_file <EOL><DEDENT>return self._output_path <EOL><DEDENT>def __exit__(self,*exc_info):<EOL><INDENT>if self._output_file :<EOL><INDENT>self._output_file.close()<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>from flask_wtf import Form <EOL>from wtforms import StringField,PasswordField,BooleanField,SubmitField,SelectField,ValidationError <EOL>from wtforms.validators import DataRequired,Length,Email,EqualTo <EOL>from.models import User,Role <EOL>class LoginForm(Form):<EOL><INDENT>email=StringField(u'Email',validators=[DataRequired(),<EOL>Length(,),Email()])<EOL>password=PasswordField(u'Password',validators=[DataRequired()])<EOL>remember_me=BooleanField(u'Remember Me')<EOL>submit=SubmitField(u'Log In')<EOL><DEDENT>class RegisterForm(Form):<EOL><INDENT>name=StringField(u'Your Name',validators=[DataRequired()])<EOL>email=StringField(u'Email',validators=[DataRequired(),<EOL>Length(,),Email()])<EOL>password=PasswordField(u'Password',validators=[DataRequired(),<EOL>EqualTo('cpassword',<EOL>message='<STR_LIT>')])<EOL>cpassword=PasswordField('<STR_LIT>',validators=[DataRequired()])<EOL>role=SelectField(u'Role',coerce=int)<EOL>confirm=BooleanField('<STR_LIT>')<EOL>submit=SubmitField(u'Sign Up')<EOL>def __init__(self,**kwargs):<EOL><INDENT>super(RegisterForm,self).__init__(**kwargs)<EOL>self.role.choices=[(r.id,r.name)<EOL>for r in Role.query.with_entities(<EOL>Role.id,Role.name).all()]<EOL><DEDENT>def validate_email(self,field):<EOL><INDENT>if User.query.filter_by(email=field.data).first():<EOL><INDENT>raise ValidationError('<STR_LIT>')<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>__author__='<STR_LIT>'<EOL>import io <EOL>import jinja2 <EOL>import logging <EOL>import os <EOL>import webapp2 <EOL>from google.appengine.api import memcache <EOL>from google.appengine.api import urlfetch <EOL>import httplib2 <EOL>from apiclient import errors <EOL>from apiclient.http import MediaIoBaseUpload <EOL>from apiclient.http import BatchHttpRequest <EOL>from oauth2client.appengine import StorageByKeyName <EOL>from model import Credentials <EOL>import util <EOL>jinja_environment=jinja2.Environment(<EOL>loader=jinja2.FileSystemLoader(os.path.dirname(__file__)))<EOL>PAGINATED_HTML='<STR_LIT>'<EOL>class _BatchCallback(object):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self):<EOL><INDENT> '<STR_LIT>'<EOL>self.success=<EOL>self.failure=<EOL><DEDENT>def callback(self,request_id,response,exception):<EOL><INDENT> '<STR_LIT>'<EOL>if exception is None :<EOL><INDENT>self.success +=<EOL><DEDENT>else :<EOL><INDENT>self.failure +=<EOL>logging.error(<EOL>'<STR_LIT>',request_id,exception)<EOL><DEDENT> <DEDENT> <DEDENT>class MainHandler(webapp2.RequestHandler):<EOL><INDENT> '<STR_LIT>'<EOL>def _render_template(self,message=None):<EOL><INDENT> '<STR_LIT>'<EOL>template_values={'userId':self.userid }<EOL>if message :<EOL><INDENT>template_values ['message']=message <EOL><DEDENT>try :<EOL><INDENT>template_values ['contact']=self.mirror_service.contacts().get(<EOL>id='<STR_LIT>').execute()<EOL><DEDENT>except errors.HttpError :<EOL><INDENT>logging.info('<STR_LIT>')<EOL><DEDENT>timeline_items=self.mirror_service.timeline().list(maxResults=).execute()<EOL>template_values ['timelineItems']=timeline_items.get('items',[])<EOL>subscriptions=self.mirror_service.subscriptions().list().execute()<EOL>for subscription in subscriptions.get('items',[]):<EOL><INDENT>collection=subscription.get('collection')<EOL>if collection=='timeline':<EOL><INDENT>template_values ['<STR_LIT>']=True <EOL><DEDENT>elif collection=='locations':<EOL><INDENT>template_values ['<STR_LIT>']=True <EOL><DEDENT> <DEDENT>template=jinja_environment.get_template('<STR_LIT>')<EOL>self.response.out.write(template.render(template_values))<EOL><DEDENT>@util.auth_required <EOL>def get(self):<EOL><INDENT> '<STR_LIT>'<EOL>message=memcache.get(key=self.userid)<EOL>memcache.delete(key=self.userid)<EOL>self._render_template(message)<EOL><DEDENT>@util.auth_required <EOL>def post(self):<EOL><INDENT> '<STR_LIT>'<EOL>operation=self.request.get('operation')<EOL>operations={<EOL>'<STR_LIT>':self._insert_subscription,<EOL>'<STR_LIT>':self._delete_subscription,<EOL>'insertItem':self._insert_item,<EOL>'<STR_LIT>':self._insert_paginated_item,<EOL>'<STR_LIT>':self._insert_item_with_action,<EOL>'<STR_LIT>':self._insert_item_all_users,<EOL>'insertContact':self._insert_contact,<EOL>'deleteContact':self._delete_contact,<EOL>'<STR_LIT>':self._delete_timeline_item <EOL>}<EOL>if operation in operations :<EOL><INDENT>message=operations [operation ]()<EOL><DEDENT>else :<EOL><INDENT>message='<STR_LIT>'+operation <EOL><DEDENT>memcache.set(key=self.userid,value=message,time=)<EOL>self.redirect('/')<EOL><DEDENT>def _insert_subscription(self):<EOL><INDENT> '<STR_LIT>'<EOL>body={<EOL>'collection':self.request.get('collection','timeline'),<EOL>'userToken':self.userid,<EOL>'callbackUrl':util.get_full_url(self,'/notify')<EOL>}<EOL>self.mirror_service.subscriptions().insert(body=body).execute()<EOL>return '<STR_LIT>'<EOL><DEDENT>def _delete_subscription(self):<EOL><INDENT> '<STR_LIT>'<EOL>collection=self.request.get('subscriptionId')<EOL>self.mirror_service.subscriptions().delete(id=collection).execute()<EOL>return '<STR_LIT>'<EOL><DEDENT>def _insert_item(self):<EOL><INDENT> '<STR_LIT>'<EOL>logging.info('<STR_LIT>')<EOL>body={<EOL>'notification':{'level':'DEFAULT'}<EOL>}<EOL>if self.request.get('html')=='on':<EOL><INDENT>body ['html']=[self.request.get('message')]<EOL><DEDENT>else :<EOL><INDENT>body ['text']=self.request.get('message')<EOL><DEDENT>media_link=self.request.get('imageUrl')<EOL>if media_link :<EOL><INDENT>if media_link.startswith('/'):<EOL><INDENT>media_link=util.get_full_url(self,media_link)<EOL><DEDENT>resp=urlfetch.fetch(media_link,deadline=)<EOL>media=MediaIoBaseUpload(<EOL>io.BytesIO(resp.content),mimetype='image/jpeg',resumable=True)<EOL><DEDENT>else :<EOL><INDENT>media=None <EOL><DEDENT>self.mirror_service.timeline().insert(body=body,media_body=media).execute()<EOL>return '<STR_LIT>'<EOL><DEDENT>def _insert_paginated_item(self):<EOL><INDENT> '<STR_LIT>'<EOL>logging.info('<STR_LIT>')<EOL>body={<EOL>'html':PAGINATED_HTML,<EOL>'notification':{'level':'DEFAULT'},<EOL>'menuItems':[{<EOL>'action':'OPEN_URI',<EOL>'payload':'<STR_LIT>'<EOL>}]<EOL>}<EOL>self.mirror_service.timeline().insert(body=body).execute()<EOL>return '<STR_LIT>'<EOL><DEDENT>def _insert_item_with_action(self):<EOL><INDENT> '<STR_LIT>'<EOL>logging.info('<STR_LIT>')<EOL>body={<EOL>'creator':{<EOL>'displayName':'<STR_LIT>',<EOL>'id':'<STR_LIT>'<EOL>},<EOL>'text':'<STR_LIT>',<EOL>'notification':{'level':'DEFAULT'},<EOL>'menuItems':[{'action':'REPLY'}]<EOL>}<EOL>self.mirror_service.timeline().insert(body=body).execute()<EOL>return '<STR_LIT>'<EOL><DEDENT>def _insert_item_all_users(self):<EOL><INDENT> '<STR_LIT>'<EOL>logging.info('<STR_LIT>')<EOL>users=Credentials.all()<EOL>total_users=users.count()<EOL>if total_users >:<EOL><INDENT>return '<STR_LIT>'%(<EOL>total_users)<EOL><DEDENT>body={<EOL>'text':'Hello Everyone!',<EOL>'notification':{'level':'DEFAULT'}<EOL>}<EOL>batch_responses=_BatchCallback()<EOL>batch=BatchHttpRequest(callback=batch_responses.callback)<EOL>for user in users :<EOL><INDENT>creds=StorageByKeyName(<EOL>Credentials,user.key().name(),'credentials').get()<EOL>mirror_service=util.create_service('mirror','v1',creds)<EOL>batch.add(<EOL>mirror_service.timeline().insert(body=body),<EOL>request_id=user.key().name())<EOL><DEDENT>batch.execute(httplib2.Http())<EOL>return '<STR_LIT>'%(<EOL>batch_responses.success,batch_responses.failure)<EOL><DEDENT>def _insert_contact(self):<EOL><INDENT> '<STR_LIT>'<EOL>logging.info('<STR_LIT>')<EOL>id=self.request.get('id')<EOL>name=self.request.get('name')<EOL>image_url=self.request.get('imageUrl')<EOL>if not name or not image_url :<EOL><INDENT>return '<STR_LIT>'<EOL><DEDENT>else :<EOL><INDENT>if image_url.startswith('/'):<EOL><INDENT>image_url=util.get_full_url(self,image_url)<EOL><DEDENT>body={<EOL>'id':id,<EOL>'displayName':name,<EOL>'imageUrls':[image_url ],<EOL>'acceptCommands':[{'type':'TAKE_A_NOTE'}]<EOL>}<EOL>self.mirror_service.contacts().insert(body=body).execute()<EOL>return '<STR_LIT>'+name <EOL><DEDENT> <DEDENT>def _delete_contact(self):<EOL><INDENT> '<STR_LIT>'<EOL>self.mirror_service.contacts().delete(<EOL>id=self.request.get('id')).execute()<EOL>return '<STR_LIT>'<EOL><DEDENT>def _delete_timeline_item(self):<EOL><INDENT> '<STR_LIT>'<EOL>logging.info('<STR_LIT>')<EOL>self.mirror_service.timeline().delete(id=self.request.get('itemId')).execute()<EOL>return '<STR_LIT>'<EOL><DEDENT> <DEDENT>MAIN_ROUTES=[('/',MainHandler)<EOL>]<EOF><BOF>import time <EOL>from robot import utils <EOL>from.stringcache import StringIndex <EOL>class JsExecutionResult(object):<EOL><INDENT>def __init__(self,suite,statistics,errors,strings,basemillis=None,<EOL>split_results=None,min_level=None):<EOL><INDENT>self.suite=suite <EOL>self.strings=strings <EOL>self.min_level=min_level <EOL>self.data=self._get_data(statistics,errors,basemillis or)<EOL>self.split_results=split_results or []<EOL><DEDENT>def _get_data(self,statistics,errors,basemillis):<EOL><INDENT>gentime=time.localtime()<EOL>return {<EOL>'stats':statistics,<EOL>'errors':errors,<EOL>'baseMillis':basemillis,<EOL>'generatedMillis':long(time.mktime(gentime)*)-basemillis,<EOL>'<STR_LIT>':utils.format_time(gentime,gmtsep=' ')<EOL>}<EOL><DEDENT>def remove_data_not_needed_in_report(self):<EOL><INDENT>self.data.pop('errors')<EOL>remover=_KeywordRemover()<EOL>self.suite=remover.remove_keywords(self.suite)<EOL>self.suite,self.strings=remover.remove_unused_strings(self.suite,self.strings)<EOL><DEDENT> <DEDENT>class _KeywordRemover(object):<EOL><INDENT>def remove_keywords(self,suite):<EOL><INDENT>return self._remove_keywords_from_suite(suite)<EOL><DEDENT>def _remove_keywords_from_suite(self,suite):<EOL><INDENT>return suite [:]+(self._remove_keywords_from_suites(suite []),<EOL>self._remove_keywords_from_tests(suite []),(),suite [])<EOL><DEDENT>def _remove_keywords_from_suites(self,suites):<EOL><INDENT>return tuple(self._remove_keywords_from_suite(s)for s in suites)<EOL><DEDENT>def _remove_keywords_from_tests(self,tests):<EOL><INDENT>return tuple(self._remove_keywords_from_test(t)for t in tests)<EOL><DEDENT>def _remove_keywords_from_test(self,test):<EOL><INDENT>return test [:-]+((),)<EOL><DEDENT>def remove_unused_strings(self,model,strings):<EOL><INDENT>used=set(self._get_used_indices(model))<EOL>remap={}<EOL>strings=tuple(self._get_used_strings(strings,used,remap))<EOL>model=tuple(self._remap_string_indices(model,remap))<EOL>return model,strings <EOL><DEDENT>def _get_used_indices(self,model):<EOL><INDENT>for item in model :<EOL><INDENT>if isinstance(item,StringIndex):<EOL><INDENT>yield item <EOL><DEDENT>elif isinstance(item,tuple):<EOL><INDENT>for i in self._get_used_indices(item):<EOL><INDENT>yield i <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>def _get_used_strings(self,strings,used_indices,remap):<EOL><INDENT>offset=<EOL>for index,string in enumerate(strings):<EOL><INDENT>if index in used_indices :<EOL><INDENT>remap [index ]=index -offset <EOL>yield string <EOL><DEDENT>else :<EOL><INDENT>offset +=<EOL><DEDENT> <DEDENT> <DEDENT>def _remap_string_indices(self,model,remap):<EOL><INDENT>for item in model :<EOL><INDENT>if isinstance(item,StringIndex):<EOL><INDENT>yield remap [item ]<EOL><DEDENT>elif isinstance(item,tuple):<EOL><INDENT>yield tuple(self._remap_string_indices(item,remap))<EOL><DEDENT>else :<EOL><INDENT>yield item <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT><EOF><BOF>import cv2 <EOL>import numpy as np <EOL>from glob import glob <EOL>class undistortor :<EOL><INDENT>def __init__(self,cal_data=None):<EOL><INDENT>if cal_data is None :<EOL><INDENT>npz_mask='*.npz'<EOL>self.cal_data=glob(npz_mask)[]<EOL><DEDENT>else :<EOL><INDENT>self.cal_data=cal_data <EOL><DEDENT>with np.load(self.cal_data)as X :<EOL><INDENT>self.mtx,self.dist,_,_=[X [i ]for i in('mtx','dist','rvecs','tvecs')]<EOL><DEDENT> <DEDENT>def apply(self,img,crop=True):<EOL><INDENT>h,w=img.shape [:]<EOL>newcameramtx,roi=cv2.getOptimalNewCameraMatrix(self.mtx,self.dist,(w,h),,(w,h))<EOL>dst=cv2.undistort(img,self.mtx,self.dist,None,newcameramtx)<EOL>if crop is not True :<EOL><INDENT>return dst <EOL><DEDENT>x,y,w,h=roi <EOL>dst=dst [y :y +h,x :x +w ]<EOL>return dst <EOL><DEDENT> <DEDENT>if __name__=="__main__":<EOL><INDENT>ud=undistortor()<EOL>img=cv2.imread('img.jpg')<EOL>cv2.imshow('compare',np.hstack([img,ud.apply(img,crop=False)]))<EOL>cv2.waitKey()<DEDENT><EOF><BOF>import re <EOL>from.tsvreader import TsvReader <EOL>class TxtReader(TsvReader):<EOL><INDENT>_space_splitter=re.compile(' {2,}')<EOL>_pipe_splitter=re.compile(' \|(?=)')<EOL>@classmethod <EOL>def split_row(cls,row):<EOL><INDENT>if '\t'in row :<EOL><INDENT>row=row.replace('\t','  ')<EOL><DEDENT>if not row.startswith('| '):<EOL><INDENT>return cls._space_splitter.split(row)<EOL><DEDENT>row=row [:-]if row.endswith(' |')else row [:]<EOL>return [cell.strip()for cell in cls._pipe_splitter.split(row)]<EOL><DEDENT>def _process(self,cell):<EOL><INDENT>return cell <EOL><DEDENT> <DEDENT><EOF><BOF>import cv2.cv as cv <EOL>import time <EOL>from pydmtx import DataMatrix <EOL>import numpy <EOL>import sys <EOL>import math <EOL>'<STR_LIT>'<EOL>def absnorm8(im,im8):<EOL><INDENT> '<STR_LIT>'(minVal,maxVal,_,_)=cv.MinMaxLoc(im)<EOL>cv.ConvertScaleAbs(im,im8,/max(abs(minVal),abs(maxVal)),)<EOL>return im8 <EOL><DEDENT>font=cv.InitFont(cv.CV_FONT_HERSHEY_SIMPLEX,,,thickness=,lineType=cv.CV_AA)<EOL>if :<EOL><INDENT>started=time.time()<EOL>print dm_write.decode(bg.width,bg.height,buffer(bg.tostring()),max_count=,min_edge=,max_edge=,shape=DataMatrix.DmtxSymbol10x10)<EOL>print "took",time.time()-started <EOL><DEDENT>class DmtxFinder :<EOL><INDENT>def __init__(self):<EOL><INDENT>self.cache={}<EOL>self.dm=DataMatrix()<EOL><DEDENT>def Cached(self,name,rows,cols,type):<EOL><INDENT>key=(name,rows,cols)<EOL>if not key in self.cache :<EOL><INDENT>self.cache [key ]=cv.CreateMat(rows,cols,type)<EOL><DEDENT>return self.cache [key ]<EOL><DEDENT>def find0(self,img):<EOL><INDENT>started=time.time()<EOL>self.dm.decode(img.width,<EOL>img.height,<EOL>buffer(img.tostring()),<EOL>max_count=,<EOL>)<EOL>print "brute",time.time()-started <EOL>found={}<EOL>for i in range(self.dm.count()):<EOL><INDENT>stats=dm_read.stats(i +)<EOL>print stats <EOL>found [stats []]=stats []<EOL><DEDENT>return found <EOL><DEDENT>def find(self,img):<EOL><INDENT>started=time.time()<EOL>gray=self.Cached('gray',img.height,img.width,cv.CV_8UC1)<EOL>cv.CvtColor(img,gray,cv.CV_BGR2GRAY)<EOL>sobel=self.Cached('sobel',img.height,img.width,cv.CV_16SC1)<EOL>sobely=self.Cached('sobely',img.height,img.width,cv.CV_16SC1)<EOL>cv.Sobel(gray,sobel,,)<EOL>cv.Sobel(gray,sobely,,)<EOL>cv.Add(sobel,sobely,sobel)<EOL>sobel8=self.Cached('sobel8',sobel.height,sobel.width,cv.CV_8UC1)<EOL>absnorm8(sobel,sobel8)<EOL>cv.Threshold(sobel8,sobel8,,,cv.CV_THRESH_BINARY)<EOL>sobel_integral=self.Cached('sobel_integral',img.height +,img.width +,cv.CV_32SC1)<EOL>cv.Integral(sobel8,sobel_integral)<EOL>d=<EOL>_x1y1=cv.GetSubRect(sobel_integral,(,,sobel_integral.cols -d,sobel_integral.rows -d))<EOL>_x1y2=cv.GetSubRect(sobel_integral,(,d,sobel_integral.cols -d,sobel_integral.rows -d))<EOL>_x2y1=cv.GetSubRect(sobel_integral,(d,,sobel_integral.cols -d,sobel_integral.rows -d))<EOL>_x2y2=cv.GetSubRect(sobel_integral,(d,d,sobel_integral.cols -d,sobel_integral.rows -d))<EOL>summation=cv.CloneMat(_x2y2)<EOL>cv.Sub(summation,_x1y2,summation)<EOL>cv.Sub(summation,_x2y1,summation)<EOL>cv.Add(summation,_x1y1,summation)<EOL>sum8=self.Cached('sum8',summation.height,summation.width,cv.CV_8UC1)<EOL>absnorm8(summation,sum8)<EOL>cv.Threshold(sum8,sum8,,,cv.CV_THRESH_BINARY)<EOL>cv.ShowImage("sum8",sum8)<EOL>seq=cv.FindContours(sum8,cv.CreateMemStorage(),cv.CV_RETR_EXTERNAL)<EOL>subimg=cv.GetSubRect(img,(d /,d /,sum8.cols,sum8.rows))<EOL>t_cull=time.time()-started <EOL>seqs=[]<EOL>while seq :<EOL><INDENT>seqs.append(seq)<EOL>seq=seq.h_next()<EOL><DEDENT>started=time.time()<EOL>found={}<EOL>print 'seqs',len(seqs)<EOL>for seq in seqs :<EOL><INDENT>area=cv.ContourArea(seq)<EOL>if area >:<EOL><INDENT>rect=cv.BoundingRect(seq)<EOL>edge=int((/)*math.sqrt(area)/+)<EOL>candidate=cv.GetSubRect(subimg,rect)<EOL>sym=self.dm.decode(candidate.width,<EOL>candidate.height,<EOL>buffer(candidate.tostring()),<EOL>max_count=,<EOL>)<EOL>if sym :<EOL><INDENT>onscreen=[(d /+rect []+x,d /+rect []+y)for(x,y)in self.dm.stats()[]]<EOL>found [sym ]=onscreen <EOL><DEDENT>else :<EOL><INDENT>print "FAILED"<EOL><DEDENT> <DEDENT> <DEDENT>t_brute=time.time()-started <EOL>print "cull took",t_cull,"brute",t_brute <EOL>return found <EOL><DEDENT> <DEDENT>bg=cv.CreateMat(,,cv.CV_8UC3)<EOL>cv.Set(bg,cv.RGB(,,))<EOL>df=DmtxFinder()<EOL>cv.NamedWindow("camera",)<EOL>def mkdmtx(msg):<EOL><INDENT>dm_write=DataMatrix()<EOL>dm_write.encode(msg)<EOL>pi=dm_write.image <EOL>cv_im=cv.CreateImageHeader(pi.size,cv.IPL_DEPTH_8U,)<EOL>cv.SetData(cv_im,pi.tostring())<EOL>return cv_im <EOL><DEDENT>test=[]<EOL>y=<EOL>for j in range():<EOL><INDENT>r=+j *<EOL>mr=r *math.sqrt()<EOL>y +=mr *<EOL>test +=[(str(deg)+"abcdefgh"[j ],(+deg *,y),math.pi *deg /,r)for deg in range(,,)]<EOL><DEDENT>for(msg,(x,y),angle,r)in test :<EOL><INDENT>map=cv.CreateMat(,,cv.CV_32FC1)<EOL>corners=[(x +r *math.cos(angle +th),y +r *math.sin(angle +th))for th in [,math.pi /,math.pi,*math.pi /]]<EOL>src=mkdmtx(msg)(sx,sy)=cv.GetSize(src)<EOL>cv.GetAffineTransform([(,),(sx,),(sx,sy)],corners [:],map)<EOL>temp=cv.CreateMat(bg.rows,bg.cols,cv.CV_8UC3)<EOL>cv.Set(temp,cv.RGB(,,))<EOL>cv.WarpAffine(src,temp,map)<EOL>cv.Or(temp,bg,bg)<EOL><DEDENT>cv.ShowImage("comp",bg)<EOL>scribble=cv.CloneMat(bg)<EOL>if :<EOL><INDENT>for i in range():<EOL><INDENT>df.find(bg)<EOL><DEDENT> <DEDENT>for(sym,coords)in df.find(bg).items():<EOL><INDENT>print sym <EOL>cv.PolyLine(scribble,[coords ],,cv.CV_RGB(,,),,lineType=cv.CV_AA)<EOL>Xs=[x for(x,y)in coords ]<EOL>Ys=[y for(x,y)in coords ]<EOL>where=((min(Xs)+max(Xs))/,max(Ys)-)<EOL>cv.PutText(scribble,sym,where,font,cv.RGB(,,))<EOL><DEDENT>cv.ShowImage("results",scribble)<EOL>cv.WaitKey()<EOL>cv.DestroyAllWindows()<EOL>sys.exit()<EOL>capture=cv.CaptureFromCAM()<EOL>while True :<EOL><INDENT>img=cv.QueryFrame(capture)<EOL>cv.ShowImage("capture",img)<EOL>print df.find(img)<EOL>cv.WaitKey()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from.resultbuilder import ExecutionResult <EOF><BOF>import sys <EOL>import random <EOL>from operator import add <EOL>from pyspark import SparkConf,SparkContext <EOL>def estimate(idx):<EOL><INDENT>x=random.random()*-<EOL>y=random.random()*-<EOL>return if(x *x +y *y <)else <EOL><DEDENT>def main(sc,*args):<EOL><INDENT>slices=int(args [])if len(args)>else <EOL>N=*slices <EOL>count=sc.parallelize(xrange(N),slices).map(estimate)<EOL>count=count.reduce(add)<EOL>print '<STR_LIT>'%(*count /N)<EOL>sc.stop()<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>conf=SparkConf().setAppName("Estimate Pi")<EOL>sc=SparkContext(conf=conf)<EOL>main(sc,*sys.argv [:])<EOL><DEDENT><EOF><BOF>import os <EOL>import re <EOL>from copy import copy <EOL>from collections import deque <EOL>from time import time <EOL>import sublime <EOL>from robot.api import TestCaseFile,ResourceFile <EOL>from robot.errors import DataError <EOL>from scanner_cache import ScannerCache <EOL>from string_populator import populate_from_lines <EOL>scanner_cache=ScannerCache()<EOL>SCAN_TIMEOUT=<EOL>detect_robot_regex='<STR_LIT>'<EOL>class WrappedKeyword :<EOL><INDENT>def __init__(self,data_file,keyword,file_path):<EOL><INDENT>self.keyword=keyword <EOL>self.name=data_file.name +'.'+keyword.name <EOL>self.file_path=file_path <EOL>self.description=[]<EOL>args=', '.join(keyword.args.value)<EOL>if args :<EOL><INDENT>self.description.append(args)<EOL><DEDENT>if keyword.doc.value :<EOL><INDENT>self.description.append(keyword.doc.value)<EOL><DEDENT>self.description.append(file_path)<EOL><DEDENT>def show_definition(self,view,views_to_center):<EOL><INDENT>source_path=self.keyword.source <EOL>new_view=view.window().open_file("%s:%d"%(source_path,self.keyword.linenumber),sublime.ENCODED_POSITION)<EOL>new_view.show_at_center(new_view.text_point(self.keyword.linenumber,))<EOL>if new_view.is_loading():<EOL><INDENT>views_to_center [new_view.id()]=self.keyword.linenumber <EOL><DEDENT> <DEDENT>def __eq__(self,other):<EOL><INDENT>return isinstance(other,WrappedKeyword)and self.file_path==other.file_path <EOL><DEDENT>def allow_unprompted_go_to(self):<EOL><INDENT>return True <EOL><DEDENT> <DEDENT>class Scanner(object):<EOL><INDENT>def __init__(self,view):<EOL><INDENT>self.view=view <EOL><DEDENT>def scan_file(self,data_file):<EOL><INDENT>self.start_time=time()<EOL>self.start_path=data_file.directory <EOL>self.scanned_files=set()<EOL>keywords={}<EOL>self.__scan_file(keywords,data_file,deque())<EOL>return keywords <EOL><DEDENT>def __scan_file(self,keywords,data_file,import_history):<EOL><INDENT>if time()-self.start_time >SCAN_TIMEOUT :<EOL><INDENT>sublime.set_timeout(lambda :self.view.set_status('scan_error','<STR_LIT>'),)<EOL>sublime.set_timeout(lambda :self.view.erase_status('scan_error'),)<EOL>return <EOL><DEDENT>self.scanned_files.add(data_file.source)<EOL>if data_file.source in import_history :<EOL><INDENT>return <EOL><DEDENT>import_history=copy(import_history)<EOL>import_history.append(data_file.source)<EOL>for setting in data_file.imports :<EOL><INDENT>if hasattr(setting,'type'):<EOL><INDENT>if setting.type=='Resource':<EOL><INDENT>resource_path=os.path.normpath(os.path.join(setting.directory,setting.name))<EOL>cached,stored_hash=scanner_cache.get_cached_data(resource_path)<EOL>if cached :<EOL><INDENT>self.__scan_file(keywords,cached,import_history)<EOL><DEDENT>else :<EOL><INDENT>try :<EOL><INDENT>resource_data=ResourceFile(source=resource_path).populate()<EOL>scanner_cache.put_data(resource_path,resource_data,stored_hash)<EOL>self.__scan_file(keywords,resource_data,import_history)<EOL><DEDENT>except DataError as de :<EOL><INDENT>print '<STR_LIT>',resource_path <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>self.scan_keywords(data_file,keywords)<EOL><DEDENT>def scan_keywords(self,data_file,keywords):<EOL><INDENT>for keyword in data_file.keyword_table :<EOL><INDENT>lower_name=keyword.name.lower()<EOL>if not keywords.has_key(lower_name):<EOL><INDENT>keywords [lower_name ]=[]<EOL><DEDENT>wrapped=WrappedKeyword(data_file,keyword,os.path.relpath(keyword.source,self.start_path))<EOL>if wrapped in keywords [lower_name ]:<EOL><INDENT>continue <EOL><DEDENT>keywords [lower_name ].append(wrapped)<EOL><DEDENT> <DEDENT>def scan_without_resources(self,file_path,keywords):<EOL><INDENT>if file_path in self.scanned_files :<EOL><INDENT>return <EOL><DEDENT>try :<EOL><INDENT>with open(file_path,'rb')as f :<EOL><INDENT>lines=f.readlines()<EOL><DEDENT> <DEDENT>except IOError as e :<EOL><INDENT>return <EOL><DEDENT>cached,stored_hash=scanner_cache.get_cached_data(file_path,lines)<EOL>if cached :<EOL><INDENT>self.scan_keywords(cached,keywords)<EOL><DEDENT>else :<EOL><INDENT>try :<EOL><INDENT>for line in lines :<EOL><INDENT>if re.search(detect_robot_regex,line,re.IGNORECASE)!=None :<EOL><INDENT>data_file=populate_from_lines(lines,file_path)<EOL>scanner_cache.put_data(file_path,data_file,stored_hash)<EOL>self.scan_keywords(data_file,keywords)<EOL>break <EOL><DEDENT> <DEDENT> <DEDENT>except DataError as de :<EOL><INDENT>pass <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT><EOF><BOF>import sys <EOL>import urllib2 <EOL>import cv2.cv as cv <EOL>src=<EOL>image=<EOL>dest=<EOL>element_shape=cv.CV_SHAPE_RECT <EOL>def Opening(pos):<EOL><INDENT>element=cv.CreateStructuringElementEx(pos *+,pos *+,pos,pos,element_shape)<EOL>cv.Erode(src,image,element,)<EOL>cv.Dilate(image,dest,element,)<EOL>cv.ShowImage('<STR_LIT>',dest)<EOL><DEDENT>def Closing(pos):<EOL><INDENT>element=cv.CreateStructuringElementEx(pos *+,pos *+,pos,pos,element_shape)<EOL>cv.Dilate(src,image,element,)<EOL>cv.Erode(image,dest,element,)<EOL>cv.ShowImage('<STR_LIT>',dest)<EOL><DEDENT>def Erosion(pos):<EOL><INDENT>element=cv.CreateStructuringElementEx(pos *+,pos *+,pos,pos,element_shape)<EOL>cv.Erode(src,dest,element,)<EOL>cv.ShowImage('<STR_LIT>',dest)<EOL><DEDENT>def Dilation(pos):<EOL><INDENT>element=cv.CreateStructuringElementEx(pos *+,pos *+,pos,pos,element_shape)<EOL>cv.Dilate(src,dest,element,)<EOL>cv.ShowImage('<STR_LIT>',dest)<EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>if len(sys.argv)>:<EOL><INDENT>src=cv.LoadImage(sys.argv [],cv.CV_LOAD_IMAGE_COLOR)<EOL><DEDENT>else :<EOL><INDENT>url='<STR_LIT>'<EOL>filedata=urllib2.urlopen(url).read()<EOL>imagefiledata=cv.CreateMatHeader(,len(filedata),cv.CV_8UC1)<EOL>cv.SetData(imagefiledata,filedata,len(filedata))<EOL>src=cv.DecodeImage(imagefiledata,cv.CV_LOAD_IMAGE_COLOR)<EOL><DEDENT>image=cv.CloneImage(src)<EOL>dest=cv.CloneImage(src)<EOL>cv.NamedWindow('<STR_LIT>',)<EOL>cv.NamedWindow('<STR_LIT>',)<EOL>cv.ShowImage('<STR_LIT>',src)<EOL>cv.ShowImage('<STR_LIT>',src)<EOL>cv.CreateTrackbar("Open",'<STR_LIT>',,,Opening)<EOL>cv.CreateTrackbar("Close",'<STR_LIT>',,,Closing)<EOL>cv.CreateTrackbar("Dilate",'<STR_LIT>',,,Dilation)<EOL>cv.CreateTrackbar("Erode",'<STR_LIT>',,,Erosion)<EOL>cv.WaitKey()<EOL>cv.DestroyWindow('<STR_LIT>')<EOL>cv.DestroyWindow('<STR_LIT>')<EOL><DEDENT><EOF><BOF>__version__='0.2.0'<EOF><BOF>import cv2 <EOL>def webcam_gui(filter_func,video_src=):<EOL><INDENT>cap=cv2.VideoCapture(video_src)<EOL>key_code=-<EOL>while(key_code==-):<EOL><INDENT>ret,frame=cap.read()<EOL>frame_out=filter_func(frame)<EOL>cv2.imshow('<STR_LIT>',frame_out)<EOL>key_code=cv2.waitKey()<EOL><DEDENT>cap.release()<EOL>cv2.destroyAllWindows()<EOL><DEDENT>def edge_filter(frame_in):<EOL><INDENT>frame_gray=cv2.cvtColor(frame_in,cv2.COLOR_BGR2GRAY)<EOL>frame_blur=cv2.blur(frame_gray,(,))<EOL>frame_out=cv2.Canny(frame_blur,,)<EOL>return frame_out <EOL><DEDENT>def threshold(frame_in):<EOL><INDENT>frame_gray=cv2.cvtColor(frame_in,cv2.COLOR_BGR2GRAY)<EOL>frame_blur=cv2.blur(frame_gray,(,))<EOL>thresh1,thresh=cv2.threshold(frame_blur,,,cv2.THRESH_BINARY)<EOL>frame_out=thresh <EOL>return frame_out <EOL><DEDENT>def adap_threshold(frame_in):<EOL><INDENT>frame_gray=cv2.cvtColor(frame_in,cv2.COLOR_BGR2GRAY)<EOL>frame_blur=cv2.blur(frame_gray,(,))<EOL>thresh=cv2.adaptiveThreshold(frame_blur,,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,,)<EOL>frame_out=thresh <EOL>return frame_out <EOL><DEDENT>def gray_filter(frame_in):<EOL><INDENT>frame_out=cv2.cvtColor(frame_in,cv2.COLOR_BGR2GRAY)<EOL>return frame_out <EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>webcam_gui(adap_threshold)<EOL><DEDENT><EOF><BOF>import pygame <EOL>from pygame.locals import *<EOL>from py2d.Bezier import *<EOL>from py2d.Math import *<EOL>SELECTION_DISTANCE=<EOL>from examples import Example <EOL>class Cubic(Example):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,runner):<EOL><INDENT>self.runner=runner <EOL>self.title="Cubic Beziers"<EOL>self.p1=Vector(,)<EOL>self.p2=Vector(,)<EOL>self.c1=Vector(,)<EOL>self.c2=Vector(,)<EOL>self.points=(('P1',(,,),self.p1),('P2',(,,),self.p2),('C1',(,,),self.c1),('C2',(,,),self.c2))<EOL>self.sel_point=None <EOL><DEDENT>def update(self,time_elapsed):<EOL><INDENT>pass <EOL><DEDENT>def render(self):<EOL><INDENT>pygame.draw.line(self.runner.screen,,self.p1.as_tuple(),self.c1.as_tuple())<EOL>pygame.draw.line(self.runner.screen,,self.p2.as_tuple(),self.c2.as_tuple())<EOL>for label,color,pos in self.points :<EOL><INDENT>self.draw_point(pos,color,label)<EOL><DEDENT>bezier=[self.p1 ]+flatten_cubic_bezier(self.p1,self.p2,self.c1,self.c2)+[self.p2 ]<EOL>pygame.draw.lines(self.runner.screen,,False,[p.as_tuple()for p in bezier ],)<EOL>if self.sel_point :<EOL><INDENT>pygame.draw.ellipse(self.runner.screen,,pygame.Rect((self.sel_point.x -,self.sel_point.y -),(,)),)<EOL><DEDENT> <DEDENT>def draw_point(self,p,color,label=None):<EOL><INDENT>pygame.draw.ellipse(self.runner.screen,color,pygame.Rect(p.as_tuple(),(,)))<EOL>if label :<EOL><INDENT>self.runner.screen.blit(self.runner.font.render(label,False,color),p.as_tuple())<EOL><DEDENT> <DEDENT>def mouse_down(self,pos,button):<EOL><INDENT>if button==:<EOL><INDENT>mouse=Vector(*pos)<EOL>nearest=min(self.points,key=lambda p :(p []-mouse).length)<EOL>if(nearest []-mouse).length_squared <=SELECTION_DISTANCE :<EOL><INDENT>self.sel_point=nearest []<EOL><DEDENT>else :<EOL><INDENT>self.sel_point=None <EOL><DEDENT> <DEDENT> <DEDENT>def mouse_move(self,pos,rel,buttons):<EOL><INDENT>if buttons []and self.sel_point :<EOL><INDENT>self.sel_point.x,self.sel_point.y=pos <EOL><DEDENT> <DEDENT> <DEDENT>class Quadratic(Example):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,runner):<EOL><INDENT>self.runner=runner <EOL>self.title='<STR_LIT>'<EOL>self.p1=Vector(,)<EOL>self.p2=Vector(,)<EOL>self.c=Vector(,)<EOL>self.points=(('P1',(,,),self.p1),('P2',(,,),self.p2),('C',(,,),self.c))<EOL>self.sel_point=None <EOL><DEDENT>def update(self,time_elapsed):<EOL><INDENT>pass <EOL><DEDENT>def render(self):<EOL><INDENT>pygame.draw.line(self.runner.screen,,self.p1.as_tuple(),self.c.as_tuple())<EOL>pygame.draw.line(self.runner.screen,,self.p2.as_tuple(),self.c.as_tuple())<EOL>for label,color,pos in self.points :<EOL><INDENT>self.draw_point(pos,color,label)<EOL><DEDENT>bezier=[self.p1 ]+flatten_quadratic_bezier(self.p1,self.p2,self.c)+[self.p2 ]<EOL>pygame.draw.lines(self.runner.screen,,False,[p.as_tuple()for p in bezier ],)<EOL>if self.sel_point :<EOL><INDENT>pygame.draw.ellipse(self.runner.screen,,pygame.Rect((self.sel_point.x -,self.sel_point.y -),(,)),)<EOL><DEDENT> <DEDENT>def draw_point(self,p,color,label=None):<EOL><INDENT>pygame.draw.ellipse(self.runner.screen,color,pygame.Rect(p.as_tuple(),(,)))<EOL>if label :<EOL><INDENT>self.runner.screen.blit(self.runner.font.render(label,False,color),p.as_tuple())<EOL><DEDENT> <DEDENT>def mouse_down(self,pos,button):<EOL><INDENT>if button==:<EOL><INDENT>mouse=Vector(*pos)<EOL>nearest=min(self.points,key=lambda p :(p []-mouse).length)<EOL>if(nearest []-mouse).length_squared <=SELECTION_DISTANCE :<EOL><INDENT>self.sel_point=nearest []<EOL><DEDENT>else :<EOL><INDENT>self.sel_point=None <EOL><DEDENT> <DEDENT> <DEDENT>def mouse_move(self,pos,rel,buttons):<EOL><INDENT>if buttons []and self.sel_point :<EOL><INDENT>self.sel_point.x,self.sel_point.y=pos <EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>from zerotest.request import Request <EOL>req=Request(scheme="http",method="GET",params={"hello":"test"},host="example.com",path="/test",<EOL>headers={"Auth":"FOR_TEST"},data="ok")<EOL>def test_url():<EOL><INDENT>assert req.url=='<STR_LIT>'<EOL><DEDENT>def test_endpoint():<EOL><INDENT>assert req.endpoint=='<STR_LIT>'<EOL><DEDENT>def test_endpoint_setter():<EOL><INDENT>endpoint=req.endpoint <EOL>req.endpoint='<STR_LIT>'<EOL>assert req.endpoint=='<STR_LIT>'<EOL>assert req.host=='<STR_LIT>'<EOL>assert req.scheme=="https"<EOL>req.endpoint=endpoint <EOL><DEDENT>def test__str__():<EOL><INDENT>assert str(req)=='<STR_LIT>'<EOL><DEDENT><EOF><BOF>import re <EOL>from functools import partial <EOL>from.normalizing import normalize <EOL>def eq(str1,str2,ignore=(),caseless=True,spaceless=True):<EOL><INDENT>str1=normalize(str1,ignore,caseless,spaceless)<EOL>str2=normalize(str2,ignore,caseless,spaceless)<EOL>return str1==str2 <EOL><DEDENT>def matches(string,pattern,ignore=(),caseless=True,spaceless=True):<EOL><INDENT> '<STR_LIT>'<EOL>return Matcher(pattern,ignore,caseless,spaceless).match(string)<EOL><DEDENT>def matches_any(string,patterns,ignore=(),caseless=True,spaceless=True):<EOL><INDENT> '<STR_LIT>'<EOL>matcher=MultiMatcher(patterns,ignore,caseless,spaceless)<EOL>return matcher.match(string)<EOL><DEDENT>class Matcher(object):<EOL><INDENT>_pattern_tokenizer=re.compile('(\*|\?)')<EOL>_wildcards={'*':'.*','?':'.'}<EOL>def __init__(self,pattern,ignore=(),caseless=True,spaceless=True):<EOL><INDENT>self.pattern=pattern <EOL>self._normalize=partial(normalize,ignore=ignore,caseless=caseless,<EOL>spaceless=spaceless)<EOL>self._regexp=self._get_and_compile_regexp(self._normalize(pattern))<EOL><DEDENT>def _get_and_compile_regexp(self,pattern):<EOL><INDENT>pattern='^%s$'%''.join(self._yield_regexp(pattern))<EOL>return re.compile(pattern,re.DOTALL)<EOL><DEDENT>def _yield_regexp(self,pattern):<EOL><INDENT>for token in self._pattern_tokenizer.split(pattern):<EOL><INDENT>if token in self._wildcards :<EOL><INDENT>yield self._wildcards [token ]<EOL><DEDENT>else :<EOL><INDENT>yield re.escape(token)<EOL><DEDENT> <DEDENT> <DEDENT>def match(self,string):<EOL><INDENT>return self._regexp.match(self._normalize(string))is not None <EOL><DEDENT> <DEDENT>class MultiMatcher(object):<EOL><INDENT>def __init__(self,patterns=None,ignore=(),caseless=True,spaceless=True,<EOL>match_if_no_patterns=False):<EOL><INDENT>self._matchers=[Matcher(pattern,ignore,caseless,spaceless)<EOL>for pattern in self._ensure_list(patterns)]<EOL>self._match_if_no_patterns=match_if_no_patterns <EOL><DEDENT>def _ensure_list(self,patterns):<EOL><INDENT>if patterns is None :<EOL><INDENT>return []<EOL><DEDENT>if isinstance(patterns,basestring):<EOL><INDENT>return [patterns ]<EOL><DEDENT>return patterns <EOL><DEDENT>def match(self,string):<EOL><INDENT>if self._matchers :<EOL><INDENT>return any(m.match(string)for m in self._matchers)<EOL><DEDENT>return self._match_if_no_patterns <EOL><DEDENT>def __len__(self):<EOL><INDENT>return len(self._matchers)<EOL><DEDENT>def __iter__(self):<EOL><INDENT>for matcher in self._matchers :<EOL><INDENT>yield matcher.pattern <EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import pygit2 <EOL>import shutil <EOL>import itertools <EOL>from.exceptions import(<EOL>NotJsonError,InvalidKeyError,DifferentRepoError,StagedDataError)<EOL>from.wrappers import Commit,Diff,Conflict,Merge <EOL>import constants <EOL>import utils <EOL>class Repository(object):<EOL><INDENT>def __init__(self,repo,dumps,loads):<EOL><INDENT>self._repo=repo <EOL>self._global_name=utils.global_config('user.name')<EOL>self._global_email=utils.global_config('user.email')<EOL>self._dumps=dumps <EOL>self._loads=loads <EOL><DEDENT>def __eq__(self,other):<EOL><INDENT>return self._repo.path==other._repo.path <EOL><DEDENT>def _key2ref(self,key):<EOL><INDENT> '<STR_LIT>'<EOL>if not isinstance(key,basestring):<EOL><INDENT>raise InvalidKeyError('<STR_LIT>'%key)<EOL><DEDENT>elif key [-]=='.'or key [-]=='/'or key []=='/'or key []=='.':<EOL><INDENT>raise InvalidKeyError('<STR_LIT>'%key)<EOL><DEDENT>else :<EOL><INDENT>return '<STR_LIT>'%key <EOL><DEDENT> <DEDENT>def _navigate_tree(self,oid,path):<EOL><INDENT> '<STR_LIT>'<EOL>steps=path.split('/')<EOL>for step in steps :<EOL><INDENT>oid=self._repo [oid ][step ].oid <EOL><DEDENT>return oid <EOL><DEDENT>def _build_commit(self,pygit2_commit):<EOL><INDENT>key=pygit2_commit.tree [].name <EOL>raw=self._repo [pygit2_commit.tree [].oid ].data <EOL>value=self._loads(raw)<EOL>return Commit(self,key,value,pygit2_commit)<EOL><DEDENT>def _head_target(self):<EOL><INDENT>return self._repo.lookup_reference('HEAD').target <EOL><DEDENT>def _repo_head(self):<EOL><INDENT>try :<EOL><INDENT>return self._repo [self._repo.lookup_reference(self._head_target()).oid ]<EOL><DEDENT>except KeyError :<EOL><INDENT>return None <EOL><DEDENT> <DEDENT>def add(self,key,value):<EOL><INDENT> '<STR_LIT>'<EOL>self._key2ref(key)<EOL>try :<EOL><INDENT>blob_id=self._repo.write(pygit2.GIT_OBJ_BLOB,self._dumps(value))<EOL><DEDENT>except ValueError as e :<EOL><INDENT>raise NotJsonError(e)<EOL><DEDENT>except TypeError as e :<EOL><INDENT>raise NotJsonError(e)<EOL><DEDENT>if key in self._repo.index :<EOL><INDENT>del self._repo.index [key ]<EOL><DEDENT>working_tree_id=self._repo.index.write_tree()<EOL>working_tree=self._repo [working_tree_id ]<EOL>new_entry='<STR_LIT>'%(key,blob_id)<EOL>tree_data=working_tree.read_raw()+new_entry <EOL>working_tree_id=self._repo.write(pygit2.GIT_OBJ_TREE,tree_data)<EOL>self._repo.index.read_tree(working_tree_id)<EOL>self._repo.index.write()<EOL><DEDENT>def checkout(self,source,dest,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>message='<STR_LIT>'%(dest,source)<EOL>commit=self.head(source)<EOL>self.commit(dest,commit.data,message=message,parents=[commit ])<EOL><DEDENT>def commit(self,key=None,value=None,add=True,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>keys=[key ]if key is not None else [e.path for e in self._repo.index ]<EOL>message=kwargs.pop('message','')<EOL>parents=kwargs.pop('parents',None)<EOL>author=kwargs.pop('author',utils.signature(self._global_name,<EOL>self._global_email))<EOL>committer=kwargs.pop('committer',author)<EOL>if kwargs :<EOL><INDENT>raise TypeError('<STR_LIT>'%kwargs)<EOL><DEDENT>if key is None and value is not None :<EOL><INDENT>raise InvalidKeyError()<EOL><DEDENT>if parents is not None :<EOL><INDENT>for parent in parents :<EOL><INDENT>if parent.repo !=self :<EOL><INDENT>raise DifferentRepoError()<EOL><DEDENT> <DEDENT> <DEDENT>if add is True and key is not None and value is not None :<EOL><INDENT>self.add(key,value)<EOL><DEDENT>repo_head=self._repo_head()<EOL>tree_id=self._repo.index.write_tree()<EOL>self._repo.create_commit(self._head_target(),author,committer,<EOL>message,tree_id,<EOL>[repo_head.oid ]if repo_head else [])<EOL>for key in keys :<EOL><INDENT>if parents is None :<EOL><INDENT>parents=[self.head(key)]if self.committed(key)else []<EOL><DEDENT>try :<EOL><INDENT>blob_id=self._navigate_tree(tree_id,key)<EOL>key_tree_data='<STR_LIT>'%(key,blob_id)<EOL>key_tree_id=self._repo.write(pygit2.GIT_OBJ_TREE,key_tree_data)<EOL>self._repo.create_commit(self._key2ref(key),author,<EOL>committer,message,key_tree_id,<EOL>[parent.oid for parent in parents ])<EOL><DEDENT>except pygit2.GitError as e :<EOL><INDENT>if str(e).startswith('<STR_LIT>'):<EOL><INDENT>raise InvalidKeyError(e)<EOL><DEDENT>else :<EOL><INDENT>raise e <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>def committed(self,key):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>self._repo.lookup_reference(self._key2ref(key))<EOL>return True <EOL><DEDENT>except KeyError :<EOL><INDENT>return False <EOL><DEDENT> <DEDENT>def destroy(self):<EOL><INDENT> '<STR_LIT>'<EOL>shutil.rmtree(self._repo.path)<EOL>self._repo=None <EOL><DEDENT>def head(self,key,back=):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>return itertools.islice(self.log(key),back,back +).next()<EOL><DEDENT>except KeyError :<EOL><INDENT>raise KeyError('<STR_LIT>'%key)<EOL><DEDENT>except StopIteration :<EOL><INDENT>raise IndexError('<STR_LIT>'%(key,back))<EOL><DEDENT> <DEDENT>def index(self,key):<EOL><INDENT> '<STR_LIT>'<EOL>self._repo.index.read()<EOL>raw=self._repo [self._repo.index [key ].oid ].data <EOL>return self._loads(raw)<EOL><DEDENT>def merge(self,dest,key=None,commit=None,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>if commit is None :<EOL><INDENT>commit=self.head(key)<EOL><DEDENT>if commit.key==dest :<EOL><INDENT>raise ValueError('<STR_LIT>')<EOL><DEDENT>dest_head=self.head(dest)<EOL>if commit.oid==dest_head.oid :<EOL><INDENT>return Merge(True,commit,dest_head,"Same commit",result=commit)<EOL><DEDENT>try :<EOL><INDENT>shared_commit=(dc for dc in self.log(commit=dest_head)<EOL>if dc.oid in(sc.oid for sc in self.log(commit=commit))).next()<EOL><DEDENT>except StopIteration :<EOL><INDENT>return Merge(False,commit,dest_head,'<STR_LIT>')<EOL><DEDENT>source_diff=Diff(shared_commit.data,commit.data)<EOL>dest_diff=Diff(shared_commit.data,dest_head.data)<EOL>conflict=Conflict(source_diff,dest_diff)<EOL>if conflict :<EOL><INDENT>return Merge(False,commit,dest_head,"Merge conflict",<EOL>conflict=conflict)<EOL><DEDENT>else :<EOL><INDENT>merged_data=dest_diff.apply(source_diff.apply(shared_commit.data))<EOL>message='<STR_LIT>'%(<EOL>commit.hex [:],dest_head.hex [:],shared_commit.hex [:])<EOL>parents=[dest_head,commit ]<EOL>result=self.commit(dest,merged_data,message=message,parents=parents,**kwargs)<EOL>return Merge(True,commit,dest_head,message,result=result)<EOL><DEDENT> <DEDENT>def log(self,key=None,commit=None,order=constants.GIT_SORT_TOPOLOGICAL):<EOL><INDENT> '<STR_LIT>'<EOL>if key is None and commit is None :<EOL><INDENT>raise TypeError()<EOL><DEDENT>elif commit is None :<EOL><INDENT>c=self._repo [self._repo.lookup_reference(self._key2ref(key)).oid ]<EOL>commit=self._build_commit(c)<EOL><DEDENT>return(self._build_commit(c)for c in self._repo.walk(commit.oid,order))<EOL><DEDENT>def remove(self,key,force=False):<EOL><INDENT> '<STR_LIT>'<EOL>if force is True or self.staged(key)is False :<EOL><INDENT>del self._repo.index [key ]<EOL><DEDENT>elif force is False and self.staged(key):<EOL><INDENT>raise StagedDataError('<STR_LIT>'%key)<EOL><DEDENT>self._repo.lookup_reference(self._key2ref(key)).delete()<EOL><DEDENT>def reset(self,key):<EOL><INDENT> '<STR_LIT>'<EOL>self.add(key,self.head(key).data)<EOL><DEDENT>def show(self,key,back=):<EOL><INDENT> '<STR_LIT>'<EOL>return self.head(key,back=back).data <EOL><DEDENT>def staged(self,key):<EOL><INDENT> '<STR_LIT>'<EOL>if key in self._repo.index :<EOL><INDENT>if self.committed(key):<EOL><INDENT>return self.index(key)!=self.show(key)<EOL><DEDENT>else :<EOL><INDENT>return True <EOL><DEDENT> <DEDENT>else :<EOL><INDENT>return False <EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import functools <EOL>import py2d.Math <EOL>class Vision :<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,obstructors,debug=False):<EOL><INDENT> '<STR_LIT>'<EOL>self.set_obstructors(obstructors)<EOL>self.debug=debug <EOL>self.debug_points=[]<EOL>self.debug_linesegs=[]<EOL><DEDENT>def set_obstructors(self,obstructors):<EOL><INDENT> '<STR_LIT>'<EOL>def flatten_list(l):<EOL><INDENT>return functools.reduce(lambda x,y :x +y,l)<EOL><DEDENT>self.obs_points=flatten_list(obstructors)<EOL>self.obs_segs=flatten_list([list(zip(strip,strip [:]))for strip in obstructors ])<EOL>self.cached_vision=None <EOL>self.cached_position=None <EOL>self.cached_radius=None <EOL><DEDENT>def get_vision(self,eye,radius,boundary):<EOL><INDENT> '<STR_LIT>'<EOL>if self.cached_vision==None or(self.cached_position -eye).get_length_squared()>:<EOL><INDENT>self.calculate(eye,radius,boundary)<EOL><DEDENT>return self.cached_vision <EOL><DEDENT>def calculate(self,eye,radius,boundary):<EOL><INDENT> '<STR_LIT>'<EOL>self.cached_radius=radius <EOL>self.cached_position=eye <EOL>self.debug_points=[]<EOL>self.debug_linesegs=[]<EOL>radius_squared=radius *radius <EOL>closest_points=lambda points,reference :sorted(points,key=lambda p :(p -reference).get_length_squared())<EOL>def sub_segment(small,big):<EOL><INDENT>return py2d.Math.distance_point_lineseg_squared(small [],big [],big [])<and py2d.Math.distance_point_lineseg_squared(small [],big [],big [])<<EOL><DEDENT>def segment_in_obs(seg):<EOL><INDENT>for line_segment in self.obs_segs :<EOL><INDENT>if sub_segment(seg,line_segment):<EOL><INDENT>return True <EOL><DEDENT> <DEDENT>return False <EOL><DEDENT>def check_visibility(p):<EOL><INDENT>bpoints=set(boundary.points)<EOL>if p not in bpoints :<EOL><INDENT>if(eye -p).get_length_squared()>radius_squared :return False <EOL>if not boundary.contains_point(p):return False <EOL><DEDENT>for line_segment in obs_segs :<EOL><INDENT>if py2d.Math.check_intersect_lineseg_lineseg(eye,p,line_segment [],line_segment []):<EOL><INDENT>if line_segment []!=p and line_segment []!=p :<EOL><INDENT>return False <EOL><DEDENT> <DEDENT> <DEDENT>return True <EOL><DEDENT>def lineseg_in_radius(seg):<EOL><INDENT>return py2d.Math.distance_point_lineseg_squared(eye,seg [],seg [])<=radius_squared <EOL><DEDENT>obs_segs=filter(lineseg_in_radius,self.obs_segs)<EOL>visible_points=list(filter(check_visibility,set(self.obs_points +boundary.points)))<EOL>boundary_intersection_points=py2d.Math.intersect_linesegs_linesegs(obs_segs,list(zip(boundary.points,boundary.points [:]))+[(boundary.points [-],boundary.points [])])<EOL>if self.debug :self.debug_points.extend([(p,)for p in visible_points ])<EOL>if self.debug :self.debug_points.extend([(p,)for p in boundary_intersection_points ])<EOL>for line_segment in obs_segs :<EOL><INDENT>i=<EOL>while i <len(boundary_intersection_points):<EOL><INDENT>p=boundary_intersection_points [i ]<EOL>if py2d.Math.distance_point_lineseg_squared(p,line_segment [],line_segment [])>and py2d.Math.check_intersect_lineseg_lineseg(eye,p,line_segment [],line_segment []):<EOL><INDENT>boundary_intersection_points.remove(p)<EOL><DEDENT>else :<EOL><INDENT>i +=<EOL><DEDENT> <DEDENT> <DEDENT>visible_points +=boundary_intersection_points <EOL>poly=py2d.Math.Polygon()<EOL>poly.add_points(visible_points)<EOL>poly.sort_around(eye)<EOL>i=<EOL>while i <len(poly.points):<EOL><INDENT>p=poly.points [i -]<EOL>c=poly.points [i ]<EOL>n=poly.points [(i +)%len(poly.points)]<EOL>intersections=set(py2d.Math.intersect_linesegs_ray(obs_segs,eye,c)+py2d.Math.intersect_poly_ray(boundary.points,eye,c))<EOL>intersections=[ip for ip in intersections if ip !=c and boundary.contains_point(ip)]<EOL>if self.debug :self.debug_points.extend([(pt,)for pt in intersections ])<EOL>if intersections :<EOL><INDENT>intersection=min(intersections,key=lambda p :(p -eye).length_squared)<EOL>sio_pc=segment_in_obs((p,c))<EOL>sio_cn=segment_in_obs((c,n))<EOL>if not sio_pc :<EOL><INDENT>poly.points.insert(i,intersection)<EOL>i +=<EOL>if segment_in_obs((poly.points [i -],poly.points [i -])):<EOL><INDENT>poly.points.remove(poly.points [i -])<EOL>i -=<EOL><DEDENT> <DEDENT>elif sio_pc and not sio_cn :<EOL><INDENT>poly.points.insert(i +,intersection)<EOL>i +=<EOL><DEDENT> <DEDENT>i +=<EOL><DEDENT>if segment_in_obs((poly.points [-],poly.points [])):<EOL><INDENT>poly.points [],poly.points []=poly.points [],poly.points []<EOL><DEDENT>self.cached_vision=poly <EOL>return poly <EOL><DEDENT> <DEDENT><EOF><BOF>import os <EOL>import json <EOL>import webbrowser <EOL>import urllib <EOL>keywords={}<EOL>class WebKeyword :<EOL><INDENT>def __init__(self,name,url,library_name,args,doc):<EOL><INDENT>self.name=library_name +'.'+name <EOL>self.url=url <EOL>self.description=[args,doc,url ]<EOL><DEDENT>def show_definition(self,view,views_to_center):<EOL><INDENT>webbrowser.open(self.url)<EOL><DEDENT>def allow_unprompted_go_to(self):<EOL><INDENT>return False <EOL><DEDENT> <DEDENT>def load(plugin_dir):<EOL><INDENT>keywords.clear()<EOL>scan_dir=os.path.join(plugin_dir,'stdlib_keywords')<EOL>for root,dirs,files in os.walk(scan_dir):<EOL><INDENT>for file_path in filter(lambda f :f.endswith('.json'),files):<EOL><INDENT>library_name=file_path [:-]<EOL>file_path=os.path.join(root,file_path)<EOL>with open(file_path,'rb')as f :<EOL><INDENT>json_dict=json.load(f)<EOL>url=json_dict ['url']<EOL>for keyword in json_dict ['keywords']:<EOL><INDENT>name=keyword ['name']<EOL>args=keyword ['args']<EOL>doc=keyword ['shortdoc']<EOL>lower_name=name.lower()<EOL>web_keyword=WebKeyword(name,url +'#'+urllib.quote(name),library_name,args,doc)<EOL>if not keywords.has_key(lower_name):<EOL><INDENT>keywords [lower_name ]=[]<EOL><DEDENT>keywords [lower_name ].append(web_keyword)<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>def search_keywords(name):<EOL><INDENT>lower_name=name.lower()<EOL>if not keywords.has_key(lower_name):<EOL><INDENT>return []<EOL><DEDENT>return keywords [lower_name ]<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>from collections import namedtuple <EOL>import video <EOL>import common <EOL>FLANN_INDEX_KDTREE=<EOL>FLANN_INDEX_LSH=<EOL>flann_params=dict(algorithm=FLANN_INDEX_LSH,<EOL>table_number=,<EOL>key_size=,<EOL>multi_probe_level=)<EOL>MIN_MATCH_COUNT=<EOL>'<STR_LIT>'<EOL>PlanarTarget=namedtuple('PlaneTarget','<STR_LIT>')<EOL>'<STR_LIT>'<EOL>TrackedTarget=namedtuple('TrackedTarget','<STR_LIT>')<EOL>class PlaneTracker :<EOL><INDENT>def __init__(self):<EOL><INDENT>self.detector=cv2.ORB(nfeatures=)<EOL>self.matcher=cv2.FlannBasedMatcher(flann_params,{})<EOL>self.targets=[]<EOL><DEDENT>def add_target(self,image,rect,data=None):<EOL><INDENT> '<STR_LIT>'<EOL>x0,y0,x1,y1=rect <EOL>raw_points,raw_descrs=self.detect_features(image)<EOL>points,descs=[],[]<EOL>for kp,desc in zip(raw_points,raw_descrs):<EOL><INDENT>x,y=kp.pt <EOL>if x0 <=x <=x1 and y0 <=y <=y1 :<EOL><INDENT>points.append(kp)<EOL>descs.append(desc)<EOL><DEDENT> <DEDENT>descs=np.uint8(descs)<EOL>self.matcher.add([descs ])<EOL>target=PlanarTarget(image=image,rect=rect,keypoints=points,descrs=descs,data=None)<EOL>self.targets.append(target)<EOL><DEDENT>def clear(self):<EOL><INDENT> '<STR_LIT>'<EOL>self.targets=[]<EOL>self.matcher.clear()<EOL><DEDENT>def track(self,frame):<EOL><INDENT> '<STR_LIT>'<EOL>self.frame_points,self.frame_descrs=self.detect_features(frame)<EOL>if len(self.frame_points)<MIN_MATCH_COUNT :<EOL><INDENT>return []<EOL><DEDENT>matches=self.matcher.knnMatch(self.frame_descrs,k=)<EOL>matches=[m []for m in matches if len(m)==and m [].distance <m [].distance *]<EOL>if len(matches)<MIN_MATCH_COUNT :<EOL><INDENT>return []<EOL><DEDENT>matches_by_id=[[]for _ in xrange(len(self.targets))]<EOL>for m in matches :<EOL><INDENT>matches_by_id [m.imgIdx ].append(m)<EOL><DEDENT>tracked=[]<EOL>for imgIdx,matches in enumerate(matches_by_id):<EOL><INDENT>if len(matches)<MIN_MATCH_COUNT :<EOL><INDENT>continue <EOL><DEDENT>target=self.targets [imgIdx ]<EOL>p0=[target.keypoints [m.trainIdx ].pt for m in matches ]<EOL>p1=[self.frame_points [m.queryIdx ].pt for m in matches ]<EOL>p0,p1=np.float32((p0,p1))<EOL>H,status=cv2.findHomography(p0,p1,cv2.RANSAC,)<EOL>status=status.ravel()!=<EOL>if status.sum()<MIN_MATCH_COUNT :<EOL><INDENT>continue <EOL><DEDENT>p0,p1=p0 [status ],p1 [status ]<EOL>x0,y0,x1,y1=target.rect <EOL>quad=np.float32([[x0,y0 ],[x1,y0 ],[x1,y1 ],[x0,y1 ]])<EOL>quad=cv2.perspectiveTransform(quad.reshape(,-,),H).reshape(-,)<EOL>track=TrackedTarget(target=target,p0=p0,p1=p1,H=H,quad=quad)<EOL>tracked.append(track)<EOL><DEDENT>tracked.sort(key=lambda t :len(t.p0),reverse=True)<EOL>return tracked <EOL><DEDENT>def detect_features(self,frame):<EOL><INDENT> '<STR_LIT>'<EOL>keypoints,descrs=self.detector.detectAndCompute(frame,None)<EOL>if descrs is None :<EOL><INDENT>descrs=[]<EOL><DEDENT>return keypoints,descrs <EOL><DEDENT> <DEDENT>class App :<EOL><INDENT>def __init__(self,src):<EOL><INDENT>self.cap=video.create_capture(src)<EOL>self.frame=None <EOL>self.paused=False <EOL>self.tracker=PlaneTracker()<EOL>cv2.namedWindow('plane')<EOL>self.rect_sel=common.RectSelector('plane',self.on_rect)<EOL><DEDENT>def on_rect(self,rect):<EOL><INDENT>self.tracker.add_target(self.frame,rect)<EOL><DEDENT>def run(self):<EOL><INDENT>while True :<EOL><INDENT>playing=not self.paused and not self.rect_sel.dragging <EOL>if playing or self.frame is None :<EOL><INDENT>ret,frame=self.cap.read()<EOL>if not ret :<EOL><INDENT>break <EOL><DEDENT>self.frame=frame.copy()<EOL><DEDENT>vis=self.frame.copy()<EOL>if playing :<EOL><INDENT>tracked=self.tracker.track(self.frame)<EOL>for tr in tracked :<EOL><INDENT>cv2.polylines(vis,[np.int32(tr.quad)],True,(,,),)<EOL>for(x,y)in np.int32(tr.p1):<EOL><INDENT>cv2.circle(vis,(x,y),,(,,))<EOL><DEDENT> <DEDENT> <DEDENT>self.rect_sel.draw(vis)<EOL>cv2.imshow('plane',vis)<EOL>ch=cv2.waitKey()<EOL>if ch==ord(' '):<EOL><INDENT>self.paused=not self.paused <EOL><DEDENT>if ch==ord('c'):<EOL><INDENT>self.tracker.clear()<EOL><DEDENT>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>import sys <EOL>try :<EOL><INDENT>video_src=sys.argv []<EOL><DEDENT>except :<EOL><INDENT>video_src=<EOL><DEDENT>App(video_src).run()<EOL><DEDENT><EOF><BOF>from robot import utils <EOL>from.logger import LOGGER <EOL>from.loggerhelper import IsLogged <EOL>def DebugFile(path):<EOL><INDENT>if path=='NONE':<EOL><INDENT>LOGGER.info('No debug file')<EOL>return None <EOL><DEDENT>try :<EOL><INDENT>outfile=open(path,'w')<EOL><DEDENT>except EnvironmentError,err :<EOL><INDENT>LOGGER.error('<STR_LIT>'%(path,err.strerror))<EOL>return None <EOL><DEDENT>else :<EOL><INDENT>LOGGER.info('Debug file: %s'%path)<EOL>return _DebugFileWriter(outfile)<EOL><DEDENT> <DEDENT>class _DebugFileWriter :<EOL><INDENT>_separators={'SUITE':'=','TEST':'-','KW':'~'}<EOL>_setup_or_teardown=('setup','teardown')<EOL>def __init__(self,outfile):<EOL><INDENT>self._indent=<EOL>self._kw_level=<EOL>self._separator_written_last=False <EOL>self._outfile=outfile <EOL>self._is_logged=IsLogged('DEBUG')<EOL><DEDENT>def start_suite(self,suite):<EOL><INDENT>self._separator('SUITE')<EOL>self._start('SUITE',suite.longname)<EOL>self._separator('SUITE')<EOL><DEDENT>def end_suite(self,suite):<EOL><INDENT>self._separator('SUITE')<EOL>self._end('SUITE',suite.longname,suite.elapsedtime)<EOL>self._separator('SUITE')<EOL>if self._indent==:<EOL><INDENT>LOGGER.output_file('Debug',self._outfile.name)<EOL>self.close()<EOL><DEDENT> <DEDENT>def start_test(self,test):<EOL><INDENT>self._separator('TEST')<EOL>self._start('TEST',test.name)<EOL>self._separator('TEST')<EOL><DEDENT>def end_test(self,test):<EOL><INDENT>self._separator('TEST')<EOL>self._end('TEST',test.name,test.elapsedtime)<EOL>self._separator('TEST')<EOL><DEDENT>def start_keyword(self,kw):<EOL><INDENT>if self._kw_level==:<EOL><INDENT>self._separator('KW')<EOL><DEDENT>self._start(self._get_kw_type(kw),kw.name,kw.args)<EOL>self._kw_level +=<EOL><DEDENT>def end_keyword(self,kw):<EOL><INDENT>self._end(self._get_kw_type(kw),kw.name,kw.elapsedtime)<EOL>self._kw_level -=<EOL><DEDENT>def log_message(self,msg):<EOL><INDENT>if self._is_logged(msg.level):<EOL><INDENT>self._write(msg.message)<EOL><DEDENT> <DEDENT>def close(self):<EOL><INDENT>if not self._outfile.closed :<EOL><INDENT>self._outfile.close()<EOL><DEDENT> <DEDENT>def _get_kw_type(self,kw):<EOL><INDENT>if kw.type in self._setup_or_teardown :<EOL><INDENT>return kw.type.upper()<EOL><DEDENT>return 'KW'<EOL><DEDENT>def _start(self,type_,name,args=''):<EOL><INDENT>args=' '+utils.seq2str2(args)<EOL>self._write('<STR_LIT>'%('-'*self._indent,type_,name,args))<EOL>self._indent +=<EOL><DEDENT>def _end(self,type_,name,elapsed):<EOL><INDENT>self._indent -=<EOL>self._write('<STR_LIT>'%('-'*self._indent,type_,name,elapsed))<EOL><DEDENT>def _separator(self,type_):<EOL><INDENT>self._write(self._separators [type_ ]*,separator=True)<EOL><DEDENT>def _write(self,text,separator=False):<EOL><INDENT>if not(separator and self._separator_written_last):<EOL><INDENT>self._outfile.write(text.encode('UTF-8').rstrip()+'\n')<EOL>self._outfile.flush()<EOL>self._separator_written_last=separator <EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>import cv2.cv as cv <EOL>cap=cv.CreateFileCapture("../c/tree.avi")<EOL>img=cv.QueryFrame(cap)<EOL>print '<STR_LIT>',img.width," x ",img.height,")"<EOL>cv.NamedWindow("win",cv.CV_WINDOW_AUTOSIZE)<EOL>cv.ShowImage("win",img)<EOL>cv.MoveWindow("win",,)<EOL>cv.WaitKey()<EOL>cv.DestroyAllWindows()<EOF><BOF>'<STR_LIT>'<EOL>def get_char_width(char):<EOL><INDENT>char=ord(char)<EOL>if _char_in_map(char,_COMBINING_CHARS):<EOL><INDENT>return <EOL><DEDENT>if _char_in_map(char,_EAST_ASIAN_WILD_CHARS):<EOL><INDENT>return <EOL><DEDENT>return <EOL><DEDENT>def _char_in_map(char,map):<EOL><INDENT>for begin,end in map :<EOL><INDENT>if char <begin :<EOL><INDENT>break <EOL><DEDENT>if begin <=char <=end :<EOL><INDENT>return True <EOL><DEDENT> <DEDENT>return False <EOL><DEDENT>_COMBINING_CHARS=[(,)]<EOL>_EAST_ASIAN_WILD_CHARS=[(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),<EOL>]<EOF><BOF>'<STR_LIT>'<EOL>import os <EOL>import tempfile <EOL>from robot import utils <EOL>from robot.output import LOGGER <EOL>from.isvar import is_var,is_scalar_var,is_list_var <EOL>from.variables import Variables <EOL>from.variableassigner import VariableAssigner <EOL>from.variablesplitter import VariableSplitter <EOL>GLOBAL_VARIABLES=Variables()<EOL>def init_global_variables(settings):<EOL><INDENT>GLOBAL_VARIABLES.clear()<EOL>_set_cli_vars(settings)<EOL>for name,value in [('${TEMPDIR}',utils.abspath(tempfile.gettempdir())),('${EXECDIR}',utils.abspath('.')),('${/}',os.sep),('${:}',os.pathsep),('${\\n}',os.linesep),('${SPACE}',' '),('${EMPTY}',''),('@{EMPTY}',()),('${True}',True),('${False}',False),('${None}',None),('${null}',None),('${OUTPUT_DIR}',settings ['OutputDir']),('${OUTPUT_FILE}',settings ['Output']),('${REPORT_FILE}',settings ['Report']),('${LOG_FILE}',settings ['Log']),('${DEBUG_FILE}',settings ['DebugFile']),('<STR_LIT>',''),('<STR_LIT>',''),('<STR_LIT>','')]:<EOL><INDENT>GLOBAL_VARIABLES [name ]=value <EOL><DEDENT> <DEDENT>def _set_cli_vars(settings):<EOL><INDENT>for path,args in settings ['VariableFiles']:<EOL><INDENT>try :<EOL><INDENT>GLOBAL_VARIABLES.set_from_file(path,args)<EOL><DEDENT>except :<EOL><INDENT>msg,details=utils.get_error_details()<EOL>LOGGER.error(msg)<EOL>LOGGER.info(details)<EOL><DEDENT> <DEDENT>for varstr in settings ['Variables']:<EOL><INDENT>try :<EOL><INDENT>name,value=varstr.split(':',)<EOL><DEDENT>except ValueError :<EOL><INDENT>name,value=varstr,''<EOL><DEDENT>GLOBAL_VARIABLES ['${%s}'%name ]=value <EOL><DEDENT> <DEDENT><EOF><BOF>from robot.errors import DataError <EOL>from robot.variables import GLOBAL_VARIABLES <EOL>class ExecutionContexts(object):<EOL><INDENT>def __init__(self):<EOL><INDENT>self._contexts=[]<EOL><DEDENT>@property <EOL>def current(self):<EOL><INDENT>return self._contexts [-]if self._contexts else None <EOL><DEDENT>def __iter__(self):<EOL><INDENT>return iter(self._contexts)<EOL><DEDENT>@property <EOL>def namespaces(self):<EOL><INDENT>return(context.namespace for context in self)<EOL><DEDENT>def start_suite(self,namespace,output,dry_run=False):<EOL><INDENT>self._contexts.append(_ExecutionContext(namespace,output,dry_run))<EOL>return self.current <EOL><DEDENT>def end_suite(self):<EOL><INDENT>self._contexts.pop()<EOL><DEDENT> <DEDENT>EXECUTION_CONTEXTS=ExecutionContexts()<EOL>class _ExecutionContext(object):<EOL><INDENT>_started_keywords_threshold=<EOL>def __init__(self,namespace,output,dry_run=False):<EOL><INDENT>self.namespace=namespace <EOL>self.output=output <EOL>self.dry_run=dry_run <EOL>self._in_teardown=<EOL>self._started_keywords=<EOL><DEDENT>@property <EOL>def teardown(self):<EOL><INDENT>if self._in_teardown :<EOL><INDENT>return True <EOL><DEDENT>test_or_suite=self.namespace.test or self.namespace.suite <EOL>return test_or_suite.status !='RUNNING'<EOL><DEDENT>def start_keyword_teardown(self,error):<EOL><INDENT>self.namespace.variables ['<STR_LIT>']='FAIL'if error else 'PASS'<EOL>self.namespace.variables ['<STR_LIT>']=unicode(error or '')<EOL>self._in_teardown +=<EOL><DEDENT>def end_keyword_teardown(self):<EOL><INDENT>self._in_teardown -=<EOL><DEDENT>def get_current_vars(self):<EOL><INDENT>return self.namespace.variables <EOL><DEDENT>def end_test(self,test):<EOL><INDENT>self.output.end_test(test)<EOL>self.namespace.end_test()<EOL><DEDENT>def end_suite(self,suite):<EOL><INDENT>self.output.end_suite(suite)<EOL>self.namespace.end_suite()<EOL>EXECUTION_CONTEXTS.end_suite()<EOL><DEDENT>def output_file_changed(self,filename):<EOL><INDENT>self._set_global_variable('${OUTPUT_FILE}',filename)<EOL><DEDENT>def replace_vars_from_setting(self,name,value,errors):<EOL><INDENT>return self.namespace.variables.replace_meta(name,value,errors)<EOL><DEDENT>def log_file_changed(self,filename):<EOL><INDENT>self._set_global_variable('${LOG_FILE}',filename)<EOL><DEDENT>def set_prev_test_variables(self,test):<EOL><INDENT>self._set_prev_test_variables(self.get_current_vars(),test.name,<EOL>test.status,test.message)<EOL><DEDENT>def copy_prev_test_vars_to_global(self):<EOL><INDENT>varz=self.get_current_vars()<EOL>name,status,message=varz ['<STR_LIT>'],varz ['<STR_LIT>'],varz ['<STR_LIT>']<EOL>self._set_prev_test_variables(GLOBAL_VARIABLES,name,status,message)<EOL><DEDENT>def _set_prev_test_variables(self,destination,name,status,message):<EOL><INDENT>destination ['<STR_LIT>']=name <EOL>destination ['<STR_LIT>']=status <EOL>destination ['<STR_LIT>']=message <EOL><DEDENT>def _set_global_variable(self,name,value):<EOL><INDENT>self.namespace.variables.set_global(name,value)<EOL><DEDENT>def report_suite_status(self,status,message):<EOL><INDENT>self.get_current_vars()['${SUITE_STATUS}']=status <EOL>self.get_current_vars()['<STR_LIT>']=message <EOL><DEDENT>def start_test(self,test):<EOL><INDENT>self.namespace.start_test(test)<EOL>self.output.start_test(test)<EOL><DEDENT>def set_test_status_before_teardown(self,message,status):<EOL><INDENT>self.namespace.set_test_status_before_teardown(message,status)<EOL><DEDENT>def get_handler(self,name):<EOL><INDENT>return self.namespace.get_handler(name)<EOL><DEDENT>def start_keyword(self,keyword):<EOL><INDENT>self._started_keywords +=<EOL>if self._started_keywords >self._started_keywords_threshold :<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>self.output.start_keyword(keyword)<EOL><DEDENT>def end_keyword(self,keyword):<EOL><INDENT>self.output.end_keyword(keyword)<EOL>self._started_keywords -=<EOL><DEDENT>def start_user_keyword(self,kw):<EOL><INDENT>self.namespace.start_user_keyword(kw)<EOL><DEDENT>def end_user_keyword(self):<EOL><INDENT>self.namespace.end_user_keyword()<EOL><DEDENT>def warn(self,message):<EOL><INDENT>self.output.warn(message)<EOL><DEDENT>def trace(self,message):<EOL><INDENT>self.output.trace(message)<EOL><DEDENT> <DEDENT><EOF><BOF>from __future__ import unicode_literals <EOL>from django.db import migrations,models <EOL>class Migration(migrations.Migration):<EOL><INDENT>dependencies=[('buildservice','<STR_LIT>'),<EOL>]<EOL>operations=[<EOL>migrations.AddField(<EOL>model_name='build',<EOL>name='number',<EOL>field=models.IntegerField(default=),),<EOL>migrations.AddField(<EOL>model_name='repository',<EOL>name='build_count',<EOL>field=models.IntegerField(default=),),<EOL>]<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import itertools as it <EOL>from common import draw_str <EOL>w,h=,<EOL>def toint(p):<EOL><INDENT>return tuple(map(int,p))<EOL><DEDENT>def sample_line(p1,p2,n,noise=):<EOL><INDENT>p1=np.float32(p1)<EOL>t=np.random.rand(n,)<EOL>return p1 +(p2 -p1)*t +np.random.normal(size=(n,))*noise <EOL><DEDENT>dist_func_names=it.cycle('<STR_LIT>'.split())<EOL>cur_func_name=dist_func_names.next()<EOL>def update(_=None):<EOL><INDENT>noise=cv2.getTrackbarPos('noise','fit line')<EOL>n=cv2.getTrackbarPos('point n','fit line')<EOL>r=cv2.getTrackbarPos('outlier %','fit line')/<EOL>outn=int(n *r)<EOL>p0,p1=(,),(w -,h -)<EOL>img=np.zeros((h,w,),np.uint8)<EOL>cv2.line(img,toint(p0),toint(p1),(,,))<EOL>if n >:<EOL><INDENT>line_points=sample_line(p0,p1,n -outn,noise)<EOL>outliers=np.random.rand(outn,)*(w,h)<EOL>points=np.vstack([line_points,outliers ])<EOL>for p in line_points :<EOL><INDENT>cv2.circle(img,toint(p),,(,,),-)<EOL><DEDENT>for p in outliers :<EOL><INDENT>cv2.circle(img,toint(p),,(,,),-)<EOL><DEDENT>func=getattr(cv2,cur_func_name)<EOL>vx,vy,cx,cy=cv2.fitLine(np.float32(points),func,,,)<EOL>cv2.line(img,(int(cx -vx *w),int(cy -vy *w)),(int(cx +vx *w),int(cy +vy *w)),(,,))<EOL><DEDENT>draw_str(img,(,),cur_func_name)<EOL>cv2.imshow('fit line',img)<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>cv2.namedWindow('fit line')<EOL>cv2.createTrackbar('noise','fit line',,,update)<EOL>cv2.createTrackbar('point n','fit line',,,update)<EOL>cv2.createTrackbar('outlier %','fit line',,,update)<EOL>while True :<EOL><INDENT>update()<EOL>ch=cv2.waitKey()<EOL>if ch==ord('f'):<EOL><INDENT>cur_func_name=dist_func_names.next()<EOL><DEDENT>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>import numpy as np <EOL>import cv2 <EOL>import os <EOL>import sys <EOL>import video <EOL>from common import mosaic <EOL>from digits import *<EOL>def main():<EOL><INDENT>try :src=sys.argv []<EOL>except :src=<EOL>cap=video.create_capture(src)<EOL>classifier_fn='digits_svm.dat'<EOL>if not os.path.exists(classifier_fn):<EOL><INDENT>print '<STR_LIT>'%classifier_fn <EOL>return <EOL><DEDENT>model=SVM()<EOL>model.load(classifier_fn)<EOL>while True :<EOL><INDENT>ret,frame=cap.read()<EOL>gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)<EOL>bin=cv2.adaptiveThreshold(gray,,cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY_INV,,)<EOL>bin=cv2.medianBlur(bin,)<EOL>contours,heirs=cv2.findContours(bin.copy(),cv2.RETR_CCOMP,cv2.CHAIN_APPROX_SIMPLE)<EOL>try :heirs=heirs []<EOL>except :heirs=[]<EOL>for cnt,heir in zip(contours,heirs):<EOL><INDENT>_,_,_,outer_i=heir <EOL>if outer_i >=:<EOL><INDENT>continue <EOL><DEDENT>x,y,w,h=cv2.boundingRect(cnt)<EOL>if not(<=h <=and w <=*h):<EOL><INDENT>continue <EOL><DEDENT>pad=max(h -w,)<EOL>x,w=x -pad /,w +pad <EOL>cv2.rectangle(frame,(x,y),(x +w,y +h),(,,))<EOL>bin_roi=bin [y :,x :][:h,:w ]<EOL>gray_roi=gray [y :,x :][:h,:w ]<EOL>m=bin_roi !=<EOL>if not <m.mean()<:<EOL><INDENT>continue <EOL><DEDENT> '<STR_LIT>'<EOL>s=*float(h)/SZ <EOL>m=cv2.moments(bin_roi)<EOL>c1=np.float32([m ['m10'],m ['m01']])/m ['m00']<EOL>c0=np.float32([SZ /,SZ /])<EOL>t=c1 -s *c0 <EOL>A=np.zeros((,),np.float32)<EOL>A [:,:]=np.eye()*s <EOL>A [:,]=t <EOL>bin_norm=cv2.warpAffine(bin_roi,A,(SZ,SZ),flags=cv2.WARP_INVERSE_MAP |cv2.INTER_LINEAR)<EOL>bin_norm=deskew(bin_norm)<EOL>if x +w +SZ <frame.shape []and y +SZ <frame.shape []:<EOL><INDENT>frame [y :,x +w :][:SZ,:SZ ]=bin_norm [...,np.newaxis ]<EOL><DEDENT>sample=preprocess_hog([bin_norm ])<EOL>digit=model.predict(sample)[]<EOL>cv2.putText(frame,'%d'%digit,(x,y),cv2.FONT_HERSHEY_PLAIN,,(,,),thickness=)<EOL><DEDENT>cv2.imshow('frame',frame)<EOL>cv2.imshow('bin',bin)<EOL>ch=cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>main()<EOL><DEDENT><EOF><BOF>import webb <EOL>webb.download_google_images("Flowers")<EOF><BOF>from __future__ import unicode_literals <EOL>from django.conf import settings <EOL>from django.db import migrations,models <EOL>class Migration(migrations.Migration):<EOL><INDENT>dependencies=[<EOL>migrations.swappable_dependency(settings.AUTH_USER_MODEL),('buildservice','<STR_LIT>'),<EOL>]<EOL>operations=[<EOL>migrations.RemoveField(<EOL>model_name='webhook',<EOL>name='user',),<EOL>migrations.AddField(<EOL>model_name='repository',<EOL>name='users',<EOL>field=models.ManyToManyField(related_name='repositories',related_query_name=b'repository',to=settings.AUTH_USER_MODEL),),<EOL>]<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import cv2 <EOL>import numpy as np <EOL>bins=np.arange().reshape(,)<EOL>def hist_curve(im):<EOL><INDENT>h=np.zeros((,,))<EOL>if len(im.shape)==:<EOL><INDENT>color=[(,,)]<EOL><DEDENT>elif im.shape []==:<EOL><INDENT>color=[(,,),(,,),(,,)]<EOL><DEDENT>for ch,col in enumerate(color):<EOL><INDENT>hist_item=cv2.calcHist([im ],[ch ],None,[],[,])<EOL>cv2.normalize(hist_item,hist_item,,,cv2.NORM_MINMAX)<EOL>hist=np.int32(np.around(hist_item))<EOL>pts=np.int32(np.column_stack((bins,hist)))<EOL>cv2.polylines(h,[pts ],False,col)<EOL><DEDENT>y=np.flipud(h)<EOL>return y <EOL><DEDENT>def hist_lines(im):<EOL><INDENT>h=np.zeros((,,))<EOL>if len(im.shape)!=:<EOL><INDENT>print '<STR_LIT>'<EOL>im=cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)<EOL><DEDENT>hist_item=cv2.calcHist([im ],[],None,[],[,])<EOL>cv2.normalize(hist_item,hist_item,,,cv2.NORM_MINMAX)<EOL>hist=np.int32(np.around(hist_item))<EOL>for x,y in enumerate(hist):<EOL><INDENT>cv2.line(h,(x,),(x,y),(,,))<EOL><DEDENT>y=np.flipud(h)<EOL>return y <EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>import sys <EOL>if len(sys.argv)>:<EOL><INDENT>im=cv2.imread(sys.argv [])<EOL><DEDENT>else :<EOL><INDENT>im=cv2.imread('../cpp/lena.jpg')<EOL>print '<STR_LIT>'<EOL><DEDENT>gray=cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)<EOL>print '<STR_LIT>'<EOL>cv2.imshow('image',im)<EOL>while True :<EOL><INDENT>k=cv2.waitKey()&<EOL>if k==ord('a'):<EOL><INDENT>curve=hist_curve(im)<EOL>cv2.imshow('histogram',curve)<EOL>cv2.imshow('image',im)<EOL>print 'a'<EOL><DEDENT>elif k==ord('b'):<EOL><INDENT>print 'b'<EOL>lines=hist_lines(im)<EOL>cv2.imshow('histogram',lines)<EOL>cv2.imshow('image',gray)<EOL><DEDENT>elif k==ord('c'):<EOL><INDENT>print 'c'<EOL>equ=cv2.equalizeHist(gray)<EOL>lines=hist_lines(equ)<EOL>cv2.imshow('histogram',lines)<EOL>cv2.imshow('image',equ)<EOL><DEDENT>elif k==ord('d'):<EOL><INDENT>print 'd'<EOL>curve=hist_curve(gray)<EOL>cv2.imshow('histogram',curve)<EOL>cv2.imshow('image',gray)<EOL><DEDENT>elif k==ord('e'):<EOL><INDENT>print 'e'<EOL>norm=cv2.normalize(gray,alpha=,beta=,norm_type=cv2.NORM_MINMAX)<EOL>lines=hist_lines(norm)<EOL>cv2.imshow('histogram',lines)<EOL>cv2.imshow('image',norm)<EOL><DEDENT>elif k==:<EOL><INDENT>print 'ESC'<EOL>cv2.destroyAllWindows()<EOL>break <EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import cv2 <EOL>import os <EOL>from time import clock <EOL>from datetime import datetime as dt <EOL>class OpenCV_Cam(object):<EOL><INDENT>def __init__(self,src=None):<EOL><INDENT>self.pic_idx=<EOL>self.start_cam(src)<EOL>self.__fcount,self.__frate,self.__start=,,clock()<EOL><DEDENT>@staticmethod <EOL>def cam_count():<EOL><INDENT>cam_idx=<EOL>cap=cv2.VideoCapture(cam_idx)<EOL>while cap.read()[]:<EOL><INDENT>cam_idx +=<EOL>cap=cv2.VideoCapture(cam_idx)<EOL><DEDENT>return cam_idx <EOL><DEDENT>def start_cam(self,src=None):<EOL><INDENT>if src is not None :<EOL><INDENT>self.cam=VideoCapture(src)<EOL>if not self.cam.isOpened():<EOL><INDENT>raise ValueError('Cannot open '+src +'as VideoCapture')<EOL><DEDENT>return <EOL><DEDENT>idx=<EOL>cam1,cam2=cv2.VideoCapture(),cv2.VideoCapture()<EOL>while(cam2.read()[]):<EOL><INDENT>cam1.release()<EOL>cam1=cam2 <EOL>idx +=<EOL>cam2=cv2.VideoCapture(idx)<EOL><DEDENT>self.cam=cam1 <EOL>if not self.cam.isOpened():<EOL><INDENT>raise Error('<STR_LIT>')<EOL><DEDENT> <DEDENT>@property <EOL>def size(self):<EOL><INDENT>w=self.cam.get(cv2.cv.CV_CAP_PROP_FRAME_WIDTH)<EOL>h=self.cam.get(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT)<EOL>return(int(w),int(h))<EOL><DEDENT>@size.setter <EOL>def size(self,shape):<EOL><INDENT>self.cam.set(cv2.cv.CV_CAP_PROP_FRAME_WIDTH,shape [])<EOL>self.cam.set(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT,shape [])<EOL><DEDENT>def read(self):<EOL><INDENT>self.__fcount +=<EOL>self.__frame=self.cam.read()[]<EOL>if self.__fcount==:<EOL><INDENT>end=clock()<EOL>self.__frate=/(end -self.__start)<EOL>self.__start=clock()<EOL>self.__fcount=<EOL><DEDENT>return self.__frame <EOL><DEDENT>@property <EOL>def frame_rate(self):<EOL><INDENT>return self.__frate <EOL><DEDENT>@property <EOL>def info(self):<EOL><INDENT>vars=[x [:]for x in dir(cv2.cv)if 'CV_CAP_PROP'in x ]<EOL>ret={}<EOL>for p in vars :<EOL><INDENT>cmd='ret[\''+p +'<STR_LIT>'+p +')'<EOL>exec cmd <EOL><DEDENT>return ret <EOL><DEDENT>def set(self,property,value):<EOL><INDENT>cmd='<STR_LIT>'+property +', '+str(value)+')'<EOL>print cmd <EOL>exec cmd <EOL><DEDENT>def cam_loop(self,func=lambda x :x,params=()):<EOL><INDENT>while True :<EOL><INDENT>input=self.read()<EOL>output=func(input,*params)<EOL>window_name=func.__name__ <EOL>if window_name=='<lambda>':window_name='camera image'<EOL>cv2.imshow(window_name,output)<EOL>k=cv2.waitKey()<EOL>if k==:<EOL><INDENT>break <EOL><DEDENT>elif k==ord('p'):<EOL><INDENT>info=self.info <EOL>for i in info :<EOL><INDENT>print i,'=',info [i ]<EOL><DEDENT> <DEDENT>elif k==ord('s'):<EOL><INDENT>p=raw_input('type property:')<EOL>if('<STR_LIT>'+p)not in dir(cv2.cv):<EOL><INDENT>print p,'<STR_LIT>'<EOL>print '<STR_LIT>',[x [:]for x in dir(cv2.cv)if 'CV_CAP_PROP'in x ]<EOL><DEDENT>else :<EOL><INDENT>v=raw_input('type value:')<EOL>self.set(p,v)<EOL><DEDENT> <DEDENT>elif k==ord('f'):<EOL><INDENT>print self.frame_rate <EOL><DEDENT>elif k==ord(' '):<EOL><INDENT>directory='<STR_LIT>'<EOL>f=str(dt.now())<EOL>idx=''.join([c for c in f if c.isdigit()or c.isalpha()or c in '-_.'])<EOL>filename=directory +'/'+idx +".png"<EOL>if not os.path.exists(directory):<EOL><INDENT>os.makedirs(directory)<EOL><DEDENT>cv2.imwrite(filename,output)<EOL>print "image saved to "+filename <EOL>self.pic_idx +=<EOL><DEDENT> <DEDENT> <DEDENT>def __enter__(self):<EOL><INDENT>return self <EOL><DEDENT>def __exit__(self,exc_type,exc_value,traceback):<EOL><INDENT>self.cam.release()<EOL><DEDENT>def release(self):<EOL><INDENT>self.cam.release()<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>cam=OpenCV_Cam()<EOL>cam.size=(,)<EOL>info=cam.info <EOL>for i in info :<EOL><INDENT>print i,'=',info [i ]<EOL><DEDENT>cam.cam_loop()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import unittest <EOL>class InitializationTest(unittest.TestCase):<EOL><INDENT> '<STR_LIT>'<EOL>def test_initialization(self):<EOL><INDENT> '<STR_LIT>'<EOL>self.assertEqual(+,)<EOL><DEDENT>def test_import(self):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>import octavo <EOL><DEDENT>except ImportError :<EOL><INDENT>self.fail('<STR_LIT>')<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>import os <EOL>import sys <EOL>import time <EOL>import glob <EOL>import fnmatch <EOL>import shutil <EOL>import subprocess <EOL>try :<EOL><INDENT>from robot.version import get_version <EOL>from robot.api import logger <EOL>from robot.utils import(ConnectionCache,seq2str,timestr_to_secs,<EOL>secs_to_timestr,plural_or_not,get_time,abspath,<EOL>secs_to_timestamp,parse_time,unic,decode_output,<EOL>get_env_var,set_env_var,del_env_var,get_env_vars,<EOL>decode_from_system)<EOL>__version__=get_version()<EOL>PROCESSES=ConnectionCache('<STR_LIT>')<EOL>del ConnectionCache,get_version <EOL><DEDENT>except ImportError :<EOL><INDENT>from os.path import abspath <EOL>from os import(getenv as get_env_var,putenv as set_env_var,<EOL>unsetenv as del_env_var,environ)<EOL>__version__='<unknown>'<EOL>get_env_vars=environ.copy <EOL>logger=None <EOL>seq2str=lambda items :', '.join("'%s'"%item for item in items)<EOL>timestr_to_secs=int <EOL>plural_or_not=lambda count :''if count==else 's'<EOL>secs_to_timestr=lambda secs :'%d second%s'%(secs,plural_or_not(secs))<EOL>unic=unicode <EOL>decode_output=decode_from_system=lambda string :string <EOL>class _NotImplemented :<EOL><INDENT>def __getattr__(self,name):<EOL><INDENT>raise NotImplementedError('<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT> <DEDENT>get_time=secs_to_timestamp=parse_time=PROCESSES=_NotImplemented()<EOL><DEDENT>class OperatingSystem :<EOL><INDENT> '<STR_LIT>'<EOL>ROBOT_LIBRARY_SCOPE='GLOBAL'<EOL>ROBOT_LIBRARY_VERSION=__version__ <EOL>def run(self,command):<EOL><INDENT> '<STR_LIT>'<EOL>return self._run(command)[]<EOL><DEDENT>def run_and_return_rc(self,command):<EOL><INDENT> '<STR_LIT>'<EOL>return self._run(command)[]<EOL><DEDENT>def run_and_return_rc_and_output(self,command):<EOL><INDENT> '<STR_LIT>'<EOL>return self._run(command)<EOL><DEDENT>def _run(self,command):<EOL><INDENT>process=_Process(command)<EOL>self._info('<STR_LIT>'%process)<EOL>stdout=process.read()<EOL>rc=process.close()<EOL>return rc,stdout <EOL><DEDENT>def start_process(self,command,stdin=None,alias=None):<EOL><INDENT> '<STR_LIT>'<EOL>process=_Process2(command,stdin)<EOL>self._info('<STR_LIT>'%process)<EOL>return PROCESSES.register(process,alias)<EOL><DEDENT>def switch_process(self,index_or_alias):<EOL><INDENT> '<STR_LIT>'<EOL>PROCESSES.switch(index_or_alias)<EOL><DEDENT>def read_process_output(self):<EOL><INDENT> '<STR_LIT>'<EOL>output=PROCESSES.current.read()<EOL>PROCESSES.current.close()<EOL>return output <EOL><DEDENT>def stop_process(self):<EOL><INDENT> '<STR_LIT>'<EOL>PROCESSES.current.close()<EOL><DEDENT>def stop_all_processes(self):<EOL><INDENT> '<STR_LIT>'<EOL>PROCESSES.close_all()<EOL><DEDENT>def get_file(self,path,encoding='UTF-8'):<EOL><INDENT> '<STR_LIT>'<EOL>content=self.get_binary_file(path)<EOL>return unicode(content,encoding).replace('\r\n','\n')<EOL><DEDENT>def get_binary_file(self,path):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>self._link('<STR_LIT>',path)<EOL>f=open(path,'rb')<EOL>try :<EOL><INDENT>return f.read()<EOL><DEDENT>finally :<EOL><INDENT>f.close()<EOL><DEDENT> <DEDENT>def grep_file(self,path,pattern,encoding='UTF-8'):<EOL><INDENT> '<STR_LIT>'<EOL>pattern='*%s*'%pattern <EOL>orig=self.get_file(path,encoding).splitlines()<EOL>lines=[line for line in orig if fnmatch.fnmatchcase(line,pattern)]<EOL>self._info('<STR_LIT>'%(len(lines),len(orig)))<EOL>return '\n'.join(lines)<EOL><DEDENT>def log_file(self,path,encoding='UTF-8'):<EOL><INDENT> '<STR_LIT>'<EOL>content=self.get_file(path,encoding)<EOL>self._info(content)<EOL>return content <EOL><DEDENT>def should_exist(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>if not glob.glob(path):<EOL><INDENT>self._fail(msg,'<STR_LIT>'%path)<EOL><DEDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>def should_not_exist(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>matches=glob.glob(path)<EOL>if not matches :<EOL><INDENT>self._link('<STR_LIT>',path)<EOL>return <EOL><DEDENT>if not msg :<EOL><INDENT>if self._is_pattern_path(path):<EOL><INDENT>matches.sort()<EOL>msg='<STR_LIT>'%(path,seq2str(matches))<EOL><DEDENT>else :<EOL><INDENT>msg='<STR_LIT>'%path <EOL><DEDENT> <DEDENT>raise AssertionError(msg)<EOL><DEDENT>def file_should_exist(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>matches=[p for p in glob.glob(path)if os.path.isfile(p)]<EOL>if not matches :<EOL><INDENT>self._fail(msg,'<STR_LIT>'%path)<EOL><DEDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>def file_should_not_exist(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>matches=[p for p in glob.glob(path)if os.path.isfile(p)]<EOL>if not matches :<EOL><INDENT>self._link('<STR_LIT>',path)<EOL>return <EOL><DEDENT>if not msg :<EOL><INDENT>if self._is_pattern_path(path):<EOL><INDENT>matches.sort()<EOL>name=len(matches)==and 'file'or 'files'<EOL>msg='<STR_LIT>'%(path,name,seq2str(matches))<EOL><DEDENT>else :<EOL><INDENT>msg='<STR_LIT>'%path <EOL><DEDENT> <DEDENT>raise AssertionError(msg)<EOL><DEDENT>def directory_should_exist(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>matches=[p for p in glob.glob(path)if os.path.isdir(p)]<EOL>if not matches :<EOL><INDENT>self._fail(msg,'<STR_LIT>'%path)<EOL><DEDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>def directory_should_not_exist(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>matches=[p for p in glob.glob(path)if os.path.isdir(p)]<EOL>if not matches :<EOL><INDENT>self._link('<STR_LIT>',path)<EOL>return <EOL><DEDENT>if not msg :<EOL><INDENT>if self._is_pattern_path(path):<EOL><INDENT>matches.sort()<EOL>name=len(matches)==and 'directory'or 'directories'<EOL>msg='<STR_LIT>'%(path,name,seq2str(matches))<EOL><DEDENT>else :<EOL><INDENT>msg='<STR_LIT>'%path <EOL><DEDENT> <DEDENT>raise AssertionError(msg)<EOL><DEDENT>def _is_pattern_path(self,path):<EOL><INDENT>return '*'in path or '?'in path or('['in path and ']'in path)<EOL><DEDENT>def wait_until_removed(self,path,timeout='1 minute'):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>timeout=timestr_to_secs(timeout)<EOL>maxtime=time.time()+timeout <EOL>while glob.glob(path):<EOL><INDENT>time.sleep()<EOL>if timeout >=and time.time()>maxtime :<EOL><INDENT>raise AssertionError('<STR_LIT>'<EOL>%(path,secs_to_timestr(timeout)))<EOL><DEDENT> <DEDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>def wait_until_created(self,path,timeout='1 minute'):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>timeout=timestr_to_secs(timeout)<EOL>maxtime=time.time()+timeout <EOL>while not glob.glob(path):<EOL><INDENT>time.sleep()<EOL>if timeout >=and time.time()>maxtime :<EOL><INDENT>raise AssertionError('<STR_LIT>'<EOL>%(path,secs_to_timestr(timeout)))<EOL><DEDENT> <DEDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>def directory_should_be_empty(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>items=self._list_dir(path)<EOL>if items :<EOL><INDENT>if not msg :<EOL><INDENT>msg='<STR_LIT>'%(path,seq2str(items,lastsep=', '))<EOL><DEDENT>raise AssertionError(msg)<EOL><DEDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>def directory_should_not_be_empty(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>count=len(self._list_dir(path))<EOL>if count==:<EOL><INDENT>self._fail(msg,'<STR_LIT>'%path)<EOL><DEDENT>plural=plural_or_not(count)<EOL>self._link('<STR_LIT>'%(count,plural),<EOL>path)<EOL><DEDENT>def file_should_be_empty(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>if not os.path.isfile(path):<EOL><INDENT>raise AssertionError('<STR_LIT>'%path)<EOL><DEDENT>size=os.stat(path).st_size <EOL>if size >:<EOL><INDENT>self._fail(msg,'<STR_LIT>'%(path,size))<EOL><DEDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>def file_should_not_be_empty(self,path,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>if not os.path.isfile(path):<EOL><INDENT>raise AssertionError('<STR_LIT>'%path)<EOL><DEDENT>size=os.stat(path).st_size <EOL>if size==:<EOL><INDENT>self._fail(msg,'<STR_LIT>'%path)<EOL><DEDENT>self._link('<STR_LIT>'%size,path)<EOL><DEDENT>def create_file(self,path,content='',encoding='UTF-8'):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._write_to_file(path,content,encoding,'w')<EOL>self._link('<STR_LIT>',path)<EOL><DEDENT>def append_to_file(self,path,content,encoding='UTF-8'):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._write_to_file(path,content,encoding,'a')<EOL>self._link('<STR_LIT>',path)<EOL><DEDENT>def _write_to_file(self,path,content,encoding,mode):<EOL><INDENT>path=self._absnorm(path)<EOL>parent=os.path.dirname(path)<EOL>if not os.path.exists(parent):<EOL><INDENT>os.makedirs(parent)<EOL><DEDENT>f=open(path,mode +'b')<EOL>try :<EOL><INDENT>f.write(content.encode(encoding))<EOL><DEDENT>finally :<EOL><INDENT>f.close()<EOL><DEDENT>return path <EOL><DEDENT>def remove_file(self,path):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>matches=glob.glob(path)<EOL>if not matches :<EOL><INDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>for match in matches :<EOL><INDENT>if not os.path.isfile(match):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%match)<EOL><DEDENT>os.remove(match)<EOL>self._link('<STR_LIT>',match)<EOL><DEDENT> <DEDENT>def remove_files(self,*paths):<EOL><INDENT> '<STR_LIT>'<EOL>for path in paths :<EOL><INDENT>self.remove_file(path)<EOL><DEDENT> <DEDENT>def empty_directory(self,path):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>items=[os.path.join(path,item)for item in self._list_dir(path)]<EOL>for item in items :<EOL><INDENT>if os.path.isdir(item):<EOL><INDENT>shutil.rmtree(item)<EOL><DEDENT>else :<EOL><INDENT>os.remove(item)<EOL><DEDENT> <DEDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>def create_directory(self,path):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>if os.path.isdir(path):<EOL><INDENT>self._link('<STR_LIT>',path)<EOL>return <EOL><DEDENT>if os.path.exists(path):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%path)<EOL><DEDENT>os.makedirs(path)<EOL>self._link('<STR_LIT>',path)<EOL><DEDENT>def remove_directory(self,path,recursive=False):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>if not os.path.exists(path):<EOL><INDENT>self._link('<STR_LIT>',path)<EOL>return <EOL><DEDENT>if os.path.isfile(path):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%path)<EOL><DEDENT>if recursive :<EOL><INDENT>shutil.rmtree(path)<EOL><DEDENT>else :<EOL><INDENT>msg='<STR_LIT>'%path <EOL>self.directory_should_be_empty(path,msg)<EOL>os.rmdir(path)<EOL><DEDENT>self._link('<STR_LIT>',path)<EOL><DEDENT>def copy_file(self,source,destination):<EOL><INDENT> '<STR_LIT>'<EOL>source,destination=self._copy_file(source,destination)<EOL>self._link('<STR_LIT>',source,destination)<EOL><DEDENT>def move_file(self,source,destination):<EOL><INDENT> '<STR_LIT>'<EOL>source,destination=self._copy_file(source,destination)<EOL>os.remove(source)<EOL>self._link('<STR_LIT>',source,destination)<EOL><DEDENT>def _copy_file(self,source,dest):<EOL><INDENT>source=self._absnorm(source)<EOL>dest=dest.replace('/',os.sep)<EOL>dest_is_dir=dest.endswith(os.sep)<EOL>dest=self._absnorm(dest)<EOL>if not os.path.exists(source):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%source)<EOL><DEDENT>if not os.path.isfile(source):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%source)<EOL><DEDENT>if not os.path.exists(dest):<EOL><INDENT>if dest_is_dir :<EOL><INDENT>parent=dest <EOL><DEDENT>else :<EOL><INDENT>parent=os.path.dirname(dest)<EOL><DEDENT>if not os.path.exists(parent):<EOL><INDENT>os.makedirs(parent)<EOL><DEDENT> <DEDENT>shutil.copy(source,dest)<EOL>return source,dest <EOL><DEDENT>def copy_directory(self,source,destination):<EOL><INDENT> '<STR_LIT>'<EOL>source,destination=self._copy_dir(source,destination)<EOL>self._link('<STR_LIT>',source,destination)<EOL><DEDENT>def move_directory(self,source,destination):<EOL><INDENT> '<STR_LIT>'<EOL>source,destination=self._copy_dir(source,destination)<EOL>shutil.rmtree(source)<EOL>self._link('<STR_LIT>',source,destination)<EOL><DEDENT>def _copy_dir(self,source,dest):<EOL><INDENT>source=self._absnorm(source)<EOL>dest=self._absnorm(dest)<EOL>if not os.path.exists(source):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%source)<EOL><DEDENT>if not os.path.isdir(source):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%source)<EOL><DEDENT>if os.path.exists(dest)and not os.path.isdir(dest):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%dest)<EOL><DEDENT>if os.path.exists(dest):<EOL><INDENT>base=os.path.basename(source)<EOL>dest=os.path.join(dest,base)<EOL><DEDENT>else :<EOL><INDENT>parent=os.path.dirname(dest)<EOL>if not os.path.exists(parent):<EOL><INDENT>os.makedirs(parent)<EOL><DEDENT> <DEDENT>shutil.copytree(source,dest)<EOL>return source,dest <EOL><DEDENT>def get_environment_variable(self,name,default=None):<EOL><INDENT> '<STR_LIT>'<EOL>value=get_env_var(name,default)<EOL>if value is None :<EOL><INDENT>raise RuntimeError('<STR_LIT>'%name)<EOL><DEDENT>return value <EOL><DEDENT>def set_environment_variable(self,name,value):<EOL><INDENT> '<STR_LIT>'<EOL>set_env_var(name,value)<EOL>self._info('<STR_LIT>'%(name,value))<EOL><DEDENT>def remove_environment_variable(self,*names):<EOL><INDENT> '<STR_LIT>'<EOL>for name in names :<EOL><INDENT>value=del_env_var(name)<EOL>if value :<EOL><INDENT>self._info('<STR_LIT>'%name)<EOL><DEDENT>else :<EOL><INDENT>self._info('<STR_LIT>'%name)<EOL><DEDENT> <DEDENT> <DEDENT>def environment_variable_should_be_set(self,name,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>value=get_env_var(name)<EOL>if not value :<EOL><INDENT>self._fail(msg,'<STR_LIT>'%name)<EOL><DEDENT>self._info('<STR_LIT>'%(name,value))<EOL><DEDENT>def environment_variable_should_not_be_set(self,name,msg=None):<EOL><INDENT> '<STR_LIT>'<EOL>value=get_env_var(name)<EOL>if value :<EOL><INDENT>self._fail(msg,'<STR_LIT>'%(name,value))<EOL><DEDENT>self._info('<STR_LIT>'%name)<EOL><DEDENT>def get_environment_variables(self):<EOL><INDENT> '<STR_LIT>'<EOL>return get_env_vars()<EOL><DEDENT>def log_environment_variables(self,level='INFO'):<EOL><INDENT> '<STR_LIT>'<EOL>vars=get_env_vars()<EOL>for name,value in sorted(vars.items(),key=lambda item :item [].lower()):<EOL><INDENT>self._log('%s= %s'%(name,value),level)<EOL><DEDENT>return vars <EOL><DEDENT>def join_path(self,base,*parts):<EOL><INDENT> '<STR_LIT>'<EOL>base=base.replace('/',os.sep)<EOL>parts=[p.replace('/',os.sep)for p in parts ]<EOL>return self.normalize_path(os.path.join(base,*parts))<EOL><DEDENT>def join_paths(self,base,*paths):<EOL><INDENT> '<STR_LIT>'<EOL>return [self.join_path(base,path)for path in paths ]<EOL><DEDENT>def normalize_path(self,path):<EOL><INDENT> '<STR_LIT>'<EOL>return os.path.normpath(path.replace('/',os.sep))or '.'<EOL><DEDENT>def split_path(self,path):<EOL><INDENT> '<STR_LIT>'<EOL>return os.path.split(self.normalize_path(path))<EOL><DEDENT>def split_extension(self,path):<EOL><INDENT> '<STR_LIT>'<EOL>path=self.normalize_path(path)<EOL>basename=os.path.basename(path)<EOL>if basename.startswith('.'*basename.count('.')):<EOL><INDENT>return path,''<EOL><DEDENT>if path.endswith('.'):<EOL><INDENT>path2=path.rstrip('.')<EOL>trailing_dots='.'*(len(path)-len(path2))<EOL>path=path2 <EOL><DEDENT>else :<EOL><INDENT>trailing_dots=''<EOL><DEDENT>basepath,ext=os.path.splitext(path)<EOL>if ext.startswith('.'):<EOL><INDENT>ext=ext [:]<EOL><DEDENT>if ext :<EOL><INDENT>ext +=trailing_dots <EOL><DEDENT>else :<EOL><INDENT>basepath +=trailing_dots <EOL><DEDENT>return basepath,ext <EOL><DEDENT>def get_modified_time(self,path,format='timestamp'):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>if not os.path.exists(path):<EOL><INDENT>raise RuntimeError('<STR_LIT>'<EOL>'<STR_LIT>'%path)<EOL><DEDENT>mtime=get_time(format,os.stat(path).st_mtime)<EOL>self._link('<STR_LIT>'%mtime,path)<EOL>return mtime <EOL><DEDENT>def set_modified_time(self,path,mtime):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>try :<EOL><INDENT>if not os.path.exists(path):<EOL><INDENT>raise ValueError('<STR_LIT>')<EOL><DEDENT>if not os.path.isfile(path):<EOL><INDENT>raise ValueError('<STR_LIT>')<EOL><DEDENT>mtime=parse_time(mtime)<EOL><DEDENT>except ValueError,err :<EOL><INDENT>raise RuntimeError('<STR_LIT>'<EOL>%(path,unicode(err)))<EOL><DEDENT>os.utime(path,(mtime,mtime))<EOL>time.sleep()<EOL>tstamp=secs_to_timestamp(mtime,('-',' ',':'))<EOL>self._link('<STR_LIT>'%tstamp,path)<EOL><DEDENT>def get_file_size(self,path):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>if not os.path.isfile(path):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%path)<EOL><DEDENT>size=os.stat(path).st_size <EOL>plural=plural_or_not(size)<EOL>self._link('<STR_LIT>'%(size,plural),path)<EOL>return size <EOL><DEDENT>def list_directory(self,path,pattern=None,absolute=False):<EOL><INDENT> '<STR_LIT>'<EOL>items=self._list_dir(path,pattern,absolute)<EOL>self._info('%d item%s:\n%s'%(len(items),plural_or_not(items),'\n'.join(items)))<EOL>return items <EOL><DEDENT>def list_files_in_directory(self,path,pattern=None,absolute=False):<EOL><INDENT> '<STR_LIT>'<EOL>files=self._list_files_in_dir(path,pattern,absolute)<EOL>self._info('%d file%s:\n%s'%(len(files),plural_or_not(files),'\n'.join(files)))<EOL>return files <EOL><DEDENT>def list_directories_in_directory(self,path,pattern=None,absolute=False):<EOL><INDENT> '<STR_LIT>'<EOL>dirs=self._list_dirs_in_dir(path,pattern,absolute)<EOL>self._info('<STR_LIT>'%(len(dirs),'y'if len(dirs)==else 'ies','\n'.join(dirs)))<EOL>return dirs <EOL><DEDENT>def count_items_in_directory(self,path,pattern=None):<EOL><INDENT> '<STR_LIT>'<EOL>count=len(self._list_dir(path,pattern))<EOL>self._info("%s item%s."%(count,plural_or_not(count)))<EOL>return count <EOL><DEDENT>def count_files_in_directory(self,path,pattern=None):<EOL><INDENT> '<STR_LIT>'<EOL>count=len(self._list_files_in_dir(path,pattern))<EOL>self._info("%s file%s."%(count,plural_or_not(count)))<EOL>return count <EOL><DEDENT>def count_directories_in_directory(self,path,pattern=None):<EOL><INDENT> '<STR_LIT>'<EOL>count=len(self._list_dirs_in_dir(path,pattern))<EOL>self._info("%s director%s."%(count,'y'if count==else 'ies'))<EOL>return count <EOL><DEDENT>def _list_dir(self,path,pattern=None,absolute=False):<EOL><INDENT>path=self._absnorm(path)<EOL>self._link('<STR_LIT>',path)<EOL>if not os.path.isdir(path):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%path)<EOL><DEDENT>items=sorted(unic(item)for item in os.listdir(path))<EOL>if pattern :<EOL><INDENT>items=[i for i in items if fnmatch.fnmatchcase(i,pattern)]<EOL><DEDENT>if absolute :<EOL><INDENT>path=os.path.normpath(path)<EOL>items=[os.path.join(path,item)for item in items ]<EOL><DEDENT>return items <EOL><DEDENT>def _list_files_in_dir(self,path,pattern=None,absolute=False):<EOL><INDENT>return [item for item in self._list_dir(path,pattern,absolute)<EOL>if os.path.isfile(os.path.join(path,item))]<EOL><DEDENT>def _list_dirs_in_dir(self,path,pattern=None,absolute=False):<EOL><INDENT>return [item for item in self._list_dir(path,pattern,absolute)<EOL>if os.path.isdir(os.path.join(path,item))]<EOL><DEDENT>def touch(self,path):<EOL><INDENT> '<STR_LIT>'<EOL>path=self._absnorm(path)<EOL>if os.path.isdir(path):<EOL><INDENT>raise RuntimeError('<STR_LIT>'%path)<EOL><DEDENT>if not os.path.exists(os.path.dirname(path)):<EOL><INDENT>raise RuntimeError('<STR_LIT>'<EOL>"does not exist"%path)<EOL><DEDENT>if os.path.exists(path):<EOL><INDENT>mtime=round(time.time())<EOL>os.utime(path,(mtime,mtime))<EOL>self._link('<STR_LIT>',path)<EOL><DEDENT>else :<EOL><INDENT>open(path,'w').close()<EOL>self._link('<STR_LIT>',path)<EOL><DEDENT> <DEDENT>def _absnorm(self,path):<EOL><INDENT>try :<EOL><INDENT>return abspath(path.replace('/',os.sep))<EOL><DEDENT>except ValueError :<EOL><INDENT>return os.path.normpath(path.replace('/',os.sep))<EOL><DEDENT> <DEDENT>def _fail(self,error,default):<EOL><INDENT>raise AssertionError(error or default)<EOL><DEDENT>def _info(self,msg):<EOL><INDENT>self._log(msg,'INFO')<EOL><DEDENT>def _link(self,msg,*paths):<EOL><INDENT>paths=tuple('<STR_LIT>'%(p,p)for p in paths)<EOL>self._log(msg %paths,'HTML')<EOL><DEDENT>def _warn(self,msg):<EOL><INDENT>self._log(msg,'WARN')<EOL><DEDENT>def _log(self,msg,level):<EOL><INDENT>if logger :<EOL><INDENT>logger.write(msg,level)<EOL><DEDENT>else :<EOL><INDENT>print '*%s* %s'%(level,msg)<EOL><DEDENT> <DEDENT> <DEDENT>class _Process :<EOL><INDENT>def __init__(self,command):<EOL><INDENT>self._command=self._process_command(command)<EOL>self._process=os.popen(self._command)<EOL><DEDENT>def __str__(self):<EOL><INDENT>return self._command <EOL><DEDENT>def read(self):<EOL><INDENT>return self._process_output(self._process.read())<EOL><DEDENT>def close(self):<EOL><INDENT>try :<EOL><INDENT>rc=self._process.close()<EOL><DEDENT>except IOError :<EOL><INDENT>return <EOL><DEDENT>if rc is None :<EOL><INDENT>return <EOL><DEDENT>if os.sep=='\\'or sys.platform.startswith('java'):<EOL><INDENT>return rc %<EOL><DEDENT>return rc >><EOL><DEDENT>def _process_command(self,command):<EOL><INDENT>if '>'not in command :<EOL><INDENT>if command.endswith('&'):<EOL><INDENT>command=command [:-]+' 2>&1 &'<EOL><DEDENT>else :<EOL><INDENT>command +=' 2>&1'<EOL><DEDENT> <DEDENT>return self._encode_to_file_system(command)<EOL><DEDENT>def _encode_to_file_system(self,string):<EOL><INDENT>enc=sys.getfilesystemencoding()<EOL>return string.encode(enc)if enc else string <EOL><DEDENT>def _process_output(self,stdout):<EOL><INDENT>stdout=stdout.replace('\r\n','\n')<EOL>if stdout.endswith('\n'):<EOL><INDENT>stdout=stdout [:-]<EOL><DEDENT>return decode_output(stdout)<EOL><DEDENT> <DEDENT>class _Process2(_Process):<EOL><INDENT>def __init__(self,command,input_):<EOL><INDENT>self._command=self._process_command(command)<EOL>p=subprocess.Popen(self._command,shell=True,stdin=subprocess.PIPE,<EOL>stdout=subprocess.PIPE,stderr=subprocess.STDOUT,<EOL>close_fds=os.sep=='/')<EOL>stdin,self.stdout=p.stdin,p.stdout <EOL>if input_ :<EOL><INDENT>stdin.write(input_)<EOL><DEDENT>stdin.close()<EOL>self.closed=False <EOL><DEDENT>def read(self):<EOL><INDENT>if self.closed :<EOL><INDENT>raise RuntimeError('<STR_LIT>')<EOL><DEDENT>return self._process_output(self.stdout.read())<EOL><DEDENT>def close(self):<EOL><INDENT>if not self.closed :<EOL><INDENT>self.stdout.close()<EOL>self.closed=True <EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>from multiprocessing.pool import ThreadPool <EOL>from collections import deque <EOL>from common import clock,draw_str,StatValue <EOL>import video <EOL>class DummyTask :<EOL><INDENT>def __init__(self,data):<EOL><INDENT>self.data=data <EOL><DEDENT>def ready(self):<EOL><INDENT>return True <EOL><DEDENT>def get(self):<EOL><INDENT>return self.data <EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>import sys <EOL>print __doc__ <EOL>try :fn=sys.argv []<EOL>except :fn=<EOL>cap=video.create_capture(fn)<EOL>def process_frame(frame,t0):<EOL><INDENT>frame=cv2.medianBlur(frame,)<EOL>frame=cv2.medianBlur(frame,)<EOL>return frame,t0 <EOL><DEDENT>threadn=cv2.getNumberOfCPUs()<EOL>pool=ThreadPool(processes=threadn)<EOL>pending=deque()<EOL>threaded_mode=True <EOL>latency=StatValue()<EOL>frame_interval=StatValue()<EOL>last_frame_time=clock()<EOL>while True :<EOL><INDENT>while len(pending)>and pending [].ready():<EOL><INDENT>res,t0=pending.popleft().get()<EOL>latency.update(clock()-t0)<EOL>draw_str(res,(,),'<STR_LIT>'+str(threaded_mode))<EOL>draw_str(res,(,),'<STR_LIT>'%(latency.value *))<EOL>draw_str(res,(,),'<STR_LIT>'%(frame_interval.value *))<EOL>cv2.imshow('threaded video',res)<EOL><DEDENT>if len(pending)<threadn :<EOL><INDENT>ret,frame=cap.read()<EOL>t=clock()<EOL>frame_interval.update(t -last_frame_time)<EOL>last_frame_time=t <EOL>if threaded_mode :<EOL><INDENT>task=pool.apply_async(process_frame,(frame.copy(),t))<EOL><DEDENT>else :<EOL><INDENT>task=DummyTask(process_frame(frame,t))<EOL><DEDENT>pending.append(task)<EOL><DEDENT>ch=&cv2.waitKey()<EOL>if ch==ord(' '):<EOL><INDENT>threaded_mode=not threaded_mode <EOL><DEDENT>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT>cv2.destroyAllWindows()<EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>from common import Sketcher <EOL>class App :<EOL><INDENT>def __init__(self,fn):<EOL><INDENT>self.img=cv2.imread(fn)<EOL>if self.img is None :<EOL><INDENT>raise Exception('<STR_LIT>'%fn)<EOL><DEDENT>h,w=self.img.shape [:]<EOL>self.markers=np.zeros((h,w),np.int32)<EOL>self.markers_vis=self.img.copy()<EOL>self.cur_marker=<EOL>self.colors=np.int32(list(np.ndindex(,,)))*<EOL>self.auto_update=True <EOL>self.sketch=Sketcher('img',[self.markers_vis,self.markers ],self.get_colors)<EOL><DEDENT>def get_colors(self):<EOL><INDENT>return map(int,self.colors [self.cur_marker ]),self.cur_marker <EOL><DEDENT>def watershed(self):<EOL><INDENT>m=self.markers.copy()<EOL>cv2.watershed(self.img,m)<EOL>overlay=self.colors [np.maximum(m,)]<EOL>vis=cv2.addWeighted(self.img,,overlay,,,dtype=cv2.CV_8UC3)<EOL>cv2.imshow('watershed',vis)<EOL><DEDENT>def run(self):<EOL><INDENT>while True :<EOL><INDENT>ch=&cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT>if ch >=ord('1')and ch <=ord('7'):<EOL><INDENT>self.cur_marker=ch -ord('0')<EOL>print 'marker: ',self.cur_marker <EOL><DEDENT>if ch==ord(' ')or(self.sketch.dirty and self.auto_update):<EOL><INDENT>self.watershed()<EOL>self.sketch.dirty=False <EOL><DEDENT>if ch in [ord('a'),ord('A')]:<EOL><INDENT>self.auto_update=not self.auto_update <EOL>print 'auto_update if',['off','on'][self.auto_update ]<EOL><DEDENT>if ch in [ord('r'),ord('R')]:<EOL><INDENT>self.markers [:]=<EOL>self.markers_vis [:]=self.img <EOL>self.sketch.show()<EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>import sys <EOL>try :<EOL><INDENT>fn=sys.argv []<EOL><DEDENT>except :<EOL><INDENT>fn='<STR_LIT>'<EOL><DEDENT>print __doc__ <EOL>App(fn).run()<EOL><DEDENT><EOF><BOF>import pygame <EOL>from pygame.locals import *<EOL>from py2d.Math import *<EOL>from examples import Example <EOL>class Draw(Example):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,runner):<EOL><INDENT>self.runner=runner <EOL>self.title="Simple Drawing"<EOL>self.poly=Polygon()<EOL><DEDENT>def update(self,time_elapsed):<EOL><INDENT>if self.runner.keys [K_BACKSPACE ]and self.poly.points :<EOL><INDENT>del(self.poly.points [len(self.poly.points)-])<EOL>self.runner.keys [K_BACKSPACE ]=False <EOL><DEDENT> <DEDENT>def render(self):<EOL><INDENT>if len(self.poly)>:<EOL><INDENT>pygame.draw.lines(self.runner.screen,,True,self.poly.as_tuple_list())<EOL><DEDENT>elif self.poly.points :<EOL><INDENT>pygame.draw.circle(self.runner.screen,,self.poly.points [].as_tuple(),)<EOL><DEDENT> <DEDENT>def mouse_down(self,pos,button):<EOL><INDENT>if button==:<EOL><INDENT>self.poly.add_point(Vector(pos [],pos []))<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import cv2 <EOL>import numpy as np <EOL>import sys <EOL>def data_matrix_demo(cap):<EOL><INDENT>window_name='<STR_LIT>'<EOL>frame_number=<EOL>need_to_save=False <EOL>while :<EOL><INDENT>ret,frame=cap.read()<EOL>if not ret :<EOL><INDENT>break <EOL><DEDENT>gray=cv2.cvtColor(frame,cv2.COLOR_RGB2GRAY)<EOL>codes,corners,dmtx=cv2.findDataMatrix(gray)<EOL>cv2.drawDataMatrixCodes(frame,codes,corners)<EOL>cv2.imshow(window_name,frame)<EOL>key=cv2.waitKey()<EOL>c=chr(key &)<EOL>if c in ['q','Q',chr()]:<EOL><INDENT>break <EOL><DEDENT>if c==' ':<EOL><INDENT>need_to_save=True <EOL><DEDENT>if need_to_save and codes :<EOL><INDENT>filename=('<STR_LIT>'%frame_number)<EOL>cv2.imwrite(filename,frame)<EOL>print "Saved frame to "+filename <EOL>need_to_save=False <EOL><DEDENT>frame_number +=<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>if len(sys.argv)==:<EOL><INDENT>cap=cv2.VideoCapture()<EOL><DEDENT>else :<EOL><INDENT>cap=cv2.VideoCapture(sys.argv [])<EOL>if not cap.isOpened():<EOL><INDENT>cap=cv2.VideoCapture(int(sys.argv []))<EOL><DEDENT> <DEDENT>if not cap.isOpened():<EOL><INDENT>print '<STR_LIT>'<EOL>sys.exit(-)<EOL><DEDENT>data_matrix_demo(cap)<EOL><DEDENT><EOF><BOF>from setuptools import setup <EOL>'<STR_LIT>'<EOL>import sys <EOL>from distutils.core import setup <EOL>from codecs import open <EOL>from os import path <EOL>here=path.abspath(path.dirname(__file__))<EOL>with open(path.join(here,'README.md'),encoding='utf-8')as f :<EOL><INDENT>long_description=f.read()<EOL><DEDENT>setup(<EOL>name='webb',<EOL>version='0.9.2.5',<EOL>description='<STR_LIT>',<EOL>author='Hardik Vasa',<EOL>maintainer='Hardik Vasa',<EOL>author_email='<STR_LIT>',<EOL>long_description=long_description,<EOL>license='<STR_LIT>',<EOL>url='<STR_LIT>',<EOL>keywords='<STR_LIT>',<EOL>classifiers=[<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>],<EOL>zip_safe=False,<EOL>packages=['webb'],)<EOF><BOF>class CommentCache(object):<EOL><INDENT>def __init__(self):<EOL><INDENT>self._comments=[]<EOL><DEDENT>def add(self,comment):<EOL><INDENT>self._comments.append(comment)<EOL><DEDENT>def consume_with(self,function):<EOL><INDENT>map(function,self._comments)<EOL>self.__init__()<EOL><DEDENT> <DEDENT>class Comments(object):<EOL><INDENT>def __init__(self):<EOL><INDENT>self._comments=[]<EOL><DEDENT>def add(self,row):<EOL><INDENT>if row.comments :<EOL><INDENT>self._comments.extend(c.strip()for c in row.comments if c.strip())<EOL><DEDENT> <DEDENT>@property <EOL>def value(self):<EOL><INDENT>return self._comments <EOL><DEDENT> <DEDENT><EOF><BOF>from django.contrib.auth import get_user_model <EOL>from django.core.urlresolvers import reverse <EOL>from django.test import TestCase,override_settings <EOL>from mock import patch <EOL>from buildservice.errors import MissingToken,InvalidStatus <EOL>from buildservice.models import Build,Repository <EOL>from buildservice.utils.testing import create_user_token <EOL>@override_settings(BUILDSERVICE_BASE_URL='<STR_LIT>')<EOL>class BuildTestCase(TestCase):<EOL><INDENT>def setUp(self):<EOL><INDENT>self.user=get_user_model().objects.create_user('user',password='pwd')<EOL>self.repo=Repository.objects.create(name='john-doe/repo')<EOL>self.repo.users.add(self.user)<EOL>self.build=Build.objects.create(<EOL>repository=self.repo,<EOL>pusher_name='john-doe',<EOL>branch='master',<EOL>sha='<STR_LIT>',<EOL>number=)<EOL><DEDENT>def test_pusher_profile_url(self):<EOL><INDENT>self.assertEqual(self.build.pusher_profile_url,'<STR_LIT>')<EOL><DEDENT>def test_url(self):<EOL><INDENT>build_detail=reverse('build_detail',args=[self.repo.name,self.build.number ])<EOL>self.assertEqual(self.build.url,'<STR_LIT>'%build_detail)<EOL><DEDENT>def test_is_success_yes(self):<EOL><INDENT>self.build.status='success'<EOL>self.assertTrue(self.build.is_success)<EOL><DEDENT>def test_is_success_no(self):<EOL><INDENT>self.assertFalse(self.build.is_success)<EOL><DEDENT>def test_is_pending_yes(self):<EOL><INDENT>self.assertTrue(self.build.is_pending)<EOL><DEDENT>def test_is_pending_no(self):<EOL><INDENT>self.build.status='errored'<EOL>self.assertFalse(self.build.is_pending)<EOL><DEDENT>def test_short_sha(self):<EOL><INDENT>self.assertEqual(self.build.short_sha,'1234567')<EOL><DEDENT>def test_update_status_no_token(self):<EOL><INDENT>self.assertRaises(MissingToken,self.build.update_status,'something')<EOL><DEDENT>def test_update_status_bad_status(self):<EOL><INDENT>create_user_token(self.user,self.repo)<EOL>self.assertRaises(InvalidStatus,self.build.update_status,'something')<EOL>self.build.refresh_from_db()<EOL>self.assertEqual(self.build.status,'pending')<EOL><DEDENT>@patch('<STR_LIT>')<EOL>def test_update_status_ok(self,create_status):<EOL><INDENT>token=create_user_token(self.user,self.repo)<EOL>self.build.update_status('success')<EOL>self.build.refresh_from_db()<EOL>self.assertEqual(self.build.status,'success')<EOL>create_status.assert_called_with(<EOL>token.value,'john-doe/repo',self.build.sha,<EOL>state='success',target_url=self.build.url )<EOL><DEDENT> <DEDENT><EOF><BOF>def climebox_usage():<EOL><INDENT>clime.Program().printusage()<EOL><DEDENT>def climebox_dirname(file_name):<EOL><INDENT>print(os.path.dirname(file_name))<EOL><DEDENT>def climebox_false():<EOL><INDENT>exit()<EOL><DEDENT>def climebox_pwd():<EOL><INDENT>print(os.getcwd())<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>import clime <EOL>import sys,os <EOL>import inspect <EOL>execname=os.path.basename(sys.argv [])<EOL>if execname=='climebox'or execname=='climebox.py':<EOL><INDENT>clime.Program(defcmdname='climebox_usage').main()<EOL>exit()<EOL><DEDENT>import __main__ <EOL>for cmdname in clime.Program().cmdfs.keys():<EOL><INDENT>attr=getattr(__main__,cmdname)<EOL>cmdname='climebox_'+execname <EOL>if cmdname==attr.func_name :<EOL><INDENT>clime.Program(defcmdname=cmdname,progname=execname).main()<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import sys <EOL>BLUE=[,,]<EOL>RED=[,,]<EOL>GREEN=[,,]<EOL>BLACK=[,,]<EOL>WHITE=[,,]<EOL>DRAW_BG={'color':BLACK,'val':}<EOL>DRAW_FG={'color':WHITE,'val':}<EOL>DRAW_PR_FG={'color':GREEN,'val':}<EOL>DRAW_PR_BG={'color':RED,'val':}<EOL>rect=(,,,)<EOL>drawing=False <EOL>rectangle=False <EOL>rect_over=False <EOL>rect_or_mask=<EOL>value=DRAW_FG <EOL>thickness=<EOL>def onmouse(event,x,y,flags,param):<EOL><INDENT>global img,img2,drawing,value,mask,rectangle,rect,rect_or_mask,ix,iy,rect_over <EOL>if event==cv2.EVENT_RBUTTONDOWN :<EOL><INDENT>rectangle=True <EOL>ix,iy=x,y <EOL><DEDENT>elif event==cv2.EVENT_MOUSEMOVE :<EOL><INDENT>if rectangle==True :<EOL><INDENT>img=img2.copy()<EOL>cv2.rectangle(img,(ix,iy),(x,y),BLUE,)<EOL>rect=(ix,iy,abs(ix -x),abs(iy -y))<EOL>rect_or_mask=<EOL><DEDENT> <DEDENT>elif event==cv2.EVENT_RBUTTONUP :<EOL><INDENT>rectangle=False <EOL>rect_over=True <EOL>cv2.rectangle(img,(ix,iy),(x,y),BLUE,)<EOL>rect=(ix,iy,abs(ix -x),abs(iy -y))<EOL>rect_or_mask=<EOL>print '<STR_LIT>'<EOL><DEDENT>if event==cv2.EVENT_LBUTTONDOWN :<EOL><INDENT>if rect_over==False :<EOL><INDENT>print '<STR_LIT>'<EOL><DEDENT>else :<EOL><INDENT>drawing=True <EOL>cv2.circle(img,(x,y),thickness,value ['color'],-)<EOL>cv2.circle(mask,(x,y),thickness,value ['val'],-)<EOL><DEDENT> <DEDENT>elif event==cv2.EVENT_MOUSEMOVE :<EOL><INDENT>if drawing==True :<EOL><INDENT>cv2.circle(img,(x,y),thickness,value ['color'],-)<EOL>cv2.circle(mask,(x,y),thickness,value ['val'],-)<EOL><DEDENT> <DEDENT>elif event==cv2.EVENT_LBUTTONUP :<EOL><INDENT>if drawing==True :<EOL><INDENT>drawing=False <EOL>cv2.circle(img,(x,y),thickness,value ['color'],-)<EOL>cv2.circle(mask,(x,y),thickness,value ['val'],-)<EOL><DEDENT> <DEDENT> <DEDENT>print __doc__ <EOL>if len(sys.argv)==:<EOL><INDENT>filename=sys.argv []<EOL><DEDENT>else :<EOL><INDENT>print '<STR_LIT>'<EOL>print '<STR_LIT>'<EOL>filename='../cpp/lena.jpg'<EOL><DEDENT>img=cv2.imread(filename)<EOL>img2=img.copy()<EOL>mask=np.zeros(img.shape [:],dtype=np.uint8)<EOL>output=np.zeros(img.shape,np.uint8)<EOL>cv2.namedWindow('output')<EOL>cv2.namedWindow('input')<EOL>cv2.setMouseCallback('input',onmouse)<EOL>cv2.moveWindow('input',img.shape []+,)<EOL>print '<STR_LIT>'<EOL>print '<STR_LIT>'<EOL>while():<EOL><INDENT>cv2.imshow('output',output)<EOL>cv2.imshow('input',img)<EOL>k=&cv2.waitKey()<EOL>if k==:<EOL><INDENT>break <EOL><DEDENT>elif k==ord('0'):<EOL><INDENT>print '<STR_LIT>'<EOL>value=DRAW_BG <EOL><DEDENT>elif k==ord('1'):<EOL><INDENT>print '<STR_LIT>'<EOL>value=DRAW_FG <EOL><DEDENT>elif k==ord('2'):<EOL><INDENT>value=DRAW_PR_BG <EOL><DEDENT>elif k==ord('3'):<EOL><INDENT>value=DRAW_PR_FG <EOL><DEDENT>elif k==ord('s'):<EOL><INDENT>bar=np.zeros((img.shape [],,),np.uint8)<EOL>res=np.hstack((img2,bar,img,bar,output))<EOL>cv2.imwrite('<STR_LIT>',res)<EOL>print '<STR_LIT>'<EOL><DEDENT>elif k==ord('r'):<EOL><INDENT>print "resetting \n"<EOL>rect=(,,,)<EOL>drawing=False <EOL>rectangle=False <EOL>rect_or_mask=<EOL>rect_over=False <EOL>value=DRAW_FG <EOL>img=img2.copy()<EOL>mask=np.zeros(img.shape [:],dtype=np.uint8)<EOL>output=np.zeros(img.shape,np.uint8)<EOL><DEDENT>elif k==ord('n'):<EOL><INDENT>print '<STR_LIT>'<EOL>if(rect_or_mask==):<EOL><INDENT>bgdmodel=np.zeros((,),np.float64)<EOL>fgdmodel=np.zeros((,),np.float64)<EOL>cv2.grabCut(img2,mask,rect,bgdmodel,fgdmodel,,cv2.GC_INIT_WITH_RECT)<EOL>rect_or_mask=<EOL><DEDENT>elif rect_or_mask==:<EOL><INDENT>bgdmodel=np.zeros((,),np.float64)<EOL>fgdmodel=np.zeros((,),np.float64)<EOL>cv2.grabCut(img2,mask,rect,bgdmodel,fgdmodel,,cv2.GC_INIT_WITH_MASK)<EOL><DEDENT> <DEDENT>mask2=np.where((mask==)+(mask==),,).astype('uint8')<EOL>output=cv2.bitwise_and(img2,img2,mask=mask2)<EOL><DEDENT>cv2.destroyAllWindows()<EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import video <EOL>from common import anorm2,draw_str <EOL>from time import clock <EOL>lk_params=dict(winSize=(,),<EOL>maxLevel=,<EOL>criteria=(cv2.TERM_CRITERIA_EPS |cv2.TERM_CRITERIA_COUNT,,))<EOL>feature_params=dict(maxCorners=,<EOL>qualityLevel=,<EOL>minDistance=,<EOL>blockSize=)<EOL>class App :<EOL><INDENT>def __init__(self,video_src):<EOL><INDENT>self.track_len=<EOL>self.detect_interval=<EOL>self.tracks=[]<EOL>self.cam=video.create_capture(video_src)<EOL>self.frame_idx=<EOL><DEDENT>def run(self):<EOL><INDENT>while True :<EOL><INDENT>ret,frame=self.cam.read()<EOL>frame_gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)<EOL>vis=frame.copy()<EOL>if len(self.tracks)>:<EOL><INDENT>img0,img1=self.prev_gray,frame_gray <EOL>p0=np.float32([tr [-]for tr in self.tracks ]).reshape(-,,)<EOL>p1,st,err=cv2.calcOpticalFlowPyrLK(img0,img1,p0,None,**lk_params)<EOL>p0r,st,err=cv2.calcOpticalFlowPyrLK(img1,img0,p1,None,**lk_params)<EOL>d=abs(p0 -p0r).reshape(-,).max(-)<EOL>good=d <<EOL>new_tracks=[]<EOL>for tr,(x,y),good_flag in zip(self.tracks,p1.reshape(-,),good):<EOL><INDENT>if not good_flag :<EOL><INDENT>continue <EOL><DEDENT>tr.append((x,y))<EOL>if len(tr)>self.track_len :<EOL><INDENT>del tr []<EOL><DEDENT>new_tracks.append(tr)<EOL>cv2.circle(vis,(x,y),,(,,),-)<EOL><DEDENT>self.tracks=new_tracks <EOL>cv2.polylines(vis,[np.int32(tr)for tr in self.tracks ],False,(,,))<EOL>draw_str(vis,(,),'track count: %d'%len(self.tracks))<EOL><DEDENT>if self.frame_idx %self.detect_interval==:<EOL><INDENT>mask=np.zeros_like(frame_gray)<EOL>mask [:]=<EOL>for x,y in [np.int32(tr [-])for tr in self.tracks ]:<EOL><INDENT>cv2.circle(mask,(x,y),,,-)<EOL><DEDENT>p=cv2.goodFeaturesToTrack(frame_gray,mask=mask,**feature_params)<EOL>if p is not None :<EOL><INDENT>for x,y in np.float32(p).reshape(-,):<EOL><INDENT>self.tracks.append([(x,y)])<EOL><DEDENT> <DEDENT> <DEDENT>self.frame_idx +=<EOL>self.prev_gray=frame_gray <EOL>cv2.imshow('lk_track',vis)<EOL>ch=&cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>def main():<EOL><INDENT>import sys <EOL>try :<EOL><INDENT>video_src=sys.argv []<EOL><DEDENT>except :<EOL><INDENT>video_src=<EOL><DEDENT>print __doc__ <EOL>App(video_src).run()<EOL>cv2.destroyAllWindows()<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>main()<EOL><DEDENT><EOF><BOF>import cv2 <EOL>import numpy as np <EOL>from screen_finder.screen_finder import ScreenFinder <EOL>from cam import OpenCV_Cam <EOL>def draw_burning(canvas,location):<EOL><INDENT>cv2.circle(canvas,(lx,ly),,(,,,))<EOL>return canvas <EOL><DEDENT>def find_laser_loc(img,threshold):<EOL><INDENT>red_part=img [:,:,]<EOL>max_pos=red_part.argmax()<EOL>ly,lx=np.unravel_index(max_pos,red_part.shape)<EOL>if red_part [ly,lx ]<threshold :<EOL><INDENT>return None <EOL><DEDENT>return np.array([lx,ly ])<EOL><DEDENT>def find_threshold(cam):<EOL><INDENT>img=cam.read()<EOL>hx,hy=find_laser_loc(img,)<EOL>threshold=img [hy,hx,]+<EOL>print '<STR_LIT>',threshold <EOL>return threshold <EOL><DEDENT>background=cv2.imread('wood.png')<EOL>cv2.imshow('Burn this page!',background)<EOL>sf=ScreenFinder()<EOL>sf.set_screen_img(background)<EOL>cam=OpenCV_Cam()<EOL>cam.size=,<EOL>img=cam.read()<EOL>sf.find_screen_img(img)<EOL>sf.find_screen_loop(cam,False)<EOL>bs=background.shape <EOL>canvas=np.full((bs [],bs [],),,dtype=np.uint8)<EOL>thresh=find_threshold(cam)<EOL>show_top_view,show_cam_view=False,False <EOL>while True :<EOL><INDENT>img=cam.read()<EOL>if show_cam_view :<EOL><INDENT>cv2.imshow('Cam view',img)<EOL><DEDENT>if show_top_view :<EOL><INDENT>top_view=sf.screen_top_view(img)<EOL>cv2.imshow('Top view',top_view)<EOL><DEDENT>cam_laser=find_laser_loc(img,thresh)<EOL>if cam_laser is not None :<EOL><INDENT>lx,ly=tuple(sf.reverse_transform(cam_laser).reshape(-))<EOL>background=draw_burning(background,(lx,ly))<EOL><DEDENT>cv2.imshow('Burn this page!',background)<EOL>k=cv2.waitKey()<EOL>if k==ord('a'):<EOL><INDENT>sf.find_screen_loop(cam,False)<EOL>thresh=find_threshold(cam)<EOL><DEDENT>elif k==ord('s'):<EOL><INDENT>background=cv2.imread('wood.png')<EOL><DEDENT>elif k==ord('d'):<EOL><INDENT>show_top_view=not show_top_view <EOL>if show_top_view is False :<EOL><INDENT>cv2.destroyWindow('Top view')<EOL><DEDENT> <DEDENT>elif k==ord('f'):<EOL><INDENT>show_cam_view=not show_cam_view <EOL>if show_cam_view is False :<EOL><INDENT>cv2.destroyWindow('Cam view')<EOL><DEDENT> <DEDENT>elif k==:<EOL><INDENT>break <DEDENT> <DEDENT><EOF><BOF>from collections import defaultdict <EOL>from pprint import pprint <EOL>def print_report(target_dict,key=None):<EOL><INDENT>len_pairs=len(target_dict)<EOL>print '<STR_LIT>'.format(len_pairs)<EOL>print <EOL>lenio_count_map=defaultdict(int)<EOL>for k,v in target_dict.iteritems():<EOL><INDENT>lenio_count_map [(len(k),len(v))]+=<EOL><DEDENT>total_count=sum(lenio_count_map.itervalues())<EOL>print '<STR_LIT>'<EOL>print <EOL>cum_pct=<EOL>for lenio,count in sorted(lenio_count_map.iteritems(),key=key):<EOL><INDENT>pct=*count /total_count <EOL>cum_pct +=pct <EOL>print '<STR_LIT>'.format(lenio,count,pct,cum_pct)<EOL><DEDENT>print <EOL>print 'Total  : {:>6,}'.format(total_count)<EOL>print '<STR_LIT>'.format(*total_count /len(lenio_count_map))<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>from time import time <EOL>start=time()<EOL>import zipcodetw <EOL>end=time()<EOL>print '<STR_LIT>'.format(end -start)<EOL>print <EOL>print '<STR_LIT>'<EOL>print <EOL>print_report(zipcodetw._dir.tokens_rzpairs_map)<EOL>print <EOL>print <EOL>print '<STR_LIT>'<EOL>print <EOL>print_report(zipcodetw._dir.tokens_gzipcode_map,key=lambda p :(p [][],-p [][]))<EOL><DEDENT><EOF><BOF>import logging <EOL>from robot.api import logger <EOL>from robot import utils <EOL>LEVELS={'TRACE':logging.NOTSET,<EOL>'DEBUG':logging.DEBUG,<EOL>'INFO':logging.INFO,<EOL>'WARN':logging.WARNING }<EOL>def initialize(level):<EOL><INDENT>logging.raiseExceptions=False <EOL>logging.getLogger().addHandler(RobotHandler())<EOL>set_level(level)<EOL><DEDENT>def set_level(level):<EOL><INDENT>try :<EOL><INDENT>level=LEVELS [level.upper()]<EOL><DEDENT>except KeyError :<EOL><INDENT>return <EOL><DEDENT>logging.getLogger().setLevel(level)<EOL><DEDENT>class RobotHandler(logging.Handler):<EOL><INDENT>def emit(self,record):<EOL><INDENT>message,error=self._get_message(record)<EOL>method=self._get_logger_method(record.levelno)<EOL>method(message)<EOL>if error :<EOL><INDENT>logger.debug(error)<EOL><DEDENT> <DEDENT>def _get_message(self,record):<EOL><INDENT>try :<EOL><INDENT>return record.getMessage(),None <EOL><DEDENT>except :<EOL><INDENT>message='<STR_LIT>'%utils.unic(record.msg)<EOL>error='\n'.join(utils.get_error_details())<EOL>return message,error <EOL><DEDENT> <DEDENT>def _get_logger_method(self,level):<EOL><INDENT>if level >=logging.WARNING :<EOL><INDENT>return logger.warn <EOL><DEDENT>if level >=logging.INFO :<EOL><INDENT>return logger.info <EOL><DEDENT>if level >=logging.DEBUG :<EOL><INDENT>return logger.debug <EOL><DEDENT>return logger.trace <EOL><DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from functools import wraps <EOL>import hashlib <EOL>import hmac <EOL>import json <EOL>from django.conf import settings <EOL>from django.http import HttpResponse,JsonResponse <EOL>from django.shortcuts import redirect <EOL>from buildservice.models import OAuthToken <EOL>def oauth_token_required(func):<EOL><INDENT> '<STR_LIT>'<EOL>@wraps(func)<EOL>def inner(request,*args,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>_=request.user.oauth_token <EOL><DEDENT>except(AttributeError,OAuthToken.DoesNotExist):<EOL><INDENT>return redirect('oauth_login')<EOL><DEDENT>return func(request,*args,**kwargs)<EOL><DEDENT>return inner <EOL><DEDENT>def signature_required(func):<EOL><INDENT> '<STR_LIT>'<EOL>@wraps(func)<EOL>def inner(request,*args,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>signature="sha1=%s"%hmac.new(<EOL>settings.GITHUB_HOOK_SECRET.encode('utf-8'),<EOL>request.body,<EOL>hashlib.sha1 ).hexdigest()<EOL>if signature !=request.META.get('<STR_LIT>'):<EOL><INDENT>return HttpResponse(status=,content='<STR_LIT>')<EOL><DEDENT>return func(request,*args,**kwargs)<EOL><DEDENT>return inner <EOL><DEDENT>def anonymous_user_required(func):<EOL><INDENT> '<STR_LIT>'<EOL>@wraps(func)<EOL>def inner(request,*args,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>if request.user.is_authenticated():<EOL><INDENT>return redirect('home')<EOL><DEDENT>return func(request,*args,**kwargs)<EOL><DEDENT>return inner <EOL><DEDENT>def require_json(func):<EOL><INDENT> '<STR_LIT>'<EOL>@wraps(func)<EOL>def wrapped(request,*args,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>request.json=json.loads(request.body or '{}')<EOL><DEDENT>except(ValueError,TypeError):<EOL><INDENT>return JsonResponse(data={'error':'<STR_LIT>'},status=)<EOL><DEDENT>return func(request,*args,**kwargs)<EOL><DEDENT>return wrapped <EOL><DEDENT>def require_api_key(func):<EOL><INDENT> '<STR_LIT>'<EOL>@wraps(func)<EOL>def wrapped(request,*args,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>if request.GET.get('api_key')!=settings.BUILDSERVICE_API_KEY :<EOL><INDENT>return HttpResponse(status=,content='<STR_LIT>')<EOL><DEDENT>return func(request,*args,**kwargs)<EOL><DEDENT>return wrapped <EOL><DEDENT><EOF><BOF>import sys <EOL>sys.path.append("core")<EOL>import os <EOL>import model <EOL>import editor <EOL>import ntpath <EOL>global shadowList <EOL>global createConfig <EOL>createConfig={}<EOL>global context <EOL>def createModule(newContext,newCreateConfig):<EOL><INDENT>global context <EOL>global createConfig <EOL>global shadowList <EOL>context=newContext <EOL>createConfig=newCreateConfig <EOL>if createConfig ["type"]=="script":<EOL><INDENT>packages=context.getScriptPackages()<EOL><DEDENT>elif createConfig ["type"]=="text":<EOL><INDENT>packages=context.getTextPackages()<EOL><DEDENT>context.window.show_quick_panel(packages,onPackageSelected,)<EOL>shadowList=packages <EOL><DEDENT>def onPackageSelected(selectionIndex):<EOL><INDENT>global createConfig <EOL>global shadowList <EOL>moduleSuggestiong=shadowList [selectionIndex ]<EOL>if selectionIndex==-:<EOL><INDENT>return <EOL><DEDENT>if selectionIndex==:<EOL><INDENT>moduleSuggestiong=""<EOL><DEDENT>if createConfig ["type"]=="script":<EOL><INDENT>packagePath=context.getBaseDir()+context.settings ["script_folder"]+"/"+moduleSuggestiong <EOL>if os.path.exists(packagePath)==True :<EOL><INDENT>createConfig ["packageBase"]=context.settings ["script_folder"]<EOL><DEDENT> <DEDENT>elif createConfig ["type"]=="text":<EOL><INDENT>packagePath=context.getBaseDir()+context.settings ["text_folder"]+"/"+moduleSuggestiong <EOL>if os.path.exists(packagePath)==True :<EOL><INDENT>createConfig ["packageBase"]=context.settings ["text_folder"]<EOL><DEDENT> <DEDENT>context.window.show_input_panel('<STR_LIT>',moduleSuggestiong +createConfig ["name"],onNameDone,onNameChange,onNamceCancle)<EOL><DEDENT>def onNameDone(inputString):<EOL><INDENT>global createConfig <EOL>global context <EOL>global shadowList <EOL>moduleFile=context.getBaseDir()+createConfig ["packageBase"]+"/"+inputString <EOL>createConfig ["moduleFile"]=moduleFile <EOL>print moduleFile <EOL>name=moduleFile [moduleFile.rfind("/"):]<EOL>if not "."in name :<EOL><INDENT>if createConfig ["type"]=="script":<EOL><INDENT>ext=".js"<EOL>name +=ext <EOL><DEDENT>elif createConfig ["type"]=="text":<EOL><INDENT>ext=".html"<EOL>name +=ext <EOL><DEDENT> <DEDENT>else :<EOL><INDENT>ext=name [name.rfind("."):]<EOL><DEDENT>moduleDir=moduleFile [:moduleFile.rfind("/")]<EOL>moduleFile=moduleDir +name <EOL>createConfig ["moduleFile"]=moduleFile <EOL>if os.path.exists(moduleDir)==False :<EOL><INDENT>os.makedirs(moduleDir)<EOL><DEDENT>if len(context.settings ['<STR_LIT>'])>:<EOL><INDENT>snippetsDir=context.getBaseDir()+context.settings ['<STR_LIT>']<EOL>snippets=[]<EOL>shadowList=[]<EOL>snippets.append("Blank")<EOL>shadowList.append("")<EOL>for file in os.listdir(snippetsDir):<EOL><INDENT>dirfile=os.path.join(snippetsDir,file)<EOL>if os.path.isfile(dirfile):<EOL><INDENT>print "TEST.="+str(ntpath.basename(file)[:]),str(ntpath.basename(file)[:])is "."<EOL>if "DS_Store"not in ntpath.basename(file):<EOL><INDENT>snippets.append(ntpath.basename(file))<EOL>shadowList.append(dirfile)<EOL><DEDENT> <DEDENT> <DEDENT>context.window.show_quick_panel(snippets,onSnippetSelected,)<EOL><DEDENT>else :<EOL><INDENT>finish("")<EOL><DEDENT> <DEDENT>def onSnippetSelected(selectionIndex):<EOL><INDENT>global shadowList <EOL>if selectionIndex==:<EOL><INDENT>finish("")<EOL><DEDENT>else :<EOL><INDENT>moduleName=createConfig ["moduleFile"][createConfig ["moduleFile"].rfind("/")+:createConfig ["moduleFile"].rfind(".")]<EOL>f=open(shadowList [selectionIndex ],"r")<EOL>data=f.read()<EOL>snippet=data <EOL>snippet=snippet.replace("$MODULE_NAME",moduleName)<EOL>f.close()<EOL>finish(snippet)<EOL><DEDENT> <DEDENT>def finish(snippet):<EOL><INDENT>global createConfig <EOL>global context <EOL>fileContent=""<EOL>if createConfig ["type"]=="script":<EOL><INDENT>fileContent='<STR_LIT>'<EOL>if len(context.settings ["auto_add"])>:<EOL><INDENT>for module in context.settings ["auto_add"]:<EOL><INDENT>addEdit=editor.ModuleEdit(fileContent,context)<EOL>addEdit.addModule(context.getModuleByImportString(module),module)<EOL>fileContent=addEdit.render()+"\n"+snippet +"\n});"<EOL><DEDENT> <DEDENT> <DEDENT>file=open(createConfig ["moduleFile"],'w+')<EOL>file.write(fileContent)<EOL>file.close()<EOL>if createConfig ["type"]=="script":<EOL><INDENT>temp=(createConfig ["moduleFile"]).split(context.getBaseDir()+createConfig ["packageBase"]+"/")[];<EOL>importString=temp [:temp.rfind(".")]<EOL><DEDENT>elif createConfig ["type"]=="text":<EOL><INDENT>temp=(createConfig ["moduleFile"]).split(context.getBaseDir()+createConfig ["packageBase"]+"/")[];<EOL>importString="text!"+context.settings ["texts_name"]+"/"+temp <EOL><DEDENT>createConfig ["callback"](importString,createConfig)<EOL><DEDENT>def onNameChange(input):<EOL><INDENT>pass <EOL><DEDENT>def onNamceCancle(input):<EOL><INDENT>pass <EOL><DEDENT><EOF><BOF>from zerotest.cli import CLI <EOL>class AttributeDict(object):<EOL><INDENT>def __init__(self,**kwargs):<EOL><INDENT>self.__dict__=kwargs <EOL><DEDENT> <DEDENT>def test_verify_parse_result():<EOL><INDENT>cli=CLI()<EOL>cli._parse_result=AttributeDict(url='invalid.url')<EOL>assert not cli.verify_parse_result()<EOL>cli._parse_result=AttributeDict(url='<STR_LIT>')<EOL>assert cli.verify_parse_result()<EOL>cli._parse_result=AttributeDict(endpoint='invalid.url')<EOL>assert not cli.verify_parse_result()<EOL>cli._parse_result=AttributeDict(endpoint='<STR_LIT>')<EOL>assert cli.verify_parse_result()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>from multiprocessing.pool import ThreadPool <EOL>from digits import *<EOL>try :<EOL><INDENT>import cloud <EOL>have_cloud=True <EOL><DEDENT>except ImportError :<EOL><INDENT>have_cloud=False <EOL><DEDENT>def cross_validate(model_class,params,samples,labels,kfold=,pool=None):<EOL><INDENT>n=len(samples)<EOL>folds=np.array_split(np.arange(n),kfold)<EOL>def f(i):<EOL><INDENT>model=model_class(**params)<EOL>test_idx=folds [i ]<EOL>train_idx=list(folds)<EOL>train_idx.pop(i)<EOL>train_idx=np.hstack(train_idx)<EOL>train_samples,train_labels=samples [train_idx ],labels [train_idx ]<EOL>test_samples,test_labels=samples [test_idx ],labels [test_idx ]<EOL>model.train(train_samples,train_labels)<EOL>resp=model.predict(test_samples)<EOL>score=(resp !=test_labels).mean()<EOL>print ".",<EOL>return score <EOL><DEDENT>if pool is None :<EOL><INDENT>scores=map(f,xrange(kfold))<EOL><DEDENT>else :<EOL><INDENT>scores=pool.map(f,xrange(kfold))<EOL><DEDENT>return np.mean(scores)<EOL><DEDENT>class App(object):<EOL><INDENT>def __init__(self,usecloud=False,cloud_env=''):<EOL><INDENT>if usecloud and not have_cloud :<EOL><INDENT>print '<STR_LIT>'<EOL>usecloud=False <EOL><DEDENT>self.usecloud=usecloud <EOL>self.cloud_env=cloud_env <EOL>if self.usecloud :<EOL><INDENT>print '<STR_LIT>'<EOL>cloud.files.put(DIGITS_FN)<EOL>self.preprocess_job=cloud.call(self.preprocess,_env=self.cloud_env)<EOL><DEDENT>else :<EOL><INDENT>self._samples,self._labels=self.preprocess()<EOL><DEDENT> <DEDENT>def preprocess(self):<EOL><INDENT>if self.usecloud :<EOL><INDENT>cloud.files.get(DIGITS_FN)<EOL><DEDENT>digits,labels=load_digits(DIGITS_FN)<EOL>shuffle=np.random.permutation(len(digits))<EOL>digits,labels=digits [shuffle ],labels [shuffle ]<EOL>digits2=map(deskew,digits)<EOL>samples=preprocess_hog(digits2)<EOL>return samples,labels <EOL><DEDENT>def get_dataset(self):<EOL><INDENT>if self.usecloud :<EOL><INDENT>return cloud.result(self.preprocess_job)<EOL><DEDENT>else :<EOL><INDENT>return self._samples,self._labels <EOL><DEDENT> <DEDENT>def run_jobs(self,f,jobs):<EOL><INDENT>if self.usecloud :<EOL><INDENT>jids=cloud.map(f,jobs,_env=self.cloud_env,_profile=True,_depends_on=self.preprocess_job)<EOL>ires=cloud.iresult(jids)<EOL><DEDENT>else :<EOL><INDENT>pool=ThreadPool(processes=cv2.getNumberOfCPUs())<EOL>ires=pool.imap_unordered(f,jobs)<EOL><DEDENT>return ires <EOL><DEDENT>def adjust_SVM(self):<EOL><INDENT>Cs=np.logspace(,,,base=)<EOL>gammas=np.logspace(-,,,base=)<EOL>scores=np.zeros((len(Cs),len(gammas)))<EOL>scores [:]=np.nan <EOL>print '<STR_LIT>'<EOL>def f(job):<EOL><INDENT>i,j=job <EOL>samples,labels=self.get_dataset()<EOL>params=dict(C=Cs [i ],gamma=gammas [j ])<EOL>score=cross_validate(SVM,params,samples,labels)<EOL>return i,j,score <EOL><DEDENT>ires=self.run_jobs(f,np.ndindex(*scores.shape))<EOL>for count,(i,j,score)in enumerate(ires):<EOL><INDENT>scores [i,j ]=score <EOL>print '<STR_LIT>'%(count +,scores.size,np.nanmin(scores)*,score *)<EOL><DEDENT>print scores <EOL>print '<STR_LIT>'<EOL>np.savez('svm_scores.npz',scores=scores,Cs=Cs,gammas=gammas)<EOL>i,j=np.unravel_index(scores.argmin(),scores.shape)<EOL>best_params=dict(C=Cs [i ],gamma=gammas [j ])<EOL>print 'best params:',best_params <EOL>print '<STR_LIT>'%(scores.min()*)<EOL>return best_params <EOL><DEDENT>def adjust_KNearest(self):<EOL><INDENT>print '<STR_LIT>'<EOL>def f(k):<EOL><INDENT>samples,labels=self.get_dataset()<EOL>err=cross_validate(KNearest,dict(k=k),samples,labels)<EOL>return k,err <EOL><DEDENT>best_err,best_k=np.inf,-<EOL>for k,err in self.run_jobs(f,xrange(,)):<EOL><INDENT>if err <best_err :<EOL><INDENT>best_err,best_k=err,k <EOL><DEDENT>print '<STR_LIT>'%(k,err *)<EOL><DEDENT>best_params=dict(k=best_k)<EOL>print 'best params:',best_params,'err: %.2f'%(best_err *)<EOL>return best_params <EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>import getopt <EOL>import sys <EOL>print __doc__ <EOL>args,_=getopt.getopt(sys.argv [:],'',['model=','cloud','env='])<EOL>args=dict(args)<EOL>args.setdefault('--model','svm')<EOL>args.setdefault('--env','')<EOL>if args ['--model']not in ['svm','knearest']:<EOL><INDENT>print '<STR_LIT>'%args ['--model']<EOL>sys.exit()<EOL><DEDENT>t=clock()<EOL>app=App(usecloud='--cloud'in args,cloud_env=args ['--env'])<EOL>if args ['--model']=='knearest':<EOL><INDENT>app.adjust_KNearest()<EOL><DEDENT>else :<EOL><INDENT>app.adjust_SVM()<EOL><DEDENT>print 'work time: %f s'%(clock()-t)<EOL><DEDENT><EOF><BOF>from robot import model,utils <EOL>from.message import Message <EOL>class Keyword(model.Keyword):<EOL><INDENT>__slots__=['status','starttime','endtime']<EOL>message_class=Message <EOL>def __init__(self,name='',doc='',args=None,type='kw',timeout='',<EOL>status='FAIL',starttime=None,endtime=None):<EOL><INDENT> '<STR_LIT>'<EOL>model.Keyword.__init__(self,name,doc,args,type,timeout)<EOL>self.status=status <EOL>self.starttime=starttime <EOL>self.endtime=endtime <EOL><DEDENT>@property <EOL>def elapsedtime(self):<EOL><INDENT>return utils.get_elapsed_time(self.starttime,self.endtime)<EOL><DEDENT>@property <EOL>def passed(self):<EOL><INDENT>return self.status=='PASS'<EOL><DEDENT> <DEDENT><EOF><BOF>import cv2 <EOL>import numpy as np <EOL>from cam import OpenCV_Cam <EOL>if __name__=='__main__':<EOL><INDENT>cam=OpenCV_Cam()<EOL>w,h=cam.size <EOL>cam.set('EXPOSURE',)<EOL>dst=np.full((h,w,),,dtype=np.uint8)<EOL>exp_list=range(-,-,-)<EOL>ratio=/len(exp_list)<EOL>for e in exp_list :<EOL><INDENT>cam.set('EXPOSURE',e)<EOL>img=None <EOL>while img is None :<EOL><INDENT>img=cam.read()<EOL><DEDENT>dst=cv2.addWeighted(dst,,img,ratio,)<EOL>cv2.imshow(str(e),img)<EOL>cv2.imshow('dst'+str(e),dst)<EOL>cv2.waitKey()<EOL><DEDENT>cv2.imshow('mix',dst)<EOL>k=cv2.waitKey()<DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import cv2 <EOL>import numpy as np <EOL>import sys <EOL>print __doc__ <EOL>try :<EOL><INDENT>fn=sys.argv []<EOL><DEDENT>except :<EOL><INDENT>fn='<STR_LIT>'<EOL><DEDENT>src=cv2.imread(fn,)<EOL>img=cv2.cvtColor(src,cv2.COLOR_BGR2GRAY)<EOL>img=cv2.medianBlur(img,)<EOL>cimg=src.copy()<EOL>circles=cv2.HoughCircles(img,cv2.HOUGH_GRADIENT,,,np.array([]),,,,)<EOL>a,b,c=circles.shape <EOL>for i in range(b):<EOL><INDENT>cv2.circle(cimg,(circles [][i ][],circles [][i ][]),circles [][i ][],(,,),,cv2.LINE_AA)<EOL>cv2.circle(cimg,(circles [][i ][],circles [][i ][]),,(,,),,cv2.LINE_AA)<EOL><DEDENT>cv2.imshow("source",src)<EOL>cv2.imshow('<STR_LIT>',cimg)<EOL>cv2.waitKey()<EOF><BOF>import numpy as np <EOL>import cv2 <EOL>from webcam_gui import webcam_gui <EOL>def edge_filter(frame_in):<EOL><INDENT>frame_gray=cv2.cvtColor(frame_in,cv2.COLOR_BGR2GRAY)<EOL>frame_blur=cv2.blur(frame_gray,(,))<EOL>frame_out=cv2.Canny(frame_blur,,)<EOL>return frame_out <EOL><DEDENT>def threshold(frame_in,min):<EOL><INDENT>frame_blur=cv2.blur(frame_in,(,))<EOL>thresh1,thresh=cv2.threshold(frame_blur,min,,cv2.THRESH_BINARY)<EOL>frame_out=thresh <EOL>return frame_out <EOL><DEDENT>def adap_threshold(frame_in):<EOL><INDENT>frame_blur=cv2.blur(frame_in,(,))<EOL>thresh=cv2.adaptiveThreshold(frame_blur,,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,,)<EOL>frame_out=thresh <EOL>return frame_out <EOL><DEDENT>def canny_filter(frame_in):<EOL><INDENT>frame_blur=cv2.blur(frame_in,(,))<EOL>canny=cv2.Canny(frame_blur,,)<EOL>frame_out=canny <EOL>return frame_out <EOL><DEDENT>def gray_filter(frame_in):<EOL><INDENT>frame_out=cv2.cvtColor(frame_in,cv2.COLOR_BGR2GRAY)<EOL>return frame_out <EOL><DEDENT>def angle_cos(p0,p1,p2):<EOL><INDENT>d1,d2=(p0 -p1).astype('float'),(p2 -p1).astype('float')<EOL>return abs(np.dot(d1,d2)/np.sqrt(np.dot(d1,d1)*np.dot(d2,d2)))<EOL><DEDENT>def equal(p0,p1,p2,tolerance):<EOL><INDENT>d1,d2=(p0 -p1).astype('float'),(p2 -p1).astype('float')<EOL>l1=np.sqrt(d1 []**+d1 []**)<EOL>l2=np.sqrt(d2 []**+d2 []**)<EOL>if l1 <=l2 *(+tolerance)and l1 >=l2 *(-tolerance):<EOL><INDENT>return True <EOL><DEDENT>else :<EOL><INDENT>return False <EOL><DEDENT> <DEDENT>def find_square(frame_in):<EOL><INDENT>frame_out=frame_in.copy()<EOL>frame_gray=cv2.cvtColor(frame_in,cv2.COLOR_BGR2GRAY)<EOL>thresh=adap_threshold(frame_gray)<EOL>frame_blur=cv2.blur(thresh,(,))<EOL>contours,hry=cv2.findContours(frame_blur,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)<EOL>squares=[]<EOL>for cnt in contours :<EOL><INDENT>cnt_len=cv2.arcLength(cnt,True)<EOL>cnt=cv2.approxPolyDP(cnt,*cnt_len,True)<EOL>if cv2.contourArea(cnt)>and len(cnt)==and cv2.isContourConvex(cnt):<EOL><INDENT>cnt=cnt.reshape(-,)<EOL>max_cos=np.max([angle_cos(cnt [i ],cnt [(i +)%],cnt [(i +)%])for i in xrange()])<EOL>if max_cos <and equal(cnt [],cnt [],cnt [],):<EOL><INDENT>squares.append(cnt)<EOL><DEDENT> <DEDENT> <DEDENT>cv2.drawContours(frame_out,squares,-,(,,),)<EOL>return frame_out <EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>webcam_gui(find_square)<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import os <EOL>import yapper as application <EOL>env=os.getenv('FLASK_CONFIG')<EOL>if env is None or env not in ["test","prod"]:<EOL><INDENT>env="dev"<EOL><DEDENT>app=application.create_app(env)<EOL>if __name__=="__main__":<EOL><INDENT>app.run(host="0.0.0.0",port=,debug=True)<EOL><DEDENT><EOF><BOF>from robot.utils import setter <EOL>from.itemlist import ItemList <EOL>from.keyword import Keyword,Keywords <EOL>from.modelobject import ModelObject <EOL>from.tags import Tags <EOL>class TestCase(ModelObject):<EOL><INDENT>__slots__=['parent','name','doc','timeout']<EOL>keyword_class=Keyword <EOL>def __init__(self,name='',doc='',tags=None,timeout=''):<EOL><INDENT>self.parent=None <EOL>self.name=name <EOL>self.doc=doc <EOL>self.tags=tags <EOL>self.timeout=timeout <EOL>self.keywords=[]<EOL><DEDENT>@setter <EOL>def tags(self,tags):<EOL><INDENT>return Tags(tags)<EOL><DEDENT>@setter <EOL>def keywords(self,keywords):<EOL><INDENT>return Keywords(self.keyword_class,self,keywords)<EOL><DEDENT>@property <EOL>def id(self):<EOL><INDENT>if not self.parent :<EOL><INDENT>return 't1'<EOL><DEDENT>return '%s-t%d'%(self.parent.id,self.parent.tests.index(self)+)<EOL><DEDENT>@property <EOL>def longname(self):<EOL><INDENT>if not self.parent :<EOL><INDENT>return self.name <EOL><DEDENT>return '%s.%s'%(self.parent.longname,self.name)<EOL><DEDENT>@property <EOL>def critical(self):<EOL><INDENT>if not self.parent :<EOL><INDENT>return True <EOL><DEDENT>return self.parent.criticality.test_is_critical(self)<EOL><DEDENT>def visit(self,visitor):<EOL><INDENT>visitor.visit_test(self)<EOL><DEDENT> <DEDENT>class TestCases(ItemList):<EOL><INDENT>__slots__=[]<EOL>def __init__(self,test_class=TestCase,parent=None,tests=None):<EOL><INDENT>ItemList.__init__(self,test_class,{'parent':parent },tests)<EOL><DEDENT> <DEDENT><EOF><BOF>from pyspark import SparkConf,SparkContext <EOL>from pyspark.mllib.clustering import LDA,LDAModel <EOL>from pyspark.mllib.linalg import Vectors <EOL>import numpy as np <EOL>def vectorizer(sentence,vocab):<EOL><INDENT> '<STR_LIT>'<EOL>vocabulary=vocab.value <EOL>vec=np.zeros(len(vocabulary))<EOL>for word in sentence.split(" "):<EOL><INDENT>if word in vocabulary :<EOL><INDENT>vec [vocabulary.index(word)]+=<EOL><DEDENT> <DEDENT>return Vectors.dense(vec)<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>conf=SparkConf().setAppName("LDA")<EOL>sc=SparkContext(conf=conf)<EOL>tolstoy=sc.textFile('<STR_LIT>')<EOL>sentences=tolstoy.filter(lambda s :len(s)>)<EOL>word_counts=sentences.flatMap(lambda s :s.split(" ")).map(lambda w :(w.lower(),)).reduceByKey(lambda a,b :a +b)<EOL>top_words=word_counts.takeOrdered(,key=lambda(w,c):-c)<EOL>vocabulary=[str(k)for(k,v)in top_words ]<EOL>br_vocabulary=sc.broadcast(vocabulary)<EOL>dense_vectors=sentences.map(lambda s :vectorizer(s,br_vocabulary))<EOL>corpus=dense_vectors.zipWithIndex().map(lambda(v,i):[i,v ])<EOL>lda_model=LDA.train(corpus,k=,maxIterations=)<EOL>print('<STR_LIT>'+str(lda_model.vocabSize())+" words):")<EOL>topics=lda_model.topicsMatrix()<EOL>for topic in range(topics.shape []):<EOL><INDENT>print("Topic "+str(topic)+":")<EOL>topic_word_counts=sorted(zip(vocabulary,lda_model.topicsMatrix()[:,topic ]),key=lambda(w,c):-c)<EOL>top_words=[w for(w,c)in topic_word_counts [:]]<EOL>print top_words <DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import cv2 <EOL>from time import clock <EOL>class OpenCV_Cam(object):<EOL><INDENT>def __init__(self,src=None):<EOL><INDENT>self.start_cam(src)<EOL>self.__fcount,self.__frate,self.__start=,,clock()<EOL><DEDENT>@staticmethod <EOL>def cam_count():<EOL><INDENT>cam_idx=<EOL>cap=cv2.VideoCapture(cam_idx)<EOL>while cap.read()[]:<EOL><INDENT>cam_idx +=<EOL>cap=cv2.VideoCapture(cam_idx)<EOL><DEDENT>return cam_idx <EOL><DEDENT>def start_cam(self,src=None):<EOL><INDENT>if src is not None :<EOL><INDENT>self.cam=VideoCapture(src)<EOL>if not self.cam.isOpened():<EOL><INDENT>raise ValueError('Cannot open '+src +'as VideoCapture')<EOL><DEDENT>return <EOL><DEDENT>idx=<EOL>cam1,cam2=cv2.VideoCapture(),cv2.VideoCapture()<EOL>while(cam2.read()[]):<EOL><INDENT>cam1.release()<EOL>cam1=cam2 <EOL>idx +=<EOL>cam2=cv2.VideoCapture(idx)<EOL><DEDENT>self.cam=cam1 <EOL>if not self.cam.isOpened():<EOL><INDENT>raise Error('<STR_LIT>')<EOL><DEDENT> <DEDENT>@property <EOL>def size(self):<EOL><INDENT>w=self.cam.get(cv2.cv.CV_CAP_PROP_FRAME_WIDTH)<EOL>h=self.cam.get(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT)<EOL>return(int(w),int(h))<EOL><DEDENT>@size.setter <EOL>def size(self,shape):<EOL><INDENT>self.cam.set(cv2.cv.CV_CAP_PROP_FRAME_WIDTH,shape [])<EOL>self.cam.set(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT,shape [])<EOL><DEDENT>def read(self):<EOL><INDENT>self.__fcount +=<EOL>self.__frame=self.cam.read()[]<EOL>if self.__fcount==:<EOL><INDENT>end=clock()<EOL>self.__frate=/(end -self.__start)<EOL>self.__start=clock()<EOL>self.__fcount=<EOL><DEDENT>return self.__frame <EOL><DEDENT>@property <EOL>def frame_rate(self):<EOL><INDENT>return self.__frate <EOL><DEDENT>@property <EOL>def info(self):<EOL><INDENT>vars=[x [:]for x in dir(cv2.cv)if 'CV_CAP_PROP'in x ]<EOL>ret={}<EOL>for p in vars :<EOL><INDENT>cmd='ret[\''+p +'<STR_LIT>'+p +')'<EOL>exec cmd <EOL><DEDENT>return ret <EOL><DEDENT>def set(self,property,value):<EOL><INDENT>cmd='<STR_LIT>'+property +', '+str(value)+')'<EOL>print cmd <EOL>exec cmd <EOL><DEDENT>def cam_loop(self,func=lambda x :x,params=()):<EOL><INDENT>while True :<EOL><INDENT>input=self.read()<EOL>output=func(input,*params)<EOL>window_name=func.__name__ <EOL>if window_name=='<lambda>':window_name='camera image'<EOL>cv2.imshow(window_name,output)<EOL>k=cv2.waitKey()<EOL>if k==:<EOL><INDENT>break <EOL><DEDENT>elif k==ord('p'):<EOL><INDENT>info=self.info <EOL>for i in info :<EOL><INDENT>print i,'=',info [i ]<EOL><DEDENT> <DEDENT>elif k==ord('s'):<EOL><INDENT>p=raw_input('type property:')<EOL>if('<STR_LIT>'+p)not in dir(cv2.cv):<EOL><INDENT>print p,'<STR_LIT>'<EOL>print '<STR_LIT>',[x [:]for x in dir(cv2.cv)if 'CV_CAP_PROP'in x ]<EOL><DEDENT>else :<EOL><INDENT>v=raw_input('type value:')<EOL>self.set(p,v)<EOL><DEDENT> <DEDENT>elif k==ord('f'):<EOL><INDENT>print self.frame_rate <EOL><DEDENT> <DEDENT> <DEDENT>def __enter__(self):<EOL><INDENT>return self <EOL><DEDENT>def __exit__(self,exc_type,exc_value,traceback):<EOL><INDENT>self.cam.release()<EOL><DEDENT>def release(self):<EOL><INDENT>self.cam.release()<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>cam=OpenCV_Cam()<EOL>cam.size=(,)<EOL>info=cam.info <EOL>for i in info :<EOL><INDENT>print i,'=',info [i ]<EOL><DEDENT>cam.cam_loop()<EOL><DEDENT><EOF><BOF>import unittest <EOL>from yapper import create_app,db <EOL>from yapper.blueprints.user.models import User,Role <EOL>class TestUserAddToDb(unittest.TestCase):<EOL><INDENT>def setUp(self):<EOL><INDENT>self.app=create_app('test')<EOL>self.app_context=self.app.app_context()<EOL>self.app_context.push()<EOL>db.create_all()<EOL><DEDENT>def tearDown(self):<EOL><INDENT>db.session.remove()<EOL>db.drop_all()<EOL>self.app_context.pop()<EOL><DEDENT>def test_role_gets_id(self):<EOL><INDENT>role=Role(name='admin')<EOL>self.assertTrue(role.id is None)<EOL>db.session.add(role)<EOL>db.session.commit()<EOL>self.assertFalse(role.id is None)<EOL><DEDENT>def test_user_gets_role_and_id(self):<EOL><INDENT>role=Role(name='administrator')<EOL>self.assertTrue(role.id is None)<EOL>user=User(email='b2@gmail.com',password='1234',role=role)<EOL>self.assertTrue(user.id is None)<EOL>db.session.add(user)<EOL>db.session.commit()<EOL>self.assertFalse(role.id is None)<EOL>self.assertFalse(user.id is None)<EOL>self.assertTrue(user.role_id==role.id)<EOL>self.assertTrue(user.is_admin())<EOL><DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import cv2 <EOL>from time import clock <EOL>class OpenCV_Cam(object):<EOL><INDENT>def __init__(self,src=None):<EOL><INDENT>self.start_cam(src)<EOL>self.__fcount,self.__frate,self.__start=,,clock()<EOL><DEDENT>@staticmethod <EOL>def cam_count():<EOL><INDENT>cam_idx=<EOL>cap=cv2.VideoCapture(cam_idx)<EOL>while cap.read()[]:<EOL><INDENT>cam_idx +=<EOL>cap=cv2.VideoCapture(cam_idx)<EOL><DEDENT>return cam_idx <EOL><DEDENT>def start_cam(self,src=None):<EOL><INDENT>if src is not None :<EOL><INDENT>self.cam=cv2.VideoCapture(src)<EOL>if not self.cam.isOpened():<EOL><INDENT>raise ValueError('Cannot open '+src +'as VideoCapture')<EOL><DEDENT>return <EOL><DEDENT>idx=<EOL>cam1,cam2=cv2.VideoCapture(),cv2.VideoCapture()<EOL>while(cam2.read()[]):<EOL><INDENT>cam1.release()<EOL>cam1=cam2 <EOL>idx +=<EOL>cam2=cv2.VideoCapture(idx)<EOL><DEDENT>self.cam=cam1 <EOL>if not self.cam.isOpened():<EOL><INDENT>raise Error('<STR_LIT>')<EOL><DEDENT> <DEDENT>@property <EOL>def size(self):<EOL><INDENT>w=self.cam.get(cv2.cv.CV_CAP_PROP_FRAME_WIDTH)<EOL>h=self.cam.get(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT)<EOL>return(int(w),int(h))<EOL><DEDENT>@size.setter <EOL>def size(self,shape):<EOL><INDENT>self.cam.set(cv2.cv.CV_CAP_PROP_FRAME_WIDTH,shape [])<EOL>self.cam.set(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT,shape [])<EOL><DEDENT>def read(self):<EOL><INDENT>self.__fcount +=<EOL>self.__frame=self.cam.read()[]<EOL>if self.__fcount==:<EOL><INDENT>end=clock()<EOL>self.__frate=/(end -self.__start)<EOL>self.__start=clock()<EOL>self.__fcount=<EOL><DEDENT>return self.__frame <EOL><DEDENT>@property <EOL>def frame_rate(self):<EOL><INDENT>return self.__frate <EOL><DEDENT>@property <EOL>def info(self):<EOL><INDENT>vars=[x [:]for x in dir(cv2.cv)if 'CV_CAP_PROP'in x ]<EOL>ret={}<EOL>for p in vars :<EOL><INDENT>cmd='ret[\''+p +'<STR_LIT>'+p +')'<EOL>exec cmd <EOL><DEDENT>return ret <EOL><DEDENT>def set(self,property,value):<EOL><INDENT>cmd='<STR_LIT>'+property +', '+str(value)+')'<EOL>print cmd <EOL>exec cmd <EOL><DEDENT>def cam_loop(self,func=lambda x :x,params=()):<EOL><INDENT>while True :<EOL><INDENT>input=self.read()<EOL>output=func(input,*params)<EOL>window_name=func.__name__ <EOL>if window_name=='<lambda>':window_name='camera image'<EOL>cv2.imshow(window_name,output)<EOL>k=cv2.waitKey()<EOL>if k==:<EOL><INDENT>break <EOL><DEDENT>elif k==ord('p'):<EOL><INDENT>info=self.info <EOL>for i in info :<EOL><INDENT>print i,'=',info [i ]<EOL><DEDENT> <DEDENT>elif k==ord('s'):<EOL><INDENT>p=raw_input('type property:')<EOL>if('<STR_LIT>'+p)not in dir(cv2.cv):<EOL><INDENT>print p,'<STR_LIT>'<EOL>print '<STR_LIT>',[x [:]for x in dir(cv2.cv)if 'CV_CAP_PROP'in x ]<EOL><DEDENT>else :<EOL><INDENT>v=raw_input('type value:')<EOL>self.set(p,v)<EOL><DEDENT> <DEDENT>elif k==ord('f'):<EOL><INDENT>print self.frame_rate <EOL><DEDENT> <DEDENT> <DEDENT>def __enter__(self):<EOL><INDENT>return self <EOL><DEDENT>def __exit__(self,exc_type,exc_value,traceback):<EOL><INDENT>self.cam.release()<EOL><DEDENT>def release(self):<EOL><INDENT>self.cam.release()<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>cam=OpenCV_Cam()<EOL>cam.size=(,)<EOL>info=cam.info <EOL>for i in info :<EOL><INDENT>print i,'=',info [i ]<EOL><DEDENT>cam.cam_loop()<EOL><DEDENT><EOF><BOF>from robot import utils <EOL>from robot.common import BaseTestSuite,BaseTestCase <EOL>from robot.parsing import TestData <EOL>from robot.errors import ExecutionFailed,DataError <EOL>from robot.variables import GLOBAL_VARIABLES <EOL>from robot.output import LOGGER <EOL>from.fixture import(Setup,Teardown,SuiteSetupListener,SuiteTearDownListener,<EOL>TestSetupListener,TestTeardownListener)<EOL>from.keywords import Keywords <EOL>from.namespace import Namespace <EOL>from.runerrors import SuiteRunErrors,TestRunErrors <EOL>from.userkeyword import UserLibrary <EOL>from.context import EXECUTION_CONTEXTS <EOL>from.defaultvalues import DefaultValues <EOL>def TestSuite(datasources,settings):<EOL><INDENT> '<STR_LIT>'<EOL>if isinstance(datasources,basestring):<EOL><INDENT>datasources=[datasources ]<EOL><DEDENT>datasources=[utils.abspath(path)for path in datasources ]<EOL>suite=_get_suite(datasources,settings ['SuiteNames'],settings ['WarnOnSkipped'])<EOL>suite.set_options(settings)<EOL>_check_suite_contains_tests(suite,settings ['RunEmptySuite'])<EOL>return suite <EOL><DEDENT>def _get_suite(datasources,include_suites,warn_on_skipped):<EOL><INDENT>if not datasources :<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>if len(datasources)>:<EOL><INDENT>return _get_multisource_suite(datasources,include_suites,warn_on_skipped)<EOL><DEDENT>return RunnableTestSuite(_parse_suite(datasources [],include_suites,warn_on_skipped))<EOL><DEDENT>def _parse_suite(path,include_suites,warn_on_skipped):<EOL><INDENT>try :<EOL><INDENT>return TestData(source=path,include_suites=include_suites,warn_on_skipped=warn_on_skipped)<EOL><DEDENT>except DataError,err :<EOL><INDENT>raise DataError('<STR_LIT>'%(path,unicode(err)))<EOL><DEDENT> <DEDENT>def _get_multisource_suite(datasources,include_suites,warn_on_skipped):<EOL><INDENT>suitedatas=[]<EOL>for datasource in datasources :<EOL><INDENT>try :<EOL><INDENT>suitedatas.append(_parse_suite(datasource,include_suites,warn_on_skipped))<EOL><DEDENT>except DataError,err :<EOL><INDENT>LOGGER.warn(err)<EOL><DEDENT> <DEDENT>suite=RunnableMultiTestSuite(suitedatas)<EOL>if suite.get_test_count()==:<EOL><INDENT>raise DataError('<STR_LIT>'<EOL>%utils.seq2str(datasources))<EOL><DEDENT>return suite <EOL><DEDENT>def _check_suite_contains_tests(suite,run_empty_suites=False):<EOL><INDENT>suite.filter_empty_suites()<EOL>if not suite.get_test_count()and not run_empty_suites :<EOL><INDENT>raise DataError('<STR_LIT>'%(suite.source))<EOL><DEDENT> <DEDENT>class RunnableTestSuite(BaseTestSuite):<EOL><INDENT>def __init__(self,data,parent=None,defaults=None):<EOL><INDENT>BaseTestSuite.__init__(self,data.name,data.source,parent)<EOL>self.variables=GLOBAL_VARIABLES.copy()<EOL>self.variables.set_from_variable_table(data.variable_table)<EOL>self.source=data.source <EOL>self.doc=data.setting_table.doc.value <EOL>self.metadata=self._get_metadata(data.setting_table.metadata)<EOL>self.imports=data.imports <EOL>self.user_keywords=UserLibrary(data.keywords)<EOL>self.setup=Setup(data.setting_table.suite_setup.name,<EOL>data.setting_table.suite_setup.args)<EOL>self.teardown=Teardown(data.setting_table.suite_teardown.name,<EOL>data.setting_table.suite_teardown.args)<EOL>defaults=DefaultValues(data.setting_table,defaults)<EOL>for suite in data.children :<EOL><INDENT>RunnableTestSuite(suite,parent=self,defaults=defaults)<EOL><DEDENT>for test in data.testcase_table :<EOL><INDENT>RunnableTestCase(test,parent=self,defaults=defaults)<EOL><DEDENT>self._run_mode_exit_on_failure=False <EOL>self._run_mode_dry_run=False <EOL>self._run_mode_skip_teardowns_on_exit=False <EOL><DEDENT>def filter_empty_suites(self):<EOL><INDENT>for suite in self.suites [:]:<EOL><INDENT>suite.filter_empty_suites()<EOL>if suite.get_test_count()==:<EOL><INDENT>self.suites.remove(suite)<EOL>LOGGER.info('<STR_LIT>'<EOL>'<STR_LIT>'%(suite.source))<EOL><DEDENT> <DEDENT> <DEDENT>def _get_metadata(self,metadata):<EOL><INDENT>meta=utils.NormalizedDict()<EOL>for item in metadata :<EOL><INDENT>meta [item.name ]=item.value <EOL><DEDENT>return meta <EOL><DEDENT>def run(self,output,parent=None,errors=None):<EOL><INDENT>context=self._start_run(output,parent,errors)<EOL>self._run_setup(context)<EOL>self._run_sub_suites(context)<EOL>self._run_tests(context)<EOL>self._report_status(context)<EOL>self._run_teardown(context)<EOL>self._end_run(context)<EOL><DEDENT>def _start_run(self,output,parent,errors):<EOL><INDENT>if not errors :<EOL><INDENT>errors=SuiteRunErrors(self._run_mode_exit_on_failure,self._run_mode_skip_teardowns_on_exit)<EOL><DEDENT>self.run_errors=errors <EOL>self.run_errors.start_suite()<EOL>self.status='RUNNING'<EOL>self.starttime=utils.get_timestamp()<EOL>parent_vars=parent.context.get_current_vars()if parent else None <EOL>ns=Namespace(self,parent_vars)<EOL>self.context=EXECUTION_CONTEXTS.start_suite(ns,output,self._run_mode_dry_run)<EOL>if not errors.exit :<EOL><INDENT>ns.handle_imports()<EOL><DEDENT>self._set_variable_dependent_metadata(self.context)<EOL>output.start_suite(self)<EOL>return self.context <EOL><DEDENT>def _set_variable_dependent_metadata(self,context):<EOL><INDENT>errors=[]<EOL>self.doc=context.replace_vars_from_setting('Documentation',self.doc,<EOL>errors)<EOL>self.setup.replace_variables(context.get_current_vars(),errors)<EOL>self.teardown.replace_variables(context.get_current_vars(),errors)<EOL>for name,value in self.metadata.items():<EOL><INDENT>self.metadata [name ]=context.replace_vars_from_setting(name,value,<EOL>errors)<EOL><DEDENT>if errors :<EOL><INDENT>self.run_errors.suite_init_err('<STR_LIT>'<EOL>%'\n'.join(errors))<EOL><DEDENT> <DEDENT>def _run_setup(self,context):<EOL><INDENT>if self.run_errors.is_suite_setup_allowed():<EOL><INDENT>self.setup.run(context,SuiteSetupListener(self))<EOL>self.run_errors.setup_executed()<EOL><DEDENT> <DEDENT>def _run_teardown(self,context):<EOL><INDENT>if self.run_errors.is_suite_teardown_allowed():<EOL><INDENT>self.teardown.run(context,SuiteTearDownListener(self))<EOL><DEDENT> <DEDENT>def _run_sub_suites(self,context):<EOL><INDENT>for suite in self.suites :<EOL><INDENT>suite.run(context.output,self,self.run_errors)<EOL><DEDENT> <DEDENT>def _run_tests(self,context):<EOL><INDENT>executed_tests=[]<EOL>for test in self.tests :<EOL><INDENT>normname=utils.normalize(test.name)<EOL>if normname in executed_tests :<EOL><INDENT>LOGGER.warn('<STR_LIT>'<EOL>"test suite '%s'"%(test.name,self.longname))<EOL><DEDENT>executed_tests.append(normname)<EOL>test.run(context,self.run_errors)<EOL>context.set_prev_test_variables(test)<EOL><DEDENT> <DEDENT>def _report_status(self,context):<EOL><INDENT>self.set_status()<EOL>self.message=self.run_errors.suite_error()<EOL>context.report_suite_status(self.status,self.get_full_message())<EOL><DEDENT>def _end_run(self,context):<EOL><INDENT>self.endtime=utils.get_timestamp()<EOL>self.elapsedtime=utils.get_elapsed_time(self.starttime,self.endtime)<EOL>context.copy_prev_test_vars_to_global()<EOL>context.end_suite(self)<EOL>self.run_errors.end_suite()<EOL><DEDENT> <DEDENT>class RunnableMultiTestSuite(RunnableTestSuite):<EOL><INDENT>def __init__(self,suitedatas):<EOL><INDENT>BaseTestSuite.__init__(self,name='')<EOL>self.variables=GLOBAL_VARIABLES.copy()<EOL>self.doc=''<EOL>self.imports=[]<EOL>self.setup=Setup(None,None)<EOL>self.teardown=Teardown(None,None)<EOL>for suite in suitedatas :<EOL><INDENT>RunnableTestSuite(suite,parent=self)<EOL><DEDENT>self._run_mode_exit_on_failure=False <EOL>self._run_mode_dry_run=False <EOL>self._run_mode_skip_teardowns_on_exit=False <EOL><DEDENT> <DEDENT>class RunnableTestCase(BaseTestCase):<EOL><INDENT>def __init__(self,tc_data,parent,defaults):<EOL><INDENT>BaseTestCase.__init__(self,tc_data.name,parent)<EOL>self.doc=tc_data.doc.value <EOL>self.setup=defaults.get_setup(tc_data.setup)<EOL>self.teardown=defaults.get_teardown(tc_data.teardown)<EOL>self.tags=defaults.get_tags(tc_data.tags)<EOL>self.timeout=defaults.get_timeout(tc_data.timeout)<EOL>self.template=defaults.get_template(tc_data.template)<EOL>self.keywords=Keywords(tc_data.steps,self.template)<EOL><DEDENT>def run(self,context,suite_errors):<EOL><INDENT>self._suite_errors=suite_errors <EOL>self._start_run(context)<EOL>if self.run_errors.is_allowed_to_run():<EOL><INDENT>self._run(context)<EOL><DEDENT>else :<EOL><INDENT>self._not_allowed_to_run()<EOL><DEDENT>self._end_run(context)<EOL><DEDENT>def _start_run(self,context):<EOL><INDENT>self.run_errors=TestRunErrors(self._suite_errors)<EOL>self.status='RUNNING'<EOL>self.starttime=utils.get_timestamp()<EOL>self.run_errors.init_err(self._init_test(context))<EOL>context.start_test(self)<EOL><DEDENT>def _init_test(self,context):<EOL><INDENT>errors=[]<EOL>self.doc=context.replace_vars_from_setting('Documentation',self.doc,<EOL>errors)<EOL>self.setup.replace_variables(context.get_current_vars(),errors)<EOL>self.teardown.replace_variables(context.get_current_vars(),errors)<EOL>tags=context.replace_vars_from_setting('Tags',self.tags,errors)<EOL>self.tags=utils.normalize_tags(tags)<EOL>self.timeout.replace_variables(context.get_current_vars())<EOL>if errors :<EOL><INDENT>return '<STR_LIT>'%'\n'.join(errors)<EOL><DEDENT>if not self.name :<EOL><INDENT>return '<STR_LIT>'<EOL><DEDENT>if not self.keywords :<EOL><INDENT>return '<STR_LIT>'<EOL><DEDENT>return None <EOL><DEDENT>def _run(self,context):<EOL><INDENT>self.timeout.start()<EOL>self._run_setup(context)<EOL>if not self.run_errors.setup_failed():<EOL><INDENT>try :<EOL><INDENT>self.keywords.run(context)<EOL><DEDENT>except ExecutionFailed,err :<EOL><INDENT>self.run_errors.kw_err(unicode(err))<EOL>self.keyword_failed(err)<EOL><DEDENT> <DEDENT>context.set_test_status_before_teardown(*self._report_status())<EOL>self._run_teardown(context)<EOL>self._report_status_after_teardown()<EOL><DEDENT>def keyword_failed(self,err):<EOL><INDENT>self.timeout.set_keyword_timeout(err.timeout)<EOL>self._suite_errors.test_failed(exit=err.exit,critical=self.critical)<EOL><DEDENT>def _run_setup(self,context):<EOL><INDENT>self.setup.run(context,TestSetupListener(self))<EOL><DEDENT>def _report_status(self):<EOL><INDENT>message=self.run_errors.get_message()<EOL>if message :<EOL><INDENT>self.status='FAIL'<EOL>self.message=message <EOL><DEDENT>else :<EOL><INDENT>self.status='PASS'<EOL><DEDENT>return self.message,self.status <EOL><DEDENT>def _run_teardown(self,context):<EOL><INDENT>if self._suite_errors.is_test_teardown_allowed():<EOL><INDENT>self.teardown.run(context,TestTeardownListener(self))<EOL><DEDENT> <DEDENT>def _report_status_after_teardown(self):<EOL><INDENT>if self.run_errors.teardown_failed():<EOL><INDENT>self.status='FAIL'<EOL>self.message=self.run_errors.get_teardown_message(self.message)<EOL><DEDENT>if self.status=='PASS'and self.timeout.timed_out():<EOL><INDENT>self.status='FAIL'<EOL>self.message=self.timeout.get_message()<EOL><DEDENT>if self.status=='FAIL':<EOL><INDENT>self._suite_errors.test_failed(critical=self.critical)<EOL><DEDENT> <DEDENT>def _not_allowed_to_run(self):<EOL><INDENT>self.status='FAIL'<EOL>self.message=self.run_errors.parent_or_init_error()<EOL><DEDENT>def _end_run(self,context):<EOL><INDENT>self.endtime=utils.get_timestamp()<EOL>self.elapsedtime=utils.get_elapsed_time(self.starttime,self.endtime)<EOL>context.end_test(self)<EOL><DEDENT> <DEDENT><EOF><BOF>import telnetlib <EOL>import time <EOL>import re <EOL>import inspect <EOL>from robot.version import get_version <EOL>from robot import utils <EOL>class Telnet :<EOL><INDENT> '<STR_LIT>'<EOL>ROBOT_LIBRARY_SCOPE='TEST_SUITE'<EOL>ROBOT_LIBRARY_VERSION=get_version()<EOL>def __init__(self,timeout=,newline='CRLF',prompt=None,prompt_is_regexp=False):<EOL><INDENT> '<STR_LIT>'<EOL>self._timeout=timeout==''and or timeout <EOL>self._newline=newline==''and 'CRLF'or newline <EOL>self._prompt=(prompt,prompt_is_regexp)<EOL>self._cache=utils.ConnectionCache()<EOL>self._conn=None <EOL>self._conn_kws=self._lib_kws=None <EOL><DEDENT>def get_keyword_names(self):<EOL><INDENT>return self._get_library_keywords()+self._get_connection_keywords()<EOL><DEDENT>def _get_library_keywords(self):<EOL><INDENT>if self._lib_kws is None :<EOL><INDENT>self._lib_kws=[name for name in dir(self)<EOL>if not name.startswith('_')and name !='<STR_LIT>'<EOL>and inspect.ismethod(getattr(self,name))]<EOL><DEDENT>return self._lib_kws <EOL><DEDENT>def _get_connection_keywords(self):<EOL><INDENT>if self._conn_kws is None :<EOL><INDENT>conn=self._get_connection()<EOL>excluded=[name for name in dir(telnetlib.Telnet())<EOL>if name not in ['write','read','read_until']]<EOL>self._conn_kws=[name for name in dir(conn)<EOL>if not name.startswith('_')and name not in excluded <EOL>and inspect.ismethod(getattr(conn,name))]<EOL><DEDENT>return self._conn_kws <EOL><DEDENT>def __getattr__(self,name):<EOL><INDENT>if name not in self._get_connection_keywords():<EOL><INDENT>raise AttributeError(name)<EOL><DEDENT>conn=self._conn is None and self._get_connection()or self._conn <EOL>return getattr(conn,name)<EOL><DEDENT>def open_connection(self,host,alias=None,port=,timeout=None,<EOL>newline=None,prompt=None,prompt_is_regexp=False):<EOL><INDENT> '<STR_LIT>'<EOL>if timeout is None or timeout=='':<EOL><INDENT>timeout=self._timeout <EOL><DEDENT>if newline is None :<EOL><INDENT>newline=self._newline <EOL><DEDENT>if prompt is None :<EOL><INDENT>prompt,prompt_is_regexp=self._prompt <EOL><DEDENT>print '<STR_LIT>'%(host,port,self._prompt)<EOL>self._conn=self._get_connection(host,port,timeout,newline,<EOL>prompt,prompt_is_regexp)<EOL>return self._cache.register(self._conn,alias)<EOL><DEDENT>def _get_connection(self,*args):<EOL><INDENT> '<STR_LIT>'<EOL>return TelnetConnection(*args)<EOL><DEDENT>def switch_connection(self,index_or_alias):<EOL><INDENT> '<STR_LIT>'<EOL>old_index=self._cache.current_index <EOL>self._conn=self._cache.switch(index_or_alias)<EOL>return old_index <EOL><DEDENT>def close_all_connections(self):<EOL><INDENT> '<STR_LIT>'<EOL>self._conn=self._cache.close_all()<EOL><DEDENT> <DEDENT>class TelnetConnection(telnetlib.Telnet):<EOL><INDENT>def __init__(self,host=None,port=,timeout=,newline='CRLF',<EOL>prompt=None,prompt_is_regexp=False):<EOL><INDENT>port=port==''and or int(port)<EOL>telnetlib.Telnet.__init__(self,host,port)<EOL>self.set_timeout(timeout)<EOL>self.set_newline(newline)<EOL>self.set_prompt(prompt,prompt_is_regexp)<EOL>self._default_log_level='INFO'<EOL>self.set_option_negotiation_callback(self._negotiate_echo_on)<EOL><DEDENT>def set_timeout(self,timeout):<EOL><INDENT> '<STR_LIT>'<EOL>old=getattr(self,'_timeout',)<EOL>self._timeout=utils.timestr_to_secs(timeout)<EOL>return utils.secs_to_timestr(old)<EOL><DEDENT>def set_newline(self,newline):<EOL><INDENT> '<STR_LIT>'<EOL>old=getattr(self,'_newline','CRLF')<EOL>self._newline=newline.upper().replace('LF','\n').replace('CR','\r')<EOL>return old <EOL><DEDENT>def close_connection(self,loglevel=None):<EOL><INDENT> '<STR_LIT>'<EOL>telnetlib.Telnet.close(self)<EOL>ret=self.read_all().decode('ASCII','ignore')<EOL>self._log(ret,loglevel)<EOL>return ret <EOL><DEDENT>def login(self,username,password,login_prompt='login: ',<EOL>password_prompt='Password: '):<EOL><INDENT> '<STR_LIT>'<EOL>ret=self.read_until(login_prompt,'TRACE').decode('ASCII','ignore')<EOL>self.write_bare(username +self._newline)<EOL>ret +=username +'\n'<EOL>ret +=self.read_until(password_prompt,'TRACE').decode('ASCII','ignore')<EOL>self.write_bare(password +self._newline)<EOL>ret +='*'*len(password)+'\n'<EOL>if self._prompt_is_set():<EOL><INDENT>try :<EOL><INDENT>ret +=self.read_until_prompt('TRACE')<EOL><DEDENT>except AssertionError :<EOL><INDENT>self._verify_login(ret)<EOL>raise <EOL><DEDENT> <DEDENT>else :<EOL><INDENT>ret +=self._verify_login(ret)<EOL><DEDENT>self._log(ret)<EOL>return ret <EOL><DEDENT>def _verify_login(self,ret):<EOL><INDENT>time.sleep()<EOL>while True :<EOL><INDENT>try :<EOL><INDENT>ret +=self.read_until('\n','TRACE').decode('ASCII','ignore')<EOL><DEDENT>except AssertionError :<EOL><INDENT>return ret <EOL><DEDENT>else :<EOL><INDENT>if 'Login incorrect'in ret :<EOL><INDENT>self._log(ret)<EOL>raise AssertionError("Login incorrect")<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>def write(self,text,loglevel=None):<EOL><INDENT> '<STR_LIT>'<EOL>if self._newline in text :<EOL><INDENT>raise RuntimeError('<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT>text +=self._newline <EOL>self.write_bare(text)<EOL>return self.read_until(self._newline,loglevel)<EOL><DEDENT>def write_bare(self,text):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>text=str(text)<EOL><DEDENT>except UnicodeError :<EOL><INDENT>raise ValueError('<STR_LIT>'<EOL>'Got: %s'%text)<EOL><DEDENT>telnetlib.Telnet.write(self,text)<EOL><DEDENT>def write_until_expected_output(self,text,expected,timeout,<EOL>retry_interval,loglevel=None):<EOL><INDENT> '<STR_LIT>'<EOL>timeout=utils.timestr_to_secs(timeout)<EOL>retry_interval=utils.timestr_to_secs(retry_interval)<EOL>starttime=time.time()<EOL>while time.time()-starttime <timeout :<EOL><INDENT>self.write_bare(text)<EOL>self.read_until(text,loglevel)<EOL>ret=telnetlib.Telnet.read_until(self,expected,<EOL>retry_interval).decode('ASCII','ignore')<EOL>self._log(ret,loglevel)<EOL>if ret.endswith(expected):<EOL><INDENT>return ret <EOL><DEDENT> <DEDENT>raise AssertionError('<STR_LIT>'<EOL>%(expected,utils.secs_to_timestr(timeout)))<EOL><DEDENT>def read(self,loglevel=None):<EOL><INDENT> '<STR_LIT>'<EOL>ret=self.read_very_eager().decode('ASCII','ignore')<EOL>self._log(ret,loglevel)<EOL>return ret <EOL><DEDENT>def read_until(self,expected,loglevel=None):<EOL><INDENT> '<STR_LIT>'<EOL>ret=telnetlib.Telnet.read_until(self,expected,<EOL>self._timeout).decode('ASCII','ignore')<EOL>self._log(ret,loglevel)<EOL>if not ret.endswith(expected):<EOL><INDENT>raise AssertionError('<STR_LIT>'<EOL>%(expected,utils.secs_to_timestr(self._timeout)))<EOL><DEDENT>return ret <EOL><DEDENT>def read_until_regexp(self,*expected):<EOL><INDENT> '<STR_LIT>'<EOL>expected=list(expected)<EOL>if self._is_valid_log_level(expected [-]):<EOL><INDENT>loglevel=expected [-]<EOL>expected=expected [:-]<EOL><DEDENT>else :<EOL><INDENT>loglevel='INFO'<EOL><DEDENT>try :<EOL><INDENT>index,_,ret=self.expect(expected,self._timeout)<EOL><DEDENT>except TypeError :<EOL><INDENT>index,ret=-,''<EOL><DEDENT>ret=ret.decode('ASCII','ignore')<EOL>self._log(ret,loglevel)<EOL>if index==-:<EOL><INDENT>expected=[exp if isinstance(exp,basestring)else exp.pattern <EOL>for exp in expected ]<EOL>raise AssertionError('<STR_LIT>'<EOL>%(utils.seq2str(expected,lastsep=' or '),<EOL>utils.secs_to_timestr(self._timeout)))<EOL><DEDENT>return ret <EOL><DEDENT>def read_until_prompt(self,loglevel=None):<EOL><INDENT> '<STR_LIT>'<EOL>if not self._prompt_is_set():<EOL><INDENT>raise RuntimeError('<STR_LIT>')<EOL><DEDENT>prompt,regexp=self._prompt <EOL>if regexp :<EOL><INDENT>return self.read_until_regexp(prompt,loglevel)<EOL><DEDENT>return self.read_until(prompt,loglevel)<EOL><DEDENT>def execute_command(self,command,loglevel=None):<EOL><INDENT> '<STR_LIT>'<EOL>self.write(command,loglevel)<EOL>return self.read_until_prompt(loglevel)<EOL><DEDENT>def set_prompt(self,prompt,prompt_is_regexp=False):<EOL><INDENT> '<STR_LIT>'<EOL>old=hasattr(self,'_prompt')and self._prompt or(None,False)<EOL>if prompt_is_regexp :<EOL><INDENT>self._prompt=(re.compile(prompt),True)<EOL><DEDENT>else :<EOL><INDENT>self._prompt=(prompt,False)<EOL><DEDENT>if old []:<EOL><INDENT>return old [].pattern,True <EOL><DEDENT>return old <EOL><DEDENT>def _prompt_is_set(self):<EOL><INDENT>return self._prompt []is not None <EOL><DEDENT>def set_default_log_level(self,level):<EOL><INDENT> '<STR_LIT>'<EOL>self._is_valid_log_level(level,raise_if_invalid=True)<EOL>old=self._default_log_level <EOL>self._default_log_level=level.upper()<EOL>return old <EOL><DEDENT>def _log(self,msg,level=None):<EOL><INDENT>self._is_valid_log_level(level,raise_if_invalid=True)<EOL>msg=msg.strip()<EOL>if level is None :<EOL><INDENT>level=self._default_log_level <EOL><DEDENT>if msg !='':<EOL><INDENT>print '*%s* %s'%(level.upper(),msg)<EOL><DEDENT> <DEDENT>def _is_valid_log_level(self,level,raise_if_invalid=False):<EOL><INDENT>if level is None :<EOL><INDENT>return True <EOL><DEDENT>if isinstance(level,basestring)and level.upper()in ['TRACE','DEBUG','INFO','WARN']:<EOL><INDENT>return True <EOL><DEDENT>if not raise_if_invalid :<EOL><INDENT>return False <EOL><DEDENT>raise AssertionError('<STR_LIT>'%level)<EOL><DEDENT>def _negotiate_echo_on(self,sock,cmd,opt):<EOL><INDENT>if opt==telnetlib.ECHO and cmd in(telnetlib.WILL,telnetlib.WONT):<EOL><INDENT>self.sock.sendall(telnetlib.IAC +telnetlib.DO +opt)<EOL><DEDENT>elif opt !=telnetlib.NOOPT :<EOL><INDENT>if cmd in(telnetlib.DO,telnetlib.DONT):<EOL><INDENT>self.sock.sendall(telnetlib.IAC +telnetlib.WONT +opt)<EOL><DEDENT>elif cmd in(telnetlib.WILL,telnetlib.WONT):<EOL><INDENT>self.sock.sendall(telnetlib.IAC +telnetlib.DONT +opt)<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT><EOF><BOF>import psycopg2 <EOL>from pprint import pprint <EOL>from mosql.query import select,left_join <EOL>from mosql.db import Database,all_to_dicts <EOL>db=Database(psycopg2,host='127.0.0.1')<EOL>with db as cur :<EOL><INDENT>cur.execute(select(<EOL>'person',<EOL>{'person_id':'mosky'},<EOL>joins=left_join('detail',using='person_id'),<EOL>))<EOL>pprint(all_to_dicts(cur))<EOL><DEDENT><EOF><BOF>import cv2.cv as cv <EOL>class PyrSegmentation :<EOL><INDENT>def __init__(self,img0):<EOL><INDENT>self.thresh1=<EOL>self.thresh2=<EOL>self.level=<EOL>self.storage=cv.CreateMemStorage()<EOL>cv.NamedWindow("Source",)<EOL>cv.ShowImage("Source",img0)<EOL>cv.NamedWindow("Segmentation",)<EOL>cv.CreateTrackbar("Thresh1","Segmentation",self.thresh1,,self.set_thresh1)<EOL>cv.CreateTrackbar("Thresh2","Segmentation",self.thresh2,,self.set_thresh2)<EOL>self.image0=cv.CloneImage(img0)<EOL>self.image1=cv.CloneImage(img0)<EOL>cv.ShowImage("Segmentation",self.image1)<EOL><DEDENT>def set_thresh1(self,val):<EOL><INDENT>self.thresh1=val <EOL>self.on_segment()<EOL><DEDENT>def set_thresh2(self,val):<EOL><INDENT>self.thresh2=val <EOL>self.on_segment()<EOL><DEDENT>def on_segment(self):<EOL><INDENT>comp=cv.PyrSegmentation(self.image0,self.image1,self.storage,self.level,self.thresh1 +,self.thresh2 +)<EOL>cv.ShowImage("Segmentation",self.image1)<EOL><DEDENT>def run(self):<EOL><INDENT>self.on_segment()<EOL>cv.WaitKey()<EOL><DEDENT> <DEDENT>if __name__=="__main__":<EOL><INDENT>img0=cv.LoadImage("../c/fruits.jpg",)<EOL>PyrSegmentation(img0).run()<EOL>cv.DestroyAllWindows()<EOL><DEDENT><EOF><BOF>from functools import wraps <EOL>from flask import request,abort <EOL>def has_access_token(tkn):<EOL><INDENT> '<STR_LIT>'<EOL>def decorator(f):<EOL><INDENT>@wraps(f)<EOL>def decorated_function(*args,**kwargs):<EOL><INDENT>token=request.headers.get('Access-Token','')<EOL>if token !=tkn :<EOL><INDENT>abort()<EOL><DEDENT>return f(*args,**kwargs)<EOL><DEDENT>return decorated_function <EOL><DEDENT>return decorator <EOL><DEDENT><EOF><BOF>import logging <EOL>from zerotest.common import DEBUG <EOL>if not DEBUG :<EOL><INDENT>logging.getLogger("werkzeug").setLevel(logging.ERROR)<EOL>logging.getLogger('<STR_LIT>').setLevel(logging.ERROR)<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>from common import anorm,getsize <EOL>FLANN_INDEX_KDTREE=<EOL>FLANN_INDEX_LSH=<EOL>def init_feature(name):<EOL><INDENT>chunks=name.split('-')<EOL>if chunks []=='sift':<EOL><INDENT>detector=cv2.SIFT()<EOL>norm=cv2.NORM_L2 <EOL><DEDENT>elif chunks []=='surf':<EOL><INDENT>detector=cv2.SURF()<EOL>norm=cv2.NORM_L2 <EOL><DEDENT>elif chunks []=='orb':<EOL><INDENT>detector=cv2.ORB()<EOL>norm=cv2.NORM_HAMMING <EOL><DEDENT>else :<EOL><INDENT>return None,None <EOL><DEDENT>if 'flann'in chunks :<EOL><INDENT>if norm==cv2.NORM_L2 :<EOL><INDENT>flann_params=dict(algorithm=FLANN_INDEX_KDTREE,trees=)<EOL><DEDENT>else :<EOL><INDENT>flann_params=dict(algorithm=FLANN_INDEX_LSH,<EOL>table_number=,<EOL>key_size=,<EOL>multi_probe_level=)<EOL><DEDENT>matcher=cv2.FlannBasedMatcher(flann_params,{})<EOL><DEDENT>else :<EOL><INDENT>matcher=cv2.BFMatcher(norm)<EOL><DEDENT>return detector,matcher <EOL><DEDENT>def filter_matches(kp1,kp2,matches,ratio=):<EOL><INDENT>mkp1,mkp2=[],[]<EOL>for m in matches :<EOL><INDENT>if len(m)==and m [].distance <m [].distance *ratio :<EOL><INDENT>m=m []<EOL>mkp1.append(kp1 [m.queryIdx ])<EOL>mkp2.append(kp2 [m.trainIdx ])<EOL><DEDENT> <DEDENT>p1=np.float32([kp.pt for kp in mkp1 ])<EOL>p2=np.float32([kp.pt for kp in mkp2 ])<EOL>kp_pairs=zip(mkp1,mkp2)<EOL>return p1,p2,kp_pairs <EOL><DEDENT>def explore_match(win,img1,img2,kp_pairs,status=None,H=None):<EOL><INDENT>h1,w1=img1.shape [:]<EOL>h2,w2=img2.shape [:]<EOL>vis=np.zeros((max(h1,h2),w1 +w2),np.uint8)<EOL>vis [:h1,:w1 ]=img1 <EOL>vis [:h2,w1 :w1 +w2 ]=img2 <EOL>vis=cv2.cvtColor(vis,cv2.COLOR_GRAY2BGR)<EOL>if H is not None :<EOL><INDENT>corners=np.float32([[,],[w1,],[w1,h1 ],[,h1 ]])<EOL>corners=np.int32(cv2.perspectiveTransform(corners.reshape(,-,),H).reshape(-,)+(w1,))<EOL>cv2.polylines(vis,[corners ],True,(,,))<EOL><DEDENT>if status is None :<EOL><INDENT>status=np.ones(len(kp_pairs),np.bool_)<EOL><DEDENT>p1=np.int32([kpp [].pt for kpp in kp_pairs ])<EOL>p2=np.int32([kpp [].pt for kpp in kp_pairs ])+(w1,)<EOL>green=(,,)<EOL>red=(,,)<EOL>white=(,,)<EOL>kp_color=(,,)<EOL>for(x1,y1),(x2,y2),inlier in zip(p1,p2,status):<EOL><INDENT>if inlier :<EOL><INDENT>col=green <EOL>cv2.circle(vis,(x1,y1),,col,-)<EOL>cv2.circle(vis,(x2,y2),,col,-)<EOL><DEDENT>else :<EOL><INDENT>col=red <EOL>r=<EOL>thickness=<EOL>cv2.line(vis,(x1 -r,y1 -r),(x1 +r,y1 +r),col,thickness)<EOL>cv2.line(vis,(x1 -r,y1 +r),(x1 +r,y1 -r),col,thickness)<EOL>cv2.line(vis,(x2 -r,y2 -r),(x2 +r,y2 +r),col,thickness)<EOL>cv2.line(vis,(x2 -r,y2 +r),(x2 +r,y2 -r),col,thickness)<EOL><DEDENT> <DEDENT>vis0=vis.copy()<EOL>for(x1,y1),(x2,y2),inlier in zip(p1,p2,status):<EOL><INDENT>if inlier :<EOL><INDENT>cv2.line(vis,(x1,y1),(x2,y2),green)<EOL><DEDENT> <DEDENT>cv2.imshow(win,vis)<EOL>def onmouse(event,x,y,flags,param):<EOL><INDENT>cur_vis=vis <EOL>if flags &cv2.EVENT_FLAG_LBUTTON :<EOL><INDENT>cur_vis=vis0.copy()<EOL>r=<EOL>m=(anorm(p1 -(x,y))<r)|(anorm(p2 -(x,y))<r)<EOL>idxs=np.where(m)[]<EOL>kp1s,kp2s=[],[]<EOL>for i in idxs :<EOL><INDENT>(x1,y1),(x2,y2)=p1 [i ],p2 [i ]<EOL>col=(red,green)[status [i ]]<EOL>cv2.line(cur_vis,(x1,y1),(x2,y2),col)<EOL>kp1,kp2=kp_pairs [i ]<EOL>kp1s.append(kp1)<EOL>kp2s.append(kp2)<EOL><DEDENT>cur_vis=cv2.drawKeypoints(cur_vis,kp1s,flags=,color=kp_color)<EOL>cur_vis [:,w1 :]=cv2.drawKeypoints(cur_vis [:,w1 :],kp2s,flags=,color=kp_color)<EOL><DEDENT>cv2.imshow(win,cur_vis)<EOL><DEDENT>cv2.setMouseCallback(win,onmouse)<EOL>return vis <EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>import sys,getopt <EOL>opts,args=getopt.getopt(sys.argv [:],'',['feature='])<EOL>opts=dict(opts)<EOL>feature_name=opts.get('--feature','sift')<EOL>try :fn1,fn2=args <EOL>except :<EOL><INDENT>fn1='../c/box.png'<EOL>fn2='<STR_LIT>'<EOL><DEDENT>img1=cv2.imread(fn1,)<EOL>img2=cv2.imread(fn2,)<EOL>detector,matcher=init_feature(feature_name)<EOL>if detector !=None :<EOL><INDENT>print 'using',feature_name <EOL><DEDENT>else :<EOL><INDENT>print '<STR_LIT>',feature_name <EOL>sys.exit()<EOL><DEDENT>kp1,desc1=detector.detectAndCompute(img1,None)<EOL>kp2,desc2=detector.detectAndCompute(img2,None)<EOL>print '<STR_LIT>'%(len(kp1),len(kp2))<EOL>def match_and_draw(win):<EOL><INDENT>print 'matching...'<EOL>raw_matches=matcher.knnMatch(desc1,trainDescriptors=desc2,k=)<EOL>p1,p2,kp_pairs=filter_matches(kp1,kp2,raw_matches)<EOL>if len(p1)>=:<EOL><INDENT>H,status=cv2.findHomography(p1,p2,cv2.RANSAC,)<EOL>print '<STR_LIT>'%(np.sum(status),len(status))<EOL><DEDENT>else :<EOL><INDENT>H,status=None,None <EOL>print '<STR_LIT>'%len(p1)<EOL><DEDENT>vis=explore_match(win,img1,img2,kp_pairs,status,H)<EOL><DEDENT>match_and_draw('find_obj')<EOL>cv2.waitKey()<EOL>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import sys <EOL>import types <EOL>PY2=sys.version_info []==<EOL>PY3=sys.version_info []==<EOL>if PY3 :<EOL><INDENT>string_types=str,<EOL>integer_types=int,<EOL>class_types=type,<EOL>text_type=str <EOL>binary_type=bytes <EOL><DEDENT>else :<EOL><INDENT>string_types=basestring,<EOL>integer_types=(int,long)<EOL>class_types=(type,types.ClassType)<EOL>text_type=unicode <EOL>binary_type=str <EOL><DEDENT>try :<EOL><INDENT>from itertools import izip <EOL><DEDENT>except ImportError :<EOL><INDENT>izip=zip <EOL><DEDENT><EOF><BOF>from __future__ import unicode_literals <EOL>from django.db import migrations,models <EOL>import django.db.models.deletion <EOL>class Migration(migrations.Migration):<EOL><INDENT>dependencies=[('buildservice','<STR_LIT>'),<EOL>]<EOL>operations=[<EOL>migrations.CreateModel(<EOL>name='Repository',<EOL>fields=[('id',models.AutoField(auto_created=True,primary_key=True,serialize=False,verbose_name='ID')),('name',models.CharField(max_length=)),('created_at',models.DateTimeField(auto_now_add=True)),<EOL>],),<EOL>migrations.AlterField(<EOL>model_name='build',<EOL>name='repository',<EOL>field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE,to='<STR_LIT>'),),<EOL>migrations.AlterField(<EOL>model_name='webhook',<EOL>name='repository',<EOL>field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE,to='<STR_LIT>'),),<EOL>]<EOL><DEDENT><EOF><BOF>from robot.errors import DataError <EOL>class XmlElementHandler(object):<EOL><INDENT>def __init__(self,execution_result,root_handler=None):<EOL><INDENT>self._stack=[(execution_result,root_handler or RootHandler())]<EOL><DEDENT>def start(self,elem):<EOL><INDENT>result,handler=self._stack [-]<EOL>self._stack.append(handler.handle_child(elem,result))<EOL><DEDENT>def end(self,elem):<EOL><INDENT>result,handler=self._stack.pop()<EOL>handler.end(elem,result)<EOL><DEDENT> <DEDENT>class _Handler(object):<EOL><INDENT>def __init__(self):<EOL><INDENT>self._child_map=dict((c.tag,c)for c in self._children())<EOL><DEDENT>def _children(self):<EOL><INDENT>return []<EOL><DEDENT>def handle_child(self,elem,result):<EOL><INDENT>try :<EOL><INDENT>handler=self._child_map [elem.tag ]<EOL><DEDENT>except KeyError :<EOL><INDENT>raise DataError('<STR_LIT>'%elem.tag)<EOL><DEDENT>return handler.start(elem,result),handler <EOL><DEDENT>def start(self,elem,result):<EOL><INDENT>return result <EOL><DEDENT>def end(self,elem,result):<EOL><INDENT>pass <EOL><DEDENT>def _timestamp(self,elem,attr_name):<EOL><INDENT>timestamp=elem.get(attr_name)<EOL>return timestamp if timestamp !='N/A'else None <EOL><DEDENT> <DEDENT>class RootHandler(_Handler):<EOL><INDENT>def _children(self):<EOL><INDENT>return [RobotHandler()]<EOL><DEDENT> <DEDENT>class RobotHandler(_Handler):<EOL><INDENT>tag='robot'<EOL>def start(self,elem,result):<EOL><INDENT>result.generator=elem.get('generator','unknown').split()[].upper()<EOL>return result <EOL><DEDENT>def _children(self):<EOL><INDENT>return [RootSuiteHandler(),StatisticsHandler(),ErrorsHandler()]<EOL><DEDENT> <DEDENT>class SuiteHandler(_Handler):<EOL><INDENT>tag='suite'<EOL>def start(self,elem,result):<EOL><INDENT>return result.suites.create(name=elem.get('name'),<EOL>source=elem.get('source',''))<EOL><DEDENT>def _children(self):<EOL><INDENT>return [DocHandler(),MetadataHandler(),SuiteStatusHandler(),<EOL>KeywordHandler(),TestCaseHandler(),self ]<EOL><DEDENT> <DEDENT>class RootSuiteHandler(SuiteHandler):<EOL><INDENT>def start(self,elem,result):<EOL><INDENT>result.suite.name=elem.get('name')<EOL>result.suite.source=elem.get('source','')<EOL>return result.suite <EOL><DEDENT>def _children(self):<EOL><INDENT>return SuiteHandler._children(self)[:-]+[SuiteHandler()]<EOL><DEDENT> <DEDENT>class TestCaseHandler(_Handler):<EOL><INDENT>tag='test'<EOL>def start(self,elem,result):<EOL><INDENT>return result.tests.create(name=elem.get('name'),<EOL>timeout=elem.get('timeout',''))<EOL><DEDENT>def _children(self):<EOL><INDENT>return [DocHandler(),TagsHandler(),TestStatusHandler(),KeywordHandler()]<EOL><DEDENT> <DEDENT>class KeywordHandler(_Handler):<EOL><INDENT>tag='kw'<EOL>def start(self,elem,result):<EOL><INDENT>return result.keywords.create(name=elem.get('name'),<EOL>timeout=elem.get('timeout'),<EOL>type=elem.get('type'))<EOL><DEDENT>def _children(self):<EOL><INDENT>return [DocHandler(),ArgumentsHandler(),KeywordStatusHandler(),<EOL>MessageHandler(),self ]<EOL><DEDENT> <DEDENT>class MessageHandler(_Handler):<EOL><INDENT>tag='msg'<EOL>def end(self,elem,result):<EOL><INDENT>result.messages.create(elem.text or '',<EOL>elem.get('level'),<EOL>elem.get('html','no')=='yes',<EOL>self._timestamp(elem,'timestamp'))<EOL><DEDENT> <DEDENT>class _StatusHandler(_Handler):<EOL><INDENT>tag='status'<EOL>def _set_status(self,elem,result):<EOL><INDENT>result.status=elem.get('status','FAIL')<EOL><DEDENT>def _set_message(self,elem,result):<EOL><INDENT>result.message=elem.text or ''<EOL><DEDENT>def _set_times(self,elem,result):<EOL><INDENT>result.starttime=self._timestamp(elem,'starttime')<EOL>result.endtime=self._timestamp(elem,'endtime')<EOL><DEDENT> <DEDENT>class KeywordStatusHandler(_StatusHandler):<EOL><INDENT>def end(self,elem,result):<EOL><INDENT>self._set_status(elem,result)<EOL>self._set_times(elem,result)<EOL><DEDENT> <DEDENT>class SuiteStatusHandler(_StatusHandler):<EOL><INDENT>def end(self,elem,result):<EOL><INDENT>self._set_message(elem,result)<EOL>self._set_times(elem,result)<EOL><DEDENT> <DEDENT>class TestStatusHandler(_StatusHandler):<EOL><INDENT>def end(self,elem,result):<EOL><INDENT>self._set_status(elem,result)<EOL>self._set_message(elem,result)<EOL>self._set_times(elem,result)<EOL><DEDENT> <DEDENT>class DocHandler(_Handler):<EOL><INDENT>tag='doc'<EOL>def end(self,elem,result):<EOL><INDENT>result.doc=elem.text or ''<EOL><DEDENT> <DEDENT>class MetadataHandler(_Handler):<EOL><INDENT>tag='metadata'<EOL>def _children(self):<EOL><INDENT>return [MetadataItemHandler()]<EOL><DEDENT> <DEDENT>class MetadataItemHandler(_Handler):<EOL><INDENT>tag='item'<EOL>def end(self,elem,result):<EOL><INDENT>result.metadata [elem.get('name')]=elem.text or ''<EOL><DEDENT> <DEDENT>class TagsHandler(_Handler):<EOL><INDENT>tag='tags'<EOL>def _children(self):<EOL><INDENT>return [TagHandler()]<EOL><DEDENT> <DEDENT>class TagHandler(_Handler):<EOL><INDENT>tag='tag'<EOL>def end(self,elem,result):<EOL><INDENT>result.tags.add(elem.text or '')<EOL><DEDENT> <DEDENT>class ArgumentsHandler(_Handler):<EOL><INDENT>tag='arguments'<EOL>def _children(self):<EOL><INDENT>return [ArgumentHandler()]<EOL><DEDENT> <DEDENT>class ArgumentHandler(_Handler):<EOL><INDENT>tag='arg'<EOL>def end(self,elem,result):<EOL><INDENT>result.args.append(elem.text or '')<EOL><DEDENT> <DEDENT>class ErrorsHandler(_Handler):<EOL><INDENT>tag='errors'<EOL>def start(self,elem,result):<EOL><INDENT>return result.errors <EOL><DEDENT>def _children(self):<EOL><INDENT>return [MessageHandler()]<EOL><DEDENT> <DEDENT>class StatisticsHandler(_Handler):<EOL><INDENT>tag='statistics'<EOL>def handle_child(self,elem,result):<EOL><INDENT>return result,self <EOL><DEDENT> <DEDENT><EOF><BOF>import os <EOL>import re <EOL>from robot.errors import DataError <EOL>from robot.htmldata import HtmlFileWriter,ModelWriter,JsonWriter,LIBDOC <EOL>from robot import utils <EOL>class LibdocHtmlWriter(object):<EOL><INDENT>def write(self,libdoc,output):<EOL><INDENT>model_writer=LibdocModelWriter(output,libdoc)<EOL>HtmlFileWriter(output,model_writer).write(LIBDOC)<EOL><DEDENT> <DEDENT>class LibdocModelWriter(ModelWriter):<EOL><INDENT>def __init__(self,output,libdoc):<EOL><INDENT>self._output=output <EOL>self._libdoc=libdoc <EOL><DEDENT>def write(self,line):<EOL><INDENT>self._output.write('<STR_LIT>'+os.linesep)<EOL>self.write_data()<EOL>self._output.write('</script>'+os.linesep)<EOL><DEDENT>def write_data(self):<EOL><INDENT>formatter=DocFormatter(self._libdoc.keywords,self._libdoc.doc,<EOL>self._libdoc.doc_format)<EOL>libdoc=JsonConverter(formatter).convert(self._libdoc)<EOL>JsonWriter(self._output).write_json('libdoc= ',libdoc)<EOL><DEDENT> <DEDENT>class JsonConverter(object):<EOL><INDENT>def __init__(self,doc_formatter):<EOL><INDENT>self._doc_formatter=doc_formatter <EOL><DEDENT>def convert(self,libdoc):<EOL><INDENT>return {<EOL>'name':libdoc.name,<EOL>'doc':self._doc_formatter.html(libdoc.doc,intro=True),<EOL>'version':libdoc.version,<EOL>'named_args':libdoc.named_args,<EOL>'scope':libdoc.scope,<EOL>'generated':utils.get_timestamp(daysep='-',millissep=None),<EOL>'inits':self._get_keywords(libdoc.inits),<EOL>'keywords':self._get_keywords(libdoc.keywords)<EOL>}<EOL><DEDENT>def _get_keywords(self,keywords):<EOL><INDENT>return [self._convert_keyword(kw)for kw in keywords ]<EOL><DEDENT>def _convert_keyword(self,kw):<EOL><INDENT>return {<EOL>'name':kw.name,<EOL>'args':', '.join(kw.args),<EOL>'doc':self._doc_formatter.html(kw.doc),<EOL>'shortdoc':kw.shortdoc <EOL>}<EOL><DEDENT> <DEDENT>class DocFormatter(object):<EOL><INDENT>_header_regexp=re.compile(r'<h2>(.+?)</h2>')<EOL>_name_regexp=re.compile('`(.+?)`')<EOL>def __init__(self,keywords,introduction,doc_format='ROBOT'):<EOL><INDENT>self._doc_to_html=DocToHtml(doc_format)<EOL>self._targets=self._get_targets(keywords,introduction,<EOL>doc_format=='ROBOT')<EOL><DEDENT>def _get_targets(self,keywords,introduction,robot_format):<EOL><INDENT>targets=utils.NormalizedDict({<EOL>'introduction':'introduction',<EOL>'<STR_LIT>':'introduction',<EOL>'importing':'importing',<EOL>'<STR_LIT>':'importing',<EOL>'shortcuts':'shortcuts',<EOL>'keywords':'keywords'<EOL>})<EOL>for kw in keywords :<EOL><INDENT>targets [kw.name ]=kw.name <EOL><DEDENT>if robot_format :<EOL><INDENT>for header in self._yield_header_targets(introduction):<EOL><INDENT>targets [header ]=header <EOL><DEDENT> <DEDENT>return targets <EOL><DEDENT>def _yield_header_targets(self,introduction):<EOL><INDENT>for line in introduction.splitlines():<EOL><INDENT>line=line.strip()<EOL>if line.startswith('= ')and line.endswith('='):<EOL><INDENT>yield line [:-].strip()<EOL><DEDENT> <DEDENT> <DEDENT>def html(self,doc,intro=False):<EOL><INDENT>doc=self._doc_to_html(doc)<EOL>if intro :<EOL><INDENT>doc=self._header_regexp.sub('<STR_LIT>',doc)<EOL><DEDENT>return self._name_regexp.sub(self._link_keywords,doc)<EOL><DEDENT>def _link_keywords(self,match):<EOL><INDENT>name=match.group()<EOL>if name in self._targets :<EOL><INDENT>return '<STR_LIT>'%(self._targets [name ],name)<EOL><DEDENT>return '<STR_LIT>'%name <EOL><DEDENT> <DEDENT>class DocToHtml(object):<EOL><INDENT>def __init__(self,format):<EOL><INDENT>self._formatter=self._get_formatter(format)<EOL><DEDENT>def _get_formatter(self,format):<EOL><INDENT>try :<EOL><INDENT>return {'ROBOT':utils.html_format,<EOL>'TEXT':self._format_text,<EOL>'HTML':self._format_html,<EOL>'REST':self._format_rest }[format ]<EOL><DEDENT>except KeyError :<EOL><INDENT>raise DataError('<STR_LIT>'%format)<EOL><DEDENT> <DEDENT>def _format_text(self,doc):<EOL><INDENT>return '<STR_LIT>'%utils.html_escape(doc)<EOL><DEDENT>def _format_html(self,doc):<EOL><INDENT>return '<STR_LIT>'%doc <EOL><DEDENT>def _format_rest(self,doc):<EOL><INDENT>try :<EOL><INDENT>from docutils.core import publish_parts <EOL><DEDENT>except ImportError :<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>parts=publish_parts(doc,writer_name='html')<EOL>return self._format_html(parts ['html_body'])<EOL><DEDENT>def __call__(self,doc):<EOL><INDENT>return self._formatter(doc)<EOL><DEDENT> <DEDENT><EOF><BOF>import numpy as np <EOL>import cv2 <EOL>def draw_match(img1,kp1,<EOL>img2,kp2,<EOL>matches,<EOL>output=None,<EOL>matchColor=(,,),<EOL>matchesMask=None,<EOL>*args,**kargs):<EOL><INDENT>h1=img1.shape []<EOL>w1=img1.shape []<EOL>h2=img2.shape []<EOL>w2=img2.shape []<EOL>w=w1 +w2 <EOL>h=max(h1,h2)<EOL>outimg=np.full((h,w,),,np.uint8)<EOL>img1_=img1.copy()<EOL>img2_=img2.copy()<EOL>if len(img1.shape)==or img1.shape []==:<EOL><INDENT>img1_=cv2.cvtColor(img1_,cv2.COLOR_GRAY2BGR)<EOL><DEDENT>if len(img2.shape)==or img2.shape []==:<EOL><INDENT>img2_=cv2.cvtColor(img2_,cv2.COLOR_GRAY2BGR)<EOL><DEDENT>outimg [:h1,:w1,:]=img1_ <EOL>outimg [:h2,w1 :w1 +w2,:]=img2_ <EOL>for i,m in enumerate(matches):<EOL><INDENT>if matchesMask is not None and matchesMask [i ]==:continue <EOL>i1,i2=m.queryIdx,m.trainIdx <EOL>pt1,pt2=kp1 [i1 ].pt,kp2 [i2 ].pt <EOL>pt1=(int(pt1 []),int(pt1 []))<EOL>pt2=(int(w1 +pt2 []),int(pt2 []))<EOL>cv2.line(outimg,pt1,pt2,matchColor)<EOL><DEDENT>if output is not None :<EOL><INDENT>output=outimg.copy()<EOL><DEDENT>return outimg <EOL><DEDENT>def test_feature_matching_realtime(detetor=cv2.ORB()):<EOL><INDENT>from cam import MyCam <EOL>'<STR_LIT>'<EOL>MIN_MATCH_COUNT=<EOL>cam=MyCam()<EOL>cam.size=(,)<EOL>img1=img1=cv2.imread('box.png',)<EOL>cv2.imshow('source',img1)<EOL>while True :<EOL><INDENT>img2=cv2.flip(cv2.cvtColor(cam.read(),cv2.COLOR_BGR2GRAY),)<EOL>k=cv2.waitKey()<EOL>if k==ord('s'):<EOL><INDENT>img1=img2.copy()<EOL>cv2.imwrite('campic.png',img1)<EOL><DEDENT>elif k==:<EOL><INDENT>break <EOL><DEDENT>if k is not None :<EOL><INDENT>cv2.destroyWindow('preview')<EOL>kp1,des1=detetor.detectAndCompute(img1,None)<EOL><DEDENT>kp2,des2=detetor.detectAndCompute(img2,None)<EOL>if des2 is None :<EOL><INDENT>img3=img3=draw_match(img1,kp1,img2,kp2,[])<EOL>continue <EOL><DEDENT>des1=des1.astype(np.uint8,copy=False)<EOL>des2=des2.astype(np.uint8,copy=False)<EOL>bf=cv2.BFMatcher(cv2.NORM_HAMMING)<EOL>matches=bf.knnMatch(des1,des2,k=)<EOL>good=[]<EOL>try :<EOL><INDENT>for m,n in matches :<EOL><INDENT>if m.distance <*n.distance :<EOL><INDENT>good.append(m)<EOL><DEDENT> <DEDENT> <DEDENT>except ValueError :<EOL><INDENT>good=[]<EOL><DEDENT>if len(good)>MIN_MATCH_COUNT :<EOL><INDENT>src_pts=np.float32([kp1 [m.queryIdx ].pt for m in good ]).reshape(-,,)<EOL>dst_pts=np.float32([kp2 [m.trainIdx ].pt for m in good ]).reshape(-,,)<EOL>M,mask=cv2.findHomography(src_pts,dst_pts,cv2.RANSAC,)<EOL>matchesMask=mask.ravel().tolist()<EOL>h,w=img1.shape <EOL>pts=np.float32([[,],[,h -],[w -,h -],[w -,]]).reshape(-,,)<EOL>dst=cv2.perspectiveTransform(pts,M)<EOL>cv2.polylines(img2,[np.int32(dst)],True,(,,),)<EOL><DEDENT>else :<EOL><INDENT>matchesMask=None <EOL>good=[]<EOL><DEDENT>img3=draw_match(img1,kp1,img2,kp2,good,matchesMask=matchesMask)<EOL>cv2.imshow('matches',img3)<EOL><DEDENT>print '<STR_LIT>'<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>test_feature_matching_realtime()<DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from robot.parsing import TestCaseFile,TestDataDirectory,ResourceFile,TestData <EOL>from robot.result import ExecutionResult <EOL>from robot.running import TestSuite <EOF><BOF>import re <EOL>from functools import partial <EOL>from itertools import cycle <EOL>class LinkFormatter(object):<EOL><INDENT>_image_exts=('.jpg','.jpeg','.png','.gif','.bmp')<EOL>_link=re.compile('\[(.+?\|.*?)\]')<EOL>_url=re.compile('<STR_LIT>',re.VERBOSE |re.MULTILINE)<EOL>def format_url(self,text):<EOL><INDENT>return self._format_url(text,format_as_image=False)<EOL><DEDENT>def _format_url(self,text,format_as_image=True):<EOL><INDENT>if '://'not in text :<EOL><INDENT>return text <EOL><DEDENT>return self._url.sub(partial(self._replace_url,format_as_image),text)<EOL><DEDENT>def _replace_url(self,format_as_image,match):<EOL><INDENT>pre=match.group()<EOL>url=match.group()<EOL>if format_as_image and self._is_image(url):<EOL><INDENT>return pre +self._get_image(url)<EOL><DEDENT>return pre +self._get_link(url)<EOL><DEDENT>def _get_image(self,src,title=None):<EOL><INDENT>return '<STR_LIT>'%(self._quot(src),self._quot(title or src))<EOL><DEDENT>def _get_link(self,href,content=None):<EOL><INDENT>return '<STR_LIT>'%(self._quot(href),content or href)<EOL><DEDENT>def _quot(self,attr):<EOL><INDENT>return attr if '"'not in attr else attr.replace('"','&quot;')<EOL><DEDENT>def format_link(self,text):<EOL><INDENT>tokens=self._link.split(text)<EOL>formatters=cycle((self._format_url,self._format_link))<EOL>return ''.join(f(t)for f,t in zip(formatters,tokens))<EOL><DEDENT>def _format_link(self,text):<EOL><INDENT>link,content=[t.strip()for t in text.split('|',)]<EOL>if self._is_image(content):<EOL><INDENT>content=self._get_image(content,link)<EOL><DEDENT>elif self._is_image(link):<EOL><INDENT>return self._get_image(link,content)<EOL><DEDENT>return self._get_link(link,content)<EOL><DEDENT>def _is_image(self,text):<EOL><INDENT>return text.lower().endswith(self._image_exts)<EOL><DEDENT> <DEDENT>class LineFormatter(object):<EOL><INDENT>handles=lambda self,line :True <EOL>newline='\n'<EOL>_bold=re.compile('<STR_LIT>',re.VERBOSE)<EOL>_italic=re.compile('<STR_LIT>',re.VERBOSE)<EOL>def __init__(self):<EOL><INDENT>self._format_link=LinkFormatter().format_link <EOL><DEDENT>def format(self,line):<EOL><INDENT>return self._format_link(self._format_italic(self._format_bold(line)))<EOL><DEDENT>def _format_bold(self,line):<EOL><INDENT>return self._bold.sub('\\1<b>\\3</b>',line)if '*'in line else line <EOL><DEDENT>def _format_italic(self,line):<EOL><INDENT>return self._italic.sub('\\1<i>\\3</i>',line)if '_'in line else line <EOL><DEDENT> <DEDENT>class HtmlFormatter(object):<EOL><INDENT>def __init__(self):<EOL><INDENT>self._results=[]<EOL>self._formatters=[TableFormatter(),<EOL>PreformattedFormatter(),<EOL>ListFormatter(),<EOL>HeaderFormatter(),<EOL>RulerFormatter()]<EOL>self._formatters.append(ParagraphFormatter(self._formatters [:]))<EOL>self._current=None <EOL><DEDENT>def format(self,text):<EOL><INDENT>for line in text.splitlines():<EOL><INDENT>self._process_line(line)<EOL><DEDENT>self._end_current()<EOL>return '\n'.join(self._results)<EOL><DEDENT>def _process_line(self,line):<EOL><INDENT>if not line.strip():<EOL><INDENT>self._end_current()<EOL><DEDENT>elif self._current and self._current.handles(line):<EOL><INDENT>self._current.add(line)<EOL><DEDENT>else :<EOL><INDENT>self._end_current()<EOL>self._current=self._find_formatter(line)<EOL>self._current.add(line)<EOL><DEDENT> <DEDENT>def _end_current(self):<EOL><INDENT>if self._current :<EOL><INDENT>self._results.append(self._current.end())<EOL>self._current=None <EOL><DEDENT> <DEDENT>def _find_formatter(self,line):<EOL><INDENT>for formatter in self._formatters :<EOL><INDENT>if formatter.handles(line):<EOL><INDENT>return formatter <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>class _Formatter(object):<EOL><INDENT>_strip_lines=True <EOL>def __init__(self):<EOL><INDENT>self._lines=[]<EOL><DEDENT>def handles(self,line):<EOL><INDENT>return self._handles(line.strip()if self._strip_lines else line)<EOL><DEDENT>def _handles(self,line):<EOL><INDENT>raise NotImplementedError <EOL><DEDENT>def add(self,line):<EOL><INDENT>self._lines.append(line.strip()if self._strip_lines else line)<EOL><DEDENT>def end(self):<EOL><INDENT>result=self.format(self._lines)<EOL>self._lines=[]<EOL>return result <EOL><DEDENT>def format(self,lines):<EOL><INDENT>raise NotImplementedError <EOL><DEDENT> <DEDENT>class _SingleLineFormatter(_Formatter):<EOL><INDENT>def _handles(self,line):<EOL><INDENT>return not self._lines and self._match(line)<EOL><DEDENT>def _match(self,line):<EOL><INDENT>raise NotImplementedError <EOL><DEDENT>def format(self,lines):<EOL><INDENT>return self.format_line(lines [])<EOL><DEDENT>def format_line(self,line):<EOL><INDENT>raise NotImplementedError <EOL><DEDENT> <DEDENT>class RulerFormatter(_SingleLineFormatter):<EOL><INDENT>_match=re.compile('^-{3,}$').match <EOL>def format_line(self,line):<EOL><INDENT>return '<hr>'<EOL><DEDENT> <DEDENT>class HeaderFormatter(_SingleLineFormatter):<EOL><INDENT>_match=re.compile('<STR_LIT>').match <EOL>def format_line(self,line):<EOL><INDENT>level,text=self._match(line).groups()<EOL>level=len(level)+<EOL>return '<h%d>%s</h%d>'%(level,text,level)<EOL><DEDENT> <DEDENT>class ParagraphFormatter(_Formatter):<EOL><INDENT>_format_line=LineFormatter().format <EOL>def __init__(self,other_formatters):<EOL><INDENT>_Formatter.__init__(self)<EOL>self._other_formatters=other_formatters <EOL><DEDENT>def _handles(self,line):<EOL><INDENT>return not any(other.handles(line)<EOL>for other in self._other_formatters)<EOL><DEDENT>def format(self,lines):<EOL><INDENT>return '<p>%s</p>'%self._format_line(' '.join(lines))<EOL><DEDENT> <DEDENT>class TableFormatter(_Formatter):<EOL><INDENT>_table_line=re.compile('^\|(.* |)\|$')<EOL>_line_splitter=re.compile(' \|(?=)')<EOL>_format_cell=LineFormatter().format <EOL>def _handles(self,line):<EOL><INDENT>return self._table_line.match(line)is not None <EOL><DEDENT>def format(self,lines):<EOL><INDENT>return self._format_table([self._split_to_cells(l)for l in lines ])<EOL><DEDENT>def _split_to_cells(self,line):<EOL><INDENT>return [cell.strip()for cell in self._line_splitter.split(line [:-])]<EOL><DEDENT>def _format_table(self,rows):<EOL><INDENT>maxlen=max(len(row)for row in rows)<EOL>table=['<STR_LIT>']<EOL>for row in rows :<EOL><INDENT>row +=['']*(maxlen -len(row))<EOL>table.append('<tr>')<EOL>table.extend('<td>%s</td>'%self._format_cell(c)for c in row)<EOL>table.append('</tr>')<EOL><DEDENT>table.append('</table>')<EOL>return '\n'.join(table)<EOL><DEDENT> <DEDENT>class PreformattedFormatter(_Formatter):<EOL><INDENT>_format_line=LineFormatter().format <EOL>def _handles(self,line):<EOL><INDENT>return line.startswith('| ')or line=='|'<EOL><DEDENT>def format(self,lines):<EOL><INDENT>lines=[self._format_line(line [:])for line in lines ]<EOL>return '\n'.join(['<pre>']+lines +['</pre>'])<EOL><DEDENT> <DEDENT>class ListFormatter(_Formatter):<EOL><INDENT>_strip_lines=False <EOL>_format_item=LineFormatter().format <EOL>def _handles(self,line):<EOL><INDENT>return line.strip().startswith('- ')or line.startswith(' ')and self._lines <EOL><DEDENT>def format(self,lines):<EOL><INDENT>items=['<li>%s</li>'%self._format_item(line)<EOL>for line in self._combine_lines(lines)]<EOL>return '\n'.join(['<ul>']+items +['</ul>'])<EOL><DEDENT>def _combine_lines(self,lines):<EOL><INDENT>current=[]<EOL>for line in lines :<EOL><INDENT>line=line.strip()<EOL>if not line.startswith('- '):<EOL><INDENT>current.append(line)<EOL>continue <EOL><DEDENT>if current :<EOL><INDENT>yield ' '.join(current)<EOL><DEDENT>current=[line [:].strip()]<EOL><DEDENT>yield ' '.join(current)<EOL><DEDENT> <DEDENT><EOF><BOF>from flask_wtf import Form <EOL>from wtforms.fields import StringField,TextAreaField,SubmitField <EOL>from wtforms.validators import DataRequired,Length <EOL>class PostForm(Form):<EOL><INDENT>title=StringField(<EOL>u'Post Title',<EOL>validators=[<EOL>DataRequired(message=u'Empty title'),<EOL>Length(max=,message='<STR_LIT>')<EOL>])<EOL>description=TextAreaField(<EOL>u'Description',<EOL>validators=[<EOL>DataRequired(message='<STR_LIT>'),<EOL>Length(max=,message='<STR_LIT>')<EOL>])<EOL>body=TextAreaField(<EOL>u'Content',<EOL>validators=[DataRequired(message=u'Empty Post')])<EOL>submit=SubmitField(u'Add Post')<EOL><DEDENT>class TagForm(Form):<EOL><INDENT> '<STR_LIT>'<EOL>name=StringField(<EOL>'<STR_LIT>',<EOL>validators=[<EOL>DataRequired(message=u'Empty name'),<EOL>Length(max=,message='<STR_LIT>')<EOL>])<EOL><DEDENT><EOF><BOF>from collections import OrderedDict <EOL>from zerotest.request import Request <EOL>from zerotest.utils.generator_helper import(<EOL>get_name_from_request,<EOL>dict_to_param_style_code )<EOL>INVALID_CHARS=(<EOL>'*',<EOL>'-',<EOL>'#',<EOL>'/',<EOL>'.')<EOL>def test_get_name_from_request():<EOL><INDENT>req=Request(path='/',method='GET')<EOL>assert get_name_from_request(req)=='get_root'<EOL>req=Request(path='/the/world',method='PUT')<EOL>assert get_name_from_request(req)=='put_the_world'<EOL>for invalid_char in INVALID_CHARS :<EOL><INDENT>assert(<EOL>get_name_from_request(<EOL>Request(<EOL>path='<STR_LIT>'.format(invalid_char),<EOL>method='GET'))=='<STR_LIT>')<EOL><DEDENT> <DEDENT>def test_dict_to_param_style_code():<EOL><INDENT>test_dict=OrderedDict()<EOL>test_dict ['param_a']='A'<EOL>test_dict ['test_c']='C'<EOL>assert dict_to_param_style_code(test_dict)=='<STR_LIT>'<EOL><DEDENT><EOF><BOF>import cv2 <EOL>import numpy as np <EOL>from cam import OpenCV_Cam <EOL>from time import time <EOL>def draw_oriented_polylines(img,pts_in,is_closed,color_start,thickness=,color_end=(,,)):<EOL><INDENT>img_out=img <EOL>pts=pts_in.reshape(-,)<EOL>if len(img.shape)==or img.shape []==:<EOL><INDENT>img_out=cv2.cvtColor(img_out,cv2.COLOR_GRAY2BGR)<EOL><DEDENT>cs,ce=color_start,color_end <EOL>n=len(pts)<EOL>for idx,pt in enumerate(pts):<EOL><INDENT>if idx==n and not is_closed :break <EOL>next_pt=pts [(idx +)%n ]<EOL>color=((cs []*(n -idx)+ce []*idx)/n,(cs []*(n -idx)+ce []*idx)/n,(cs []*(n -idx)+ce []*idx)/n)<EOL>cv2.line(img_out,tuple(pt),tuple(next_pt),color,thickness)<EOL><DEDENT> <DEDENT>def find_polygons(gray_image_in,edge_num,tolerance=,area_threshold=,convex_only=True,edge_threshold=,orientation=):<EOL><INDENT> '<STR_LIT>'<EOL>img=gray_image_in.copy()<EOL>lo,hi=,<EOL>edge=cv2.Canny(img,lo,hi)<EOL>thresh1,dst=cv2.threshold(edge,edge_threshold,,cv2.THRESH_BINARY)<EOL>ctr,hry=cv2.findContours(dst,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)<EOL>if hry is None :return []<EOL>hry=hry []<EOL>polygons=[]<EOL>for cnt in ctr :<EOL><INDENT>cnt=cnt.reshape(-,)<EOL>epsilon=tolerance **((*cv2.contourArea(cnt))**)<EOL>tmp=cv2.approxPolyDP(cnt,epsilon,True)<EOL>if len(tmp)!=edge_num :continue <EOL>if convex_only and not cv2.isContourConvex(tmp):continue <EOL>if cv2.contourArea(tmp)<area_threshold :continue <EOL>cross_product=np.cross(tmp []-tmp [],tmp []-tmp [])[]<EOL>if cross_product *orientation >:<EOL><INDENT>tmp=np.flipud(tmp)<EOL><DEDENT>tmp=tmp.reshape(-,)<EOL>distance_from_origin=map(lambda pt :pt []**+pt []**,tmp)<EOL>val,idx=min((val,idx)for(idx,val)in enumerate(distance_from_origin))<EOL>if idx >:<EOL><INDENT>up,down=np.vsplit(tmp,[idx ])<EOL>tmp=np.vstack((down,up))<EOL><DEDENT>polygons.append(tmp)<EOL><DEDENT>return polygons <EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>cam=OpenCV_Cam()<EOL>while True :<EOL><INDENT>img=cam.read()<EOL>polygons=find_polygons(img,)<EOL>for ctr in polygons :<EOL><INDENT>draw_oriented_polylines(img,ctr,,(,,),,(,,))<EOL><DEDENT>cv2.imshow('<STR_LIT>',img)<EOL>k=cv2.waitKey()<EOL>if k==:<EOL><INDENT>break <DEDENT> <DEDENT> <DEDENT><EOF><BOF>import slugify <EOL>from flask import url_for <EOL>from vomitter import LOGGER as L <EOL>from yapper import db <EOL>from yapper.lib.models import BaseModel <EOL>from yapper.lib.cache import cache <EOL>from yapper.lib.decorators import profile <EOL>from yapper.utilities.md import create_post_from_md <EOL>TYPE_POST=<EOL>TYPE_PAGE=<EOL>tags_posts=db.Table(<EOL>'tags_posts',<EOL>db.Column('id',db.Integer,primary_key=True),<EOL>db.Column('tag_id',db.Integer,db.ForeignKey('tags.id')),<EOL>db.Column('post_id',db.Integer,db.ForeignKey('posts.id')))<EOL>categories_posts=db.Table(<EOL>'<STR_LIT>',<EOL>db.Column('id',db.Integer,primary_key=True),<EOL>db.Column('category_id',db.Integer,db.ForeignKey('categories.id')),<EOL>db.Column('post_id',db.Integer,db.ForeignKey('posts.id')))<EOL>class Tag(BaseModel):<EOL><INDENT>__tablename__='tags'<EOL>id=db.Column(db.Integer(),primary_key=True)<EOL>name=db.Column(db.String(),unique=True,index=True)<EOL>def __repr__(self):<EOL><INDENT>return '<Tag %s>'%self.name <EOL><DEDENT>def to_json(self):<EOL><INDENT>json_data={<EOL>'id':self.id,<EOL>'name':self.name,<EOL>'created_at':str(self.created_at)}<EOL>return json_data <EOL><DEDENT> <DEDENT>class Category(BaseModel):<EOL><INDENT>__tablename__='categories'<EOL>id=db.Column(db.Integer(),primary_key=True)<EOL>name=db.Column(db.String(),unique=True,index=True)<EOL>def __repr__(self):<EOL><INDENT>return '<Category %s>'%self.name <EOL><DEDENT>def to_json(self):<EOL><INDENT>json_data={<EOL>'id':self.id,<EOL>'name':self.name,<EOL>'created_at':str(self.created_at)}<EOL>return json_data <EOL><DEDENT> <DEDENT>class Post(BaseModel):<EOL><INDENT>__tablename__='posts'<EOL>author_id=db.Column(db.Integer,db.ForeignKey('users.id'))<EOL>title=db.Column(db.String())<EOL>slug=db.Column(db.String(),unique=True)<EOL>description=db.Column(db.Text,default='')<EOL>body=db.Column(db.Text,default='')<EOL>status=db.Column(db.Boolean,default=True)<EOL>body_html=db.Column(db.Text,default='')<EOL>tags=db.relationship(<EOL>'Tag',secondary=tags_posts,<EOL>backref=db.backref('posts',lazy='dynamic'))<EOL>categories=db.relationship(<EOL>'Category',secondary=categories_posts,<EOL>backref=db.backref('posts',lazy='dynamic'))<EOL>def to_json(self):<EOL><INDENT>json_data={<EOL>'id':self.id,<EOL>'title':self.title,<EOL>'slug':self.slug,<EOL>'description':self.description,<EOL>'created_at':str(self.created_at),<EOL>'modified_at':str(self.modified_at),<EOL>'author':self.author.to_json(),<EOL>'permalink':url_for('<STR_LIT>',<EOL>slug=self.slug,_external=True)<EOL>}<EOL>return json_data <EOL><DEDENT>@classmethod <EOL>@profile <EOL>def get_by_slug(cls,slug):<EOL><INDENT>L.d('<STR_LIT>')<EOL>obj=cache.get(cls.key(slug))<EOL>if obj :<EOL><INDENT>L.d('<STR_LIT>'%cls.key(slug))<EOL>return obj <EOL><DEDENT>L.d('<STR_LIT>'%cls.key(slug))<EOL>obj=cls.query.filter_by(slug=slug).first()<EOL>if obj :<EOL><INDENT>L.d('<STR_LIT>'%cls.key(slug))<EOL>cache.set(cls.key(slug),obj)<EOL><DEDENT>else :<EOL><INDENT>L.d('<STR_LIT>')<EOL><DEDENT>return obj <EOL><DEDENT>@property <EOL>def content(self):<EOL><INDENT>return self.body <EOL><DEDENT>@content.setter <EOL>def content(self,body):<EOL><INDENT>self.body=body <EOL>self.body_html=create_post_from_md(body)<EOL><DEDENT>@property <EOL>def html(self):<EOL><INDENT>return self.body_html <EOL><DEDENT>@staticmethod <EOL>def on_change_body(target,value,oldvalue,initiator):<EOL><INDENT>target.body_html=create_post_from_md(value)<EOL><DEDENT>@staticmethod <EOL>def generate_fake(count=):<EOL><INDENT>from random import seed <EOL>import forgery_py <EOL>seed()<EOL>for i in range(count):<EOL><INDENT>author_id=<EOL>title=forgery_py.lorem_ipsum.sentence()<EOL>p=Post(<EOL>content=forgery_py.lorem_ipsum.paragraphs(),<EOL>title=title,<EOL>slug=slugify.slugify(title),<EOL>description=forgery_py.lorem_ipsum.sentence(),<EOL>author_id=author_id )<EOL>db.session.add(p)<EOL><DEDENT>db.session.commit()<EOL><DEDENT> <DEDENT>db.event.listen(Post.body,'set',Post.on_change_body)<EOF><BOF>USAGE='<STR_LIT>'<EOL>import os <EOL>import sys <EOL>from StringIO import StringIO <EOL>if 'robot'not in sys.modules and __name__=='__main__':<EOL><INDENT>import pythonpathsetter <EOL><DEDENT>from robot.errors import DataError <EOL>from robot.parsing import(ResourceFile,TestDataDirectory,TestCaseFile,<EOL>disable_curdir_processing)<EOL>from robot.utils import Application <EOL>class Tidy(object):<EOL><INDENT>def __init__(self,**options):<EOL><INDENT>self._options=options <EOL><DEDENT>def file(self,path,output=None):<EOL><INDENT>data=self._create_datafile(path)<EOL>outfile=open(output,'w')if output else StringIO()<EOL>try :<EOL><INDENT>self._save_file(data,outfile)<EOL>if not output :<EOL><INDENT>return outfile.getvalue().replace('\r\n','\n').decode('UTF-8')<EOL><DEDENT> <DEDENT>finally :<EOL><INDENT>outfile.close()<EOL><DEDENT> <DEDENT>def directory(self,path):<EOL><INDENT>self._save_directory(TestDataDirectory(source=path).populate())<EOL><DEDENT>def inplace(self,path):<EOL><INDENT>self._save_file(self._create_datafile(path))<EOL><DEDENT>def _save_file(self,data,output=None):<EOL><INDENT>source=data.initfile if self._is_directory(data)else data.source <EOL>if source and not output :<EOL><INDENT>os.remove(source)<EOL><DEDENT>data.save(output=output,**self._options)<EOL><DEDENT>def _save_directory(self,data):<EOL><INDENT>if not self._is_directory(data):<EOL><INDENT>self._save_file(data)<EOL>return <EOL><DEDENT>if data.initfile :<EOL><INDENT>self._save_file(data)<EOL><DEDENT>for child in data.children :<EOL><INDENT>self._save_directory(child)<EOL><DEDENT> <DEDENT>def _is_directory(self,data):<EOL><INDENT>return hasattr(data,'initfile')<EOL><DEDENT>@disable_curdir_processing <EOL>def _create_datafile(self,source):<EOL><INDENT>if self._is_init_file(source):<EOL><INDENT>dir_=os.path.dirname(source)<EOL>return TestDataDirectory(source=dir_).populate(recurse=False)<EOL><DEDENT>try :<EOL><INDENT>return TestCaseFile(source=source).populate()<EOL><DEDENT>except DataError :<EOL><INDENT>try :<EOL><INDENT>return ResourceFile(source=source).populate()<EOL><DEDENT>except DataError :<EOL><INDENT>raise DataError('<STR_LIT>'%source)<EOL><DEDENT> <DEDENT> <DEDENT>def _is_init_file(self,source):<EOL><INDENT>return os.path.splitext(os.path.basename(source))[]=='__init__'<EOL><DEDENT> <DEDENT>class TidyCommandLine(Application):<EOL><INDENT>def __init__(self):<EOL><INDENT>Application.__init__(self,USAGE,arg_limits=(,))<EOL><DEDENT>def main(self,arguments,recursive=False,inplace=False,format='txt',<EOL>usepipes=False,spacecount=):<EOL><INDENT>tidy=Tidy(format=format,pipe_separated=usepipes,<EOL>txt_separating_spaces=spacecount)<EOL>if recursive :<EOL><INDENT>tidy.directory(arguments [])<EOL><DEDENT>elif inplace :<EOL><INDENT>for source in arguments :<EOL><INDENT>tidy.inplace(source)<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>output=tidy.file(*arguments)<EOL>self.console(output)<EOL><DEDENT> <DEDENT>def validate(self,opts,args):<EOL><INDENT>self._validate_mode_and_arguments(args,**opts)<EOL>opts ['format']=self._validate_format(args,**opts)<EOL>if not opts ['spacecount']:<EOL><INDENT>opts.pop('spacecount')<EOL><DEDENT>else :<EOL><INDENT>opts ['spacecount']=self._validate_spacecount(opts ['spacecount'])<EOL><DEDENT>return opts,args <EOL><DEDENT>def _validate_mode_and_arguments(self,args,inplace,recursive,**others):<EOL><INDENT>if inplace and recursive :<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>if recursive and(len(args)>or not os.path.isdir(args [])):<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>if not(inplace or recursive)and len(args)>:<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT> <DEDENT>def _validate_format(self,args,format,inplace,recursive,**others):<EOL><INDENT>if not format :<EOL><INDENT>if inplace or recursive or len(args)<:<EOL><INDENT>return None <EOL><DEDENT>format=os.path.splitext(args [])[][:]<EOL><DEDENT>format=format.upper()<EOL>if format not in ['TXT','TSV','HTML']:<EOL><INDENT>raise DataError('<STR_LIT>'%format)<EOL><DEDENT>return format <EOL><DEDENT>def _validate_spacecount(self,spacecount):<EOL><INDENT>try :<EOL><INDENT>spacecount=int(spacecount)<EOL>if spacecount <:<EOL><INDENT>raise ValueError <EOL><DEDENT> <DEDENT>except ValueError :<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>return spacecount <EOL><DEDENT> <DEDENT>def tidy_cli(args):<EOL><INDENT> '<STR_LIT>'<EOL>TidyCommandLine().execute_cli(args)<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>tidy_cli(sys.argv [:])<EOL><DEDENT><EOF><BOF>from robot.utils import setter <EOL>from itemlist import ItemList <EOL>from message import Message,Messages <EOL>from modelobject import ModelObject <EOL>class Keyword(ModelObject):<EOL><INDENT>__slots__=['parent','name','doc','args','type','timeout']<EOL>KEYWORD_TYPE='kw'<EOL>SETUP_TYPE='setup'<EOL>TEARDOWN_TYPE='teardown'<EOL>FOR_LOOP_TYPE='for'<EOL>FOR_ITEM_TYPE='foritem'<EOL>message_class=Message <EOL>def __init__(self,name='',doc='',args=None,type='kw',timeout=''):<EOL><INDENT>self.parent=None <EOL>self.name=name <EOL>self.doc=doc <EOL>self.args=args or []<EOL>self.type=type <EOL>self.timeout=timeout <EOL>self.messages=[]<EOL>self.keywords=[]<EOL><DEDENT>@setter <EOL>def keywords(self,keywords):<EOL><INDENT>return Keywords(self.__class__,self,keywords)<EOL><DEDENT>@setter <EOL>def messages(self,messages):<EOL><INDENT>return Messages(self.message_class,self,messages)<EOL><DEDENT>@property <EOL>def id(self):<EOL><INDENT>if not self.parent :<EOL><INDENT>return 'k1'<EOL><DEDENT>return '%s-k%d'%(self.parent.id,self.parent.keywords.index(self)+)<EOL><DEDENT>def visit(self,visitor):<EOL><INDENT>visitor.visit_keyword(self)<EOL><DEDENT> <DEDENT>class Keywords(ItemList):<EOL><INDENT>__slots__=[]<EOL>def __init__(self,keyword_class=Keyword,parent=None,keywords=None):<EOL><INDENT>ItemList.__init__(self,keyword_class,{'parent':parent },keywords)<EOL><DEDENT>@property <EOL>def setup(self):<EOL><INDENT>return self []if(self and self [].type=='setup')else None <EOL><DEDENT>@property <EOL>def teardown(self):<EOL><INDENT>return self [-]if(self and self [-].type=='teardown')else None <EOL><DEDENT>@property <EOL>def all(self):<EOL><INDENT>return self <EOL><DEDENT>@property <EOL>def normal(self):<EOL><INDENT>for kw in self :<EOL><INDENT>if kw.type not in('setup','teardown'):<EOL><INDENT>yield kw <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>__author__='<STR_LIT>'<EOL>from google.appengine.ext import db <EOL>from oauth2client.appengine import CredentialsProperty <EOL>class Credentials(db.Model):<EOL><INDENT> '<STR_LIT>'<EOL>credentials=CredentialsProperty()<EOL><DEDENT><EOF><BOF>__title__='jsongit'<EOL>__author__='John Krauss'<EOL>__license__='BSD'<EOL>__copyright__='<STR_LIT>'<EOL>from.api import init <EOL>from.utils import signature,global_config <EOL>from.exceptions import(<EOL>NotJsonError,InvalidKeyError,DifferentRepoError,NoGlobalSettingError,<EOL>StagedDataError)<EOL>from.constants import GIT_SORT_NONE,GIT_SORT_TOPOLOGICAL,GIT_SORT_TIME,GIT_SORT_REVERSE <EOF><BOF>import sys <EOL>VERSION='2.7.5'<EOL>RELEASE='final'<EOL>TIMESTAMP='20121024-155048'<EOL>def get_version(sep=' '):<EOL><INDENT>if RELEASE=='final':<EOL><INDENT>return VERSION <EOL><DEDENT>return VERSION +sep +RELEASE <EOL><DEDENT>def get_full_version(who=''):<EOL><INDENT>sys_version=sys.version.split()[]<EOL>version='<STR_LIT>'%(who,get_version(),_get_interpreter(),sys_version,sys.platform)<EOL>return version.strip()<EOL><DEDENT>def _get_interpreter():<EOL><INDENT>if sys.platform.startswith('java'):<EOL><INDENT>return 'Jython'<EOL><DEDENT>if sys.platform=='cli':<EOL><INDENT>return 'IronPython'<EOL><DEDENT>if 'PyPy'in sys.version :<EOL><INDENT>return 'PyPy'<EOL><DEDENT>return 'Python'<EOL><DEDENT><EOF><BOF>from __future__ import unicode_literals <EOL>from __future__ import print_function <EOL>import logging <EOL>import sys <EOL>from zerotest.fuzzy_matcher import FuzzyMatcher <EOL>LOG=logging.getLogger(__name__)<EOL>_SERIALIZABLE_CONTENT_TYPE={'<STR_LIT>':'json'}<EOL>class ResponseMatcher(object):<EOL><INDENT>def __init__(self,fuzzy_match=False,fuzzy_match_options=None,ignore_headers=None,ignore_all_headers=False,<EOL>ignore_fields=None):<EOL><INDENT> '<STR_LIT>'<EOL>ignore_headers=ignore_headers or []<EOL>self._fuzzy_match=fuzzy_match <EOL>self._fuzzy_match_options=fuzzy_match_options or {}<EOL>self._ignore_headers=set(map(lambda h :h.upper(),ignore_headers))<EOL>self._ignore_all_headers=ignore_all_headers <EOL>self._ignore_fields=ignore_fields <EOL><DEDENT>def _compare_status(self,r1,r2):<EOL><INDENT>assert r1.status==r2.status <EOL><DEDENT>def __remove_ignore_headers(self,headers):<EOL><INDENT>return {k.upper():headers [k ]for k in headers if <EOL>k.upper()not in self._ignore_headers }<EOL><DEDENT>def _compare_headers(self,expect,real):<EOL><INDENT>if not self._ignore_all_headers :<EOL><INDENT>expect_headers=self.__remove_ignore_headers(expect.headers)<EOL>real_headers=self.__remove_ignore_headers(real.headers)<EOL>assert expect_headers==real_headers <EOL><DEDENT> <DEDENT>def __delete_ignore_fields(self,content):<EOL><INDENT>from zerotest.utils.data_helper import delete_path_from_dict <EOL>for field_path in self._ignore_fields or():<EOL><INDENT>if field_path in content :<EOL><INDENT>content.pop(field_path,None)<EOL><DEDENT>else :<EOL><INDENT>delete_path_from_dict(content,field_path)<EOL><DEDENT> <DEDENT> <DEDENT>def _handle_content_type_json(self,content):<EOL><INDENT>import json <EOL>try :<EOL><INDENT>content=json.loads(content)<EOL><DEDENT>except :<EOL><INDENT>LOG.error('<STR_LIT>')<EOL>raise <EOL><DEDENT>self.__delete_ignore_fields(content)<EOL>return content <EOL><DEDENT>def _prepare_body_data(self,r1,r2):<EOL><INDENT>r1_content_type=r1.get_header('Content-Type')<EOL>r2_content_type=r2.get_header('Content-Type')<EOL>assert r1_content_type==r2_content_type <EOL>r1_content=r1.body <EOL>r2_content=r2.body <EOL>content_type=None <EOL>if r1_content_type :<EOL><INDENT>values=r1_content_type.split(';')<EOL>for v in values :<EOL><INDENT>content_type=_SERIALIZABLE_CONTENT_TYPE.get(v.lower())<EOL>if content_type :<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT>if content_type :<EOL><INDENT>handler=getattr(self,'<STR_LIT>'.format(content_type))<EOL>if handler :<EOL><INDENT>r1_content=handler(r1_content)<EOL>r2_content=handler(r2_content)<EOL><DEDENT> <DEDENT>return r1_content,r2_content <EOL><DEDENT>def _compare_body(self,r1,r2):<EOL><INDENT>r1_content,r2_content=self._prepare_body_data(r1,r2)<EOL>is_formatted=all([isinstance(c,dict)for c in(r1_content,r2_content)])<EOL>if self._fuzzy_match and is_formatted :<EOL><INDENT>fuzzy_matcher=FuzzyMatcher(**self._fuzzy_match_options)<EOL>fuzzy_matcher.set_items(r1_content,r2_content)<EOL>try :<EOL><INDENT>fuzzy_matcher.compare()<EOL><DEDENT>except AssertionError :<EOL><INDENT>print('expect : {}'.format(r1_content),file=sys.stderr)<EOL>print('actual : {}'.format(r2_content),file=sys.stderr)<EOL>raise <EOL><DEDENT> <DEDENT>else :<EOL><INDENT>assert r1_content==r2_content <EOL><DEDENT> <DEDENT>def match_responses(self,expect,real):<EOL><INDENT> '<STR_LIT>'<EOL>for attr in('status','headers','body'):<EOL><INDENT>compare_func='_compare_{}'.format(attr)<EOL>getattr(self,compare_func)(expect,real)<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>from robot.utils import setter <EOL>from.tags import TagPatterns <EOL>from.namepatterns import SuiteNamePatterns,TestNamePatterns <EOL>from.visitor import SuiteVisitor <EOL>class Filter(SuiteVisitor):<EOL><INDENT>def __init__(self,include_suites=None,include_tests=None,<EOL>include_tags=None,exclude_tags=None):<EOL><INDENT>self.include_suites=include_suites <EOL>self.include_tests=include_tests <EOL>self.include_tags=include_tags <EOL>self.exclude_tags=exclude_tags <EOL><DEDENT>@setter <EOL>def include_suites(self,suites):<EOL><INDENT>return SuiteNamePatterns(suites)if not isinstance(suites,SuiteNamePatterns)else suites <EOL><DEDENT>@setter <EOL>def include_tests(self,tests):<EOL><INDENT>return TestNamePatterns(tests)if not isinstance(tests,TestNamePatterns)else tests <EOL><DEDENT>@setter <EOL>def include_tags(self,tags):<EOL><INDENT>return TagPatterns(tags)if not isinstance(tags,TagPatterns)else tags <EOL><DEDENT>@setter <EOL>def exclude_tags(self,tags):<EOL><INDENT>return TagPatterns(tags)if not isinstance(tags,TagPatterns)else tags <EOL><DEDENT>def start_suite(self,suite):<EOL><INDENT>if not self :<EOL><INDENT>return False <EOL><DEDENT>if hasattr(suite,'starttime'):<EOL><INDENT>suite.starttime=suite.endtime=None <EOL><DEDENT>if self.include_suites :<EOL><INDENT>return self._filter_by_suite_name(suite)<EOL><DEDENT>if self.include_tests :<EOL><INDENT>suite.tests=self._filter(suite,self._included_by_test_name)<EOL><DEDENT>if self.include_tags :<EOL><INDENT>suite.tests=self._filter(suite,self._included_by_tags)<EOL><DEDENT>if self.exclude_tags :<EOL><INDENT>suite.tests=self._filter(suite,self._not_excluded_by_tags)<EOL><DEDENT>return bool(suite.suites)<EOL><DEDENT>def _filter_by_suite_name(self,suite):<EOL><INDENT>if self.include_suites.match(suite.name,suite.longname):<EOL><INDENT>suite.visit(Filter(include_suites=[],<EOL>include_tests=self.include_tests,<EOL>include_tags=self.include_tags,<EOL>exclude_tags=self.exclude_tags))<EOL>return False <EOL><DEDENT>suite.tests=[]<EOL>return True <EOL><DEDENT>def _filter(self,suite,filter):<EOL><INDENT>return [t for t in suite.tests if filter(t)]<EOL><DEDENT>def _included_by_test_name(self,test):<EOL><INDENT>return self.include_tests.match(test.name,test.longname)<EOL><DEDENT>def _included_by_tags(self,test):<EOL><INDENT>return self.include_tags.match(test.tags)<EOL><DEDENT>def _not_excluded_by_tags(self,test):<EOL><INDENT>return not self.exclude_tags.match(test.tags)<EOL><DEDENT>def end_suite(self,suite):<EOL><INDENT>suite.suites=[s for s in suite.suites if s.test_count ]<EOL><DEDENT>def visit_test(self,test):<EOL><INDENT>pass <EOL><DEDENT>def visit_keyword(self,keyword):<EOL><INDENT>pass <EOL><DEDENT>def __nonzero__(self):<EOL><INDENT>return bool(self.include_suites or self.include_tests or <EOL>self.include_tags or self.exclude_tags)<EOL><DEDENT> <DEDENT><EOF><BOF>from distutils.core import setup <EOL>from postbox import __version__ <EOL>setup(<EOL>name='postbox',<EOL>description='<STR_LIT>',<EOL>long_description=open('README.rst').read(),<EOL>version=__version__,<EOL>author='Mosky',<EOL>author_email='<STR_LIT>',<EOL>url='<STR_LIT>',<EOL>py_modules=['postbox'],<EOL>license='MIT',<EOL>classifiers=[<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>])<EOF><BOF>from django.conf import settings <EOL>from django.contrib.auth import get_user_model <EOL>from django.core.urlresolvers import reverse <EOL>from django.test import TestCase,Client,override_settings <EOL>from mock import patch <EOL>from buildservice.models import OAuthToken,Repository <EOL>@override_settings(GITHUB_CLIENT_SECRET='the_secret')<EOL>class OAuthViewsTestCase(TestCase):<EOL><INDENT>login_url=reverse('oauth_login')<EOL>callback_url=reverse('oauth_callback')<EOL>def setUp(self):<EOL><INDENT>self.client=Client()<EOL>self.user=get_user_model().objects.create_user('user',password='pwd')<EOL><DEDENT>def test_get_login_anonymous(self):<EOL><INDENT>resp=self.client.get(self.login_url)<EOL>self.assertEqual(resp.status_code,)<EOL>self.assertEqual(resp.url,reverse('auth_login')+'?next='+self.login_url)<EOL><DEDENT>@patch(<EOL>'<STR_LIT>',<EOL>return_value=('<STR_LIT>','the_state'))<EOL>def test_get_login_ok(self,authorization_url):<EOL><INDENT>self.assertTrue(self.client.login(username='user',password='pwd'))<EOL>resp=self.client.get(self.login_url)<EOL>self.assertEqual(resp.status_code,)<EOL>authorization_url.assert_called_with(settings.GITHUB_AUTHORIZATION_BASE_URL)<EOL>self.assertEqual(resp.url,'<STR_LIT>')<EOL>self.assertEqual(resp.wsgi_request.session ['oauth_state'],'the_state')<EOL><DEDENT>def test_callback_anonymous(self):<EOL><INDENT>resp=self.client.get(self.callback_url)<EOL>self.assertEqual(resp.status_code,)<EOL>self.assertEqual(resp.url,reverse('auth_login')+'?next='+self.callback_url)<EOL><DEDENT>def test_callback_token_missing_oauth_state(self):<EOL><INDENT>self.assertTrue(self.client.login(username='user',password='pwd'))<EOL>resp=self.client.get(self.callback_url)<EOL>self.assertEqual(resp.status_code,)<EOL>self.assertEqual(resp.content,'<STR_LIT>')<EOL><DEDENT>@patch('<STR_LIT>',return_value='token')<EOL>def test_callback_token_malformatted(self,fetch_token):<EOL><INDENT>self.assertTrue(self.client.login(username='user',password='pwd'))<EOL>session=self.client.session <EOL>session ['oauth_state']='the_state'<EOL>session.save()<EOL>resp=self.client.get(self.callback_url)<EOL>fetch_token.assert_called_with(<EOL>settings.GITHUB_TOKEN_URL,<EOL>client_secret='the_secret',<EOL>authorization_response=resp.wsgi_request.build_absolute_uri())<EOL>self.assertEqual(resp.status_code,)<EOL>self.assertEqual(resp.content,'<STR_LIT>')<EOL><DEDENT>@patch('<STR_LIT>',return_value={})<EOL>def test_callback_token_malformatted_bis(self,fetch_token):<EOL><INDENT>self.assertTrue(self.client.login(username='user',password='pwd'))<EOL>session=self.client.session <EOL>session ['oauth_state']='the_state'<EOL>session.save()<EOL>resp=self.client.get(self.callback_url)<EOL>fetch_token.assert_called_with(<EOL>settings.GITHUB_TOKEN_URL,<EOL>client_secret='the_secret',<EOL>authorization_response=resp.wsgi_request.build_absolute_uri())<EOL>self.assertEqual(resp.status_code,)<EOL>self.assertEqual(resp.content,'<STR_LIT>')<EOL><DEDENT>@patch.object(Repository,'<STR_LIT>')<EOL>@patch('<STR_LIT>',return_value={'access_token':'abc'})<EOL>def test_callback_ok(self,fetch_token,add_repos):<EOL><INDENT>self.assertTrue(self.client.login(username='user',password='pwd'))<EOL>session=self.client.session <EOL>session ['oauth_state']='the_state'<EOL>session.save()<EOL>resp=self.client.get(self.callback_url)<EOL>fetch_token.assert_called_with(<EOL>settings.GITHUB_TOKEN_URL,<EOL>client_secret='the_secret',<EOL>authorization_response=resp.wsgi_request.build_absolute_uri())<EOL>add_repos.assert_called_with(self.user)<EOL>self.assertEqual(resp.status_code,)<EOL>self.assertEqual(resp.url,'/')<EOL>token=OAuthToken.objects.get(user=self.user)<EOL>self.assertEqual(token.value,'abc')<EOL><DEDENT> <DEDENT><EOF><BOF>try :<EOL><INDENT>from Queue import Queue,Empty <EOL><DEDENT>except ImportError :<EOL><INDENT>from queue import Queue,Empty <EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>__author__=['<STR_LIT>',<EOL>'<STR_LIT>',<EOL>]<EOL>__all__=[<EOL>'positional',<EOL>]<EOL>import gflags <EOL>import inspect <EOL>import logging <EOL>import types <EOL>import urllib <EOL>import urlparse <EOL>try :<EOL><INDENT>from urlparse import parse_qsl <EOL><DEDENT>except ImportError :<EOL><INDENT>from cgi import parse_qsl <EOL><DEDENT>logger=logging.getLogger(__name__)<EOL>FLAGS=gflags.FLAGS <EOL>gflags.DEFINE_enum('<STR_LIT>','WARNING',<EOL>['EXCEPTION','WARNING','IGNORE'],<EOL>'<STR_LIT>')<EOL>def positional(max_positional_args):<EOL><INDENT> '<STR_LIT>'<EOL>def positional_decorator(wrapped):<EOL><INDENT>def positional_wrapper(*args,**kwargs):<EOL><INDENT>if len(args)>max_positional_args :<EOL><INDENT>plural_s=''<EOL>if max_positional_args !=:<EOL><INDENT>plural_s='s'<EOL><DEDENT>message='<STR_LIT>'%(<EOL>wrapped.__name__,max_positional_args,plural_s,len(args))<EOL>if FLAGS.positional_parameters_enforcement=='EXCEPTION':<EOL><INDENT>raise TypeError(message)<EOL><DEDENT>elif FLAGS.positional_parameters_enforcement=='WARNING':<EOL><INDENT>logger.warning(message)<EOL><DEDENT>else :<EOL><INDENT>pass <EOL><DEDENT> <DEDENT>return wrapped(*args,**kwargs)<EOL><DEDENT>return positional_wrapper <EOL><DEDENT>if isinstance(max_positional_args,(int,long)):<EOL><INDENT>return positional_decorator <EOL><DEDENT>else :<EOL><INDENT>args,_,_,defaults=inspect.getargspec(max_positional_args)<EOL>return positional(len(args)-len(defaults))(max_positional_args)<EOL><DEDENT> <DEDENT>def scopes_to_string(scopes):<EOL><INDENT> '<STR_LIT>'<EOL>if isinstance(scopes,types.StringTypes):<EOL><INDENT>return scopes <EOL><DEDENT>else :<EOL><INDENT>return ' '.join(scopes)<EOL><DEDENT> <DEDENT>def dict_to_tuple_key(dictionary):<EOL><INDENT> '<STR_LIT>'<EOL>return tuple(sorted(dictionary.items()))<EOL><DEDENT>def _add_query_parameter(url,name,value):<EOL><INDENT> '<STR_LIT>'<EOL>if value is None :<EOL><INDENT>return url <EOL><DEDENT>else :<EOL><INDENT>parsed=list(urlparse.urlparse(url))<EOL>q=dict(parse_qsl(parsed []))<EOL>q [name ]=value <EOL>parsed []=urllib.urlencode(q)<EOL>return urlparse.urlunparse(parsed)<EOL><DEDENT> <DEDENT><EOF><BOF>from __future__ import print_function <EOL>__all__=['start','customize','CMD_SUFFIX','Program','Command']<EOL>import sys <EOL>import inspect <EOL>import re <EOL>from os.path import basename <EOL>from collections import defaultdict <EOL>from.util import json,autotype,getargspec <EOL>Empty=type('Empty',(object,),{<EOL>'__nonzero__':lambda self :False,<EOL>'__repr__':lambda self :'Empty',<EOL>})()<EOL>class Command(object):<EOL><INDENT> '<STR_LIT>'<EOL>arg_desc_re=re.compile(r'^\s*-')<EOL>'<STR_LIT>'<EOL>arg_re=re.compile('<STR_LIT>')<EOL>'<STR_LIT>'<EOL>arg_type_map={<EOL>'n':int,'num':int,'number':int,<EOL>'i':int,'int':int,'integer':int,<EOL>'s':str,'str':str,'string':str,<EOL>'f':float,'float':float,<EOL>'json':json,<EOL>None :autotype <EOL>}<EOL>'<STR_LIT>'<EOL>def __init__(self,func,name=None):<EOL><INDENT>self.name=name <EOL>self.func=func <EOL>arg_names,vararg_name,keyarg_name,arg_defaults=getargspec(func)<EOL>self.arg_names=arg_names <EOL>self.vararg_name=vararg_name <EOL>self.keyarg_name=keyarg_name <EOL>self.arg_defaults=arg_defaults or tuple()<EOL>self.no_defult_args_len=len(self.arg_names)-len(self.arg_defaults)<EOL>self.arg_name_set=set(arg_names)<EOL>self.arg_default_map=dict(zip(<EOL>*map(reversed,(self.arg_names,self.arg_defaults))))<EOL>self.arg_meta_map={}<EOL>self.alias_arg_map={}<EOL>doc=inspect.getdoc(func)<EOL>if not doc :return <EOL>for line in doc.splitlines():<EOL><INDENT>if not self.arg_desc_re.match(line):continue <EOL>arg_part,_,desc_part=line.strip().partition('  ')<EOL>aliases_set=set()<EOL>for m in self.arg_re.finditer(arg_part):<EOL><INDENT>key,meta=m.group('key','meta')<EOL>key=key.replace('-','_')<EOL>self.arg_meta_map [key ]=meta <EOL>aliases_set.add(key)<EOL><DEDENT>arg_name_set=self.arg_name_set &aliases_set <EOL>if not arg_name_set :continue <EOL>aliases_set -=arg_name_set <EOL>arg_name=arg_name_set.pop()<EOL>for alias in aliases_set :<EOL><INDENT>self.alias_arg_map [alias ]=arg_name <EOL><DEDENT> <DEDENT> <DEDENT>def dealias(self,alias):<EOL><INDENT> '<STR_LIT>'<EOL>return self.alias_arg_map.get(alias,alias)<EOL><DEDENT>def cast(self,arg_name,val):<EOL><INDENT> '<STR_LIT>'<EOL>meta=self.arg_meta_map.get(arg_name)<EOL>if meta is not None :<EOL><INDENT>meta=meta.strip('<>').lower()<EOL><DEDENT>type=self.arg_type_map [meta ]<EOL>return type(val)<EOL><DEDENT>def parse(self,raw_args=None):<EOL><INDENT> '<STR_LIT>'<EOL>if raw_args is None :<EOL><INDENT>raw_args=sys.argv [:]<EOL><DEDENT>elif isinstance(raw_args,str):<EOL><INDENT>raw_args=raw_args.split()<EOL><DEDENT>pargs=[]<EOL>kargs=defaultdict(list)<EOL>while raw_args :<EOL><INDENT>arg_name=None <EOL>val=Empty <EOL>if raw_args [].startswith('-')and len(raw_args [])>=:<EOL><INDENT>before_eq_str,eq_str,val=raw_args.pop().partition('=')<EOL>if not eq_str :<EOL><INDENT>val=Empty <EOL><DEDENT>if before_eq_str.startswith('--'):<EOL><INDENT>arg_name=self.dealias(before_eq_str [:].replace('-','_'))<EOL><DEDENT>else :<EOL><INDENT>sep=<EOL>for c in before_eq_str [:]:<EOL><INDENT>if c in self.arg_name_set or c in self.alias_arg_map :<EOL><INDENT>sep +=<EOL><DEDENT>else :<EOL><INDENT>break <EOL><DEDENT> <DEDENT>for c in before_eq_str [:sep -]:<EOL><INDENT>arg_name=self.dealias(c)<EOL>kargs [arg_name ].append(Empty)<EOL><DEDENT>arg_name=self.dealias(before_eq_str [sep -])<EOL>if val is Empty :<EOL><INDENT>val=before_eq_str [sep :]or Empty <EOL><DEDENT> <DEDENT>if(<EOL>val is Empty and <EOL>not isinstance(self.arg_default_map.get(arg_name),bool)and <EOL>raw_args and not raw_args [].startswith('-')):<EOL><INDENT>val=raw_args.pop()<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>val=raw_args.pop()<EOL><DEDENT>if arg_name :<EOL><INDENT>kargs [arg_name ].append(val)<EOL><DEDENT>else :<EOL><INDENT>pargs.append(val)<EOL><DEDENT> <DEDENT>kargs=dict(kargs)<EOL>for arg_name,collected_vals in kargs.items():<EOL><INDENT>default=self.arg_default_map.get(arg_name)<EOL>if isinstance(default,bool):<EOL><INDENT>kargs [arg_name ]=not default <EOL><DEDENT>elif all(val is Empty for val in collected_vals):<EOL><INDENT>if isinstance(default,int):<EOL><INDENT>kargs [arg_name ]=len(collected_vals)<EOL><DEDENT>else :<EOL><INDENT>kargs [arg_name ]=None <EOL><DEDENT> <DEDENT>else :<EOL><INDENT>val=next(val for val in reversed(collected_vals)if val is not Empty)<EOL>if not self.keyarg_name or arg_name in self.arg_meta_map :<EOL><INDENT>kargs [arg_name ]=self.cast(arg_name,val)<EOL><DEDENT>else :<EOL><INDENT>kargs [arg_name ]=self.cast(self.keyarg_name,val)<EOL><DEDENT> <DEDENT> <DEDENT>for arg_name,default in self.arg_default_map.items():<EOL><INDENT>if arg_name not in kargs :<EOL><INDENT>kargs [arg_name ]=default <EOL><DEDENT> <DEDENT>isbuiltin=inspect.isbuiltin(self.func)<EOL>for pos,name in enumerate(self.arg_names):<EOL><INDENT>if name in kargs and(pos <len(pargs)or isbuiltin):<EOL><INDENT>pargs.insert(pos,kargs.pop(name))<EOL><DEDENT> <DEDENT>for i,parg in enumerate(pargs):<EOL><INDENT>if i <self.no_defult_args_len :<EOL><INDENT>pargs [i ]=self.cast(self.arg_names [i ],parg)<EOL><DEDENT>elif self.vararg_name :<EOL><INDENT>pargs [i ]=self.cast(self.vararg_name,parg)<EOL><DEDENT> <DEDENT>return(pargs,kargs)<EOL><DEDENT>scan=parse <EOL>'<STR_LIT>'<EOL>def execute(self,raw_args=None):<EOL><INDENT> '<STR_LIT>'<EOL>pargs,kargs=self.parse(raw_args)<EOL>return self.func(*pargs,**kargs)<EOL><DEDENT>def build_usage(self,without_name=False):<EOL><INDENT> '<STR_LIT>'<EOL>alias_arg_rmap={}<EOL>for alias,arg_name in self.alias_arg_map.items():<EOL><INDENT>aliases=alias_arg_rmap.setdefault(arg_name,[])<EOL>aliases.append(alias)<EOL><DEDENT>usage=[]<EOL>if self.arg_defaults :<EOL><INDENT>for arg_name in self.arg_names [-len(self.arg_defaults):]:<EOL><INDENT>pieces=[]<EOL>for name in alias_arg_rmap.get(arg_name,[])+[arg_name ]:<EOL><INDENT>is_long_opt=len(name)><EOL>pieces.append('%s%s'%('-'*(+is_long_opt),name.replace('_','-')))<EOL>meta=self.arg_meta_map.get(name)<EOL>if meta is None :<EOL><INDENT>default=self.arg_default_map [self.dealias(name)]<EOL>if isinstance(default,bool):<EOL><INDENT>continue <EOL><DEDENT>elif default is None :<EOL><INDENT>meta='<value>'<EOL><DEDENT>else :<EOL><INDENT>meta='{!r}'.format(default)<EOL><DEDENT> <DEDENT>if is_long_opt :<EOL><INDENT>pieces [-]+='='+meta <EOL><DEDENT>else :<EOL><INDENT>pieces [-]+=' '+meta <EOL><DEDENT> <DEDENT>usage.append('[%s]'%' | '.join(pieces))<EOL><DEDENT> <DEDENT>if self.keyarg_name :<EOL><INDENT>usage.append('<STR_LIT>')<EOL><DEDENT>usage.extend('<%s>'%name.replace('_','-')for name in self.arg_names [:-len(self.arg_defaults)or None ])<EOL>if self.vararg_name :<EOL><INDENT>usage.append('[<%s>...]'%self.vararg_name.replace('_','-'))<EOL><DEDENT>if without_name :<EOL><INDENT>return '%s'%' '.join(usage)<EOL><DEDENT>else :<EOL><INDENT>return '%s %s'%((self.name or self.func.__name__).replace('_','-'),' '.join(usage))<EOL><DEDENT> <DEDENT>get_usage=build_usage <EOL>'<STR_LIT>'<EOL><DEDENT>CMD_SUFFIX=re.compile('<STR_LIT>')<EOL>'<STR_LIT>'<EOL>class Program(object):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,obj=None,default=None,white_list=None,white_pattern=None,black_list=None,ignore_help=False,ignore_return=False,name=None,doc=None,debug=False):<EOL><INDENT>obj=obj or sys.modules ['__main__']<EOL>self.obj=obj <EOL>if hasattr(obj,'items'):<EOL><INDENT>obj_items=obj.items()<EOL><DEDENT>else :<EOL><INDENT>obj_items=inspect.getmembers(obj)<EOL><DEDENT>if not white_list and hasattr(obj,'__all__'):<EOL><INDENT>white_list=obj.__all__ <EOL><DEDENT>tests=(inspect.isbuiltin,inspect.isfunction,inspect.ismethod)<EOL>self.command_funcs={}<EOL>for obj_name,obj in obj_items :<EOL><INDENT>if obj_name.startswith('_'):continue <EOL>if not any(test(obj)for test in tests):continue <EOL>if white_list is not None and obj_name not in white_list :continue <EOL>if black_list is not None and obj_name in black_list :continue <EOL>if white_pattern :<EOL><INDENT>match=white_pattern.match(obj_name)<EOL>if not match :continue <EOL>obj_name=match.group('name')<EOL><DEDENT>self.command_funcs [obj_name ]=obj <EOL><DEDENT>self.default=default <EOL>if len(self.command_funcs)==:<EOL><INDENT>self.default=list(self.command_funcs.keys())[]<EOL><DEDENT>self.ignore_help=ignore_help <EOL>self.ignore_return=ignore_return <EOL>self.name=name or basename(sys.argv [])<EOL>self.doc=doc <EOL>self.debug=debug <EOL><DEDENT>def complain(self,msg):<EOL><INDENT> '<STR_LIT>'<EOL>print('%s: %s'%(self.name,msg),file=sys.stdout)<EOL><DEDENT>def main(self,raw_args=None):<EOL><INDENT> '<STR_LIT>'<EOL>if raw_args is None :<EOL><INDENT>raw_args=sys.argv [:]<EOL><DEDENT>elif isinstance(raw_args,str):<EOL><INDENT>raw_args=raw_args.split()<EOL><DEDENT>cmd_name=None <EOL>cmd_func=None <EOL>if len(raw_args)==:<EOL><INDENT>pass <EOL><DEDENT>elif not self.ignore_help and raw_args []in('--help','-h'):<EOL><INDENT>self.print_usage()<EOL>return <EOL><DEDENT>else :<EOL><INDENT>cmd_func=self.command_funcs.get(raw_args [].replace('-','_'))<EOL>if cmd_func is not None :<EOL><INDENT>cmd_name=raw_args.pop().replace('-','_')<EOL><DEDENT> <DEDENT>if cmd_func is None :<EOL><INDENT>if self.default :<EOL><INDENT>cmd_name=cmd_name <EOL>cmd_func=self.command_funcs [self.default ]<EOL><DEDENT>else :<EOL><INDENT>self.print_usage()<EOL>return <EOL><DEDENT> <DEDENT>if not self.ignore_help and '--help'in raw_args :<EOL><INDENT>self.print_usage(cmd_name)<EOL>return <EOL><DEDENT>cmd=Command(cmd_func,cmd_name)<EOL>try :<EOL><INDENT>return_val=cmd.execute(raw_args)<EOL><DEDENT>except BaseException as e :<EOL><INDENT>if self.debug :<EOL><INDENT>raise <EOL><DEDENT>self.complain('<STR_LIT>'.format(<EOL>e.__class__.__name__,<EOL>e ))<EOL>sys.exit()<EOL><DEDENT>if not self.ignore_return and return_val is not None :<EOL><INDENT>if inspect.isgenerator(return_val):<EOL><INDENT>for i in return_val :<EOL><INDENT>print(i)<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>print(return_val)<EOL><DEDENT> <DEDENT> <DEDENT>def print_usage(self,cmd_name=None):<EOL><INDENT> '<STR_LIT>'<EOL>def append_usage(cmd_name,without_name=False):<EOL><INDENT>cmd_func=self.command_funcs [cmd_name ]<EOL>usages.append(Command(cmd_func,cmd_name).build_usage(without_name))<EOL><DEDENT>usages=[]<EOL>if cmd_name is None :<EOL><INDENT>if self.default is not None :<EOL><INDENT>append_usage(self.default,True)<EOL><DEDENT>for name in sorted(self.command_funcs.keys()):<EOL><INDENT>append_usage(name)<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>if self.default==cmd_name :<EOL><INDENT>append_usage(cmd_name,without_name=True)<EOL><DEDENT>append_usage(cmd_name)<EOL><DEDENT>iusages=iter(usages)<EOL>try :<EOL><INDENT>print('usage:',next(iusages))<EOL><DEDENT>except StopIteration :<EOL><INDENT>pass <EOL><DEDENT>else :<EOL><INDENT>for usage in iusages :<EOL><INDENT>print('   or:',usage)<EOL><DEDENT> <DEDENT>if cmd_name is None :<EOL><INDENT>if self.doc :<EOL><INDENT>doc=self.doc <EOL><DEDENT>elif inspect.ismodule(self.obj):<EOL><INDENT>doc=inspect.getdoc(self.obj)<EOL><DEDENT>else :<EOL><INDENT>doc=None <EOL><DEDENT>if not doc :<EOL><INDENT>cmd_name=self.default <EOL><DEDENT> <DEDENT>if cmd_name :<EOL><INDENT>doc=inspect.getdoc(self.command_funcs [cmd_name ])<EOL><DEDENT>if doc :<EOL><INDENT>print()<EOL>print(doc)<EOL>print()<EOL><DEDENT> <DEDENT> <DEDENT>def start(*args,**kargs):<EOL><INDENT> '<STR_LIT>'<EOL>prog=Program(*args,**kargs)<EOL>prog.main()<EOL>return prog <EOL><DEDENT>customize=start <EOL>'<STR_LIT>'<EOL>if __name__=='__main__':<EOL><INDENT>import doctest <EOL>doctest.testmod()<EOL>def read_json(json=None):<EOL><INDENT> '<STR_LIT>'<EOL>return json <EOL><DEDENT>read_json_cmd=Command(read_json)<EOL>print('---')<EOL>print(read_json_cmd.build_usage())<EOL>print(read_json_cmd.execute('[1,2,3]'))<EOL>print(read_json_cmd.execute(['--json','{"x": 1}']))<EOL>print('---')<EOL>prog=Program(white_list=['read_json'],debug=True)<EOL>prog.main()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import video <EOL>from common import draw_str <EOL>lk_params=dict(winSize=(,),<EOL>maxLevel=,<EOL>criteria=(cv2.TERM_CRITERIA_EPS |cv2.TERM_CRITERIA_COUNT,,))<EOL>feature_params=dict(maxCorners=,<EOL>qualityLevel=,<EOL>minDistance=,<EOL>blockSize=)<EOL>def checkedTrace(img0,img1,p0,back_threshold=):<EOL><INDENT>p1,st,err=cv2.calcOpticalFlowPyrLK(img0,img1,p0,None,**lk_params)<EOL>p0r,st,err=cv2.calcOpticalFlowPyrLK(img1,img0,p1,None,**lk_params)<EOL>d=abs(p0 -p0r).reshape(-,).max(-)<EOL>status=d <back_threshold <EOL>return p1,status <EOL><DEDENT>green=(,,)<EOL>red=(,,)<EOL>class App :<EOL><INDENT>def __init__(self,video_src):<EOL><INDENT>self.cam=video.create_capture(video_src)<EOL>self.p0=None <EOL>self.use_ransac=True <EOL><DEDENT>def run(self):<EOL><INDENT>while True :<EOL><INDENT>ret,frame=self.cam.read()<EOL>frame_gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)<EOL>vis=frame.copy()<EOL>if self.p0 is not None :<EOL><INDENT>p2,trace_status=checkedTrace(self.gray1,frame_gray,self.p1)<EOL>self.p1=p2 [trace_status ].copy()<EOL>self.p0=self.p0 [trace_status ].copy()<EOL>self.gray1=frame_gray <EOL>if len(self.p0)<:<EOL><INDENT>self.p0=None <EOL>continue <EOL><DEDENT>H,status=cv2.findHomography(self.p0,self.p1,(,cv2.RANSAC)[self.use_ransac ],)<EOL>h,w=frame.shape [:]<EOL>overlay=cv2.warpPerspective(self.frame0,H,(w,h))<EOL>vis=cv2.addWeighted(vis,,overlay,,)<EOL>for(x0,y0),(x1,y1),good in zip(self.p0 [:,],self.p1 [:,],status [:,]):<EOL><INDENT>if good :<EOL><INDENT>cv2.line(vis,(x0,y0),(x1,y1),(,,))<EOL><DEDENT>cv2.circle(vis,(x1,y1),,(red,green)[good ],-)<EOL><DEDENT>draw_str(vis,(,),'track count: %d'%len(self.p1))<EOL>if self.use_ransac :<EOL><INDENT>draw_str(vis,(,),'RANSAC')<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>p=cv2.goodFeaturesToTrack(frame_gray,**feature_params)<EOL>if p is not None :<EOL><INDENT>for x,y in p [:,]:<EOL><INDENT>cv2.circle(vis,(x,y),,green,-)<EOL><DEDENT>draw_str(vis,(,),'<STR_LIT>'%len(p))<EOL><DEDENT> <DEDENT>cv2.imshow('lk_homography',vis)<EOL>ch=&cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT>if ch==ord(' '):<EOL><INDENT>self.frame0=frame.copy()<EOL>self.p0=cv2.goodFeaturesToTrack(frame_gray,**feature_params)<EOL>if self.p0 is not None :<EOL><INDENT>self.p1=self.p0 <EOL>self.gray0=frame_gray <EOL>self.gray1=frame_gray <EOL><DEDENT> <DEDENT>if ch==ord('r'):<EOL><INDENT>self.use_ransac=not self.use_ransac <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>def main():<EOL><INDENT>import sys <EOL>try :<EOL><INDENT>video_src=sys.argv []<EOL><DEDENT>except :<EOL><INDENT>video_src=<EOL><DEDENT>print __doc__ <EOL>App(video_src).run()<EOL>cv2.destroyAllWindows()<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>main()<EOL><DEDENT><EOF><BOF>import psycopg2 <EOL>from flask import Flask,request,jsonify <EOL>from mosql.query import select,left_join <EOL>from mosql.db import Database <EOL>db=Database(psycopg2,host='127.0.0.1')<EOL>app=Flask(__name__)<EOL>@app.route('/')<EOL>def index():<EOL><INDENT>with db as cur :<EOL><INDENT>cur.execute(select(<EOL>'person',<EOL>request.args or None,<EOL>joins=left_join('detail',using=('person_id',)),))<EOL>return jsonify(data=list(cur))<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>app.run(debug=True)<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>if __name__=='__main__':<EOL><INDENT>import sys <EOL>try :<EOL><INDENT>fn=sys.argv []<EOL><DEDENT>except :<EOL><INDENT>fn='<STR_LIT>'<EOL><DEDENT>print __doc__ <EOL>img=cv2.imread(fn,True)<EOL>if img is None :<EOL><INDENT>print '<STR_LIT>',fn <EOL>sys.exit()<EOL><DEDENT>h,w=img.shape [:]<EOL>mask=np.zeros((h +,w +),np.uint8)<EOL>seed_pt=None <EOL>fixed_range=True <EOL>connectivity=<EOL>def update(dummy=None):<EOL><INDENT>if seed_pt is None :<EOL><INDENT>cv2.imshow('floodfill',img)<EOL>return <EOL><DEDENT>flooded=img.copy()<EOL>mask [:]=<EOL>lo=cv2.getTrackbarPos('lo','floodfill')<EOL>hi=cv2.getTrackbarPos('hi','floodfill')<EOL>flags=connectivity <EOL>if fixed_range :<EOL><INDENT>flags |=cv2.FLOODFILL_FIXED_RANGE <EOL><DEDENT>cv2.floodFill(flooded,mask,seed_pt,(,,),(lo,)*,(hi,)*,flags)<EOL>cv2.circle(flooded,seed_pt,,(,,),-)<EOL>cv2.imshow('floodfill',flooded)<EOL><DEDENT>def onmouse(event,x,y,flags,param):<EOL><INDENT>global seed_pt <EOL>if flags &cv2.EVENT_FLAG_LBUTTON :<EOL><INDENT>seed_pt=x,y <EOL>update()<EOL><DEDENT> <DEDENT>update()<EOL>cv2.setMouseCallback('floodfill',onmouse)<EOL>cv2.createTrackbar('lo','floodfill',,,update)<EOL>cv2.createTrackbar('hi','floodfill',,,update)<EOL>while True :<EOL><INDENT>ch=&cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT>if ch==ord('f'):<EOL><INDENT>fixed_range=not fixed_range <EOL>print 'using %s range'%('floating','fixed')[fixed_range ]<EOL>update()<EOL><DEDENT>if ch==ord('c'):<EOL><INDENT>connectivity=-connectivity <EOL>print 'connectivity=',connectivity <EOL>update()<EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>import sys <EOL>from threading import currentThread <EOL>try :<EOL><INDENT>import signal <EOL><DEDENT>except ImportError :<EOL><INDENT>signal=None <EOL><DEDENT>if sys.platform.startswith('java'):<EOL><INDENT>from java.lang import IllegalArgumentException <EOL><DEDENT>else :<EOL><INDENT>IllegalArgumentException=None <EOL><DEDENT>from robot.errors import ExecutionFailed <EOL>from robot.output import LOGGER <EOL>class _StopSignalMonitor(object):<EOL><INDENT>def __init__(self):<EOL><INDENT>self._signal_count=<EOL>self._running_keyword=False <EOL><DEDENT>def __call__(self,signum,frame):<EOL><INDENT>self._signal_count +=<EOL>LOGGER.info('<STR_LIT>'%signum)<EOL>if self._signal_count >:<EOL><INDENT>sys.__stderr__.write('<STR_LIT>')<EOL>raise SystemExit()<EOL><DEDENT>sys.__stderr__.write('<STR_LIT>')<EOL>if self._running_keyword and not sys.platform.startswith('java'):<EOL><INDENT>self._stop_execution_gracefully()<EOL><DEDENT> <DEDENT>def _stop_execution_gracefully(self):<EOL><INDENT>raise ExecutionFailed('<STR_LIT>',exit=True)<EOL><DEDENT>def start(self):<EOL><INDENT>if signal :<EOL><INDENT>for signum in signal.SIGINT,signal.SIGTERM :<EOL><INDENT>self._register_signal_handler(signum)<EOL><DEDENT> <DEDENT> <DEDENT>def _register_signal_handler(self,signum):<EOL><INDENT>try :<EOL><INDENT>signal.signal(signum,self)<EOL><DEDENT>except(ValueError,IllegalArgumentException),err :<EOL><INDENT>if currentThread().getName()=='MainThread':<EOL><INDENT>self._warn_about_registeration_error(signum,err)<EOL><DEDENT> <DEDENT> <DEDENT>def _warn_about_registeration_error(self,signum,err):<EOL><INDENT>name,ctrlc={signal.SIGINT :('INT','or with Ctrl-C '),<EOL>signal.SIGTERM :('TERM','')}[signum ]<EOL>LOGGER.warn('<STR_LIT>'<EOL>'<STR_LIT>'<EOL>'<STR_LIT>'%(name,ctrlc,err))<EOL><DEDENT>def start_running_keyword(self,in_teardown):<EOL><INDENT>self._running_keyword=True <EOL>if self._signal_count and not in_teardown :<EOL><INDENT>self._stop_execution_gracefully()<EOL><DEDENT> <DEDENT>def stop_running_keyword(self):<EOL><INDENT>self._running_keyword=False <EOL><DEDENT> <DEDENT>STOP_SIGNAL_MONITOR=_StopSignalMonitor()<EOF><BOF>import psycopg2 <EOL>from mosql.util import raw <EOL>from mosql.query import select,left_join <EOL>from mosql.db import Database,group <EOL>db=Database(psycopg2,host='127.0.0.1')<EOL>with db as cur :<EOL><INDENT>cur.execute(select(<EOL>'person',<EOL>joins=left_join('detail',using='person_id'),<EOL>where={'key':'email'},<EOL>group_by='person_id',<EOL>select=('person_id',raw('array_agg(val)')),<EOL>order_by='person_id',))<EOL>print '<STR_LIT>'<EOL>for row in cur :<EOL><INDENT>print row <EOL><DEDENT>print <EOL>cur.execute(select(<EOL>'person',<EOL>joins=left_join('detail',using='person_id'),<EOL>where={'key':'email'},<EOL>select=('person_id','val'),<EOL>order_by='person_id',))<EOL>print '<STR_LIT>'<EOL>for row in group(['person_id'],cur):<EOL><INDENT>print row <EOL><DEDENT> <DEDENT><EOF><BOF>import cv2 <EOL>import numpy as np <EOL>def mix_image(back,fore,(x,y),in_place=False):<EOL><INDENT> '<STR_LIT>'<EOL>x,y=round(x),round(y)<EOL>if in_place :<EOL><INDENT>ret=back <EOL><DEDENT>else :<EOL><INDENT>ret=back.copy()<EOL><DEDENT>fh,fw,fd=fore.shape <EOL>bh,bw,bd=ret.shape <EOL>if fd==:<EOL><INDENT>fore_alpha=lambda fy,h,fx,w :fore [fy :fy +h,fx :fx +w,]/<EOL><DEDENT>else :<EOL><INDENT>fore_alpha=lambda fy,h,fx,w :<EOL><DEDENT>if True in [x +fw <,x >bw,y +fh <,y >bh ]:<EOL><INDENT>return ret <EOL><DEDENT>fx,fy=,<EOL>bx,by=x,y <EOL>w,h=fw,fh <EOL>if bx <:<EOL><INDENT>w=fw +bx <EOL>fx=-bx <EOL>bx=<EOL><DEDENT>if by <:<EOL><INDENT>h=fh +by <EOL>fy=-by <EOL>by=<EOL><DEDENT>if bx +w >bw :<EOL><INDENT>w=bw -bx <EOL><DEDENT>if by +h >bh :<EOL><INDENT>h=bh -by <EOL><DEDENT>for c in range(,):<EOL><INDENT>ret [by :by +h,bx :bx +w,c ]=fore [fy :fy +h,fx :fx +w,c ]*fore_alpha(fy,h,fx,w)+ret [by :by +h,bx :bx +w,c ]*(-fore_alpha(fy,h,fx,w))<EOL><DEDENT>return ret <EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>back=cv2.imread("land.jpg")<EOL>fore=cv2.imread("phppg.png",-)<EOL>sh=fore.shape <EOL>b=np.full_like(fore,,np.uint8)<EOL>bb=mix_image(b,fore,(,))<EOL>cv2.imshow('fore',bb)<EOL>cv2.imshow('back',back)<EOL>from random import random as rdm <EOL>w,h,d=back.shape <EOL>for i in range():<EOL><INDENT>back=mix_image(back,fore,(w **(rdm()-),h **(rdm()-)))<EOL><DEDENT>cv2.imshow('mixed',back)<EOL>cv2.imwrite('mixed.png',back)<EOL>cv2.waitKey()<DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import video <EOL>class App(object):<EOL><INDENT>def __init__(self,video_src):<EOL><INDENT>self.cam=video.create_capture(video_src)<EOL>ret,self.frame=self.cam.read()<EOL>cv2.namedWindow('camshift')<EOL>cv2.setMouseCallback('camshift',self.onmouse)<EOL>self.selection=None <EOL>self.drag_start=None <EOL>self.tracking_state=<EOL>self.show_backproj=False <EOL><DEDENT>def onmouse(self,event,x,y,flags,param):<EOL><INDENT>x,y=np.int16([x,y ])<EOL>if event==cv2.EVENT_LBUTTONDOWN :<EOL><INDENT>self.drag_start=(x,y)<EOL>self.tracking_state=<EOL><DEDENT>if self.drag_start :<EOL><INDENT>if flags &cv2.EVENT_FLAG_LBUTTON :<EOL><INDENT>h,w=self.frame.shape [:]<EOL>xo,yo=self.drag_start <EOL>x0,y0=np.maximum(,np.minimum([xo,yo ],[x,y ]))<EOL>x1,y1=np.minimum([w,h ],np.maximum([xo,yo ],[x,y ]))<EOL>self.selection=None <EOL>if x1 -x0 >and y1 -y0 >:<EOL><INDENT>self.selection=(x0,y0,x1,y1)<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>self.drag_start=None <EOL>if self.selection is not None :<EOL><INDENT>self.tracking_state=<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>def show_hist(self):<EOL><INDENT>bin_count=self.hist.shape []<EOL>bin_w=<EOL>img=np.zeros((,bin_count *bin_w,),np.uint8)<EOL>for i in xrange(bin_count):<EOL><INDENT>h=int(self.hist [i ])<EOL>cv2.rectangle(img,(i *bin_w +,),((i +)*bin_w -,-h),(int(*i /bin_count),,),-)<EOL><DEDENT>img=cv2.cvtColor(img,cv2.COLOR_HSV2BGR)<EOL>cv2.imshow('hist',img)<EOL><DEDENT>def run(self):<EOL><INDENT>while True :<EOL><INDENT>ret,self.frame=self.cam.read()<EOL>vis=self.frame.copy()<EOL>hsv=cv2.cvtColor(self.frame,cv2.COLOR_BGR2HSV)<EOL>mask=cv2.inRange(hsv,np.array((,,)),np.array((,,)))<EOL>if self.selection :<EOL><INDENT>x0,y0,x1,y1=self.selection <EOL>self.track_window=(x0,y0,x1 -x0,y1 -y0)<EOL>hsv_roi=hsv [y0 :y1,x0 :x1 ]<EOL>mask_roi=mask [y0 :y1,x0 :x1 ]<EOL>hist=cv2.calcHist([hsv_roi ],[],mask_roi,[],[,])<EOL>cv2.normalize(hist,hist,,,cv2.NORM_MINMAX);<EOL>self.hist=hist.reshape(-)<EOL>self.show_hist()<EOL>vis_roi=vis [y0 :y1,x0 :x1 ]<EOL>cv2.bitwise_not(vis_roi,vis_roi)<EOL>vis [mask==]=<EOL><DEDENT>if self.tracking_state==:<EOL><INDENT>self.selection=None <EOL>prob=cv2.calcBackProject([hsv ],[],self.hist,[,],)<EOL>prob &=mask <EOL>term_crit=(cv2.TERM_CRITERIA_EPS |cv2.TERM_CRITERIA_COUNT,,)<EOL>track_box,self.track_window=cv2.CamShift(prob,self.track_window,term_crit)<EOL>if self.show_backproj :<EOL><INDENT>vis [:]=prob [...,np.newaxis ]<EOL><DEDENT>try :cv2.ellipse(vis,track_box,(,,),)<EOL>except :print track_box <EOL><DEDENT>cv2.imshow('camshift',vis)<EOL>ch=&cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT>if ch==ord('b'):<EOL><INDENT>self.show_backproj=not self.show_backproj <EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>import sys <EOL>try :video_src=sys.argv []<EOL>except :video_src=<EOL>print __doc__ <EOL>App(video_src).run()<EOL><DEDENT><EOF><BOF>print '<STR_LIT>'<EOL>import cv2.cv as cv <EOL>import random <EOL>_MAX_POINTS=<EOL>if __name__=='__main__':<EOL><INDENT>my_random=random.Random()<EOL>image=cv.CreateImage((,),,)<EOL>cv.NamedWindow('hull',cv.CV_WINDOW_AUTOSIZE)<EOL>while True :<EOL><INDENT>count=my_random.randrange(,_MAX_POINTS)+<EOL>points=[]<EOL>for i in range(count):<EOL><INDENT>points.append((<EOL>my_random.randrange(,image.width /)+image.width /,<EOL>my_random.randrange(,image.width /)+image.width /))<EOL><DEDENT>storage=cv.CreateMemStorage()<EOL>hull=cv.ConvexHull2(points,storage,cv.CV_CLOCKWISE,)<EOL>cv.SetZero(image)<EOL>for i in range(count):<EOL><INDENT>cv.Circle(image,points [i ],,(,,,),<EOL>cv.CV_FILLED,cv.CV_AA,)<EOL><DEDENT>cv.PolyLine(image,[hull ],,cv.RGB(,,),,cv.CV_AA)<EOL>cv.ShowImage('hull',image)<EOL>k=cv.WaitKey()%<EOL>if k==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT>cv.DestroyAllWindows()<EOL><DEDENT><EOF><BOF>import HTMLParser <EOL>from datetime import datetime,timedelta <EOL>import pytz <EOL>import random <EOL>import re <EOL>from database import db <EOL>from models import Account,Settings,TopTodayAccount <EOL>class Simulator(object):<EOL><INDENT>def __init__(self):<EOL><INDENT>self.accounts={account.subreddit :account <EOL>for account in db.query(Account)}<EOL>self.subreddit=Settings ["subreddit"]<EOL>self.mod_account=self.accounts ["all"]<EOL><DEDENT>def pick_account_to_comment(self):<EOL><INDENT>accounts=[a for a in self.accounts.values()if a.can_comment ]<EOL>try :<EOL><INDENT>return next(a for a in accounts if not a.last_commented)<EOL><DEDENT>except StopIteration :<EOL><INDENT>pass <EOL><DEDENT>accounts=sorted(accounts,key=lambda a :a.last_commented)<EOL>num_to_keep=int(len(accounts)*)<EOL>return random.choice(accounts [:num_to_keep ])<EOL><DEDENT>def pick_account_to_submit(self):<EOL><INDENT>try :<EOL><INDENT>top_today_account=next(a for a in self.accounts.values()<EOL>if isinstance(a,TopTodayAccount))<EOL><DEDENT>except StopIteration :<EOL><INDENT>pass <EOL><DEDENT>else :<EOL><INDENT>now=datetime.now(pytz.utc)<EOL>if now -top_today_account.last_submitted >timedelta(hours=):<EOL><INDENT>return top_today_account <EOL><DEDENT> <DEDENT>accounts=[a for a in self.accounts.values()if a.is_able_to_submit ]<EOL>try :<EOL><INDENT>return next(a for a in accounts if not a.last_submitted)<EOL><DEDENT>except StopIteration :<EOL><INDENT>pass <EOL><DEDENT>accounts=sorted(accounts,key=lambda a :a.last_submitted)<EOL>num_to_keep=int(len(accounts)*)<EOL>return random.choice(accounts [:num_to_keep ])<EOL><DEDENT>def make_comment(self):<EOL><INDENT>account=self.pick_account_to_comment()<EOL>account.train_from_comments()<EOL>subreddit=account.session.get_subreddit(self.subreddit)<EOL>for submission in subreddit.get_new(limit=):<EOL><INDENT>if submission.author.name !=Settings ["owner"]:<EOL><INDENT>break <EOL><DEDENT> <DEDENT>account.post_comment_on(submission)<EOL><DEDENT>def make_submission(self):<EOL><INDENT>account=self.pick_account_to_submit()<EOL>account.train_from_submissions()<EOL>account.post_submission(self.subreddit)<EOL><DEDENT>def update_leaderboard(self,limit=):<EOL><INDENT>session=self.mod_account.session <EOL>subreddit=session.get_subreddit(self.subreddit)<EOL>accounts=sorted(<EOL>[a for a in self.accounts.values()if a.can_comment ],<EOL>key=lambda a :a.mean_comment_karma,<EOL>reverse=True,)<EOL>leaderboard_md='<STR_LIT>'<EOL>for rank,account in enumerate(accounts,start=):<EOL><INDENT>leaderboard_md +='<STR_LIT>'.format(<EOL>rank,<EOL>account.name,<EOL>account.mean_comment_karma,)<EOL>if rank >=limit :<EOL><INDENT>break <EOL><DEDENT> <DEDENT>start_delim='<STR_LIT>'<EOL>end_delim='<STR_LIT>'<EOL>current_sidebar=subreddit.get_settings()["description"]<EOL>current_sidebar=HTMLParser.HTMLParser().unescape(current_sidebar)<EOL>replace_pattern=re.compile(<EOL>"{}.*?{}".format(re.escape(start_delim),re.escape(end_delim)),<EOL>re.IGNORECASE |re.DOTALL |re.UNICODE,)<EOL>new_sidebar=re.sub(<EOL>replace_pattern,<EOL>"{}\n\n{}\n\n{}".format(start_delim,leaderboard_md,end_delim),<EOL>current_sidebar,)<EOL>subreddit.update_settings(description=new_sidebar)<EOL>flair_map=[{<EOL>"user":account.name,<EOL>"flair_text":'<STR_LIT>'.format(<EOL>rank,len(accounts),account.mean_comment_karma),<EOL>}for rank,account in enumerate(accounts,start=)]<EOL>subreddit.set_flair_csv(flair_map)<EOL><DEDENT>def print_accounts_table(self):<EOL><INDENT>accounts=sorted(self.accounts.values(),key=lambda a :a.added)<EOL>accounts=[a for a in accounts if not isinstance(a,TopTodayAccount)]<EOL>print '<STR_LIT>'<EOL>print ":--|--:|:--|:--"<EOL>checkmark="&#10003;"<EOL>for account in accounts :<EOL><INDENT>print '<STR_LIT>'.format(<EOL>account.subreddit,<EOL>"/u/"+account.name,<EOL>account.added.strftime("%Y-%m-%d"),<EOL>checkmark if account.can_comment else "",<EOL>checkmark if account.can_submit else "",)<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>import cv2 <EOL>from webcam_gui import webcam_gui <EOL>def imgproc(frame):<EOL><INDENT>gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)<EOL>cv2.imshow('gray',gray)<EOL>blur=cv2.blur(gray,(,))<EOL>edge=cv2.Canny(blur,,)<EOL>edge=cv2.blur(edge,(,))<EOL>cv2.imshow('blured edge',edge)<EOL>thresh1,thresh=cv2.threshold(edge,,,cv2.THRESH_BINARY)<EOL>cv2.imshow('thresh',thresh)<EOL>contours,hry=cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)<EOL>cpframe=frame.copy()<EOL>cv2.drawContours(cpframe,contours,-,(,,),)<EOL>cv2.imshow('cpframe',cpframe)<EOL>contours=[ctr for ctr in contours if cv2.contourArea(ctr)>]<EOL>contours=[cv2.approxPolyDP(ctr,,True)for ctr in contours ]<EOL>contours=[ctr for ctr in contours if cv2.isContourConvex(ctr)]<EOL>cv2.drawContours(frame,contours,-,(,,),)<EOL>return frame <EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>webcam_gui(imgproc,video_src=)<DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import signal <EOL>import tempfile <EOL>import time <EOL>from subprocess import Popen <EOL>import requests <EOL>from tests.mock import pickup_port <EOL>from zerotest.utils.url_helper import urljoin <EOL>class Proxy(object):<EOL><INDENT>def __init__(self):<EOL><INDENT>self.port=None <EOL>self._process=None <EOL>_,self.data_file=tempfile.mkstemp()<EOL><DEDENT>@property <EOL>def url(self):<EOL><INDENT>return '<STR_LIT>'.format(self.port)<EOL><DEDENT>@property <EOL>def running(self):<EOL><INDENT>if not self._process :<EOL><INDENT>return False <EOL><DEDENT>self._process.poll()<EOL>return self._process.returncode is None <EOL><DEDENT>def shutdown(self):<EOL><INDENT>if self.running :<EOL><INDENT>self._process.send_signal(signal.SIGINT)<EOL>self._process.wait()<EOL><DEDENT> <DEDENT>def start_server(self,url):<EOL><INDENT> '<STR_LIT>'<EOL>port=pickup_port()<EOL>self._process=Popen(['python','zerotest/cli.py','server','-p',str(port),'-f',self.data_file,url ])<EOL>self.port=port <EOL>test_count=<EOL>while test_count >:<EOL><INDENT>try :<EOL><INDENT>if self.running :<EOL><INDENT>r=requests.get(urljoin(self.url,'/count'))<EOL>if r.status_code==:<EOL><INDENT>return <EOL><DEDENT> <DEDENT> <DEDENT>except requests.exceptions.ConnectionError :<EOL><INDENT>pass <EOL><DEDENT>print('<STR_LIT>',test_count)<EOL>time.sleep()<EOL>test_count -=<EOL><DEDENT>else :<EOL><INDENT>self.shutdown()<EOL>raise RuntimeError('<STR_LIT>')<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>from __future__ import print_function <EOL>'<STR_LIT>'<EOL>'<STR_LIT>'<EOL>import difflib <EOL>import ConfigParser <EOL>import os <EOL>import random <EOL>import re <EOL>import string <EOL>import sys <EOL>import threading <EOL>import time <EOL>import xml.etree.ElementTree as ET <EOL>from urllib import urlencode <EOL>from urllib2 import build_opener,install_opener,urlopen,ProxyHandler,Request <EOL>from urlparse import urlsplit,urlunsplit,parse_qsl <EOL>from optparse import OptionParser <EOL>from subprocess import Popen,PIPE <EOL>from sys import exit <EOL>NAME="Panoptic"<EOL>VERSION="v0.1"<EOL>URL='<STR_LIT>'<EOL>INVALID_FILENAME="".join(random.sample(string.letters,))<EOL>MAX_HELP_OPTION_LENGTH=<EOL>CASES_FILE="cases.xml"<EOL>USER_AGENTS_FILE="agents.txt"<EOL>HOME_FILES_FILE="home.txt"<EOL>HEURISTIC_RATIO=<EOL>SKIP_RETRIEVE_THRESHOLD=<EOL>BANNER='<STR_LIT>'%(NAME,VERSION,URL)<EOL>ROTATOR_CHARS="|/-\\"<EOL>GIT_REPOSITORY='<STR_LIT>'<EOL>EXAMPLES='<STR_LIT>'<EOL>class PROXY_TYPE :<EOL><INDENT>HTTP="HTTP"<EOL>HTTPS="HTTPS"<EOL>SOCKS4="SOCKS4"<EOL>SOCKS5="SOCKS5"<EOL><DEDENT>class HTTP_HEADER :<EOL><INDENT>COOKIE="Cookie"<EOL>USER_AGENT="User-agent"<EOL>CONTENT_LENGTH="Content-length"<EOL><DEDENT>class AttribDict(dict):<EOL><INDENT>def __getattr__(self,name):<EOL><INDENT>return self.get(name)<EOL><DEDENT>def __setattr__(self,name,value):<EOL><INDENT>return self.__setitem__(name,value)<EOL><DEDENT> <DEDENT>kb=AttribDict()<EOL>args=None <EOL>def print(*args,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>with kb.print_lock :<EOL><INDENT>return __builtins__.print(*args,**kwargs)<EOL><DEDENT> <DEDENT>def get_cases(args):<EOL><INDENT> '<STR_LIT>'<EOL>tree=ET.parse(CASES_FILE)<EOL>root=tree.getroot()<EOL>def _(parent,element):<EOL><INDENT>element.parent=parent <EOL>for key,value in element.attrib.items():<EOL><INDENT>setattr(element,key,value)<EOL><DEDENT>for child in element.getchildren():<EOL><INDENT>_(element,child)<EOL><DEDENT> <DEDENT>_(None,root)<EOL>for attr in("os","software","category"):<EOL><INDENT>if getattr(args,attr):<EOL><INDENT>for element in root.findall(".//%s"%attr):<EOL><INDENT>if element.value.lower()!=getattr(args,attr).lower():<EOL><INDENT>element.parent.remove(element)<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>if args.type :<EOL><INDENT>for _ in(_ for _ in("conf","log","other")if _.lower()!=args.type.lower()):<EOL><INDENT>for element in root.findall(".//%s"%_):<EOL><INDENT>element.parent.remove(element)<EOL><DEDENT> <DEDENT> <DEDENT>def _(element,tag):<EOL><INDENT>while element.parent is not None :<EOL><INDENT>if element.parent.tag==tag :<EOL><INDENT>return element.parent <EOL><DEDENT>else :<EOL><INDENT>element=element.parent <EOL><DEDENT> <DEDENT> <DEDENT>cases=[]<EOL>replacements={}<EOL>if args.url :<EOL><INDENT>replacements ["HOST"]=urlsplit(args.url).netloc <EOL><DEDENT>for element in root.findall(".//file"):<EOL><INDENT>case=AttribDict()<EOL>case.location=element.value <EOL>case.os=_(element,"os").value <EOL>case.category=_(element,"category").value <EOL>case.software=_(element,"software").value <EOL>case.type=_(element,"log")is not None and "log"or _(element,"conf")is not None and "conf"or _(element,"other")is not None and "other"<EOL>for variable in re.findall(r"\{[^}]+\}",case.location):<EOL><INDENT>case.location=case.location.replace(variable,replacements.get(variable.strip("{}"),variable))<EOL><DEDENT>match=re.search(r"\[([^\]]+)\]",case.location)<EOL>if match and kb.through :<EOL><INDENT>original=case.location <EOL>for replacement in kb.versioned_locations [match.group()]:<EOL><INDENT>case=AttribDict(case)<EOL>case.location=original.replace(match.group(),replacement)<EOL>cases.append(case)<EOL><DEDENT> <DEDENT>else :<EOL><INDENT>cases.append(case)<EOL><DEDENT> <DEDENT>return cases <EOL><DEDENT>def load_list(filepath):<EOL><INDENT> '<STR_LIT>'<EOL>items=[]<EOL>cases=[]<EOL>with open(filepath,'r')as f :<EOL><INDENT>items=f.readlines()<EOL><DEDENT>for item in items :<EOL><INDENT>case=AttribDict({'location':item.strip()})<EOL>cases.append(case)<EOL><DEDENT>return cases <EOL><DEDENT>def get_revision():<EOL><INDENT> '<STR_LIT>'<EOL>retval=None <EOL>filepath=None <EOL>_=os.path.dirname(__file__)<EOL>while True :<EOL><INDENT>filepath=os.path.join(_,".git","HEAD")<EOL>if os.path.exists(filepath):<EOL><INDENT>break <EOL><DEDENT>else :<EOL><INDENT>filepath=None <EOL>if _==os.path.dirname(_):<EOL><INDENT>break <EOL><DEDENT>else :<EOL><INDENT>_=os.path.dirname(_)<EOL><DEDENT> <DEDENT> <DEDENT>while True :<EOL><INDENT>if filepath and os.path.isfile(filepath):<EOL><INDENT>with open(filepath,"r")as f :<EOL><INDENT>content=f.read()<EOL>filepath=None <EOL>if content.startswith("ref: "):<EOL><INDENT>filepath=os.path.join(_,".git",content.replace("ref: ","")).strip()<EOL><DEDENT>else :<EOL><INDENT>match=re.match('<STR_LIT>',content)<EOL>retval=match.group()if match else None <EOL>break <EOL><DEDENT> <DEDENT> <DEDENT>else :<EOL><INDENT>break <EOL><DEDENT> <DEDENT>if not retval :<EOL><INDENT>process=Popen('<STR_LIT>',shell=True,stdout=PIPE,stderr=PIPE)<EOL>stdout,_=process.communicate()<EOL>match=re.search('<STR_LIT>',stdout or "")<EOL>retval=match.group()if match else None <EOL><DEDENT>return retval [:]if retval else None <EOL><DEDENT>def check_revision():<EOL><INDENT> '<STR_LIT>'<EOL>global BANNER <EOL>global VERSION <EOL>revision=get_revision()<EOL>if revision :<EOL><INDENT>_=VERSION <EOL>VERSION="%s-%s"%(VERSION,revision)<EOL>BANNER=BANNER.replace(_,VERSION)<EOL><DEDENT> <DEDENT>def update():<EOL><INDENT> '<STR_LIT>'<EOL>print('<STR_LIT>')<EOL>process=Popen('<STR_LIT>'%GIT_REPOSITORY,shell=True,stdout=PIPE,stderr=PIPE)<EOL>stdout,stderr=process.communicate()<EOL>success=not process.returncode <EOL>if success :<EOL><INDENT>updated="Already"not in stdout <EOL>process=Popen('<STR_LIT>',shell=True,stdout=PIPE,stderr=PIPE)<EOL>stdout,_=process.communicate()<EOL>revision=stdout [:]if stdout and re.search('<STR_LIT>',stdout)else "-"<EOL>print('<STR_LIT>'%("Already at"if not updated else "Updated to",revision))<EOL><DEDENT>else :<EOL><INDENT>print('<STR_LIT>'%repr(stderr.strip()))<EOL>print('<STR_LIT>')<EOL><DEDENT> <DEDENT>def ask_question(question,default=None,automatic=False):<EOL><INDENT> '<STR_LIT>'<EOL>question="[?] %s "%question <EOL>if automatic :<EOL><INDENT>answer=default <EOL>print("%s%s"%(question,answer))<EOL><DEDENT>else :<EOL><INDENT>with kb.print_lock :<EOL><INDENT>answer=raw_input(question)<EOL><DEDENT> <DEDENT>print <EOL>return answer <EOL><DEDENT>def prepare_request(payload):<EOL><INDENT> '<STR_LIT>'<EOL>_=re.sub('<STR_LIT>'%args.param,<EOL>r"\1=%s"%(payload or ""),kb.request_params)<EOL>request_args={"url":"%s://%s%s"%(kb.parsed_target_url.scheme or "http",kb.parsed_target_url.netloc,kb.parsed_target_url.path)}<EOL>if args.data :<EOL><INDENT>request_args ["data"]=_ <EOL><DEDENT>else :<EOL><INDENT>request_args ["url"]+="?%s"%_ <EOL><DEDENT>if args.header :<EOL><INDENT>request_args ["header"]=args.header <EOL><DEDENT>if args.cookie :<EOL><INDENT>request_args ["cookie"]=args.cookie <EOL><DEDENT>if args.user_agent :<EOL><INDENT>request_args ["user_agent"]=args.user_agent <EOL><DEDENT>request_args ["verbose"]=args.verbose <EOL>return request_args <EOL><DEDENT>def clean_response(response,filepath):<EOL><INDENT> '<STR_LIT>'<EOL>response=response.replace(filepath,"")<EOL>regex=re.sub(r"[^A-Za-z0-9]",'<STR_LIT>',filepath)<EOL>return re.sub(regex,"",response,re.I)<EOL><DEDENT>def request_file(case,replace_slashes=True):<EOL><INDENT> '<STR_LIT>'<EOL>global ROTATOR_CHARS <EOL>if args.replace_slash and replace_slashes :<EOL><INDENT>case.location=case.location.replace("/",args.replace_slash.replace("\\","\\\\"))<EOL><DEDENT>if kb.restrict_os and kb.restrict_os !=case.os :<EOL><INDENT>if args.verbose :<EOL><INDENT>print('<STR_LIT>'%case.location)<EOL><DEDENT>return None <EOL><DEDENT>if args.prefix and args.prefix [len(args.prefix)-]=="/":<EOL><INDENT>args.prefix=args.prefix [:-]<EOL><DEDENT>_="%s%s%s"%(args.prefix,case.location,args.postfix)<EOL>if args.verbose :<EOL><INDENT>print('<STR_LIT>'%_)<EOL><DEDENT>else :<EOL><INDENT>with kb.print_lock :<EOL><INDENT>sys.stdout.write("\r%s\r"%ROTATOR_CHARS [])<EOL>sys.stdout.flush()<EOL><DEDENT> <DEDENT>ROTATOR_CHARS=ROTATOR_CHARS [:]+ROTATOR_CHARS []<EOL>request_args=prepare_request(_)<EOL>html=get_page(**request_args)<EOL>if not html or args.bad_string and html.find(args.bad_string)!=-:<EOL><INDENT>return None <EOL><DEDENT>matcher=difflib.SequenceMatcher(None,clean_response(html,case.location),clean_response(kb.invalid_response,INVALID_FILENAME))<EOL>if matcher.quick_ratio()<HEURISTIC_RATIO :<EOL><INDENT>with kb.value_lock :<EOL><INDENT>if not kb.found :<EOL><INDENT>print('<STR_LIT>')<EOL>if case.os :<EOL><INDENT>print("[i] OS: %s"%case.os)<EOL>if kb.restrict_os is None :<EOL><INDENT>answer=ask_question('<STR_LIT>'%case.os,default='Y',automatic=args.automatic)<EOL>kb.restrict_os=answer.upper()!='N'and case.os <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>_="/".join(_ for _ in(case.os,case.category,case.type)if _)<EOL>if _ :<EOL><INDENT>_="'%s'(%s)"%(case.location,_)<EOL>_=_.replace("%s/%s/"%(case.os,case.os),"%s/"%case.os)<EOL><DEDENT>else :<EOL><INDENT>_="'%s'"%case.location <EOL><DEDENT>print("[+] Found %s."%_)<EOL>if args.verbose :<EOL><INDENT>kb.files.append(_)<EOL><DEDENT>if args.write_files :<EOL><INDENT>_=os.path.join("output",kb.parsed_target_url.netloc)<EOL>if not os.path.exists(_):<EOL><INDENT>os.makedirs(_)<EOL><DEDENT>with open(os.path.join(_,"%s.txt"%case.location.replace(args.replace_slash if args.replace_slash else "/","_")),"w")as f :<EOL><INDENT>content=html <EOL>with kb.value_lock :<EOL><INDENT>if kb.filter_output is None :<EOL><INDENT>answer=ask_question('<STR_LIT>',default='Y',automatic=args.automatic)<EOL>kb.filter_output=answer.upper()!='N'<EOL><DEDENT> <DEDENT>if kb.get("filter_output"):<EOL><INDENT>matcher=difflib.SequenceMatcher(None,html or "",kb.original_response or "")<EOL>matching_blocks=matcher.get_matching_blocks()<EOL>if matching_blocks :<EOL><INDENT>start=matching_blocks []<EOL>if start []==start []==and start []>:<EOL><INDENT>content=content [start []:]<EOL><DEDENT>if len(matching_blocks)>:<EOL><INDENT>end=matching_blocks [-]<EOL>if end []>and end []+end []==len(html)and end []+end []==len(kb.original_response):<EOL><INDENT>content=content [:-end []]<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>f.write(content)<EOL><DEDENT> <DEDENT>return html <EOL><DEDENT>return None <EOL><DEDENT>def try_cases(cases):<EOL><INDENT> '<STR_LIT>'<EOL>passwd_files=["/etc/passwd",'<STR_LIT>']<EOL>if args.replace_slash :<EOL><INDENT>for i,v in enumerate(passwd_files):<EOL><INDENT>passwd_files [i ]=v.replace("/",args.replace_slash)<EOL><DEDENT> <DEDENT>for case in cases :<EOL><INDENT>html=request_file(case)<EOL>if html is None :<EOL><INDENT>continue <EOL><DEDENT>if not kb.found :<EOL><INDENT>kb.found=True <EOL><DEDENT>if case.location in passwd_files and not args.skip_parsing :<EOL><INDENT>users=re.finditer('<STR_LIT>',html)<EOL>if args.verbose :<EOL><INDENT>print('<STR_LIT>'%case.location)<EOL><DEDENT>for user in users :<EOL><INDENT>if args.verbose :<EOL><INDENT>print('<STR_LIT>'%(user.group("username"),user.group("info")))<EOL><DEDENT>if not kb.home_files :<EOL><INDENT>with open(HOME_FILES_FILE,"r")as f :<EOL><INDENT>kb.home_files=filter(None,(_.strip()for _ in f.readlines()))<EOL><DEDENT> <DEDENT>for _ in kb.home_files :<EOL><INDENT>if user.group("home")=="/":<EOL><INDENT>continue <EOL><DEDENT>request_file(AttribDict({"category":"*NIX User File","type":"conf","os":case.os,"location":"%s/%s"%(user.group("home"),_),"software":"*NIX"}))<EOL><DEDENT> <DEDENT> <DEDENT>if "mysql-bin.index"in case.location and not args.skip_parsing :<EOL><INDENT>binlogs=re.findall('<STR_LIT>',html)<EOL>location=case.location.rfind("/")+<EOL>if args.verbose :<EOL><INDENT>print('<STR_LIT>'%case.location)<EOL><DEDENT>for _ in binlogs :<EOL><INDENT>request_file(AttribDict({"category":"Databases","type":"log","os":case.os,"location":"%s%s"%(case.location [:location ],_),"software":"MySQL"}),False)<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>def parse_args():<EOL><INDENT> '<STR_LIT>'<EOL>OptionParser.format_epilog=lambda self,formatter :self.epilog <EOL>parser=OptionParser(usage='<STR_LIT>',epilog=EXAMPLES)<EOL>parser.add_option("-v","--verbose",action="store_true",dest="verbose",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-u","--url",dest="url",<EOL>help="set target URL")<EOL>parser.add_option("-p","--param",dest="param",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-d","--data",dest="data",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-t","--type",dest="type",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-o","--os",dest="os",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-s","--software",dest="software",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-c","--category",dest="category",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-l","--list",dest="list",metavar="GROUP",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-a","--auto",dest="automatic",action="store_true",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-w","--write-files",dest="write_files",action="store_true",<EOL>help='<STR_LIT>')<EOL>parser.add_option("-x","--skip-parsing",dest="skip_parsing",action="store_true",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--load",dest="list_file",metavar="LISTFILE",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--ignore-proxy",dest="ignore_proxy",action="store_true",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--proxy",dest="proxy",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--user-agent",dest="user_agent",metavar="UA",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--random-agent",dest="random_agent",action="store_true",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--cookie",dest="cookie",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--header",dest="header",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--prefix",dest="prefix",default="",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--postfix",dest="postfix",default="",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--multiplier",dest="multiplier",type="int",default=,<EOL>help='<STR_LIT>')<EOL>parser.add_option("--bad-string",dest="bad_string",metavar="STRING",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--replace-slash",dest="replace_slash",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--threads",dest="threads",type="int",default=,<EOL>help='<STR_LIT>')<EOL>parser.add_option("--through",dest="through",<EOL>help='<STR_LIT>')<EOL>parser.add_option("--update",dest="update",action="store_true",<EOL>help='<STR_LIT>')<EOL>parser.formatter.store_option_strings(parser)<EOL>parser.formatter.store_option_strings=lambda _ :None <EOL>for option,value in parser.formatter.option_strings.items():<EOL><INDENT>value=re.sub('<STR_LIT>',r"\g<1>/\g<3>",value)<EOL>value=value.replace(", ",'/')<EOL>if len(value)>MAX_HELP_OPTION_LENGTH :<EOL><INDENT>value=("%%.%ds.."%(MAX_HELP_OPTION_LENGTH -parser.formatter.indent_increment))%value <EOL><DEDENT>parser.formatter.option_strings [option ]=value <EOL><DEDENT>args=parser.parse_args()[]<EOL>if args.url and not args.url.lower().startswith("http"):<EOL><INDENT>args.url="http://%s"%args.url <EOL><DEDENT>if not any((args.url,args.list,args.update)):<EOL><INDENT>parser.error('<STR_LIT>')<EOL><DEDENT>if args.prefix :<EOL><INDENT>args.prefix=args.prefix *args.multiplier <EOL><DEDENT>return args <EOL><DEDENT>def main():<EOL><INDENT> '<STR_LIT>'<EOL>global args <EOL>kb.files=[]<EOL>kb.found=False <EOL>kb.print_lock=threading.Lock()<EOL>kb.value_lock=threading.Lock()<EOL>kb.versioned_locations={}<EOL>check_revision()<EOL>print(BANNER)<EOL>args=parse_args()<EOL>if args.update :<EOL><INDENT>update()<EOL>exit()<EOL><DEDENT>with open("versions.ini")as f :<EOL><INDENT>section=None <EOL>for line in f.xreadlines():<EOL><INDENT>line=line.strip()<EOL>if re.match(r"\[.+\]",line):<EOL><INDENT>section=line.strip("[]")<EOL><DEDENT>elif line :<EOL><INDENT>if section not in kb.versioned_locations :<EOL><INDENT>kb.versioned_locations [section ]=[]<EOL><DEDENT>kb.versioned_locations [section ].append(line)<EOL><DEDENT> <DEDENT> <DEDENT>cases=get_cases(args)if not args.list_file else load_list(args.list_file)<EOL>if not cases :<EOL><INDENT>print('<STR_LIT>'<EOL>'<STR_LIT>')<EOL>exit()<EOL><DEDENT>if args.list :<EOL><INDENT>args.list=args.list.lower()<EOL>_=("category","software","os")<EOL>if args.list not in _ :<EOL><INDENT>print('<STR_LIT>'%", ".join(_))<EOL>exit()<EOL><DEDENT>print('<STR_LIT>'%args.list)<EOL>try :<EOL><INDENT>for _ in set([_ [args.list ]for _ in cases ]):<EOL><INDENT>print(_ if re.search('<STR_LIT>',_)else '"%s"'%_)<EOL><DEDENT> <DEDENT>except KeyError :<EOL><INDENT>pass <EOL><DEDENT>finally :<EOL><INDENT>exit()<EOL><DEDENT> <DEDENT>if args.ignore_proxy :<EOL><INDENT>_=ProxyHandler({})<EOL>opener=build_opener(_)<EOL>install_opener(opener)<EOL><DEDENT>elif args.proxy :<EOL><INDENT>match=re.search('<STR_LIT>',args.proxy,re.I)<EOL>if match :<EOL><INDENT>if match.group("type").upper()in(PROXY_TYPE.HTTP,PROXY_TYPE.HTTPS):<EOL><INDENT>_=ProxyHandler({match.group("type"):args.proxy })<EOL>opener=build_opener(_)<EOL>install_opener(opener)<EOL><DEDENT>else :<EOL><INDENT>from thirdparty.socks import socks <EOL>if match.group("type").upper()==PROXY_TYPE.SOCKS4 :<EOL><INDENT>socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS4,match.group("address"),int(match.group("port")),True)<EOL><DEDENT>elif match.group("type").upper()==PROXY_TYPE.SOCKS5 :<EOL><INDENT>socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5,match.group("address"),int(match.group("port")),True)<EOL><DEDENT> <DEDENT> <DEDENT>else :<EOL><INDENT>print('<STR_LIT>')<EOL>exit()<EOL><DEDENT> <DEDENT>if args.random_agent :<EOL><INDENT>with open(USER_AGENTS_FILE,'r')as f :<EOL><INDENT>args.user_agent=random.sample(f.readlines(),)[]<EOL><DEDENT> <DEDENT>kb.parsed_target_url=urlsplit(args.url)<EOL>kb.request_params=args.data if args.data else kb.parsed_target_url.query <EOL>if not args.param :<EOL><INDENT>match=re.match('<STR_LIT>',kb.request_params)<EOL>if match :<EOL><INDENT>args.param=match.group("param")<EOL><DEDENT>else :<EOL><INDENT>found=False <EOL>for match in re.finditer('<STR_LIT>',kb.request_params):<EOL><INDENT>found=True <EOL>print('<STR_LIT>'%match.group("param"))<EOL><DEDENT>if found :<EOL><INDENT>print('<STR_LIT>')<EOL><DEDENT>print('<STR_LIT>')<EOL>exit()<EOL><DEDENT> <DEDENT>if args.os :<EOL><INDENT>kb.restrict_os=args.os <EOL><DEDENT>print('<STR_LIT>'%time.strftime("%X"))<EOL>print('<STR_LIT>')<EOL>request_args=prepare_request(None)<EOL>request_args ["url"]=args.url <EOL>if args.data :<EOL><INDENT>request_args ["data"]=args.data <EOL><DEDENT>kb.original_response=get_page(**request_args)<EOL>if not kb.original_response :<EOL><INDENT>print('<STR_LIT>')<EOL>if not args.verbose :<EOL><INDENT>print('<STR_LIT>')<EOL><DEDENT>exit()<EOL><DEDENT>print('<STR_LIT>')<EOL>request_args=prepare_request("%s%s%s"%(args.prefix,INVALID_FILENAME,args.postfix))<EOL>kb.invalid_response=get_page(**request_args)<EOL>print("[i] Done!")<EOL>print('<STR_LIT>')<EOL>if args.threads >:<EOL><INDENT>print('<STR_LIT>'%args.threads)<EOL><DEDENT>threads=[]<EOL>for i in xrange(args.threads):<EOL><INDENT>thread=threading.Thread(target=try_cases,args=([cases [_ ]for _ in xrange(i,len(cases),args.threads)],))<EOL>thread.daemon=True <EOL>thread.start()<EOL>threads.append(thread)<EOL><DEDENT>alive=True <EOL>while alive :<EOL><INDENT>alive=False <EOL>for thread in threads :<EOL><INDENT>if thread.isAlive():<EOL><INDENT>alive=True <EOL>time.sleep()<EOL><DEDENT> <DEDENT> <DEDENT>if not kb.found :<EOL><INDENT>print('<STR_LIT>')<EOL><DEDENT>elif args.verbose :<EOL><INDENT>print('<STR_LIT>')<EOL>for _ in kb.files :<EOL><INDENT>print("[o] %s"%_)<EOL><DEDENT> <DEDENT>print('<STR_LIT>')<EOL>print('<STR_LIT>'%time.strftime("%X"))<EOL><DEDENT>def get_page(**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>url=kwargs.get("url",None)<EOL>post=kwargs.get("data",None)<EOL>header=kwargs.get("header",None)<EOL>cookie=kwargs.get("cookie",None)<EOL>user_agent=kwargs.get("user_agent",None)<EOL>verbose=kwargs.get("verbose",False)<EOL>headers={}<EOL>parsed_url=None <EOL>page=None <EOL>if url is None :<EOL><INDENT>raise Exception('<STR_LIT>')<EOL><DEDENT>try :<EOL><INDENT>parsed_url=urlsplit(url)<EOL><DEDENT>except :<EOL><INDENT>raise Exception('<STR_LIT>'%url)<EOL><DEDENT>if user_agent is None :<EOL><INDENT>user_agent="%s %s"%(NAME,VERSION)<EOL><DEDENT>if post is None :<EOL><INDENT>parsed_url=parsed_url._replace(query=urlencode(parse_qsl(parsed_url.query)))<EOL>url=urlunsplit(parsed_url)<EOL><DEDENT>else :<EOL><INDENT>post=urlencode(parse_qsl(post),"POST")<EOL><DEDENT>try :<EOL><INDENT>headers [HTTP_HEADER.USER_AGENT ]=user_agent <EOL>if cookie :<EOL><INDENT>headers [HTTP_HEADER.COOKIE ]=cookie <EOL><DEDENT>if header :<EOL><INDENT>headers [header.split("=")[]]=header.split("=",)[]<EOL><DEDENT>req=Request(url,post,headers)<EOL>conn=urlopen(req)<EOL>if not args.write_files and kb.original_response and kb.invalid_response :<EOL><INDENT>_=conn.headers.get(HTTP_HEADER.CONTENT_LENGTH,"")<EOL>if _.isdigit():<EOL><INDENT>_=int(_)<EOL>if _ -max(len(kb.original_response),len(kb.invalid_response))>SKIP_RETRIEVE_THRESHOLD :<EOL><INDENT>page="".join(random.choice(string.letters)for i in xrange(_))<EOL><DEDENT> <DEDENT> <DEDENT>if not page :<EOL><INDENT>page=conn.read()<EOL><DEDENT> <DEDENT>except KeyboardInterrupt :<EOL><INDENT>raise <EOL><DEDENT>except Exception,e :<EOL><INDENT>if hasattr(e,"read"):<EOL><INDENT>page=page or e.read()<EOL><DEDENT>if verbose :<EOL><INDENT>if hasattr(e,"msg"):<EOL><INDENT>print('<STR_LIT>'%e.msg)<EOL><DEDENT>if hasattr(e,"reason"):<EOL><INDENT>print('<STR_LIT>'%e.reason)<EOL><DEDENT>if getattr(e,"message"):<EOL><INDENT>print('<STR_LIT>'%e.message)<EOL><DEDENT>if hasattr(e,"code"):<EOL><INDENT>print('<STR_LIT>'%e.code)<EOL><DEDENT>if hasattr(e,"info"):<EOL><INDENT>print('<STR_LIT>'%e.info())<EOL><DEDENT> <DEDENT> <DEDENT>return page <EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>try :<EOL><INDENT>main()<EOL><DEDENT>except KeyboardInterrupt :<EOL><INDENT>print('<STR_LIT>')<EOL><DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from.htmlfilewriter import HtmlFileWriter,ModelWriter <EOL>from.jsonwriter import JsonWriter <EOL>LOG='rebot/log.html'<EOL>REPORT='<STR_LIT>'<EOL>LIBDOC='<STR_LIT>'<EOL>TESTDOC='<STR_LIT>'<EOF><BOF>__version__='0.6'<EOL>from os.path import dirname,join <EOL>from.util import Directory <EOL>_package_root=dirname(__file__)<EOL>_chp_csv_path=join(_package_root,'201412.csv')<EOL>_db_path=join(_package_root,'201412.db')<EOL>_dir=Directory(_db_path)<EOL>find=_dir.find <EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>def angle_cos(p0,p1,p2):<EOL><INDENT>d1,d2=(p0 -p1).astype('float'),(p2 -p1).astype('float')<EOL>return abs(np.dot(d1,d2)/np.sqrt(np.dot(d1,d1)*np.dot(d2,d2)))<EOL><DEDENT>def find_squares(img):<EOL><INDENT>img=cv2.GaussianBlur(img,(,),)<EOL>squares=[]<EOL>for gray in cv2.split(img):<EOL><INDENT>for thrs in xrange(,,):<EOL><INDENT>if thrs==:<EOL><INDENT>bin=cv2.Canny(gray,,,apertureSize=)<EOL>bin=cv2.dilate(bin,None)<EOL><DEDENT>else :<EOL><INDENT>retval,bin=cv2.threshold(gray,thrs,,cv2.THRESH_BINARY)<EOL><DEDENT>contours,hierarchy=cv2.findContours(bin,cv2.RETR_LIST,cv2.CHAIN_APPROX_SIMPLE)<EOL>for cnt in contours :<EOL><INDENT>cnt_len=cv2.arcLength(cnt,True)<EOL>cnt=cv2.approxPolyDP(cnt,*cnt_len,True)<EOL>if len(cnt)==and cv2.contourArea(cnt)>and cv2.isContourConvex(cnt):<EOL><INDENT>cnt=cnt.reshape(-,)<EOL>max_cos=np.max([angle_cos(cnt [i ],cnt [(i +)%],cnt [(i +)%])for i in xrange()])<EOL>if max_cos <:<EOL><INDENT>squares.append(cnt)<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>return squares <EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>from glob import glob <EOL>for fn in glob('../cpp/pic*.png'):<EOL><INDENT>img=cv2.imread(fn)<EOL>squares=find_squares(img)<EOL>cv2.drawContours(img,squares,-,(,,),)<EOL>cv2.imshow('squares',img)<EOL>ch=&cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>import six <EOL>if six.PY2 :<EOL><INDENT>from StringIO import StringIO <EOL><DEDENT>else :<EOL><INDENT>from io import StringIO <EOL><DEDENT>assert StringIO <EOF><BOF>import sys <EOL>import cv2.cv as cv <EOL>import urllib2 <EOL>wndname='<STR_LIT>'<EOL>tbarname="Threshold"<EOL>dist=<EOL>dist8u1=<EOL>dist8u2=<EOL>dist8u=<EOL>dist32s=<EOL>gray=<EOL>edge=<EOL>def on_trackbar(edge_thresh):<EOL><INDENT>cv.Threshold(gray,edge,float(edge_thresh),float(edge_thresh),cv.CV_THRESH_BINARY)<EOL>cv.DistTransform(edge,dist,cv.CV_DIST_L2,cv.CV_DIST_MASK_5)<EOL>cv.ConvertScale(dist,dist,,)<EOL>cv.Pow(dist,dist,)<EOL>cv.ConvertScale(dist,dist32s,,)<EOL>cv.AndS(dist32s,cv.ScalarAll(),dist32s,None)<EOL>cv.ConvertScale(dist32s,dist8u1,,)<EOL>cv.ConvertScale(dist32s,dist32s,-,)<EOL>cv.AddS(dist32s,cv.ScalarAll(),dist32s,None)<EOL>cv.ConvertScale(dist32s,dist8u2,,)<EOL>cv.Merge(dist8u1,dist8u2,dist8u2,None,dist8u)<EOL>cv.ShowImage(wndname,dist8u)<EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>edge_thresh=<EOL>if len(sys.argv)>:<EOL><INDENT>gray=cv.LoadImage(sys.argv [],cv.CV_LOAD_IMAGE_GRAYSCALE)<EOL><DEDENT>else :<EOL><INDENT>url='<STR_LIT>'<EOL>filedata=urllib2.urlopen(url).read()<EOL>imagefiledata=cv.CreateMatHeader(,len(filedata),cv.CV_8UC1)<EOL>cv.SetData(imagefiledata,filedata,len(filedata))<EOL>gray=cv.DecodeImage(imagefiledata,cv.CV_LOAD_IMAGE_GRAYSCALE)<EOL><DEDENT>dist=cv.CreateImage((gray.width,gray.height),cv.IPL_DEPTH_32F,)<EOL>dist8u1=cv.CloneImage(gray)<EOL>dist8u2=cv.CloneImage(gray)<EOL>dist8u=cv.CreateImage((gray.width,gray.height),cv.IPL_DEPTH_8U,)<EOL>dist32s=cv.CreateImage((gray.width,gray.height),cv.IPL_DEPTH_32S,)<EOL>edge=cv.CloneImage(gray)<EOL>cv.NamedWindow(wndname,)<EOL>cv.CreateTrackbar(tbarname,wndname,edge_thresh,,on_trackbar)<EOL>on_trackbar(edge_thresh)<EOL>cv.WaitKey()<EOL>cv.DestroyAllWindows()<EOL><DEDENT><EOF><BOF>import pygame <EOL>from pygame.locals import *<EOL>from py2d.Math import *<EOL>from py2d.SVG import convert_svg <EOL>from examples import Example <EOL>class SVGConverter(Example):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,runner):<EOL><INDENT>self.runner=runner <EOL>self.title='<STR_LIT>'<EOL>self.polys=[]<EOL>for id,polys in convert_svg('<STR_LIT>',bezier_max_divisions=None).iteritems():<EOL><INDENT>self.polys.append(polys)<EOL><DEDENT>self.decomp=[]<EOL>self.poly_colors=[,,,,,]<EOL><DEDENT>def render(self):<EOL><INDENT>t=Transform.unit()<EOL>for j,p in enumerate(self.polys):<EOL><INDENT>for i,h in enumerate(p):<EOL><INDENT>self.draw_poly(t *h,self.poly_colors [j %len(self.poly_colors)],False)<EOL><DEDENT> <DEDENT> <DEDENT>def draw_poly(self,poly,color,fill):<EOL><INDENT>if len(poly)>:<EOL><INDENT>if fill and len(poly)>:<EOL><INDENT>pygame.draw.polygon(self.runner.screen,color,poly.as_tuple_list())<EOL><DEDENT>pygame.draw.lines(self.runner.screen,color,True,poly.as_tuple_list())<EOL><DEDENT>elif poly.points :<EOL><INDENT>pygame.draw.circle(self.runner.screen,color,poly.points [].as_tuple(),)<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from collections import defaultdict <EOL>def group_repositories(repos):<EOL><INDENT> '<STR_LIT>'<EOL>sections=defaultdict(list)<EOL>for repo in repos :<EOL><INDENT>sections [repo.owner.login ].append(repo)<EOL><DEDENT>for key in sections.keys():<EOL><INDENT>if len(sections [key ])<=:<EOL><INDENT>sections ['Other'].extend(sections.pop(key))<EOL><DEDENT> <DEDENT>order=lambda t :'z'*if t []=='Other'else t [].lower()<EOL>return sorted(sections.items(),key=order)<EOL><DEDENT>def get_user_active_repositories(user):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>return user.repositories.filter(webhook__active=True)<EOL><DEDENT>except AttributeError :<EOL><INDENT>return []<EOL><DEDENT> <DEDENT><EOF><BOF>class ParseConfig :<EOL><INDENT>def getFolder(self):<EOL><INDENT>return self.folder <EOL><DEDENT>def setFolder(self,folder):<EOL><INDENT>self.folder=folder <EOL><DEDENT>def getExt(self):<EOL><INDENT>return self.ext <EOL><DEDENT>def setExt(self,ext):<EOL><INDENT>self.ext=ext <EOL><DEDENT>def getType(self):<EOL><INDENT>return self.type <EOL><DEDENT>def setType(self,type):<EOL><INDENT>self.type=type <EOL><DEDENT> <DEDENT><EOF><BOF>import numpy as np <EOL>import cv2 <EOL>from common import splitfn <EOL>import os <EOL>USAGE='<STR_LIT>'<EOL>if __name__=='__main__':<EOL><INDENT>import sys <EOL>import getopt <EOL>from glob import glob <EOL>args,img_mask=getopt.getopt(sys.argv [:],'',['save=','debug=','square_size='])<EOL>args=dict(args)<EOL>try :<EOL><INDENT>img_mask=img_mask []<EOL><DEDENT>except :<EOL><INDENT>img_mask='<STR_LIT>'<EOL><DEDENT>img_names=glob(img_mask)<EOL>debug_dir=args.get('--debug')<EOL>square_size=float(args.get('--square_size',))<EOL>pattern_size=(,)<EOL>pattern_points=np.zeros((np.prod(pattern_size),),np.float32)<EOL>pattern_points [:,:]=np.indices(pattern_size).T.reshape(-,)<EOL>pattern_points *=square_size <EOL>obj_points=[]<EOL>img_points=[]<EOL>h,w=,<EOL>for fn in img_names :<EOL><INDENT>print '<STR_LIT>'%fn,<EOL>img=cv2.imread(fn,)<EOL>if img is None :<EOL><INDENT>print "Failed to load",fn <EOL>continue <EOL><DEDENT>h,w=img.shape [:]<EOL>found,corners=cv2.findChessboardCorners(img,pattern_size)<EOL>if found :<EOL><INDENT>term=(cv2.TERM_CRITERIA_EPS +cv2.TERM_CRITERIA_COUNT,,)<EOL>cv2.cornerSubPix(img,corners,(,),(-,-),term)<EOL><DEDENT>if debug_dir :<EOL><INDENT>vis=cv2.cvtColor(img,cv2.COLOR_GRAY2BGR)<EOL>cv2.drawChessboardCorners(vis,pattern_size,corners,found)<EOL>path,name,ext=splitfn(fn)<EOL>cv2.imwrite('%s/%s_chess.bmp'%(debug_dir,name),vis)<EOL><DEDENT>if not found :<EOL><INDENT>print '<STR_LIT>'<EOL>continue <EOL><DEDENT>img_points.append(corners.reshape(-,))<EOL>obj_points.append(pattern_points)<EOL>print 'ok'<EOL><DEDENT>rms,camera_matrix,dist_coefs,rvecs,tvecs=cv2.calibrateCamera(obj_points,img_points,(w,h),None,None)<EOL>print "RMS:",rms <EOL>print '<STR_LIT>',camera_matrix <EOL>print '<STR_LIT>',dist_coefs.ravel()<EOL>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>import codecs <EOL>class LibdocOutput(object):<EOL><INDENT>def __init__(self,output_path,format):<EOL><INDENT>self._output_path=output_path <EOL>self._format=format.upper()<EOL>self._output_file=None <EOL><DEDENT>def __enter__(self):<EOL><INDENT>if self._format=='HTML':<EOL><INDENT>self._output_file=codecs.open(self._output_path,'w','UTF-8')<EOL>return self._output_file <EOL><DEDENT>return self._output_path <EOL><DEDENT>def __exit__(self,*exc_info):<EOL><INDENT>if self._output_file :<EOL><INDENT>self._output_file.close()<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>from flask_wtf import Form <EOL>from wtforms import StringField,PasswordField,BooleanField,SubmitField,SelectField,ValidationError <EOL>from wtforms.validators import DataRequired,Length,Email,EqualTo <EOL>from.models import User,Role <EOL>class LoginForm(Form):<EOL><INDENT>email=StringField(u'Email',validators=[DataRequired(),<EOL>Length(,),Email()])<EOL>password=PasswordField(u'Password',validators=[DataRequired()])<EOL>remember_me=BooleanField(u'Remember Me')<EOL>submit=SubmitField(u'Log In')<EOL><DEDENT>class RegisterForm(Form):<EOL><INDENT>name=StringField(u'Your Name',validators=[DataRequired()])<EOL>email=StringField(u'Email',validators=[DataRequired(),<EOL>Length(,),Email()])<EOL>password=PasswordField(u'Password',validators=[DataRequired(),<EOL>EqualTo('cpassword',<EOL>message='<STR_LIT>')])<EOL>cpassword=PasswordField('<STR_LIT>',validators=[DataRequired()])<EOL>role=SelectField(u'Role',coerce=int)<EOL>confirm=BooleanField('<STR_LIT>')<EOL>submit=SubmitField(u'Sign Up')<EOL>def __init__(self,**kwargs):<EOL><INDENT>super(RegisterForm,self).__init__(**kwargs)<EOL>self.role.choices=[(r.id,r.name)<EOL>for r in Role.query.with_entities(<EOL>Role.id,Role.name).all()]<EOL><DEDENT>def validate_email(self,field):<EOL><INDENT>if User.query.filter_by(email=field.data).first():<EOL><INDENT>raise ValidationError('<STR_LIT>')<EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>__author__='<STR_LIT>'<EOL>import io <EOL>import jinja2 <EOL>import logging <EOL>import os <EOL>import webapp2 <EOL>from google.appengine.api import memcache <EOL>from google.appengine.api import urlfetch <EOL>import httplib2 <EOL>from apiclient import errors <EOL>from apiclient.http import MediaIoBaseUpload <EOL>from apiclient.http import BatchHttpRequest <EOL>from oauth2client.appengine import StorageByKeyName <EOL>from model import Credentials <EOL>import util <EOL>jinja_environment=jinja2.Environment(<EOL>loader=jinja2.FileSystemLoader(os.path.dirname(__file__)))<EOL>PAGINATED_HTML='<STR_LIT>'<EOL>class _BatchCallback(object):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self):<EOL><INDENT> '<STR_LIT>'<EOL>self.success=<EOL>self.failure=<EOL><DEDENT>def callback(self,request_id,response,exception):<EOL><INDENT> '<STR_LIT>'<EOL>if exception is None :<EOL><INDENT>self.success +=<EOL><DEDENT>else :<EOL><INDENT>self.failure +=<EOL>logging.error(<EOL>'<STR_LIT>',request_id,exception)<EOL><DEDENT> <DEDENT> <DEDENT>class MainHandler(webapp2.RequestHandler):<EOL><INDENT> '<STR_LIT>'<EOL>def _render_template(self,message=None):<EOL><INDENT> '<STR_LIT>'<EOL>template_values={'userId':self.userid }<EOL>if message :<EOL><INDENT>template_values ['message']=message <EOL><DEDENT>try :<EOL><INDENT>template_values ['contact']=self.mirror_service.contacts().get(<EOL>id='<STR_LIT>').execute()<EOL><DEDENT>except errors.HttpError :<EOL><INDENT>logging.info('<STR_LIT>')<EOL><DEDENT>timeline_items=self.mirror_service.timeline().list(maxResults=).execute()<EOL>template_values ['timelineItems']=timeline_items.get('items',[])<EOL>subscriptions=self.mirror_service.subscriptions().list().execute()<EOL>for subscription in subscriptions.get('items',[]):<EOL><INDENT>collection=subscription.get('collection')<EOL>if collection=='timeline':<EOL><INDENT>template_values ['<STR_LIT>']=True <EOL><DEDENT>elif collection=='locations':<EOL><INDENT>template_values ['<STR_LIT>']=True <EOL><DEDENT> <DEDENT>template=jinja_environment.get_template('<STR_LIT>')<EOL>self.response.out.write(template.render(template_values))<EOL><DEDENT>@util.auth_required <EOL>def get(self):<EOL><INDENT> '<STR_LIT>'<EOL>message=memcache.get(key=self.userid)<EOL>memcache.delete(key=self.userid)<EOL>self._render_template(message)<EOL><DEDENT>@util.auth_required <EOL>def post(self):<EOL><INDENT> '<STR_LIT>'<EOL>operation=self.request.get('operation')<EOL>operations={<EOL>'<STR_LIT>':self._insert_subscription,<EOL>'<STR_LIT>':self._delete_subscription,<EOL>'insertItem':self._insert_item,<EOL>'<STR_LIT>':self._insert_paginated_item,<EOL>'<STR_LIT>':self._insert_item_with_action,<EOL>'<STR_LIT>':self._insert_item_all_users,<EOL>'insertContact':self._insert_contact,<EOL>'deleteContact':self._delete_contact,<EOL>'<STR_LIT>':self._delete_timeline_item <EOL>}<EOL>if operation in operations :<EOL><INDENT>message=operations [operation ]()<EOL><DEDENT>else :<EOL><INDENT>message='<STR_LIT>'+operation <EOL><DEDENT>memcache.set(key=self.userid,value=message,time=)<EOL>self.redirect('/')<EOL><DEDENT>def _insert_subscription(self):<EOL><INDENT> '<STR_LIT>'<EOL>body={<EOL>'collection':self.request.get('collection','timeline'),<EOL>'userToken':self.userid,<EOL>'callbackUrl':util.get_full_url(self,'/notify')<EOL>}<EOL>self.mirror_service.subscriptions().insert(body=body).execute()<EOL>return '<STR_LIT>'<EOL><DEDENT>def _delete_subscription(self):<EOL><INDENT> '<STR_LIT>'<EOL>collection=self.request.get('subscriptionId')<EOL>self.mirror_service.subscriptions().delete(id=collection).execute()<EOL>return '<STR_LIT>'<EOL><DEDENT>def _insert_item(self):<EOL><INDENT> '<STR_LIT>'<EOL>logging.info('<STR_LIT>')<EOL>body={<EOL>'notification':{'level':'DEFAULT'}<EOL>}<EOL>if self.request.get('html')=='on':<EOL><INDENT>body ['html']=[self.request.get('message')]<EOL><DEDENT>else :<EOL><INDENT>body ['text']=self.request.get('message')<EOL><DEDENT>media_link=self.request.get('imageUrl')<EOL>if media_link :<EOL><INDENT>if media_link.startswith('/'):<EOL><INDENT>media_link=util.get_full_url(self,media_link)<EOL><DEDENT>resp=urlfetch.fetch(media_link,deadline=)<EOL>media=MediaIoBaseUpload(<EOL>io.BytesIO(resp.content),mimetype='image/jpeg',resumable=True)<EOL><DEDENT>else :<EOL><INDENT>media=None <EOL><DEDENT>self.mirror_service.timeline().insert(body=body,media_body=media).execute()<EOL>return '<STR_LIT>'<EOL><DEDENT>def _insert_paginated_item(self):<EOL><INDENT> '<STR_LIT>'<EOL>logging.info('<STR_LIT>')<EOL>body={<EOL>'html':PAGINATED_HTML,<EOL>'notification':{'level':'DEFAULT'},<EOL>'menuItems':[{<EOL>'action':'OPEN_URI',<EOL>'payload':'<STR_LIT>'<EOL>}]<EOL>}<EOL>self.mirror_service.timeline().insert(body=body).execute()<EOL>return '<STR_LIT>'<EOL><DEDENT>def _insert_item_with_action(self):<EOL><INDENT> '<STR_LIT>'<EOL>logging.info('<STR_LIT>')<EOL>body={<EOL>'creator':{<EOL>'displayName':'<STR_LIT>',<EOL>'id':'<STR_LIT>'<EOL>},<EOL>'text':'<STR_LIT>',<EOL>'notification':{'level':'DEFAULT'},<EOL>'menuItems':[{'action':'REPLY'}]<EOL>}<EOL>self.mirror_service.timeline().insert(body=body).execute()<EOL>return '<STR_LIT>'<EOL><DEDENT>def _insert_item_all_users(self):<EOL><INDENT> '<STR_LIT>'<EOL>logging.info('<STR_LIT>')<EOL>users=Credentials.all()<EOL>total_users=users.count()<EOL>if total_users >:<EOL><INDENT>return '<STR_LIT>'%(<EOL>total_users)<EOL><DEDENT>body={<EOL>'text':'Hello Everyone!',<EOL>'notification':{'level':'DEFAULT'}<EOL>}<EOL>batch_responses=_BatchCallback()<EOL>batch=BatchHttpRequest(callback=batch_responses.callback)<EOL>for user in users :<EOL><INDENT>creds=StorageByKeyName(<EOL>Credentials,user.key().name(),'credentials').get()<EOL>mirror_service=util.create_service('mirror','v1',creds)<EOL>batch.add(<EOL>mirror_service.timeline().insert(body=body),<EOL>request_id=user.key().name())<EOL><DEDENT>batch.execute(httplib2.Http())<EOL>return '<STR_LIT>'%(<EOL>batch_responses.success,batch_responses.failure)<EOL><DEDENT>def _insert_contact(self):<EOL><INDENT> '<STR_LIT>'<EOL>logging.info('<STR_LIT>')<EOL>id=self.request.get('id')<EOL>name=self.request.get('name')<EOL>image_url=self.request.get('imageUrl')<EOL>if not name or not image_url :<EOL><INDENT>return '<STR_LIT>'<EOL><DEDENT>else :<EOL><INDENT>if image_url.startswith('/'):<EOL><INDENT>image_url=util.get_full_url(self,image_url)<EOL><DEDENT>body={<EOL>'id':id,<EOL>'displayName':name,<EOL>'imageUrls':[image_url ],<EOL>'acceptCommands':[{'type':'TAKE_A_NOTE'}]<EOL>}<EOL>self.mirror_service.contacts().insert(body=body).execute()<EOL>return '<STR_LIT>'+name <EOL><DEDENT> <DEDENT>def _delete_contact(self):<EOL><INDENT> '<STR_LIT>'<EOL>self.mirror_service.contacts().delete(<EOL>id=self.request.get('id')).execute()<EOL>return '<STR_LIT>'<EOL><DEDENT>def _delete_timeline_item(self):<EOL><INDENT> '<STR_LIT>'<EOL>logging.info('<STR_LIT>')<EOL>self.mirror_service.timeline().delete(id=self.request.get('itemId')).execute()<EOL>return '<STR_LIT>'<EOL><DEDENT> <DEDENT>MAIN_ROUTES=[('/',MainHandler)<EOL>]<EOF><BOF>import time <EOL>from robot import utils <EOL>from.stringcache import StringIndex <EOL>class JsExecutionResult(object):<EOL><INDENT>def __init__(self,suite,statistics,errors,strings,basemillis=None,<EOL>split_results=None,min_level=None):<EOL><INDENT>self.suite=suite <EOL>self.strings=strings <EOL>self.min_level=min_level <EOL>self.data=self._get_data(statistics,errors,basemillis or)<EOL>self.split_results=split_results or []<EOL><DEDENT>def _get_data(self,statistics,errors,basemillis):<EOL><INDENT>gentime=time.localtime()<EOL>return {<EOL>'stats':statistics,<EOL>'errors':errors,<EOL>'baseMillis':basemillis,<EOL>'generatedMillis':long(time.mktime(gentime)*)-basemillis,<EOL>'<STR_LIT>':utils.format_time(gentime,gmtsep=' ')<EOL>}<EOL><DEDENT>def remove_data_not_needed_in_report(self):<EOL><INDENT>self.data.pop('errors')<EOL>remover=_KeywordRemover()<EOL>self.suite=remover.remove_keywords(self.suite)<EOL>self.suite,self.strings=remover.remove_unused_strings(self.suite,self.strings)<EOL><DEDENT> <DEDENT>class _KeywordRemover(object):<EOL><INDENT>def remove_keywords(self,suite):<EOL><INDENT>return self._remove_keywords_from_suite(suite)<EOL><DEDENT>def _remove_keywords_from_suite(self,suite):<EOL><INDENT>return suite [:]+(self._remove_keywords_from_suites(suite []),<EOL>self._remove_keywords_from_tests(suite []),(),suite [])<EOL><DEDENT>def _remove_keywords_from_suites(self,suites):<EOL><INDENT>return tuple(self._remove_keywords_from_suite(s)for s in suites)<EOL><DEDENT>def _remove_keywords_from_tests(self,tests):<EOL><INDENT>return tuple(self._remove_keywords_from_test(t)for t in tests)<EOL><DEDENT>def _remove_keywords_from_test(self,test):<EOL><INDENT>return test [:-]+((),)<EOL><DEDENT>def remove_unused_strings(self,model,strings):<EOL><INDENT>used=set(self._get_used_indices(model))<EOL>remap={}<EOL>strings=tuple(self._get_used_strings(strings,used,remap))<EOL>model=tuple(self._remap_string_indices(model,remap))<EOL>return model,strings <EOL><DEDENT>def _get_used_indices(self,model):<EOL><INDENT>for item in model :<EOL><INDENT>if isinstance(item,StringIndex):<EOL><INDENT>yield item <EOL><DEDENT>elif isinstance(item,tuple):<EOL><INDENT>for i in self._get_used_indices(item):<EOL><INDENT>yield i <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>def _get_used_strings(self,strings,used_indices,remap):<EOL><INDENT>offset=<EOL>for index,string in enumerate(strings):<EOL><INDENT>if index in used_indices :<EOL><INDENT>remap [index ]=index -offset <EOL>yield string <EOL><DEDENT>else :<EOL><INDENT>offset +=<EOL><DEDENT> <DEDENT> <DEDENT>def _remap_string_indices(self,model,remap):<EOL><INDENT>for item in model :<EOL><INDENT>if isinstance(item,StringIndex):<EOL><INDENT>yield remap [item ]<EOL><DEDENT>elif isinstance(item,tuple):<EOL><INDENT>yield tuple(self._remap_string_indices(item,remap))<EOL><DEDENT>else :<EOL><INDENT>yield item <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT><EOF><BOF>import cv2 <EOL>import numpy as np <EOL>from glob import glob <EOL>class undistortor :<EOL><INDENT>def __init__(self,cal_data=None):<EOL><INDENT>if cal_data is None :<EOL><INDENT>npz_mask='*.npz'<EOL>self.cal_data=glob(npz_mask)[]<EOL><DEDENT>else :<EOL><INDENT>self.cal_data=cal_data <EOL><DEDENT>with np.load(self.cal_data)as X :<EOL><INDENT>self.mtx,self.dist,_,_=[X [i ]for i in('mtx','dist','rvecs','tvecs')]<EOL><DEDENT> <DEDENT>def apply(self,img,crop=True):<EOL><INDENT>h,w=img.shape [:]<EOL>newcameramtx,roi=cv2.getOptimalNewCameraMatrix(self.mtx,self.dist,(w,h),,(w,h))<EOL>dst=cv2.undistort(img,self.mtx,self.dist,None,newcameramtx)<EOL>if crop is not True :<EOL><INDENT>return dst <EOL><DEDENT>x,y,w,h=roi <EOL>dst=dst [y :y +h,x :x +w ]<EOL>return dst <EOL><DEDENT> <DEDENT>if __name__=="__main__":<EOL><INDENT>ud=undistortor()<EOL>img=cv2.imread('img.jpg')<EOL>cv2.imshow('compare',np.hstack([img,ud.apply(img,crop=False)]))<EOL>cv2.waitKey()<DEDENT><EOF><BOF>import re <EOL>from.tsvreader import TsvReader <EOL>class TxtReader(TsvReader):<EOL><INDENT>_space_splitter=re.compile(' {2,}')<EOL>_pipe_splitter=re.compile(' \|(?=)')<EOL>@classmethod <EOL>def split_row(cls,row):<EOL><INDENT>if '\t'in row :<EOL><INDENT>row=row.replace('\t','  ')<EOL><DEDENT>if not row.startswith('| '):<EOL><INDENT>return cls._space_splitter.split(row)<EOL><DEDENT>row=row [:-]if row.endswith(' |')else row [:]<EOL>return [cell.strip()for cell in cls._pipe_splitter.split(row)]<EOL><DEDENT>def _process(self,cell):<EOL><INDENT>return cell <EOL><DEDENT> <DEDENT><EOF><BOF>import cv2.cv as cv <EOL>import time <EOL>from pydmtx import DataMatrix <EOL>import numpy <EOL>import sys <EOL>import math <EOL>'<STR_LIT>'<EOL>def absnorm8(im,im8):<EOL><INDENT> '<STR_LIT>'(minVal,maxVal,_,_)=cv.MinMaxLoc(im)<EOL>cv.ConvertScaleAbs(im,im8,/max(abs(minVal),abs(maxVal)),)<EOL>return im8 <EOL><DEDENT>font=cv.InitFont(cv.CV_FONT_HERSHEY_SIMPLEX,,,thickness=,lineType=cv.CV_AA)<EOL>if :<EOL><INDENT>started=time.time()<EOL>print dm_write.decode(bg.width,bg.height,buffer(bg.tostring()),max_count=,min_edge=,max_edge=,shape=DataMatrix.DmtxSymbol10x10)<EOL>print "took",time.time()-started <EOL><DEDENT>class DmtxFinder :<EOL><INDENT>def __init__(self):<EOL><INDENT>self.cache={}<EOL>self.dm=DataMatrix()<EOL><DEDENT>def Cached(self,name,rows,cols,type):<EOL><INDENT>key=(name,rows,cols)<EOL>if not key in self.cache :<EOL><INDENT>self.cache [key ]=cv.CreateMat(rows,cols,type)<EOL><DEDENT>return self.cache [key ]<EOL><DEDENT>def find0(self,img):<EOL><INDENT>started=time.time()<EOL>self.dm.decode(img.width,<EOL>img.height,<EOL>buffer(img.tostring()),<EOL>max_count=,<EOL>)<EOL>print "brute",time.time()-started <EOL>found={}<EOL>for i in range(self.dm.count()):<EOL><INDENT>stats=dm_read.stats(i +)<EOL>print stats <EOL>found [stats []]=stats []<EOL><DEDENT>return found <EOL><DEDENT>def find(self,img):<EOL><INDENT>started=time.time()<EOL>gray=self.Cached('gray',img.height,img.width,cv.CV_8UC1)<EOL>cv.CvtColor(img,gray,cv.CV_BGR2GRAY)<EOL>sobel=self.Cached('sobel',img.height,img.width,cv.CV_16SC1)<EOL>sobely=self.Cached('sobely',img.height,img.width,cv.CV_16SC1)<EOL>cv.Sobel(gray,sobel,,)<EOL>cv.Sobel(gray,sobely,,)<EOL>cv.Add(sobel,sobely,sobel)<EOL>sobel8=self.Cached('sobel8',sobel.height,sobel.width,cv.CV_8UC1)<EOL>absnorm8(sobel,sobel8)<EOL>cv.Threshold(sobel8,sobel8,,,cv.CV_THRESH_BINARY)<EOL>sobel_integral=self.Cached('sobel_integral',img.height +,img.width +,cv.CV_32SC1)<EOL>cv.Integral(sobel8,sobel_integral)<EOL>d=<EOL>_x1y1=cv.GetSubRect(sobel_integral,(,,sobel_integral.cols -d,sobel_integral.rows -d))<EOL>_x1y2=cv.GetSubRect(sobel_integral,(,d,sobel_integral.cols -d,sobel_integral.rows -d))<EOL>_x2y1=cv.GetSubRect(sobel_integral,(d,,sobel_integral.cols -d,sobel_integral.rows -d))<EOL>_x2y2=cv.GetSubRect(sobel_integral,(d,d,sobel_integral.cols -d,sobel_integral.rows -d))<EOL>summation=cv.CloneMat(_x2y2)<EOL>cv.Sub(summation,_x1y2,summation)<EOL>cv.Sub(summation,_x2y1,summation)<EOL>cv.Add(summation,_x1y1,summation)<EOL>sum8=self.Cached('sum8',summation.height,summation.width,cv.CV_8UC1)<EOL>absnorm8(summation,sum8)<EOL>cv.Threshold(sum8,sum8,,,cv.CV_THRESH_BINARY)<EOL>cv.ShowImage("sum8",sum8)<EOL>seq=cv.FindContours(sum8,cv.CreateMemStorage(),cv.CV_RETR_EXTERNAL)<EOL>subimg=cv.GetSubRect(img,(d /,d /,sum8.cols,sum8.rows))<EOL>t_cull=time.time()-started <EOL>seqs=[]<EOL>while seq :<EOL><INDENT>seqs.append(seq)<EOL>seq=seq.h_next()<EOL><DEDENT>started=time.time()<EOL>found={}<EOL>print 'seqs',len(seqs)<EOL>for seq in seqs :<EOL><INDENT>area=cv.ContourArea(seq)<EOL>if area >:<EOL><INDENT>rect=cv.BoundingRect(seq)<EOL>edge=int((/)*math.sqrt(area)/+)<EOL>candidate=cv.GetSubRect(subimg,rect)<EOL>sym=self.dm.decode(candidate.width,<EOL>candidate.height,<EOL>buffer(candidate.tostring()),<EOL>max_count=,<EOL>)<EOL>if sym :<EOL><INDENT>onscreen=[(d /+rect []+x,d /+rect []+y)for(x,y)in self.dm.stats()[]]<EOL>found [sym ]=onscreen <EOL><DEDENT>else :<EOL><INDENT>print "FAILED"<EOL><DEDENT> <DEDENT> <DEDENT>t_brute=time.time()-started <EOL>print "cull took",t_cull,"brute",t_brute <EOL>return found <EOL><DEDENT> <DEDENT>bg=cv.CreateMat(,,cv.CV_8UC3)<EOL>cv.Set(bg,cv.RGB(,,))<EOL>df=DmtxFinder()<EOL>cv.NamedWindow("camera",)<EOL>def mkdmtx(msg):<EOL><INDENT>dm_write=DataMatrix()<EOL>dm_write.encode(msg)<EOL>pi=dm_write.image <EOL>cv_im=cv.CreateImageHeader(pi.size,cv.IPL_DEPTH_8U,)<EOL>cv.SetData(cv_im,pi.tostring())<EOL>return cv_im <EOL><DEDENT>test=[]<EOL>y=<EOL>for j in range():<EOL><INDENT>r=+j *<EOL>mr=r *math.sqrt()<EOL>y +=mr *<EOL>test +=[(str(deg)+"abcdefgh"[j ],(+deg *,y),math.pi *deg /,r)for deg in range(,,)]<EOL><DEDENT>for(msg,(x,y),angle,r)in test :<EOL><INDENT>map=cv.CreateMat(,,cv.CV_32FC1)<EOL>corners=[(x +r *math.cos(angle +th),y +r *math.sin(angle +th))for th in [,math.pi /,math.pi,*math.pi /]]<EOL>src=mkdmtx(msg)(sx,sy)=cv.GetSize(src)<EOL>cv.GetAffineTransform([(,),(sx,),(sx,sy)],corners [:],map)<EOL>temp=cv.CreateMat(bg.rows,bg.cols,cv.CV_8UC3)<EOL>cv.Set(temp,cv.RGB(,,))<EOL>cv.WarpAffine(src,temp,map)<EOL>cv.Or(temp,bg,bg)<EOL><DEDENT>cv.ShowImage("comp",bg)<EOL>scribble=cv.CloneMat(bg)<EOL>if :<EOL><INDENT>for i in range():<EOL><INDENT>df.find(bg)<EOL><DEDENT> <DEDENT>for(sym,coords)in df.find(bg).items():<EOL><INDENT>print sym <EOL>cv.PolyLine(scribble,[coords ],,cv.CV_RGB(,,),,lineType=cv.CV_AA)<EOL>Xs=[x for(x,y)in coords ]<EOL>Ys=[y for(x,y)in coords ]<EOL>where=((min(Xs)+max(Xs))/,max(Ys)-)<EOL>cv.PutText(scribble,sym,where,font,cv.RGB(,,))<EOL><DEDENT>cv.ShowImage("results",scribble)<EOL>cv.WaitKey()<EOL>cv.DestroyAllWindows()<EOL>sys.exit()<EOL>capture=cv.CaptureFromCAM()<EOL>while True :<EOL><INDENT>img=cv.QueryFrame(capture)<EOL>cv.ShowImage("capture",img)<EOL>print df.find(img)<EOL>cv.WaitKey()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>from.resultbuilder import ExecutionResult <EOF><BOF>import sys <EOL>import random <EOL>from operator import add <EOL>from pyspark import SparkConf,SparkContext <EOL>def estimate(idx):<EOL><INDENT>x=random.random()*-<EOL>y=random.random()*-<EOL>return if(x *x +y *y <)else <EOL><DEDENT>def main(sc,*args):<EOL><INDENT>slices=int(args [])if len(args)>else <EOL>N=*slices <EOL>count=sc.parallelize(xrange(N),slices).map(estimate)<EOL>count=count.reduce(add)<EOL>print '<STR_LIT>'%(*count /N)<EOL>sc.stop()<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>conf=SparkConf().setAppName("Estimate Pi")<EOL>sc=SparkContext(conf=conf)<EOL>main(sc,*sys.argv [:])<EOL><DEDENT><EOF><BOF>import os <EOL>import re <EOL>from copy import copy <EOL>from collections import deque <EOL>from time import time <EOL>import sublime <EOL>from robot.api import TestCaseFile,ResourceFile <EOL>from robot.errors import DataError <EOL>from scanner_cache import ScannerCache <EOL>from string_populator import populate_from_lines <EOL>scanner_cache=ScannerCache()<EOL>SCAN_TIMEOUT=<EOL>detect_robot_regex='<STR_LIT>'<EOL>class WrappedKeyword :<EOL><INDENT>def __init__(self,data_file,keyword,file_path):<EOL><INDENT>self.keyword=keyword <EOL>self.name=data_file.name +'.'+keyword.name <EOL>self.file_path=file_path <EOL>self.description=[]<EOL>args=', '.join(keyword.args.value)<EOL>if args :<EOL><INDENT>self.description.append(args)<EOL><DEDENT>if keyword.doc.value :<EOL><INDENT>self.description.append(keyword.doc.value)<EOL><DEDENT>self.description.append(file_path)<EOL><DEDENT>def show_definition(self,view,views_to_center):<EOL><INDENT>source_path=self.keyword.source <EOL>new_view=view.window().open_file("%s:%d"%(source_path,self.keyword.linenumber),sublime.ENCODED_POSITION)<EOL>new_view.show_at_center(new_view.text_point(self.keyword.linenumber,))<EOL>if new_view.is_loading():<EOL><INDENT>views_to_center [new_view.id()]=self.keyword.linenumber <EOL><DEDENT> <DEDENT>def __eq__(self,other):<EOL><INDENT>return isinstance(other,WrappedKeyword)and self.file_path==other.file_path <EOL><DEDENT>def allow_unprompted_go_to(self):<EOL><INDENT>return True <EOL><DEDENT> <DEDENT>class Scanner(object):<EOL><INDENT>def __init__(self,view):<EOL><INDENT>self.view=view <EOL><DEDENT>def scan_file(self,data_file):<EOL><INDENT>self.start_time=time()<EOL>self.start_path=data_file.directory <EOL>self.scanned_files=set()<EOL>keywords={}<EOL>self.__scan_file(keywords,data_file,deque())<EOL>return keywords <EOL><DEDENT>def __scan_file(self,keywords,data_file,import_history):<EOL><INDENT>if time()-self.start_time >SCAN_TIMEOUT :<EOL><INDENT>sublime.set_timeout(lambda :self.view.set_status('scan_error','<STR_LIT>'),)<EOL>sublime.set_timeout(lambda :self.view.erase_status('scan_error'),)<EOL>return <EOL><DEDENT>self.scanned_files.add(data_file.source)<EOL>if data_file.source in import_history :<EOL><INDENT>return <EOL><DEDENT>import_history=copy(import_history)<EOL>import_history.append(data_file.source)<EOL>for setting in data_file.imports :<EOL><INDENT>if hasattr(setting,'type'):<EOL><INDENT>if setting.type=='Resource':<EOL><INDENT>resource_path=os.path.normpath(os.path.join(setting.directory,setting.name))<EOL>cached,stored_hash=scanner_cache.get_cached_data(resource_path)<EOL>if cached :<EOL><INDENT>self.__scan_file(keywords,cached,import_history)<EOL><DEDENT>else :<EOL><INDENT>try :<EOL><INDENT>resource_data=ResourceFile(source=resource_path).populate()<EOL>scanner_cache.put_data(resource_path,resource_data,stored_hash)<EOL>self.__scan_file(keywords,resource_data,import_history)<EOL><DEDENT>except DataError as de :<EOL><INDENT>print '<STR_LIT>',resource_path <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>self.scan_keywords(data_file,keywords)<EOL><DEDENT>def scan_keywords(self,data_file,keywords):<EOL><INDENT>for keyword in data_file.keyword_table :<EOL><INDENT>lower_name=keyword.name.lower()<EOL>if not keywords.has_key(lower_name):<EOL><INDENT>keywords [lower_name ]=[]<EOL><DEDENT>wrapped=WrappedKeyword(data_file,keyword,os.path.relpath(keyword.source,self.start_path))<EOL>if wrapped in keywords [lower_name ]:<EOL><INDENT>continue <EOL><DEDENT>keywords [lower_name ].append(wrapped)<EOL><DEDENT> <DEDENT>def scan_without_resources(self,file_path,keywords):<EOL><INDENT>if file_path in self.scanned_files :<EOL><INDENT>return <EOL><DEDENT>try :<EOL><INDENT>with open(file_path,'rb')as f :<EOL><INDENT>lines=f.readlines()<EOL><DEDENT> <DEDENT>except IOError as e :<EOL><INDENT>return <EOL><DEDENT>cached,stored_hash=scanner_cache.get_cached_data(file_path,lines)<EOL>if cached :<EOL><INDENT>self.scan_keywords(cached,keywords)<EOL><DEDENT>else :<EOL><INDENT>try :<EOL><INDENT>for line in lines :<EOL><INDENT>if re.search(detect_robot_regex,line,re.IGNORECASE)!=None :<EOL><INDENT>data_file=populate_from_lines(lines,file_path)<EOL>scanner_cache.put_data(file_path,data_file,stored_hash)<EOL>self.scan_keywords(data_file,keywords)<EOL>break <EOL><DEDENT> <DEDENT> <DEDENT>except DataError as de :<EOL><INDENT>pass <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT><EOF><BOF>import sys <EOL>import urllib2 <EOL>import cv2.cv as cv <EOL>src=<EOL>image=<EOL>dest=<EOL>element_shape=cv.CV_SHAPE_RECT <EOL>def Opening(pos):<EOL><INDENT>element=cv.CreateStructuringElementEx(pos *+,pos *+,pos,pos,element_shape)<EOL>cv.Erode(src,image,element,)<EOL>cv.Dilate(image,dest,element,)<EOL>cv.ShowImage('<STR_LIT>',dest)<EOL><DEDENT>def Closing(pos):<EOL><INDENT>element=cv.CreateStructuringElementEx(pos *+,pos *+,pos,pos,element_shape)<EOL>cv.Dilate(src,image,element,)<EOL>cv.Erode(image,dest,element,)<EOL>cv.ShowImage('<STR_LIT>',dest)<EOL><DEDENT>def Erosion(pos):<EOL><INDENT>element=cv.CreateStructuringElementEx(pos *+,pos *+,pos,pos,element_shape)<EOL>cv.Erode(src,dest,element,)<EOL>cv.ShowImage('<STR_LIT>',dest)<EOL><DEDENT>def Dilation(pos):<EOL><INDENT>element=cv.CreateStructuringElementEx(pos *+,pos *+,pos,pos,element_shape)<EOL>cv.Dilate(src,dest,element,)<EOL>cv.ShowImage('<STR_LIT>',dest)<EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>if len(sys.argv)>:<EOL><INDENT>src=cv.LoadImage(sys.argv [],cv.CV_LOAD_IMAGE_COLOR)<EOL><DEDENT>else :<EOL><INDENT>url='<STR_LIT>'<EOL>filedata=urllib2.urlopen(url).read()<EOL>imagefiledata=cv.CreateMatHeader(,len(filedata),cv.CV_8UC1)<EOL>cv.SetData(imagefiledata,filedata,len(filedata))<EOL>src=cv.DecodeImage(imagefiledata,cv.CV_LOAD_IMAGE_COLOR)<EOL><DEDENT>image=cv.CloneImage(src)<EOL>dest=cv.CloneImage(src)<EOL>cv.NamedWindow('<STR_LIT>',)<EOL>cv.NamedWindow('<STR_LIT>',)<EOL>cv.ShowImage('<STR_LIT>',src)<EOL>cv.ShowImage('<STR_LIT>',src)<EOL>cv.CreateTrackbar("Open",'<STR_LIT>',,,Opening)<EOL>cv.CreateTrackbar("Close",'<STR_LIT>',,,Closing)<EOL>cv.CreateTrackbar("Dilate",'<STR_LIT>',,,Dilation)<EOL>cv.CreateTrackbar("Erode",'<STR_LIT>',,,Erosion)<EOL>cv.WaitKey()<EOL>cv.DestroyWindow('<STR_LIT>')<EOL>cv.DestroyWindow('<STR_LIT>')<EOL><DEDENT><EOF><BOF>__version__='0.2.0'<EOF><BOF>import cv2 <EOL>def webcam_gui(filter_func,video_src=):<EOL><INDENT>cap=cv2.VideoCapture(video_src)<EOL>key_code=-<EOL>while(key_code==-):<EOL><INDENT>ret,frame=cap.read()<EOL>frame_out=filter_func(frame)<EOL>cv2.imshow('<STR_LIT>',frame_out)<EOL>key_code=cv2.waitKey()<EOL><DEDENT>cap.release()<EOL>cv2.destroyAllWindows()<EOL><DEDENT>def edge_filter(frame_in):<EOL><INDENT>frame_gray=cv2.cvtColor(frame_in,cv2.COLOR_BGR2GRAY)<EOL>frame_blur=cv2.blur(frame_gray,(,))<EOL>frame_out=cv2.Canny(frame_blur,,)<EOL>return frame_out <EOL><DEDENT>def threshold(frame_in):<EOL><INDENT>frame_gray=cv2.cvtColor(frame_in,cv2.COLOR_BGR2GRAY)<EOL>frame_blur=cv2.blur(frame_gray,(,))<EOL>thresh1,thresh=cv2.threshold(frame_blur,,,cv2.THRESH_BINARY)<EOL>frame_out=thresh <EOL>return frame_out <EOL><DEDENT>def adap_threshold(frame_in):<EOL><INDENT>frame_gray=cv2.cvtColor(frame_in,cv2.COLOR_BGR2GRAY)<EOL>frame_blur=cv2.blur(frame_gray,(,))<EOL>thresh=cv2.adaptiveThreshold(frame_blur,,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,,)<EOL>frame_out=thresh <EOL>return frame_out <EOL><DEDENT>def gray_filter(frame_in):<EOL><INDENT>frame_out=cv2.cvtColor(frame_in,cv2.COLOR_BGR2GRAY)<EOL>return frame_out <EOL><DEDENT>if __name__=="__main__":<EOL><INDENT>webcam_gui(adap_threshold)<EOL><DEDENT><EOF><BOF>import pygame <EOL>from pygame.locals import *<EOL>from py2d.Bezier import *<EOL>from py2d.Math import *<EOL>SELECTION_DISTANCE=<EOL>from examples import Example <EOL>class Cubic(Example):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,runner):<EOL><INDENT>self.runner=runner <EOL>self.title="Cubic Beziers"<EOL>self.p1=Vector(,)<EOL>self.p2=Vector(,)<EOL>self.c1=Vector(,)<EOL>self.c2=Vector(,)<EOL>self.points=(('P1',(,,),self.p1),('P2',(,,),self.p2),('C1',(,,),self.c1),('C2',(,,),self.c2))<EOL>self.sel_point=None <EOL><DEDENT>def update(self,time_elapsed):<EOL><INDENT>pass <EOL><DEDENT>def render(self):<EOL><INDENT>pygame.draw.line(self.runner.screen,,self.p1.as_tuple(),self.c1.as_tuple())<EOL>pygame.draw.line(self.runner.screen,,self.p2.as_tuple(),self.c2.as_tuple())<EOL>for label,color,pos in self.points :<EOL><INDENT>self.draw_point(pos,color,label)<EOL><DEDENT>bezier=[self.p1 ]+flatten_cubic_bezier(self.p1,self.p2,self.c1,self.c2)+[self.p2 ]<EOL>pygame.draw.lines(self.runner.screen,,False,[p.as_tuple()for p in bezier ],)<EOL>if self.sel_point :<EOL><INDENT>pygame.draw.ellipse(self.runner.screen,,pygame.Rect((self.sel_point.x -,self.sel_point.y -),(,)),)<EOL><DEDENT> <DEDENT>def draw_point(self,p,color,label=None):<EOL><INDENT>pygame.draw.ellipse(self.runner.screen,color,pygame.Rect(p.as_tuple(),(,)))<EOL>if label :<EOL><INDENT>self.runner.screen.blit(self.runner.font.render(label,False,color),p.as_tuple())<EOL><DEDENT> <DEDENT>def mouse_down(self,pos,button):<EOL><INDENT>if button==:<EOL><INDENT>mouse=Vector(*pos)<EOL>nearest=min(self.points,key=lambda p :(p []-mouse).length)<EOL>if(nearest []-mouse).length_squared <=SELECTION_DISTANCE :<EOL><INDENT>self.sel_point=nearest []<EOL><DEDENT>else :<EOL><INDENT>self.sel_point=None <EOL><DEDENT> <DEDENT> <DEDENT>def mouse_move(self,pos,rel,buttons):<EOL><INDENT>if buttons []and self.sel_point :<EOL><INDENT>self.sel_point.x,self.sel_point.y=pos <EOL><DEDENT> <DEDENT> <DEDENT>class Quadratic(Example):<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,runner):<EOL><INDENT>self.runner=runner <EOL>self.title='<STR_LIT>'<EOL>self.p1=Vector(,)<EOL>self.p2=Vector(,)<EOL>self.c=Vector(,)<EOL>self.points=(('P1',(,,),self.p1),('P2',(,,),self.p2),('C',(,,),self.c))<EOL>self.sel_point=None <EOL><DEDENT>def update(self,time_elapsed):<EOL><INDENT>pass <EOL><DEDENT>def render(self):<EOL><INDENT>pygame.draw.line(self.runner.screen,,self.p1.as_tuple(),self.c.as_tuple())<EOL>pygame.draw.line(self.runner.screen,,self.p2.as_tuple(),self.c.as_tuple())<EOL>for label,color,pos in self.points :<EOL><INDENT>self.draw_point(pos,color,label)<EOL><DEDENT>bezier=[self.p1 ]+flatten_quadratic_bezier(self.p1,self.p2,self.c)+[self.p2 ]<EOL>pygame.draw.lines(self.runner.screen,,False,[p.as_tuple()for p in bezier ],)<EOL>if self.sel_point :<EOL><INDENT>pygame.draw.ellipse(self.runner.screen,,pygame.Rect((self.sel_point.x -,self.sel_point.y -),(,)),)<EOL><DEDENT> <DEDENT>def draw_point(self,p,color,label=None):<EOL><INDENT>pygame.draw.ellipse(self.runner.screen,color,pygame.Rect(p.as_tuple(),(,)))<EOL>if label :<EOL><INDENT>self.runner.screen.blit(self.runner.font.render(label,False,color),p.as_tuple())<EOL><DEDENT> <DEDENT>def mouse_down(self,pos,button):<EOL><INDENT>if button==:<EOL><INDENT>mouse=Vector(*pos)<EOL>nearest=min(self.points,key=lambda p :(p []-mouse).length)<EOL>if(nearest []-mouse).length_squared <=SELECTION_DISTANCE :<EOL><INDENT>self.sel_point=nearest []<EOL><DEDENT>else :<EOL><INDENT>self.sel_point=None <EOL><DEDENT> <DEDENT> <DEDENT>def mouse_move(self,pos,rel,buttons):<EOL><INDENT>if buttons []and self.sel_point :<EOL><INDENT>self.sel_point.x,self.sel_point.y=pos <EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>from zerotest.request import Request <EOL>req=Request(scheme="http",method="GET",params={"hello":"test"},host="example.com",path="/test",<EOL>headers={"Auth":"FOR_TEST"},data="ok")<EOL>def test_url():<EOL><INDENT>assert req.url=='<STR_LIT>'<EOL><DEDENT>def test_endpoint():<EOL><INDENT>assert req.endpoint=='<STR_LIT>'<EOL><DEDENT>def test_endpoint_setter():<EOL><INDENT>endpoint=req.endpoint <EOL>req.endpoint='<STR_LIT>'<EOL>assert req.endpoint=='<STR_LIT>'<EOL>assert req.host=='<STR_LIT>'<EOL>assert req.scheme=="https"<EOL>req.endpoint=endpoint <EOL><DEDENT>def test__str__():<EOL><INDENT>assert str(req)=='<STR_LIT>'<EOL><DEDENT><EOF><BOF>import re <EOL>from functools import partial <EOL>from.normalizing import normalize <EOL>def eq(str1,str2,ignore=(),caseless=True,spaceless=True):<EOL><INDENT>str1=normalize(str1,ignore,caseless,spaceless)<EOL>str2=normalize(str2,ignore,caseless,spaceless)<EOL>return str1==str2 <EOL><DEDENT>def matches(string,pattern,ignore=(),caseless=True,spaceless=True):<EOL><INDENT> '<STR_LIT>'<EOL>return Matcher(pattern,ignore,caseless,spaceless).match(string)<EOL><DEDENT>def matches_any(string,patterns,ignore=(),caseless=True,spaceless=True):<EOL><INDENT> '<STR_LIT>'<EOL>matcher=MultiMatcher(patterns,ignore,caseless,spaceless)<EOL>return matcher.match(string)<EOL><DEDENT>class Matcher(object):<EOL><INDENT>_pattern_tokenizer=re.compile('(\*|\?)')<EOL>_wildcards={'*':'.*','?':'.'}<EOL>def __init__(self,pattern,ignore=(),caseless=True,spaceless=True):<EOL><INDENT>self.pattern=pattern <EOL>self._normalize=partial(normalize,ignore=ignore,caseless=caseless,<EOL>spaceless=spaceless)<EOL>self._regexp=self._get_and_compile_regexp(self._normalize(pattern))<EOL><DEDENT>def _get_and_compile_regexp(self,pattern):<EOL><INDENT>pattern='^%s$'%''.join(self._yield_regexp(pattern))<EOL>return re.compile(pattern,re.DOTALL)<EOL><DEDENT>def _yield_regexp(self,pattern):<EOL><INDENT>for token in self._pattern_tokenizer.split(pattern):<EOL><INDENT>if token in self._wildcards :<EOL><INDENT>yield self._wildcards [token ]<EOL><DEDENT>else :<EOL><INDENT>yield re.escape(token)<EOL><DEDENT> <DEDENT> <DEDENT>def match(self,string):<EOL><INDENT>return self._regexp.match(self._normalize(string))is not None <EOL><DEDENT> <DEDENT>class MultiMatcher(object):<EOL><INDENT>def __init__(self,patterns=None,ignore=(),caseless=True,spaceless=True,<EOL>match_if_no_patterns=False):<EOL><INDENT>self._matchers=[Matcher(pattern,ignore,caseless,spaceless)<EOL>for pattern in self._ensure_list(patterns)]<EOL>self._match_if_no_patterns=match_if_no_patterns <EOL><DEDENT>def _ensure_list(self,patterns):<EOL><INDENT>if patterns is None :<EOL><INDENT>return []<EOL><DEDENT>if isinstance(patterns,basestring):<EOL><INDENT>return [patterns ]<EOL><DEDENT>return patterns <EOL><DEDENT>def match(self,string):<EOL><INDENT>if self._matchers :<EOL><INDENT>return any(m.match(string)for m in self._matchers)<EOL><DEDENT>return self._match_if_no_patterns <EOL><DEDENT>def __len__(self):<EOL><INDENT>return len(self._matchers)<EOL><DEDENT>def __iter__(self):<EOL><INDENT>for matcher in self._matchers :<EOL><INDENT>yield matcher.pattern <EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import pygit2 <EOL>import shutil <EOL>import itertools <EOL>from.exceptions import(<EOL>NotJsonError,InvalidKeyError,DifferentRepoError,StagedDataError)<EOL>from.wrappers import Commit,Diff,Conflict,Merge <EOL>import constants <EOL>import utils <EOL>class Repository(object):<EOL><INDENT>def __init__(self,repo,dumps,loads):<EOL><INDENT>self._repo=repo <EOL>self._global_name=utils.global_config('user.name')<EOL>self._global_email=utils.global_config('user.email')<EOL>self._dumps=dumps <EOL>self._loads=loads <EOL><DEDENT>def __eq__(self,other):<EOL><INDENT>return self._repo.path==other._repo.path <EOL><DEDENT>def _key2ref(self,key):<EOL><INDENT> '<STR_LIT>'<EOL>if not isinstance(key,basestring):<EOL><INDENT>raise InvalidKeyError('<STR_LIT>'%key)<EOL><DEDENT>elif key [-]=='.'or key [-]=='/'or key []=='/'or key []=='.':<EOL><INDENT>raise InvalidKeyError('<STR_LIT>'%key)<EOL><DEDENT>else :<EOL><INDENT>return '<STR_LIT>'%key <EOL><DEDENT> <DEDENT>def _navigate_tree(self,oid,path):<EOL><INDENT> '<STR_LIT>'<EOL>steps=path.split('/')<EOL>for step in steps :<EOL><INDENT>oid=self._repo [oid ][step ].oid <EOL><DEDENT>return oid <EOL><DEDENT>def _build_commit(self,pygit2_commit):<EOL><INDENT>key=pygit2_commit.tree [].name <EOL>raw=self._repo [pygit2_commit.tree [].oid ].data <EOL>value=self._loads(raw)<EOL>return Commit(self,key,value,pygit2_commit)<EOL><DEDENT>def _head_target(self):<EOL><INDENT>return self._repo.lookup_reference('HEAD').target <EOL><DEDENT>def _repo_head(self):<EOL><INDENT>try :<EOL><INDENT>return self._repo [self._repo.lookup_reference(self._head_target()).oid ]<EOL><DEDENT>except KeyError :<EOL><INDENT>return None <EOL><DEDENT> <DEDENT>def add(self,key,value):<EOL><INDENT> '<STR_LIT>'<EOL>self._key2ref(key)<EOL>try :<EOL><INDENT>blob_id=self._repo.write(pygit2.GIT_OBJ_BLOB,self._dumps(value))<EOL><DEDENT>except ValueError as e :<EOL><INDENT>raise NotJsonError(e)<EOL><DEDENT>except TypeError as e :<EOL><INDENT>raise NotJsonError(e)<EOL><DEDENT>if key in self._repo.index :<EOL><INDENT>del self._repo.index [key ]<EOL><DEDENT>working_tree_id=self._repo.index.write_tree()<EOL>working_tree=self._repo [working_tree_id ]<EOL>new_entry='<STR_LIT>'%(key,blob_id)<EOL>tree_data=working_tree.read_raw()+new_entry <EOL>working_tree_id=self._repo.write(pygit2.GIT_OBJ_TREE,tree_data)<EOL>self._repo.index.read_tree(working_tree_id)<EOL>self._repo.index.write()<EOL><DEDENT>def checkout(self,source,dest,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>message='<STR_LIT>'%(dest,source)<EOL>commit=self.head(source)<EOL>self.commit(dest,commit.data,message=message,parents=[commit ])<EOL><DEDENT>def commit(self,key=None,value=None,add=True,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>keys=[key ]if key is not None else [e.path for e in self._repo.index ]<EOL>message=kwargs.pop('message','')<EOL>parents=kwargs.pop('parents',None)<EOL>author=kwargs.pop('author',utils.signature(self._global_name,<EOL>self._global_email))<EOL>committer=kwargs.pop('committer',author)<EOL>if kwargs :<EOL><INDENT>raise TypeError('<STR_LIT>'%kwargs)<EOL><DEDENT>if key is None and value is not None :<EOL><INDENT>raise InvalidKeyError()<EOL><DEDENT>if parents is not None :<EOL><INDENT>for parent in parents :<EOL><INDENT>if parent.repo !=self :<EOL><INDENT>raise DifferentRepoError()<EOL><DEDENT> <DEDENT> <DEDENT>if add is True and key is not None and value is not None :<EOL><INDENT>self.add(key,value)<EOL><DEDENT>repo_head=self._repo_head()<EOL>tree_id=self._repo.index.write_tree()<EOL>self._repo.create_commit(self._head_target(),author,committer,<EOL>message,tree_id,<EOL>[repo_head.oid ]if repo_head else [])<EOL>for key in keys :<EOL><INDENT>if parents is None :<EOL><INDENT>parents=[self.head(key)]if self.committed(key)else []<EOL><DEDENT>try :<EOL><INDENT>blob_id=self._navigate_tree(tree_id,key)<EOL>key_tree_data='<STR_LIT>'%(key,blob_id)<EOL>key_tree_id=self._repo.write(pygit2.GIT_OBJ_TREE,key_tree_data)<EOL>self._repo.create_commit(self._key2ref(key),author,<EOL>committer,message,key_tree_id,<EOL>[parent.oid for parent in parents ])<EOL><DEDENT>except pygit2.GitError as e :<EOL><INDENT>if str(e).startswith('<STR_LIT>'):<EOL><INDENT>raise InvalidKeyError(e)<EOL><DEDENT>else :<EOL><INDENT>raise e <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>def committed(self,key):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>self._repo.lookup_reference(self._key2ref(key))<EOL>return True <EOL><DEDENT>except KeyError :<EOL><INDENT>return False <EOL><DEDENT> <DEDENT>def destroy(self):<EOL><INDENT> '<STR_LIT>'<EOL>shutil.rmtree(self._repo.path)<EOL>self._repo=None <EOL><DEDENT>def head(self,key,back=):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>return itertools.islice(self.log(key),back,back +).next()<EOL><DEDENT>except KeyError :<EOL><INDENT>raise KeyError('<STR_LIT>'%key)<EOL><DEDENT>except StopIteration :<EOL><INDENT>raise IndexError('<STR_LIT>'%(key,back))<EOL><DEDENT> <DEDENT>def index(self,key):<EOL><INDENT> '<STR_LIT>'<EOL>self._repo.index.read()<EOL>raw=self._repo [self._repo.index [key ].oid ].data <EOL>return self._loads(raw)<EOL><DEDENT>def merge(self,dest,key=None,commit=None,**kwargs):<EOL><INDENT> '<STR_LIT>'<EOL>if commit is None :<EOL><INDENT>commit=self.head(key)<EOL><DEDENT>if commit.key==dest :<EOL><INDENT>raise ValueError('<STR_LIT>')<EOL><DEDENT>dest_head=self.head(dest)<EOL>if commit.oid==dest_head.oid :<EOL><INDENT>return Merge(True,commit,dest_head,"Same commit",result=commit)<EOL><DEDENT>try :<EOL><INDENT>shared_commit=(dc for dc in self.log(commit=dest_head)<EOL>if dc.oid in(sc.oid for sc in self.log(commit=commit))).next()<EOL><DEDENT>except StopIteration :<EOL><INDENT>return Merge(False,commit,dest_head,'<STR_LIT>')<EOL><DEDENT>source_diff=Diff(shared_commit.data,commit.data)<EOL>dest_diff=Diff(shared_commit.data,dest_head.data)<EOL>conflict=Conflict(source_diff,dest_diff)<EOL>if conflict :<EOL><INDENT>return Merge(False,commit,dest_head,"Merge conflict",<EOL>conflict=conflict)<EOL><DEDENT>else :<EOL><INDENT>merged_data=dest_diff.apply(source_diff.apply(shared_commit.data))<EOL>message='<STR_LIT>'%(<EOL>commit.hex [:],dest_head.hex [:],shared_commit.hex [:])<EOL>parents=[dest_head,commit ]<EOL>result=self.commit(dest,merged_data,message=message,parents=parents,**kwargs)<EOL>return Merge(True,commit,dest_head,message,result=result)<EOL><DEDENT> <DEDENT>def log(self,key=None,commit=None,order=constants.GIT_SORT_TOPOLOGICAL):<EOL><INDENT> '<STR_LIT>'<EOL>if key is None and commit is None :<EOL><INDENT>raise TypeError()<EOL><DEDENT>elif commit is None :<EOL><INDENT>c=self._repo [self._repo.lookup_reference(self._key2ref(key)).oid ]<EOL>commit=self._build_commit(c)<EOL><DEDENT>return(self._build_commit(c)for c in self._repo.walk(commit.oid,order))<EOL><DEDENT>def remove(self,key,force=False):<EOL><INDENT> '<STR_LIT>'<EOL>if force is True or self.staged(key)is False :<EOL><INDENT>del self._repo.index [key ]<EOL><DEDENT>elif force is False and self.staged(key):<EOL><INDENT>raise StagedDataError('<STR_LIT>'%key)<EOL><DEDENT>self._repo.lookup_reference(self._key2ref(key)).delete()<EOL><DEDENT>def reset(self,key):<EOL><INDENT> '<STR_LIT>'<EOL>self.add(key,self.head(key).data)<EOL><DEDENT>def show(self,key,back=):<EOL><INDENT> '<STR_LIT>'<EOL>return self.head(key,back=back).data <EOL><DEDENT>def staged(self,key):<EOL><INDENT> '<STR_LIT>'<EOL>if key in self._repo.index :<EOL><INDENT>if self.committed(key):<EOL><INDENT>return self.index(key)!=self.show(key)<EOL><DEDENT>else :<EOL><INDENT>return True <EOL><DEDENT> <DEDENT>else :<EOL><INDENT>return False <EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import functools <EOL>import py2d.Math <EOL>class Vision :<EOL><INDENT> '<STR_LIT>'<EOL>def __init__(self,obstructors,debug=False):<EOL><INDENT> '<STR_LIT>'<EOL>self.set_obstructors(obstructors)<EOL>self.debug=debug <EOL>self.debug_points=[]<EOL>self.debug_linesegs=[]<EOL><DEDENT>def set_obstructors(self,obstructors):<EOL><INDENT> '<STR_LIT>'<EOL>def flatten_list(l):<EOL><INDENT>return functools.reduce(lambda x,y :x +y,l)<EOL><DEDENT>self.obs_points=flatten_list(obstructors)<EOL>self.obs_segs=flatten_list([list(zip(strip,strip [:]))for strip in obstructors ])<EOL>self.cached_vision=None <EOL>self.cached_position=None <EOL>self.cached_radius=None <EOL><DEDENT>def get_vision(self,eye,radius,boundary):<EOL><INDENT> '<STR_LIT>'<EOL>if self.cached_vision==None or(self.cached_position -eye).get_length_squared()>:<EOL><INDENT>self.calculate(eye,radius,boundary)<EOL><DEDENT>return self.cached_vision <EOL><DEDENT>def calculate(self,eye,radius,boundary):<EOL><INDENT> '<STR_LIT>'<EOL>self.cached_radius=radius <EOL>self.cached_position=eye <EOL>self.debug_points=[]<EOL>self.debug_linesegs=[]<EOL>radius_squared=radius *radius <EOL>closest_points=lambda points,reference :sorted(points,key=lambda p :(p -reference).get_length_squared())<EOL>def sub_segment(small,big):<EOL><INDENT>return py2d.Math.distance_point_lineseg_squared(small [],big [],big [])<and py2d.Math.distance_point_lineseg_squared(small [],big [],big [])<<EOL><DEDENT>def segment_in_obs(seg):<EOL><INDENT>for line_segment in self.obs_segs :<EOL><INDENT>if sub_segment(seg,line_segment):<EOL><INDENT>return True <EOL><DEDENT> <DEDENT>return False <EOL><DEDENT>def check_visibility(p):<EOL><INDENT>bpoints=set(boundary.points)<EOL>if p not in bpoints :<EOL><INDENT>if(eye -p).get_length_squared()>radius_squared :return False <EOL>if not boundary.contains_point(p):return False <EOL><DEDENT>for line_segment in obs_segs :<EOL><INDENT>if py2d.Math.check_intersect_lineseg_lineseg(eye,p,line_segment [],line_segment []):<EOL><INDENT>if line_segment []!=p and line_segment []!=p :<EOL><INDENT>return False <EOL><DEDENT> <DEDENT> <DEDENT>return True <EOL><DEDENT>def lineseg_in_radius(seg):<EOL><INDENT>return py2d.Math.distance_point_lineseg_squared(eye,seg [],seg [])<=radius_squared <EOL><DEDENT>obs_segs=filter(lineseg_in_radius,self.obs_segs)<EOL>visible_points=list(filter(check_visibility,set(self.obs_points +boundary.points)))<EOL>boundary_intersection_points=py2d.Math.intersect_linesegs_linesegs(obs_segs,list(zip(boundary.points,boundary.points [:]))+[(boundary.points [-],boundary.points [])])<EOL>if self.debug :self.debug_points.extend([(p,)for p in visible_points ])<EOL>if self.debug :self.debug_points.extend([(p,)for p in boundary_intersection_points ])<EOL>for line_segment in obs_segs :<EOL><INDENT>i=<EOL>while i <len(boundary_intersection_points):<EOL><INDENT>p=boundary_intersection_points [i ]<EOL>if py2d.Math.distance_point_lineseg_squared(p,line_segment [],line_segment [])>and py2d.Math.check_intersect_lineseg_lineseg(eye,p,line_segment [],line_segment []):<EOL><INDENT>boundary_intersection_points.remove(p)<EOL><DEDENT>else :<EOL><INDENT>i +=<EOL><DEDENT> <DEDENT> <DEDENT>visible_points +=boundary_intersection_points <EOL>poly=py2d.Math.Polygon()<EOL>poly.add_points(visible_points)<EOL>poly.sort_around(eye)<EOL>i=<EOL>while i <len(poly.points):<EOL><INDENT>p=poly.points [i -]<EOL>c=poly.points [i ]<EOL>n=poly.points [(i +)%len(poly.points)]<EOL>intersections=set(py2d.Math.intersect_linesegs_ray(obs_segs,eye,c)+py2d.Math.intersect_poly_ray(boundary.points,eye,c))<EOL>intersections=[ip for ip in intersections if ip !=c and boundary.contains_point(ip)]<EOL>if self.debug :self.debug_points.extend([(pt,)for pt in intersections ])<EOL>if intersections :<EOL><INDENT>intersection=min(intersections,key=lambda p :(p -eye).length_squared)<EOL>sio_pc=segment_in_obs((p,c))<EOL>sio_cn=segment_in_obs((c,n))<EOL>if not sio_pc :<EOL><INDENT>poly.points.insert(i,intersection)<EOL>i +=<EOL>if segment_in_obs((poly.points [i -],poly.points [i -])):<EOL><INDENT>poly.points.remove(poly.points [i -])<EOL>i -=<EOL><DEDENT> <DEDENT>elif sio_pc and not sio_cn :<EOL><INDENT>poly.points.insert(i +,intersection)<EOL>i +=<EOL><DEDENT> <DEDENT>i +=<EOL><DEDENT>if segment_in_obs((poly.points [-],poly.points [])):<EOL><INDENT>poly.points [],poly.points []=poly.points [],poly.points []<EOL><DEDENT>self.cached_vision=poly <EOL>return poly <EOL><DEDENT> <DEDENT><EOF><BOF>import os <EOL>import json <EOL>import webbrowser <EOL>import urllib <EOL>keywords={}<EOL>class WebKeyword :<EOL><INDENT>def __init__(self,name,url,library_name,args,doc):<EOL><INDENT>self.name=library_name +'.'+name <EOL>self.url=url <EOL>self.description=[args,doc,url ]<EOL><DEDENT>def show_definition(self,view,views_to_center):<EOL><INDENT>webbrowser.open(self.url)<EOL><DEDENT>def allow_unprompted_go_to(self):<EOL><INDENT>return False <EOL><DEDENT> <DEDENT>def load(plugin_dir):<EOL><INDENT>keywords.clear()<EOL>scan_dir=os.path.join(plugin_dir,'stdlib_keywords')<EOL>for root,dirs,files in os.walk(scan_dir):<EOL><INDENT>for file_path in filter(lambda f :f.endswith('.json'),files):<EOL><INDENT>library_name=file_path [:-]<EOL>file_path=os.path.join(root,file_path)<EOL>with open(file_path,'rb')as f :<EOL><INDENT>json_dict=json.load(f)<EOL>url=json_dict ['url']<EOL>for keyword in json_dict ['keywords']:<EOL><INDENT>name=keyword ['name']<EOL>args=keyword ['args']<EOL>doc=keyword ['shortdoc']<EOL>lower_name=name.lower()<EOL>web_keyword=WebKeyword(name,url +'#'+urllib.quote(name),library_name,args,doc)<EOL>if not keywords.has_key(lower_name):<EOL><INDENT>keywords [lower_name ]=[]<EOL><DEDENT>keywords [lower_name ].append(web_keyword)<EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>def search_keywords(name):<EOL><INDENT>lower_name=name.lower()<EOL>if not keywords.has_key(lower_name):<EOL><INDENT>return []<EOL><DEDENT>return keywords [lower_name ]<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>from collections import namedtuple <EOL>import video <EOL>import common <EOL>FLANN_INDEX_KDTREE=<EOL>FLANN_INDEX_LSH=<EOL>flann_params=dict(algorithm=FLANN_INDEX_LSH,<EOL>table_number=,<EOL>key_size=,<EOL>multi_probe_level=)<EOL>MIN_MATCH_COUNT=<EOL>'<STR_LIT>'<EOL>PlanarTarget=namedtuple('PlaneTarget','<STR_LIT>')<EOL>'<STR_LIT>'<EOL>TrackedTarget=namedtuple('TrackedTarget','<STR_LIT>')<EOL>class PlaneTracker :<EOL><INDENT>def __init__(self):<EOL><INDENT>self.detector=cv2.ORB(nfeatures=)<EOL>self.matcher=cv2.FlannBasedMatcher(flann_params,{})<EOL>self.targets=[]<EOL><DEDENT>def add_target(self,image,rect,data=None):<EOL><INDENT> '<STR_LIT>'<EOL>x0,y0,x1,y1=rect <EOL>raw_points,raw_descrs=self.detect_features(image)<EOL>points,descs=[],[]<EOL>for kp,desc in zip(raw_points,raw_descrs):<EOL><INDENT>x,y=kp.pt <EOL>if x0 <=x <=x1 and y0 <=y <=y1 :<EOL><INDENT>points.append(kp)<EOL>descs.append(desc)<EOL><DEDENT> <DEDENT>descs=np.uint8(descs)<EOL>self.matcher.add([descs ])<EOL>target=PlanarTarget(image=image,rect=rect,keypoints=points,descrs=descs,data=None)<EOL>self.targets.append(target)<EOL><DEDENT>def clear(self):<EOL><INDENT> '<STR_LIT>'<EOL>self.targets=[]<EOL>self.matcher.clear()<EOL><DEDENT>def track(self,frame):<EOL><INDENT> '<STR_LIT>'<EOL>self.frame_points,self.frame_descrs=self.detect_features(frame)<EOL>if len(self.frame_points)<MIN_MATCH_COUNT :<EOL><INDENT>return []<EOL><DEDENT>matches=self.matcher.knnMatch(self.frame_descrs,k=)<EOL>matches=[m []for m in matches if len(m)==and m [].distance <m [].distance *]<EOL>if len(matches)<MIN_MATCH_COUNT :<EOL><INDENT>return []<EOL><DEDENT>matches_by_id=[[]for _ in xrange(len(self.targets))]<EOL>for m in matches :<EOL><INDENT>matches_by_id [m.imgIdx ].append(m)<EOL><DEDENT>tracked=[]<EOL>for imgIdx,matches in enumerate(matches_by_id):<EOL><INDENT>if len(matches)<MIN_MATCH_COUNT :<EOL><INDENT>continue <EOL><DEDENT>target=self.targets [imgIdx ]<EOL>p0=[target.keypoints [m.trainIdx ].pt for m in matches ]<EOL>p1=[self.frame_points [m.queryIdx ].pt for m in matches ]<EOL>p0,p1=np.float32((p0,p1))<EOL>H,status=cv2.findHomography(p0,p1,cv2.RANSAC,)<EOL>status=status.ravel()!=<EOL>if status.sum()<MIN_MATCH_COUNT :<EOL><INDENT>continue <EOL><DEDENT>p0,p1=p0 [status ],p1 [status ]<EOL>x0,y0,x1,y1=target.rect <EOL>quad=np.float32([[x0,y0 ],[x1,y0 ],[x1,y1 ],[x0,y1 ]])<EOL>quad=cv2.perspectiveTransform(quad.reshape(,-,),H).reshape(-,)<EOL>track=TrackedTarget(target=target,p0=p0,p1=p1,H=H,quad=quad)<EOL>tracked.append(track)<EOL><DEDENT>tracked.sort(key=lambda t :len(t.p0),reverse=True)<EOL>return tracked <EOL><DEDENT>def detect_features(self,frame):<EOL><INDENT> '<STR_LIT>'<EOL>keypoints,descrs=self.detector.detectAndCompute(frame,None)<EOL>if descrs is None :<EOL><INDENT>descrs=[]<EOL><DEDENT>return keypoints,descrs <EOL><DEDENT> <DEDENT>class App :<EOL><INDENT>def __init__(self,src):<EOL><INDENT>self.cap=video.create_capture(src)<EOL>self.frame=None <EOL>self.paused=False <EOL>self.tracker=PlaneTracker()<EOL>cv2.namedWindow('plane')<EOL>self.rect_sel=common.RectSelector('plane',self.on_rect)<EOL><DEDENT>def on_rect(self,rect):<EOL><INDENT>self.tracker.add_target(self.frame,rect)<EOL><DEDENT>def run(self):<EOL><INDENT>while True :<EOL><INDENT>playing=not self.paused and not self.rect_sel.dragging <EOL>if playing or self.frame is None :<EOL><INDENT>ret,frame=self.cap.read()<EOL>if not ret :<EOL><INDENT>break <EOL><DEDENT>self.frame=frame.copy()<EOL><DEDENT>vis=self.frame.copy()<EOL>if playing :<EOL><INDENT>tracked=self.tracker.track(self.frame)<EOL>for tr in tracked :<EOL><INDENT>cv2.polylines(vis,[np.int32(tr.quad)],True,(,,),)<EOL>for(x,y)in np.int32(tr.p1):<EOL><INDENT>cv2.circle(vis,(x,y),,(,,))<EOL><DEDENT> <DEDENT> <DEDENT>self.rect_sel.draw(vis)<EOL>cv2.imshow('plane',vis)<EOL>ch=cv2.waitKey()<EOL>if ch==ord(' '):<EOL><INDENT>self.paused=not self.paused <EOL><DEDENT>if ch==ord('c'):<EOL><INDENT>self.tracker.clear()<EOL><DEDENT>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>import sys <EOL>try :<EOL><INDENT>video_src=sys.argv []<EOL><DEDENT>except :<EOL><INDENT>video_src=<EOL><DEDENT>App(video_src).run()<EOL><DEDENT><EOF><BOF>from robot import utils <EOL>from.logger import LOGGER <EOL>from.loggerhelper import IsLogged <EOL>def DebugFile(path):<EOL><INDENT>if path=='NONE':<EOL><INDENT>LOGGER.info('No debug file')<EOL>return None <EOL><DEDENT>try :<EOL><INDENT>outfile=open(path,'w')<EOL><DEDENT>except EnvironmentError,err :<EOL><INDENT>LOGGER.error('<STR_LIT>'%(path,err.strerror))<EOL>return None <EOL><DEDENT>else :<EOL><INDENT>LOGGER.info('Debug file: %s'%path)<EOL>return _DebugFileWriter(outfile)<EOL><DEDENT> <DEDENT>class _DebugFileWriter :<EOL><INDENT>_separators={'SUITE':'=','TEST':'-','KW':'~'}<EOL>_setup_or_teardown=('setup','teardown')<EOL>def __init__(self,outfile):<EOL><INDENT>self._indent=<EOL>self._kw_level=<EOL>self._separator_written_last=False <EOL>self._outfile=outfile <EOL>self._is_logged=IsLogged('DEBUG')<EOL><DEDENT>def start_suite(self,suite):<EOL><INDENT>self._separator('SUITE')<EOL>self._start('SUITE',suite.longname)<EOL>self._separator('SUITE')<EOL><DEDENT>def end_suite(self,suite):<EOL><INDENT>self._separator('SUITE')<EOL>self._end('SUITE',suite.longname,suite.elapsedtime)<EOL>self._separator('SUITE')<EOL>if self._indent==:<EOL><INDENT>LOGGER.output_file('Debug',self._outfile.name)<EOL>self.close()<EOL><DEDENT> <DEDENT>def start_test(self,test):<EOL><INDENT>self._separator('TEST')<EOL>self._start('TEST',test.name)<EOL>self._separator('TEST')<EOL><DEDENT>def end_test(self,test):<EOL><INDENT>self._separator('TEST')<EOL>self._end('TEST',test.name,test.elapsedtime)<EOL>self._separator('TEST')<EOL><DEDENT>def start_keyword(self,kw):<EOL><INDENT>if self._kw_level==:<EOL><INDENT>self._separator('KW')<EOL><DEDENT>self._start(self._get_kw_type(kw),kw.name,kw.args)<EOL>self._kw_level +=<EOL><DEDENT>def end_keyword(self,kw):<EOL><INDENT>self._end(self._get_kw_type(kw),kw.name,kw.elapsedtime)<EOL>self._kw_level -=<EOL><DEDENT>def log_message(self,msg):<EOL><INDENT>if self._is_logged(msg.level):<EOL><INDENT>self._write(msg.message)<EOL><DEDENT> <DEDENT>def close(self):<EOL><INDENT>if not self._outfile.closed :<EOL><INDENT>self._outfile.close()<EOL><DEDENT> <DEDENT>def _get_kw_type(self,kw):<EOL><INDENT>if kw.type in self._setup_or_teardown :<EOL><INDENT>return kw.type.upper()<EOL><DEDENT>return 'KW'<EOL><DEDENT>def _start(self,type_,name,args=''):<EOL><INDENT>args=' '+utils.seq2str2(args)<EOL>self._write('<STR_LIT>'%('-'*self._indent,type_,name,args))<EOL>self._indent +=<EOL><DEDENT>def _end(self,type_,name,elapsed):<EOL><INDENT>self._indent -=<EOL>self._write('<STR_LIT>'%('-'*self._indent,type_,name,elapsed))<EOL><DEDENT>def _separator(self,type_):<EOL><INDENT>self._write(self._separators [type_ ]*,separator=True)<EOL><DEDENT>def _write(self,text,separator=False):<EOL><INDENT>if not(separator and self._separator_written_last):<EOL><INDENT>self._outfile.write(text.encode('UTF-8').rstrip()+'\n')<EOL>self._outfile.flush()<EOL>self._separator_written_last=separator <EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>import cv2.cv as cv <EOL>cap=cv.CreateFileCapture("../c/tree.avi")<EOL>img=cv.QueryFrame(cap)<EOL>print '<STR_LIT>',img.width," x ",img.height,")"<EOL>cv.NamedWindow("win",cv.CV_WINDOW_AUTOSIZE)<EOL>cv.ShowImage("win",img)<EOL>cv.MoveWindow("win",,)<EOL>cv.WaitKey()<EOL>cv.DestroyAllWindows()<EOF><BOF>'<STR_LIT>'<EOL>def get_char_width(char):<EOL><INDENT>char=ord(char)<EOL>if _char_in_map(char,_COMBINING_CHARS):<EOL><INDENT>return <EOL><DEDENT>if _char_in_map(char,_EAST_ASIAN_WILD_CHARS):<EOL><INDENT>return <EOL><DEDENT>return <EOL><DEDENT>def _char_in_map(char,map):<EOL><INDENT>for begin,end in map :<EOL><INDENT>if char <begin :<EOL><INDENT>break <EOL><DEDENT>if begin <=char <=end :<EOL><INDENT>return True <EOL><DEDENT> <DEDENT>return False <EOL><DEDENT>_COMBINING_CHARS=[(,)]<EOL>_EAST_ASIAN_WILD_CHARS=[(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),<EOL>]<EOF><BOF>'<STR_LIT>'<EOL>import os <EOL>import tempfile <EOL>from robot import utils <EOL>from robot.output import LOGGER <EOL>from.isvar import is_var,is_scalar_var,is_list_var <EOL>from.variables import Variables <EOL>from.variableassigner import VariableAssigner <EOL>from.variablesplitter import VariableSplitter <EOL>GLOBAL_VARIABLES=Variables()<EOL>def init_global_variables(settings):<EOL><INDENT>GLOBAL_VARIABLES.clear()<EOL>_set_cli_vars(settings)<EOL>for name,value in [('${TEMPDIR}',utils.abspath(tempfile.gettempdir())),('${EXECDIR}',utils.abspath('.')),('${/}',os.sep),('${:}',os.pathsep),('${\\n}',os.linesep),('${SPACE}',' '),('${EMPTY}',''),('@{EMPTY}',()),('${True}',True),('${False}',False),('${None}',None),('${null}',None),('${OUTPUT_DIR}',settings ['OutputDir']),('${OUTPUT_FILE}',settings ['Output']),('${REPORT_FILE}',settings ['Report']),('${LOG_FILE}',settings ['Log']),('${DEBUG_FILE}',settings ['DebugFile']),('<STR_LIT>',''),('<STR_LIT>',''),('<STR_LIT>','')]:<EOL><INDENT>GLOBAL_VARIABLES [name ]=value <EOL><DEDENT> <DEDENT>def _set_cli_vars(settings):<EOL><INDENT>for path,args in settings ['VariableFiles']:<EOL><INDENT>try :<EOL><INDENT>GLOBAL_VARIABLES.set_from_file(path,args)<EOL><DEDENT>except :<EOL><INDENT>msg,details=utils.get_error_details()<EOL>LOGGER.error(msg)<EOL>LOGGER.info(details)<EOL><DEDENT> <DEDENT>for varstr in settings ['Variables']:<EOL><INDENT>try :<EOL><INDENT>name,value=varstr.split(':',)<EOL><DEDENT>except ValueError :<EOL><INDENT>name,value=varstr,''<EOL><DEDENT>GLOBAL_VARIABLES ['${%s}'%name ]=value <EOL><DEDENT> <DEDENT><EOF><BOF>from robot.errors import DataError <EOL>from robot.variables import GLOBAL_VARIABLES <EOL>class ExecutionContexts(object):<EOL><INDENT>def __init__(self):<EOL><INDENT>self._contexts=[]<EOL><DEDENT>@property <EOL>def current(self):<EOL><INDENT>return self._contexts [-]if self._contexts else None <EOL><DEDENT>def __iter__(self):<EOL><INDENT>return iter(self._contexts)<EOL><DEDENT>@property <EOL>def namespaces(self):<EOL><INDENT>return(context.namespace for context in self)<EOL><DEDENT>def start_suite(self,namespace,output,dry_run=False):<EOL><INDENT>self._contexts.append(_ExecutionContext(namespace,output,dry_run))<EOL>return self.current <EOL><DEDENT>def end_suite(self):<EOL><INDENT>self._contexts.pop()<EOL><DEDENT> <DEDENT>EXECUTION_CONTEXTS=ExecutionContexts()<EOL>class _ExecutionContext(object):<EOL><INDENT>_started_keywords_threshold=<EOL>def __init__(self,namespace,output,dry_run=False):<EOL><INDENT>self.namespace=namespace <EOL>self.output=output <EOL>self.dry_run=dry_run <EOL>self._in_teardown=<EOL>self._started_keywords=<EOL><DEDENT>@property <EOL>def teardown(self):<EOL><INDENT>if self._in_teardown :<EOL><INDENT>return True <EOL><DEDENT>test_or_suite=self.namespace.test or self.namespace.suite <EOL>return test_or_suite.status !='RUNNING'<EOL><DEDENT>def start_keyword_teardown(self,error):<EOL><INDENT>self.namespace.variables ['<STR_LIT>']='FAIL'if error else 'PASS'<EOL>self.namespace.variables ['<STR_LIT>']=unicode(error or '')<EOL>self._in_teardown +=<EOL><DEDENT>def end_keyword_teardown(self):<EOL><INDENT>self._in_teardown -=<EOL><DEDENT>def get_current_vars(self):<EOL><INDENT>return self.namespace.variables <EOL><DEDENT>def end_test(self,test):<EOL><INDENT>self.output.end_test(test)<EOL>self.namespace.end_test()<EOL><DEDENT>def end_suite(self,suite):<EOL><INDENT>self.output.end_suite(suite)<EOL>self.namespace.end_suite()<EOL>EXECUTION_CONTEXTS.end_suite()<EOL><DEDENT>def output_file_changed(self,filename):<EOL><INDENT>self._set_global_variable('${OUTPUT_FILE}',filename)<EOL><DEDENT>def replace_vars_from_setting(self,name,value,errors):<EOL><INDENT>return self.namespace.variables.replace_meta(name,value,errors)<EOL><DEDENT>def log_file_changed(self,filename):<EOL><INDENT>self._set_global_variable('${LOG_FILE}',filename)<EOL><DEDENT>def set_prev_test_variables(self,test):<EOL><INDENT>self._set_prev_test_variables(self.get_current_vars(),test.name,<EOL>test.status,test.message)<EOL><DEDENT>def copy_prev_test_vars_to_global(self):<EOL><INDENT>varz=self.get_current_vars()<EOL>name,status,message=varz ['<STR_LIT>'],varz ['<STR_LIT>'],varz ['<STR_LIT>']<EOL>self._set_prev_test_variables(GLOBAL_VARIABLES,name,status,message)<EOL><DEDENT>def _set_prev_test_variables(self,destination,name,status,message):<EOL><INDENT>destination ['<STR_LIT>']=name <EOL>destination ['<STR_LIT>']=status <EOL>destination ['<STR_LIT>']=message <EOL><DEDENT>def _set_global_variable(self,name,value):<EOL><INDENT>self.namespace.variables.set_global(name,value)<EOL><DEDENT>def report_suite_status(self,status,message):<EOL><INDENT>self.get_current_vars()['${SUITE_STATUS}']=status <EOL>self.get_current_vars()['<STR_LIT>']=message <EOL><DEDENT>def start_test(self,test):<EOL><INDENT>self.namespace.start_test(test)<EOL>self.output.start_test(test)<EOL><DEDENT>def set_test_status_before_teardown(self,message,status):<EOL><INDENT>self.namespace.set_test_status_before_teardown(message,status)<EOL><DEDENT>def get_handler(self,name):<EOL><INDENT>return self.namespace.get_handler(name)<EOL><DEDENT>def start_keyword(self,keyword):<EOL><INDENT>self._started_keywords +=<EOL>if self._started_keywords >self._started_keywords_threshold :<EOL><INDENT>raise DataError('<STR_LIT>')<EOL><DEDENT>self.output.start_keyword(keyword)<EOL><DEDENT>def end_keyword(self,keyword):<EOL><INDENT>self.output.end_keyword(keyword)<EOL>self._started_keywords -=<EOL><DEDENT>def start_user_keyword(self,kw):<EOL><INDENT>self.namespace.start_user_keyword(kw)<EOL><DEDENT>def end_user_keyword(self):<EOL><INDENT>self.namespace.end_user_keyword()<EOL><DEDENT>def warn(self,message):<EOL><INDENT>self.output.warn(message)<EOL><DEDENT>def trace(self,message):<EOL><INDENT>self.output.trace(message)<EOL><DEDENT> <DEDENT><EOF><BOF>from __future__ import unicode_literals <EOL>from django.db import migrations,models <EOL>class Migration(migrations.Migration):<EOL><INDENT>dependencies=[('buildservice','<STR_LIT>'),<EOL>]<EOL>operations=[<EOL>migrations.AddField(<EOL>model_name='build',<EOL>name='number',<EOL>field=models.IntegerField(default=),),<EOL>migrations.AddField(<EOL>model_name='repository',<EOL>name='build_count',<EOL>field=models.IntegerField(default=),),<EOL>]<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import numpy as np <EOL>import cv2 <EOL>import itertools as it <EOL>from common import draw_str <EOL>w,h=,<EOL>def toint(p):<EOL><INDENT>return tuple(map(int,p))<EOL><DEDENT>def sample_line(p1,p2,n,noise=):<EOL><INDENT>p1=np.float32(p1)<EOL>t=np.random.rand(n,)<EOL>return p1 +(p2 -p1)*t +np.random.normal(size=(n,))*noise <EOL><DEDENT>dist_func_names=it.cycle('<STR_LIT>'.split())<EOL>cur_func_name=dist_func_names.next()<EOL>def update(_=None):<EOL><INDENT>noise=cv2.getTrackbarPos('noise','fit line')<EOL>n=cv2.getTrackbarPos('point n','fit line')<EOL>r=cv2.getTrackbarPos('outlier %','fit line')/<EOL>outn=int(n *r)<EOL>p0,p1=(,),(w -,h -)<EOL>img=np.zeros((h,w,),np.uint8)<EOL>cv2.line(img,toint(p0),toint(p1),(,,))<EOL>if n >:<EOL><INDENT>line_points=sample_line(p0,p1,n -outn,noise)<EOL>outliers=np.random.rand(outn,)*(w,h)<EOL>points=np.vstack([line_points,outliers ])<EOL>for p in line_points :<EOL><INDENT>cv2.circle(img,toint(p),,(,,),-)<EOL><DEDENT>for p in outliers :<EOL><INDENT>cv2.circle(img,toint(p),,(,,),-)<EOL><DEDENT>func=getattr(cv2,cur_func_name)<EOL>vx,vy,cx,cy=cv2.fitLine(np.float32(points),func,,,)<EOL>cv2.line(img,(int(cx -vx *w),int(cy -vy *w)),(int(cx +vx *w),int(cy +vy *w)),(,,))<EOL><DEDENT>draw_str(img,(,),cur_func_name)<EOL>cv2.imshow('fit line',img)<EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>cv2.namedWindow('fit line')<EOL>cv2.createTrackbar('noise','fit line',,,update)<EOL>cv2.createTrackbar('point n','fit line',,,update)<EOL>cv2.createTrackbar('outlier %','fit line',,,update)<EOL>while True :<EOL><INDENT>update()<EOL>ch=cv2.waitKey()<EOL>if ch==ord('f'):<EOL><INDENT>cur_func_name=dist_func_names.next()<EOL><DEDENT>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT><EOF><BOF>import numpy as np <EOL>import cv2 <EOL>import os <EOL>import sys <EOL>import video <EOL>from common import mosaic <EOL>from digits import *<EOL>def main():<EOL><INDENT>try :src=sys.argv []<EOL>except :src=<EOL>cap=video.create_capture(src)<EOL>classifier_fn='digits_svm.dat'<EOL>if not os.path.exists(classifier_fn):<EOL><INDENT>print '<STR_LIT>'%classifier_fn <EOL>return <EOL><DEDENT>model=SVM()<EOL>model.load(classifier_fn)<EOL>while True :<EOL><INDENT>ret,frame=cap.read()<EOL>gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)<EOL>bin=cv2.adaptiveThreshold(gray,,cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY_INV,,)<EOL>bin=cv2.medianBlur(bin,)<EOL>contours,heirs=cv2.findContours(bin.copy(),cv2.RETR_CCOMP,cv2.CHAIN_APPROX_SIMPLE)<EOL>try :heirs=heirs []<EOL>except :heirs=[]<EOL>for cnt,heir in zip(contours,heirs):<EOL><INDENT>_,_,_,outer_i=heir <EOL>if outer_i >=:<EOL><INDENT>continue <EOL><DEDENT>x,y,w,h=cv2.boundingRect(cnt)<EOL>if not(<=h <=and w <=*h):<EOL><INDENT>continue <EOL><DEDENT>pad=max(h -w,)<EOL>x,w=x -pad /,w +pad <EOL>cv2.rectangle(frame,(x,y),(x +w,y +h),(,,))<EOL>bin_roi=bin [y :,x :][:h,:w ]<EOL>gray_roi=gray [y :,x :][:h,:w ]<EOL>m=bin_roi !=<EOL>if not <m.mean()<:<EOL><INDENT>continue <EOL><DEDENT> '<STR_LIT>'<EOL>s=*float(h)/SZ <EOL>m=cv2.moments(bin_roi)<EOL>c1=np.float32([m ['m10'],m ['m01']])/m ['m00']<EOL>c0=np.float32([SZ /,SZ /])<EOL>t=c1 -s *c0 <EOL>A=np.zeros((,),np.float32)<EOL>A [:,:]=np.eye()*s <EOL>A [:,]=t <EOL>bin_norm=cv2.warpAffine(bin_roi,A,(SZ,SZ),flags=cv2.WARP_INVERSE_MAP |cv2.INTER_LINEAR)<EOL>bin_norm=deskew(bin_norm)<EOL>if x +w +SZ <frame.shape []and y +SZ <frame.shape []:<EOL><INDENT>frame [y :,x +w :][:SZ,:SZ ]=bin_norm [...,np.newaxis ]<EOL><DEDENT>sample=preprocess_hog([bin_norm ])<EOL>digit=model.predict(sample)[]<EOL>cv2.putText(frame,'%d'%digit,(x,y),cv2.FONT_HERSHEY_PLAIN,,(,,),thickness=)<EOL><DEDENT>cv2.imshow('frame',frame)<EOL>cv2.imshow('bin',bin)<EOL>ch=cv2.waitKey()<EOL>if ch==:<EOL><INDENT>break <EOL><DEDENT> <DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>main()<EOL><DEDENT><EOF><BOF>import webb <EOL>webb.download_google_images("Flowers")<EOF><BOF>from __future__ import unicode_literals <EOL>from django.conf import settings <EOL>from django.db import migrations,models <EOL>class Migration(migrations.Migration):<EOL><INDENT>dependencies=[<EOL>migrations.swappable_dependency(settings.AUTH_USER_MODEL),('buildservice','<STR_LIT>'),<EOL>]<EOL>operations=[<EOL>migrations.RemoveField(<EOL>model_name='webhook',<EOL>name='user',),<EOL>migrations.AddField(<EOL>model_name='repository',<EOL>name='users',<EOL>field=models.ManyToManyField(related_name='repositories',related_query_name=b'repository',to=settings.AUTH_USER_MODEL),),<EOL>]<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import cv2 <EOL>import numpy as np <EOL>bins=np.arange().reshape(,)<EOL>def hist_curve(im):<EOL><INDENT>h=np.zeros((,,))<EOL>if len(im.shape)==:<EOL><INDENT>color=[(,,)]<EOL><DEDENT>elif im.shape []==:<EOL><INDENT>color=[(,,),(,,),(,,)]<EOL><DEDENT>for ch,col in enumerate(color):<EOL><INDENT>hist_item=cv2.calcHist([im ],[ch ],None,[],[,])<EOL>cv2.normalize(hist_item,hist_item,,,cv2.NORM_MINMAX)<EOL>hist=np.int32(np.around(hist_item))<EOL>pts=np.int32(np.column_stack((bins,hist)))<EOL>cv2.polylines(h,[pts ],False,col)<EOL><DEDENT>y=np.flipud(h)<EOL>return y <EOL><DEDENT>def hist_lines(im):<EOL><INDENT>h=np.zeros((,,))<EOL>if len(im.shape)!=:<EOL><INDENT>print '<STR_LIT>'<EOL>im=cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)<EOL><DEDENT>hist_item=cv2.calcHist([im ],[],None,[],[,])<EOL>cv2.normalize(hist_item,hist_item,,,cv2.NORM_MINMAX)<EOL>hist=np.int32(np.around(hist_item))<EOL>for x,y in enumerate(hist):<EOL><INDENT>cv2.line(h,(x,),(x,y),(,,))<EOL><DEDENT>y=np.flipud(h)<EOL>return y <EOL><DEDENT>if __name__=='__main__':<EOL><INDENT>import sys <EOL>if len(sys.argv)>:<EOL><INDENT>im=cv2.imread(sys.argv [])<EOL><DEDENT>else :<EOL><INDENT>im=cv2.imread('../cpp/lena.jpg')<EOL>print '<STR_LIT>'<EOL><DEDENT>gray=cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)<EOL>print '<STR_LIT>'<EOL>cv2.imshow('image',im)<EOL>while True :<EOL><INDENT>k=cv2.waitKey()&<EOL>if k==ord('a'):<EOL><INDENT>curve=hist_curve(im)<EOL>cv2.imshow('histogram',curve)<EOL>cv2.imshow('image',im)<EOL>print 'a'<EOL><DEDENT>elif k==ord('b'):<EOL><INDENT>print 'b'<EOL>lines=hist_lines(im)<EOL>cv2.imshow('histogram',lines)<EOL>cv2.imshow('image',gray)<EOL><DEDENT>elif k==ord('c'):<EOL><INDENT>print 'c'<EOL>equ=cv2.equalizeHist(gray)<EOL>lines=hist_lines(equ)<EOL>cv2.imshow('histogram',lines)<EOL>cv2.imshow('image',equ)<EOL><DEDENT>elif k==ord('d'):<EOL><INDENT>print 'd'<EOL>curve=hist_curve(gray)<EOL>cv2.imshow('histogram',curve)<EOL>cv2.imshow('image',gray)<EOL><DEDENT>elif k==ord('e'):<EOL><INDENT>print 'e'<EOL>norm=cv2.normalize(gray,alpha=,beta=,norm_type=cv2.NORM_MINMAX)<EOL>lines=hist_lines(norm)<EOL>cv2.imshow('histogram',lines)<EOL>cv2.imshow('image',norm)<EOL><DEDENT>elif k==:<EOL><INDENT>print 'ESC'<EOL>cv2.destroyAllWindows()<EOL>break <EOL><DEDENT> <DEDENT>cv2.destroyAllWindows()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import cv2 <EOL>import os <EOL>from time import clock <EOL>from datetime import datetime as dt <EOL>class OpenCV_Cam(object):<EOL><INDENT>def __init__(self,src=None):<EOL><INDENT>self.pic_idx=<EOL>self.start_cam(src)<EOL>self.__fcount,self.__frate,self.__start=,,clock()<EOL><DEDENT>@staticmethod <EOL>def cam_count():<EOL><INDENT>cam_idx=<EOL>cap=cv2.VideoCapture(cam_idx)<EOL>while cap.read()[]:<EOL><INDENT>cam_idx +=<EOL>cap=cv2.VideoCapture(cam_idx)<EOL><DEDENT>return cam_idx <EOL><DEDENT>def start_cam(self,src=None):<EOL><INDENT>if src is not None :<EOL><INDENT>self.cam=VideoCapture(src)<EOL>if not self.cam.isOpened():<EOL><INDENT>raise ValueError('Cannot open '+src +'as VideoCapture')<EOL><DEDENT>return <EOL><DEDENT>idx=<EOL>cam1,cam2=cv2.VideoCapture(),cv2.VideoCapture()<EOL>while(cam2.read()[]):<EOL><INDENT>cam1.release()<EOL>cam1=cam2 <EOL>idx +=<EOL>cam2=cv2.VideoCapture(idx)<EOL><DEDENT>self.cam=cam1 <EOL>if not self.cam.isOpened():<EOL><INDENT>raise Error('<STR_LIT>')<EOL><DEDENT> <DEDENT>@property <EOL>def size(self):<EOL><INDENT>w=self.cam.get(cv2.cv.CV_CAP_PROP_FRAME_WIDTH)<EOL>h=self.cam.get(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT)<EOL>return(int(w),int(h))<EOL><DEDENT>@size.setter <EOL>def size(self,shape):<EOL><INDENT>self.cam.set(cv2.cv.CV_CAP_PROP_FRAME_WIDTH,shape [])<EOL>self.cam.set(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT,shape [])<EOL><DEDENT>def read(self):<EOL><INDENT>self.__fcount +=<EOL>self.__frame=self.cam.read()[]<EOL>if self.__fcount==:<EOL><INDENT>end=clock()<EOL>self.__frate=/(end -self.__start)<EOL>self.__start=clock()<EOL>self.__fcount=<EOL><DEDENT>return self.__frame <EOL><DEDENT>@property <EOL>def frame_rate(self):<EOL><INDENT>return self.__frate <EOL><DEDENT>@property <EOL>def info(self):<EOL><INDENT>vars=[x [:]for x in dir(cv2.cv)if 'CV_CAP_PROP'in x ]<EOL>ret={}<EOL>for p in vars :<EOL><INDENT>cmd='ret[\''+p +'<STR_LIT>'+p +')'<EOL>exec cmd <EOL><DEDENT>return ret <EOL><DEDENT>def set(self,property,value):<EOL><INDENT>cmd='<STR_LIT>'+property +', '+str(value)+')'<EOL>print cmd <EOL>exec cmd <EOL><DEDENT>def cam_loop(self,func=lambda x :x,params=()):<EOL><INDENT>while True :<EOL><INDENT>input=self.read()<EOL>output=func(input,*params)<EOL>window_name=func.__name__ <EOL>if window_name=='<lambda>':window_name='camera image'<EOL>cv2.imshow(window_name,output)<EOL>k=cv2.waitKey()<EOL>if k==:<EOL><INDENT>break <EOL><DEDENT>elif k==ord('p'):<EOL><INDENT>info=self.info <EOL>for i in info :<EOL><INDENT>print i,'=',info [i ]<EOL><DEDENT> <DEDENT>elif k==ord('s'):<EOL><INDENT>p=raw_input('type property:')<EOL>if('<STR_LIT>'+p)not in dir(cv2.cv):<EOL><INDENT>print p,'<STR_LIT>'<EOL>print '<STR_LIT>',[x [:]for x in dir(cv2.cv)if 'CV_CAP_PROP'in x ]<EOL><DEDENT>else :<EOL><INDENT>v=raw_input('type value:')<EOL>self.set(p,v)<EOL><DEDENT> <DEDENT>elif k==ord('f'):<EOL><INDENT>print self.frame_rate <EOL><DEDENT>elif k==ord(' '):<EOL><INDENT>directory='<STR_LIT>'<EOL>f=str(dt.now())<EOL>idx=''.join([c for c in f if c.isdigit()or c.isalpha()or c in '-_.'])<EOL>filename=directory +'/'+idx +".png"<EOL>if not os.path.exists(directory):<EOL><INDENT>os.makedirs(directory)<EOL><DEDENT>cv2.imwrite(filename,output)<EOL>print "image saved to "+filename <EOL>self.pic_idx +=<EOL><DEDENT> <DEDENT> <DEDENT>def __enter__(self):<EOL><INDENT>return self <EOL><DEDENT>def __exit__(self,exc_type,exc_value,traceback):<EOL><INDENT>self.cam.release()<EOL><DEDENT>def release(self):<EOL><INDENT>self.cam.release()<EOL><DEDENT> <DEDENT>if __name__=='__main__':<EOL><INDENT>print __doc__ <EOL>cam=OpenCV_Cam()<EOL>cam.size=(,)<EOL>info=cam.info <EOL>for i in info :<EOL><INDENT>print i,'=',info [i ]<EOL><DEDENT>cam.cam_loop()<EOL><DEDENT><EOF><BOF>'<STR_LIT>'<EOL>import unittest <EOL>class InitializationTest(unittest.TestCase):<EOL><INDENT> '<STR_LIT>'<EOL>def test_initialization(self):<EOL><INDENT> '<STR_LIT>'<EOL>self.assertEqual(+,)<EOL><DEDENT>def test_import(self):<EOL><INDENT> '<STR_LIT>'<EOL>try :<EOL><INDENT>import octavo <EOL><DEDENT>except ImportError :<EOL><INDENT>self.fail('<STR_LIT>')<EOL><DEDENT> <DEDENT> <DEDENT><EOF>